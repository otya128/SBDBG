OPTION STRICT
'SPLAY_TEST
'END
MAIN
DEF GET_SLOT$(N)
 PRGEDIT N
 VAR S$=""
 VAR I,L=PRGSIZE()
 FOR I=1TO L
  PUSH S$,PRGGET$()
 NEXT
 RETURN S$
END
DEF MAIN
 VAR SW,SH,TS,TS2
 XSCREEN OUT SW,SH
 IF SW!=1280||SH!=720THEN
  XSCREEN 1280,720
 ENDIF
 TSCREEN OUT TS,TS2,,
 IF TS!=16||TS2!=16THEN
  TSCREEN 16
 ENDIF
 ?TS
 VAR IN$=GET_SLOT$(1)'"PRINT 1+2-8*12"'*8"
 INIT_LEXER IN$
 INIT_AST
 INIT_PARSER
 VAR AST=PARSE()
 DUMP_AST AST,0
 INIT_COMPILER
 INIT_VM
 COMPILE AST
 VM_RUN
END
VAR LEXER_IN$
VAR LEXER_I
VAR LEXER_VAL
ENUM\
 #TKN_NONE,\
 #TKN_NUM,\
 #TKN_STR,\
 #TKN_PRINT,\
 #TKN_DEF,\
 #TKN_RETURN,\
 #TKN_IDEN,\
 #TKN_PLUS,\
 #TKN_MINUS,\
 #TKN_MUL,\
 #TKN_DIV,\
 #TKN_DIVINT,\
 #TKN_COMMA,\
 #TKN_LP,\
 #TKN_RP,\
 #TKN_LB,\
 #TKN_RB,\
 #TKN_SEMI,\
 #TKN_COL,\
 #TKN_NEWLINE,\
 #TKN_EOF,\
 #TKN_MOD,\
 #TKN_LSHIFT,\
 #TKN_RSHIFT,\
 #TKN_EQ,\
 #TKN_NEQ,\
 #TKN_LESS,\
 #TKN_LEQ,\
 #TKN_GREAT,\
 #TKN_GEQ,\
 #TKN_AND,\
 #TKN_OR,\
 #TKN_XOR,\
 #TKN_LAND,\
 #TKN_LOR,\
 #TKN_ASSIGN,\
 #TKN_NOT,\
 #TKN_LNOT,\
 #TKN_OUT,\
 #TKN_CALL,\
 #TKN_VAR,\
 #TKN_DIM,\
 #TKN_IF,\
 #TKN_THEN,\
 #TKN_ENDIF,\
 #TKN_ELSE,\
 #TKN_ELSEIF,\
 #TKN_FOR,\
 #TKN_NEXT,\
 #TKN_GOTO,\
 #TKN_GOSUB,\
 #TKN_BREAK,\
 #TKN_CONTINUE,\
 #TKN_WHILE,\
 #TKN_WEND,\
 #TKN_REPEAT,\
 #TKN_UNTIL,\
 #TKN_LOOP,\
 #TKN_ENDLOOP,\
 #TKN_LABEL,\
 #TKN_ON,\
 #TKN_,\
 #TKN_LAST
DEF TKN_STR$(T)
 CASE T
WHEN #TKN_NONE:RETURN "#TKN_NONE"WHEN #TKN_NUM:RETURN "#TKN_NUM"WHEN #TKN_STR:RETURN "#TKN_STR"WHEN #TKN_PRINT:RETURN "#TKN_PRINT"WHEN #TKN_DEF:RETURN "#TKN_DEF"WHEN #TKN_RETURN:RETURN "#TKN_RETURN"WHEN #TKN_IDEN:RETURN "#TKN_IDEN"WHEN #TKN_PLUS:RETURN "#TKN_PLUS"WHEN #TKN_MINUS:RETURN "#TKN_MINUS"WHEN #TKN_MUL:RETURN "#TKN_MUL"WHEN #TKN_DIV:RETURN "#TKN_DIV"WHEN #TKN_DIVINT:RETURN "#TKN_DIVINT"WHEN #TKN_COMMA:RETURN "#TKN_COMMA"WHEN #TKN_LP:RETURN "#TKN_LP"WHEN #TKN_RP:RETURN "#TKN_RP"WHEN #TKN_LB:RETURN "#TKN_LB"WHEN #TKN_RB:RETURN "#TKN_RB"WHEN #TKN_SEMI:RETURN "#TKN_SEMI"WHEN #TKN_COL:RETURN "#TKN_COL"WHEN #TKN_NEWLINE:RETURN "#TKN_NEWLINE"WHEN #TKN_EOF:RETURN "#TKN_EOF"WHEN #TKN_MOD:RETURN "#TKN_MOD"WHEN #TKN_LSHIFT:RETURN "#TKN_LSHIFT"WHEN #TKN_RSHIFT:RETURN "#TKN_RSHIFT"WHEN #TKN_EQ:RETURN "#TKN_EQ"WHEN #TKN_NEQ:RETURN "#TKN_NEQ"WHEN #TKN_LESS:RETURN "#TKN_LESS"WHEN #TKN_LEQ:RETURN "#TKN_LEQ"WHEN #TKN_GREAT:RETURN "#TKN_GREAT"WHEN #TKN_GEQ:RETURN "#TKN_GEQ"WHEN #TKN_AND:RETURN "#TKN_AND"WHEN #TKN_OR:RETURN "#TKN_OR"WHEN #TKN_XOR:RETURN "#TKN_XOR"WHEN #TKN_LAND:RETURN "#TKN_LAND"WHEN #TKN_LOR:RETURN "#TKN_LOR"WHEN #TKN_ASSIGN:RETURN "#TKN_ASSIGN"WHEN #TKN_NOT:RETURN "#TKN_NOT"WHEN #TKN_LNOT:RETURN "#TKN_LNOT"WHEN #TKN_OUT:RETURN "#TKN_OUT"WHEN #TKN_CALL:RETURN "#TKN_CALL"WHEN #TKN_VAR:RETURN "#TKN_VAR"WHEN #TKN_DIM:RETURN "#TKN_DIM"WHEN #TKN_IF:RETURN "#TKN_IF"WHEN #TKN_THEN:RETURN "#TKN_THEN"WHEN #TKN_ENDIF:RETURN "#TKN_ENDIF"WHEN #TKN_ELSE:RETURN "#TKN_ELSE"WHEN #TKN_ELSEIF:RETURN "#TKN_ELSEIF"WHEN #TKN_FOR:RETURN "#TKN_FOR"WHEN #TKN_NEXT:RETURN "#TKN_NEXT"WHEN #TKN_GOTO:RETURN "#TKN_GOTO"WHEN #TKN_GOSUB:RETURN "#TKN_GOSUB"WHEN #TKN_BREAK:RETURN "#TKN_BREAK"WHEN #TKN_CONTINUE:RETURN "#TKN_CONTINUE"WHEN #TKN_WHILE:RETURN "#TKN_WHILE"WHEN #TKN_WEND:RETURN "#TKN_WEND"WHEN #TKN_REPEAT:RETURN "#TKN_REPEAT"WHEN #TKN_UNTIL:RETURN "#TKN_UNTIL"WHEN #TKN_LOOP:RETURN "#TKN_LOOP"WHEN #TKN_ENDLOOP:RETURN "#TKN_ENDLOOP"WHEN #TKN_LABEL:RETURN "#TKN_LABEL"WHEN #TKN_ON:RETURN "#TKN_ON"WHEN #TKN_:RETURN "#TKN_"
 OTHERWISE
  RETURN STR$(T)
 ENDCASE
END
VAR LEXER_TKN
VAR LEXER_EOF
DEF INIT_LEXER IN$
 LEXER_I=0
 LEXER_EOF=#FALSE
 LEXER_IN$=IN$
END
DEF EMPTY OUT A
 RETURN A
END
DEF IS_NUM(C)
 RETURN C>=48&&C<=57
END
DEF IS_ALPHA(C)
 RETURN (C>=65&&C<=90)||(C>=97&&C<=122)
END
DEF TO_UPPER$(S$)
 VAR I
 VAR NS$=COPY(S$)
 FOR I=0TO LAST(S$)
  VAR C=ASC(S$[I])
  IF C>=97&&C<=122THEN
   NS$[I]=CHR$(C-97+65)
  ENDIF
 NEXT
 RETURN NS$
END
DEF LEX_CUR OUT T,V
 T=LEXER_TKN
 V=LEXER_VAL
END
DEF LEX_NEXT OUT T,V
 LEX_NEXT_IMPL
 LEX_CUR OUT T,V
 '?TKN_STR$(T)
 '??V
END
DEF IS_VARSUFFIX(C$)
 CASE C$
 WHEN "$":WHEN "#":WHEN "%":RETURN #TRUE
 OTHERWISE RETURN #FALSE
 ENDCASE
END
DEF LEX_NEXT_IMPL
 VAR C$,C
 LEXER_TKN=#TKN_NONE
 LEXER_VAL=EMPTY()
 FOR LEXER_I=LEXER_I TO LAST(LEXER_IN$)
  C$=LEXER_IN$[LEXER_I]
  C=ASC(C$)
  IF C==13||C==10THEN
   LEXER_TKN=#TKN_NEWLINE
   CONTINUE
  ENDIF
  IF C==32||C==9THEN
   CONTINUE
  ENDIF
  BREAK
 NEXT
 IF LEXER_I>=LEN(LEXER_IN$)THEN
  LEXER_TKN=#TKN_EOF
  RETURN
 ENDIF
 IF LEXER_TKN!=#TKN_NONE THEN
  RETURN
 ENDIF
  VAR N$=MID$(LEXER_IN$,LEXER_I+1,1)
 CASE C$
 WHEN "+"
  INC LEXER_I
  LEXER_TKN=#TKN_PLUS
 WHEN "-"
  INC LEXER_I
  LEXER_TKN=#TKN_MINUS
 WHEN "*"
  INC LEXER_I
  LEXER_TKN=#TKN_MUL
 WHEN "/"
  INC LEXER_I
  LEXER_TKN=#TKN_DIV
 WHEN ","
  INC LEXER_I
  LEXER_TKN=#TKN_COMMA
 WHEN "("
  INC LEXER_I
  LEXER_TKN=#TKN_LP
 WHEN ")"
  INC LEXER_I
  LEXER_TKN=#TKN_RP
 WHEN "["
  INC LEXER_I
  LEXER_TKN=#TKN_LB
 WHEN "]"
  INC LEXER_I
  LEXER_TKN=#TKN_RB
 WHEN ";"
  INC LEXER_I
  LEXER_TKN=#TKN_SEMI
 WHEN ":"
  INC LEXER_I
  LEXER_TKN=#TKN_COL
 WHEN "?"
  INC LEXER_I
  LEXER_TKN=#TKN_PRINT
 WHEN "!"
  INC LEXER_I
  LEXER_TKN=#TKN_LNOT
 WHEN "="
  INC LEXER_I
  IF N$=="="THEN
   INC LEXER_I
   LEXER_TKN=#TKN_EQ
  ELSE
   LEXER_TKN=#TKN_ASSIGN
  ENDIF
 WHEN "<"
  INC LEXER_I
  IF N$=="="THEN
   INC LEXER_I
   LEXER_TKN=#TKN_LEQ
  ELSEIF N$=="<"THEN
   LEXER_TKN=#TKN_LSHIFT
  ELSE
   LEXER_TKN=#TKN_LESS
  ENDIF
 WHEN ">"
  INC LEXER_I
  IF N$=="="THEN
   INC LEXER_I
   LEXER_TKN=#TKN_GEQ
  ELSEIF N$==">"THEN
   LEXER_TKN=#TKN_RSHIFT
  ELSE
   LEXER_TKN=#TKN_GREAT
  ENDIF
 WHEN "&"
  IF N$=="&"THEN
   INC LEXER_I,2
   LEXER_TKN=#TKN_LAND
  ENDIF
 WHEN "|"
  IF N$=="|"THEN
   INC LEXER_I,2
   LEXER_TKN=#TKN_LOR
  ENDIF
 ENDCASE
 IF LEXER_TKN!=#TKN_NONE THEN
  RETURN
 ENDIF
 VAR SI=LEXER_I
 IF IS_NUM(C) THEN
  'n.nEn
  VAR HAS_POINT,HAS_EXP
  FOR LEXER_I=LEXER_I TO LAST(LEXER_IN$)
   C$=LEXER_IN$[LEXER_I]
   C=ASC(C$)
   IF!HAS_EXP&&!HAS_POINT&&C$=="."THEN
    HAS_POINT=#TRUE
    CONTINUE
   ENDIF
   IF !HAS_EXP&&C$=="E"||C$=="e"THEN
    HAS_EXP=#TRUE
    CONTINUE
   ENDIF
   IF IS_NUM(C)THEN
    CONTINUE
   ENDIF
   BREAK
  NEXT
  LEXER_TKN=#TKN_NUM
  LEXER_VAL=VAL(MID$(LEXER_IN$,SI,LEXER_I-SI))
  RETURN
 ELSEIF C$=="@"||IS_ALPHA(C)||C$=="_"THEN
  VAR ISLBL=C$=="@"
  FOR LEXER_I=LEXER_I+ISLBL TO LAST(LEXER_IN$)
   C$=LEXER_IN$[LEXER_I]
   C=ASC(C$)
   IF IS_ALPHA(C)||C$=="_"||IS_NUM(C)THEN
    CONTINUE
   ENDIF
   BREAK
  NEXT
  IF !ISLBL&&IS_VARSUFFIX(MID$(LEXER_IN$,LEXER_I,1))THEN
   INC LEXER_I
  ENDIF
  LEXER_VAL=MID$(LEXER_IN$,SI,LEXER_I-SI)
  IF ISLBL THEN
   LEXER_TKN=#TKN_LABEL
  ELSE
   LEXER_TKN=LEX_RECOG_IDEN(LEXER_VAL)
  ENDIF
  RETURN
 ELSEIF C==34 THEN'STRING
  LEXER_VAL=""
  FOR LEXER_I=LEXER_I+1 TO LAST(LEXER_IN$)
   C$=LEXER_IN$[LEXER_I]
   C=ASC(C$)
   IF C==34||C==10||C==13 THEN
    IF C==34 THEN INC LEXER_I
    BREAK
   ENDIF
   PUSH LEXER_VAL,C$
  NEXT
  LEXER_TKN=#TKN_STR
  RETURN
 ENDIF
 ?"Synt
 STOP
END
DEF LEX_RECOG_IDEN(V)
 CASE TO_UPPER$(V)
 WHEN "PRINT"
  RETURN #TKN_PRINT
 WHEN "DIV"
  RETURN #TKN_DIVINT
 WHEN "MOD"
  RETURN #TKN_MOD
 WHEN "AND"
  RETURN #TKN_AND
 WHEN "OR"
  RETURN #TKN_OR
 WHEN "XOR"
  RETURN #TKN_XOR
 WHEN "NOT"
  RETURN #TKN_NOT
 WHEN "OUT"
  RETURN #TKN_OUT
 WHEN "CALL"
  RETURN #TKN_CALL
 WHEN "VAR"
  RETURN #TKN_VAR
 WHEN "DIM"
  RETURN #TKN_DIM
 WHEN "IF"
  RETURN #TKN_IF
 WHEN "THEN"
  RETURN #TKN_THEN
 WHEN "ENDIF"
  RETURN #TKN_ENDIF
 WHEN "ELSE"
  RETURN #TKN_ELSE
 WHEN "ELSEIF"
  RETURN #TKN_ELSEIF
 WHEN "FOR"
  RETURN #TKN_FOR
 WHEN "NEXT"
  RETURN #TKN_NEXT
 WHEN "GOTO"
  RETURN #TKN_GOTO
 WHEN "GOSUB"
  RETURN #TKN_GOSUB
 WHEN "BREAK"
  RETURN #TKN_BREAK
 WHEN "CONTINUE"
  RETURN #TKN_CONTINUE
 WHEN "REPEAT"
  RETURN #TKN_REPEAT
 WHEN "UNTIL"
  RETURN #TKN_UNTIL
 WHEN "WHILE"
  RETURN #TKN_WHILE
 WHEN "WEND"
  RETURN #TKN_WEND
 WHEN "REPEAT"
  RETURN #TKN_REPEAT
 WHEN "UNTIL"
  RETURN #TKN_UNTIL
 WHEN "LOOP"
  RETURN #TKN_LOOP
 WHEN "ENDLOOP"
  RETURN #TKN_ENDLOOP
 WHEN "RETURN"
  RETURN #TKN_RETURN
 OTHERWISE
  RETURN #TKN_IDEN
 ENDCASE
END

ENUM\
 #VMT_DEFAULT,\
 #VMT_INT,\
 #VMT_REAL,\
 #VMT_STR,\
 #VMT_VARREF,\
 #VMT_ARYREF1,\
 #VMT_ARYREF2,\
 #VMT_ARYREF3,\
 #VMT_ARYREF4,\
 #VMT_SUBROUTINE,\
 #VMT_LAST
ENUM\
 #VM_NOP,\
 #VM_PUSHINT,\
 #VM_PUSHDBL,\
 #VM_PUSHSTR,\
 #VM_BINOP,\
 #VM_PRINT_E,\
 #VM_PRINT,\
 #VM_PRINT_COMMA,\
 #VM_PRINT_SEMI,\
 #VM_ASSIGN,\
 #VM_PUSHVARREF,\
 #VM_REF,\
 #VM_BR,\
 #VM_BRTRUE,\
 #VM_BRFALSE,\
 #VM_FOR,\
 #VM_FORINIT,\
 #VM_BRAND,\
 #VM_BROR,\
 #VM_GOTO_PLACEHOLDER,\
 #VM_GOSUB_PLACEHOLDER,\
 #VM_GOSUB,\
 #VM_GOTOEXPR,\
 #VM_GOSUBEXPR,\
 #VM_ONGOTO,\
 #VM_ONGOSUB,\
 #VM_RETURN,\
 #VM_,\
 #VM_LAST



DIM AST_TYP[]
DIM AST%[]
DIM AST#[]
DIM AST$[]
DIM AST_LEFT[]
DIM AST_RIGHT[]
DIM AST_NEXT[]
DIM AST_PREV[]
DIM AST_A1[]
DIM AST_A2[]
DIM AST_A3[]
DIM AST_A4[]
DIM AST_A5[]
DEF INIT_AST
 VAR S=1
 AST_TYP=ARRAY%(S)
 AST%=ARRAY%(S)
 AST#=ARRAY#(S)
 AST$=ARRAY$(S)
 AST_LEFT=ARRAY%(S)
 AST_NEXT=ARRAY%(S)
 AST_RIGHT=ARRAY%(S)
 AST_PREV=ARRAY%(S)
 AST_A1=ARRAY%(S)
 AST_A2=ARRAY%(S)
 AST_A3=ARRAY%(S)
 AST_A4=ARRAY%(S)
 AST_A5=ARRAY%(S)
END

'BINOP:AST%-TKN
ENUM\
 #AST_ITEM,\
 #AST_BINOP,\
 #AST_PRINT,\
 #AST_IMM_INT,\
 #AST_IMM_DBL,\
 #AST_IMM_STR,\
 #AST_STATEMENTS,\
 #AST_PRINT_EXPR_NEWLINE,\
 #AST_PRINT_EXPR_COMMA,\
 #AST_PRINT_EXPR_SEMI,\
 #AST_ASSIGN,\
 #AST_VAR,\
 #AST_IF,\
 #AST_FOR,\
 #AST_BREAK,\
 #AST_CONTINUE,\
 #AST_WHILE,\
 #AST_REPEAT,\
 #AST_LOOP,\
 #AST_LABEL,\
 #AST_GOTO,\
 #AST_GOSUB,\
 #AST_GOTOEXPR,\
 #AST_GOSUBEXPR,\
 #AST_ONGOTO,\
 #AST_ONGOSUB,\
 #AST_ONBREAKGOTO,\
 #AST_ONBREAKGOTOEXPR,\
 #AST_RETURN,\
 #AST_RETURNFUNC,\
 #AST_LAST
DEF AST_STR$(TYP)
 CASE TYP
 WHEN #AST_ITEM:RETURN "#AST_ITEM"
 WHEN #AST_BINOP:RETURN "#AST_BINOP"
 WHEN #AST_PRINT:RETURN "#AST_PRINT"
 WHEN #AST_IMM_INT:RETURN "#AST_IMM_INT"
 WHEN #AST_IMM_DBL:RETURN "#AST_IMM_DBL"
 WHEN #AST_IMM_STR:RETURN "#AST_IMM_STR"
 WHEN #AST_STATEMENTS:RETURN "#AST_STATEMENTS"
 WHEN #AST_PRINT_EXPR_NEWLINE:RETURN "#AST_PRINT_EXPR_NEWLINE"
 WHEN #AST_PRINT_EXPR_COMMA:RETURN "#AST_PRINT_EXPR_COMMA"
 WHEN #AST_PRINT_EXPR_SEMI:RETURN "#AST_PRINT_EXPR_SEMI"
 WHEN #AST_ASSIGN:RETURN "#AST_ASSIGN"
 WHEN #AST_VAR:RETURN "#AST_VAR"
 WHEN #AST_IF:RETURN "#AST_IF"
 WHEN #AST_FOR:RETURN "#AST_FOR"
 WHEN #AST_BREAK:RETURN "#AST_BREAK"
 WHEN #AST_CONTINUE:RETURN "#AST_CONTINUE"
 WHEN #AST_LAST:RETURN "#AST_LAST"
 OTHERWISE
  RETURN "#AST"+STR$(TYP)
 ENDCASE
END
DEF NEW_AST(TYP)
 PUSH AST_TYP,TYP
 VAR E$
 PUSH AST%,0
 PUSH AST#,0
 PUSH AST$,E$
 PUSH AST_LEFT,0
 PUSH AST_RIGHT,0
 PUSH AST_NEXT,0
 PUSH AST_PREV,0
 PUSH AST_A1,0
 PUSH AST_A2,0
 PUSH AST_A3,0
 PUSH AST_A4,0
 PUSH AST_A5,0
 RETURN LAST(AST_TYP)
END

DEF NEW_AST_LR(TYP,L,R)
 VAR A=NEW_AST(TYP)
 AST_LEFT[A]=L
 AST_RIGHT[A]=R
 RETURN A
END

DEF NEW_AST_APPEND(TYP,PREV)
 VAR A=NEW_AST(TYP)
 AST_PREV[A]=PREV
 AST_NEXT[PREV]=LAST(AST_TYP)
 RETURN LAST(AST_TYP)
END

DEF NEW_AST_INT(TYP,V%)
 VAR A=NEW_AST(TYP)
 AST%[A]=V%
 RETURN A
END

DEF NEW_AST_DBL(TYP,V#)
 VAR A=NEW_AST(TYP)
 AST#[A]=V#
 RETURN A
END
DEF NEW_AST_STR(TYP,V$)
 VAR A=NEW_AST(TYP)
 AST$[A]=V$
 RETURN A
END

DEF AST_IND IND
 ?" "*IND;
END
DEF DUMP_AST A,IND
 IF!A THEN RETURN
 VAR I,J
 CASE AST_TYP[A]
 WHEN #AST_STATEMENTS
  AST_IND IND:?"STATEMENTS"
  I=AST_NEXT[AST_LEFT[A]]
  WHILE I
   IF!I THEN BREAK
   DUMP_AST AST_LEFT[I],IND+1
   I=AST_NEXT[I]
  WEND
 WHEN #AST_PRINT
  AST_IND IND:?"PRINT"
  INC IND
  I=AST_NEXT[AST_LEFT[A]]
  WHILE I
   IF!I THEN BREAK
   CASE AST_TYP[I]
   WHEN #AST_PRINT_EXPR_COMMA
    AST_IND IND:?"PRINT COMMA"
   WHEN #AST_PRINT_EXPR_NEWLINE
    AST_IND IND:?"PRINT NEWLINE"
   WHEN #AST_PRINT_EXPR_SEMI
    AST_IND IND:?"PRINT SEMI"
   ENDCASE
   DUMP_AST AST_LEFT[I],IND+1
   I=AST_NEXT[I]
  WEND
 WHEN #AST_IF
  AST_IND IND:?"IF"
  INC IND
  AST_IND IND:?"IF EXPR"
  DUMP_AST AST_A1[A],IND+1
  AST_IND IND:?"IF THEN STATEMENTS"
  DUMP_AST AST_A2[A],IND+1
  IF AST_A3[A] THEN
   I=AST_NEXT[AST_A3[A]]
   WHILE I
    AST_IND IND:?"IF ELSEIF EXPR[";J;"]"
    DUMP_AST AST_A1[I],IND+1
    AST_IND IND:?"IF ELSEIF STATEMENTS[";J;"]"
    DUMP_AST AST_A2[I],IND+1
    INC J
    I=AST_NEXT[I]
   WEND
  ENDIF
  AST_IND IND:?"IF ELSE STATEMENTS"
  DUMP_AST AST_A4[A],IND+1
 WHEN #AST_ASSIGN
  AST_IND IND:?"ASSIGN"
  DUMP_AST AST_LEFT[A],IND+1
  DUMP_AST AST_RIGHT[A],IND+1
 WHEN #AST_FOR
  AST_IND IND:?"FOR"
  DUMP_AST AST_A1[A],IND+1
  DUMP_AST AST_A2[A],IND+1
  DUMP_AST AST_A3[A],IND+1
  DUMP_AST AST_A4[A],IND+1
  DUMP_AST AST_A5[A],IND+1
 WHEN #AST_BINOP
  AST_IND IND:?"BINOP ";TKN_STR$(AST%[A])
  DUMP_AST AST_LEFT[A],IND+1
  DUMP_AST AST_RIGHT[A],IND+1
 WHEN #AST_IMM_INT
  AST_IND IND:?"INT ";AST%[A]
 WHEN #AST_IMM_DBL
  AST_IND IND:?"DOUBLE ";AST#[A]
 WHEN #AST_IMM_STR
  AST_IND IND:?"STR ";AST$[A]
 WHEN #AST_VAR
  AST_IND IND:?"VAR ";AST$[A]
 OTHERWISE
  AST_IND IND:?AST_STR$(AST_TYP[A])
 ENDCASE
END

VAR PARSER_RETURN_EXPR
VAR PARSER_IN_FUNC
DEF INIT_PARSER
 PARSER_RETURN_EXPR=#FALSE
 PARSER_IN_FUNC=#FALSE
END
DEF PARSE()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LEX_NEXT OUT T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_EOF THEN RETURN ROOT
  IF T==#TKN_NEWLINE THEN LEX_NEXT OUT ,:CONTINUE
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_STATEMENT()
 LOOP
  VAR T
  LEX_CUR OUT T,
  CASE T
  WHEN #TKN_PRINT
   RETURN PARSE_PRINT()
  WHEN #TKN_IDEN
   RETURN PARSE_IDEN()
  WHEN #TKN_IF
   RETURN PARSE_IF()
  WHEN #TKN_FOR
   RETURN PARSE_FOR()
  WHEN #TKN_BREAK
   LEX_NEXT OUT ,
   RETURN NEW_AST(#AST_BREAK)
  WHEN #TKN_CONTINUE
   LEX_NEXT OUT ,
   RETURN NEW_AST(#AST_CONTINUE)
  WHEN #TKN_REPEAT
   RETURN PARSE_REPEAT()
  WHEN #TKN_WHILE
   RETURN PARSE_WHILE()
  WHEN #TKN_LOOP
   RETURN PARSE_LOOP()
  WHEN #TKN_LABEL
   RETURN PARSE_LABEL()
  WHEN #TKN_GOTO
   RETURN PARSE_GOTO()
  WHEN #TKN_GOSUB
   RETURN PARSE_GOSUB()
  WHEN #TKN_ON
   RETURN PARSE_ON()
  WHEN #TKN_RETURN
   RETURN PARSE_RETURN()
  ENDCASE
  SYNTAX_ERROR
 ENDLOOP
END
DEF PARSE_IDEN()
 VAR T,NAME$,V
 LEX_CUR OUT T,NAME$
 VAR EXPR=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T==#TKN_ASSIGN THEN
  RETURN PARSE_ASSIGN(EXPR)
 ELSE
  ?"NOTIMPL":STOP
 ENDIF
 'IDEN=EXPR
 'IDEN [EXPR,EXPR...] [OUT REF-EXPR...]
END
DEF PARSE_ASSIGN(EXPR)
 LEX_NEXT OUT ,
 VAR AST=NEW_AST(#AST_ASSIGN)
 AST_LEFT[AST]=EXPR
 AST_RIGHT[AST]=PARSE_EXPR()
 RETURN AST
END
DEF PARSE_IF()
 LEX_NEXT OUT ,
 VAR EXPR=PARSE_EXPR()
 VAR T,V
 LEX_CUR OUT T,V
 CASE T
 WHEN #TKN_GOTO
  NOTIMPL
 WHEN #TKN_THEN
  LEX_NEXT OUT T,V
  IF T==#TKN_NEWLINE THEN
   RETURN PARSE_MULTILINE_IF(EXPR)
  ENDIF
  NOTIMPL
 OTHERWISE
  SYNTAX_ERROR
 ENDCASE
END
DEF PARSE_MULTILINE_IF(EXPR)
 VAR AST=NEW_AST(#AST_IF)
 VAR THENSTMTS=PARSE_MULTILINE_IF_STATEMENTS()
 VAR T,V
 AST_A1[AST]=EXPR
 AST_A2[AST]=THENSTMTS
 LEX_CUR OUT T,V
 LEX_NEXT OUT ,
 IF T==#TKN_ENDIF THEN
  RETURN AST
 ENDIF
 IF T==#TKN_ELSE THEN
  AST_A4[AST]=PARSE_MULTILINE_ELSE_STATEMENTS()
  LEX_NEXT OUT ,
  RETURN AST
 ENDIF
 IF T==#TKN_ELSEIF THEN
  VAR P=NEW_AST(#AST_ITEM)
  AST_A3[AST]=P
  LOOP
   VAR ELIFEXPR=PARSE_EXPR()
   LEX_CUR OUT T,V
   IF T!=#TKN_THEN THEN SYNTAX_ERROR "THEN EXPECTED":RETURN AST
   LEX_NEXT OUT ,
   VAR ELIFSTMTS=PARSE_MULTILINE_IF_STATEMENTS()
   VAR ITEM=NEW_AST(#AST_ITEM)
   AST_A1[ITEM]=ELIFEXPR
   AST_A2[ITEM]=ELIFSTMTS
   AST_NEXT[P]=ITEM
   P=ITEM
   LEX_CUR OUT T,V
   LEX_NEXT OUT ,
   IF T==#TKN_ENDIF THEN
    RETURN AST
   ENDIF
   IF T==#TKN_ELSE THEN
    AST_A4[AST]=PARSE_MULTILINE_ELSE_STATEMENTS()
    LEX_NEXT OUT ,
    RETURN AST
   ENDIF
  ENDLOOP
  RETURN AST
 ENDIF
 SYNTAX_ERROR
 RETURN AST
END
DEF PARSE_MULTILINE_IF_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LEX_NEXT OUT T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_ENDIF THEN RETURN ROOT
  IF T==#TKN_ELSE THEN RETURN ROOT
  IF T==#TKN_ELSEIF THEN RETURN ROOT
  IF T==#TKN_EOF THEN SYNTAX_ERROR:RETURN ROOT
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_MULTILINE_ELSE_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LEX_NEXT OUT T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_ENDIF THEN RETURN ROOT
  IF T==#TKN_EOF THEN SYNTAX_ERROR:RETURN ROOT
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_FOR_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LEX_NEXT OUT T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_NEXT THEN RETURN ROOT
  IF T==#TKN_EOF THEN SYNTAX_ERROR:RETURN ROOT
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_FOR()
 'A1:INDEXREFEXPR
 'A2:INITEXPR
 'A3:TOEXPR
 'A4:STEPEXPR
 'A5:STATEMENTS
 VAR T,V
 LEX_NEXT OUT ,
 VAR AST=NEW_AST(#AST_FOR)
 'REFEXPR
 AST_A1[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T!=#TKN_ASSIGN THEN
  SYNTAX_ERROR "EXPECTED '='"
 ENDIF
 LEX_NEXT OUT ,
 'INITEXPR
 AST_A2[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T!=#TKN_IDEN||V!="TO" THEN
  SYNTAX_ERROR "EXPECTED 'TO'"
 ENDIF
 LEX_NEXT OUT ,
 'TOEXPR
 AST_A3[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T==#TKN_IDEN&&V=="STEP" THEN
  LEX_NEXT OUT ,
  'STEPEXPR
  AST_A4[AST]=PARSE_EXPR()
 ENDIF
 AST_A5[AST]=PARSE_FOR_STATEMENTS()
 LEX_NEXT OUT T,V
 'NEXT [IDEN]
 'NEXT IDEN1,IDEN2 NOT ALLOWED
 IF T==#TKN_IDEN THEN LEX_NEXT OUT ,
 RETURN AST
END

DEF PARSE_WHILE()
 VAR AST=NEW_AST(#AST_WHILE)
 VAR T,V
 LEX_NEXT OUT ,
 AST_A1[AST]=PARSE_EXPR()
 AST_A2[AST]=PARSE_WHILE_STATEMENTS()
 RETURN AST
END
DEF PARSE_WHILE_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LEX_NEXT OUT T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_WEND THEN LEX_NEXT OUT,:RETURN ROOT
  IF T==#TKN_EOF THEN SYNTAX_ERROR:RETURN ROOT
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END

DEF PARSE_REPEAT()
 VAR AST=NEW_AST(#AST_REPEAT)
 VAR T,V
 LEX_NEXT OUT ,
 AST_A2[AST]=PARSE_REPEAT_STATEMENTS()
 AST_A1[AST]=PARSE_EXPR()
 RETURN AST
END
DEF PARSE_REPEAT_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LEX_NEXT OUT T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_UNTIL THEN LEX_NEXT OUT ,:RETURN ROOT
  IF T==#TKN_EOF THEN SYNTAX_ERROR:RETURN ROOT
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_LOOP()
 VAR AST=NEW_AST(#AST_LOOP)
 VAR T,V
 LEX_NEXT OUT ,
 AST_A2[AST]=PARSE_LOOP_STATEMENTS()
 RETURN AST
END
DEF PARSE_LOOP_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LEX_NEXT OUT T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_ENDLOOP THEN LEX_NEXT OUT ,:RETURN ROOT
  IF T==#TKN_EOF THEN SYNTAX_ERROR:RETURN ROOT
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_LABEL()
 VAR T,V
 LEX_CUR OUT T,V
 LEX_NEXT OUT ,
 VAR AST=NEW_AST(#AST_LABEL)
 AST$[AST]=V
 RETURN AST
END
DEF PARSE_GOTO()
 VAR T,V,AST
 LEX_NEXT OUT T,V
 IF T==#TKN_LABEL THEN
  AST=NEW_AST(#AST_GOTO)
  AST$[AST]=V
  LEX_NEXT OUT T,V
 ELSE
  AST=NEW_AST(#AST_GOTOEXPR)
  AST_LEFT[AST]=PARSE_EXPR()
 ENDIF
 RETURN AST
END
DEF PARSE_GOSUB()
 VAR T,V,AST
 LEX_NEXT OUT T,V
 IF T==#TKN_LABEL THEN
  AST=NEW_AST(#AST_GOSUB)
  AST$[AST]=V
  LEX_NEXT OUT T,V
 ELSE
  AST=NEW_AST(#AST_GOSUBEXPR)
  AST_LEFT[AST]=PARSE_EXPR()
 ENDIF
 RETURN AST
END
DEF PARSE_ON()
 VAR T,V,AST
 LEX_NEXT OUT T,V
 IF T==#TKN_BREAK THEN
  LEX_NEXT OUT T,V
  IF T==#TKN_LABEL THEN
   AST=NEW_AST(#AST_ONBREAKGOTO)
   AST$[AST]=V
  ELSE
   AST=NEW_AST(#AST_ONBREAKGOTOEXPR)
   AST_LEFT[AST]=PARSE_EXPR()
  ENDIF
 ELSE
  VAR EXPR=PARSE_EXPR()
  LEX_CUR OUT T,V
  IF T==#TKN_GOTO THEN
   AST=NEW_AST(#AST_ONGOTO)
  ELSEIF T==#TKN_GOSUB THEN
   AST=NEW_AST(#AST_ONGOSUB)
  ELSE
   SYNTAX_ERROR "EXPECTED GOTO OR GOSUB(ON GOTO)"
   RETURN AST
  ENDIF
  AST_A1[AST]=EXPR
  LEX_NEXT OUT T,V
  VAR P=NEW_AST(#AST_ITEM)
  AST_A3[AST]=P
  LOOP
   IF T!=#TKN_LABEL THEN
    SYNTAX_ERROR "EXPECTED LABEL(ON GOTO)"
    RETURN AST
   ENDIF
   VAR ITEM=NEW_AST(#AST_ITEM)
   AST$[ITEM]=V
   AST_NEXT[P]=ITEM
   P=ITEM
   LEX_NEXT OUT T,V
   IF T!=#TKN_COMMA THEN BREAK
  ENDLOOP
 ENDIF
END
DEF PARSE_RETURN()
 LEX_NEXT OUT ,
 VAR AST
 IF PARSER_IN_FUNC THEN
  AST=NEW_AST(#AST_RETURNFUNC)
 ELSE
  AST=NEW_AST(#AST_RETURN)
 ENDIF
 IF PARSER_RETURN_EXPR THEN
  AST_LEFT[AST]=PARSE_EXPR()
 ENDIF
 RETURN AST
END
DEF IS_EXPR_TKN(T)
 CASE T
 WHEN #TKN_NUM
 WHEN #TKN_STR
 WHEN #TKN_IDEN
 WHEN #TKN_LP
 WHEN #TKN_MINUS
 WHEN #TKN_NOT
 WHEN #TKN_LNOT
 WHEN #TKN_LABEL
  RETURN #TRUE
 ENDCASE
 RETURN #FALSE
END
DEF PARSE_PRINT()
 VAR T,V
 VAR AST=NEW_AST(#AST_PRINT)
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[AST]=PRV
 LEX_NEXT OUT T,V
 IF !IS_EXPR_TKN(T)THEN
  ?"PRINT_E"
'   EMIT_PRINT_E
  RETURN AST
 ENDIF
 WHILE 1
  VAR EXPR=PARSE_EXPR()
  LEX_CUR OUT T,V
  VAR A
  IF T==#TKN_COMMA THEN
   ?"PRINT_COMMA"
   A=NEW_AST(#AST_PRINT_EXPR_COMMA)
   LEX_NEXT OUT ,
'   EMIT_PRINT_COMMA
  ELSEIF T==#TKN_SEMI THEN
   ?"PRINT_SEMI"
   A=NEW_AST(#AST_PRINT_EXPR_SEMI)
   LEX_NEXT OUT ,
'   EMIT_PRINT_SEMI
  ELSE
   ?"PRINT"
   A=NEW_AST(#AST_PRINT_EXPR_NEWLINE)
'   EMIT_PRINT
  ENDIF
  AST_LEFT[A]=EXPR
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
  IF T!=#TKN_COMMA&&T!=#TKN_SEMI THEN
   RETURN AST
  ENDIF
  LEX_CUR OUT T,V
  IF !IS_EXPR_TKN(T)THEN
   RETURN AST
  ENDIF
 WEND
END
DEF PARSE_TERM()
 VAR T,V
 LEX_CUR OUT T,V
 VAR AST
 CASE T
 WHEN #TKN_MINUS
  RETURN PARSE_TERM()
  ?"MINUS UNARY"
 'FIXME:EXPND CONST EXPR
 WHEN #TKN_NUM
  ?"IMM",V
  IF TYPEOF(V)==#T_INT THEN
   AST=NEW_AST_INT(#AST_IMM_INT,V)
'   EMIT_PUSHINT V
  ELSEIF TYPEOF(V)==#T_REAL THEN
   AST=NEW_AST_DBL(#AST_IMM_DBL,V)
'   EMIT_PUSHDBL V
  ELSE
   STOP
  ENDIF
 WHEN #TKN_LABEL
 WHEN #TKN_STR
  ?"IMM",V
'  EMIT_PUSHSTR V
  AST=NEW_AST_STR(#AST_IMM_STR,V)
 WHEN #TKN_IDEN
  ?"VAR",V
  AST=NEW_AST_STR(#AST_VAR,V)
 OTHERWISE
  SYNTAX_ERROR
 ENDCASE
 LEX_NEXT OUT T,V
 RETURN AST
END
ENUM\
 #OPRANK_NOTANOP,\
 #OPRANK_MIN,\
 #OPRANK_PARENT,\
 #OPRANK_MUL,\
 #OPRANK_PLUS,\
 #OPRANK_SHIFT,\
 #OPRANK_EQ,\
 #OPRANK_BIT,\
 #OPRANK_LOG,\
 #OPRANK_MAX
DEF GET_OP_RANK(T)
 CASE T
 WHEN #TKN_LP
 WHEN #TKN_LB
  RETURN #OPRANK_PARENT
 WHEN #TKN_MUL
 WHEN #TKN_DIV
 WHEN #TKN_DIVINT
 WHEN #TKN_MOD
  RETURN #OPRANK_MUL
 WHEN #TKN_PLUS
 WHEN #TKN_MINUS
  RETURN #OPRANK_PLUS
 WHEN #TKN_LSHIFT
 WHEN #TKN_RSHIFT
  RETURN #OPRANK_SHIFT
 WHEN #TKN_EQ
 WHEN #TKN_NEQ
 WHEN #TKN_LESS
 WHEN #TKN_LEQ
 WHEN #TKN_GREAT
 WHEN #TKN_GEQ
  RETURN #OPRANK_EQ
 WHEN #TKN_AND
 WHEN #TKN_OR
 WHEN #TKN_XOR
  RETURN #OPRANK_BIT
 WHEN #TKN_LAND
 WHEN #TKN_LOR
  RETURN #OPRANK_LOG
 ENDCASE
 RETURN #OPRANK_NOTANOP
END
DEF PARSE_EXPR()
 RETURN PARSE_EXPR0(#OPRANK_MAX)
END
DEF PARSE_EXPR0(RANK)
 IF RANK==#OPRANK_MIN THEN
  RETURN PARSE_TERM()
 ENDIF
 VAR T,V
 VAR LEFT=PARSE_EXPR0(RANK-1)
 LOOP
  LEX_CUR OUT T,V
  IF GET_OP_RANK(T)==RANK THEN
   LEX_NEXT OUT ,
   VAR RIGHT=PARSE_EXPR0(RANK-1)
   ?"BINARY OP",TKN_STR$(T)
   LEFT=NEW_AST_LR(#AST_BINOP,LEFT,RIGHT)
   AST%[LEFT]=T
'   EMIT_BINOP T
   CONTINUE
  ENDIF
  BREAK
 ENDLOOP
 RETURN LEFT
END

VAR CMP_STRICT
VAR CMP_DEFINT
VAR CMP_GVARTBL_IDX
VAR CMP_GVARTBL_TYP
VAR CMP_GLBLTBL
VAR CMP_GFUNCTBL

VAR CMP_GVARNUM

DIM CMP_BREAK[]
DIM CMP_CONTINUE[]
DEF INIT_COMPILER
 CMP_STRICT=#FALSE
 CMP_DEFINT=#FALSE
 CMP_GVARTBL_IDX=NEW_SPLAY_TREE()
 CMP_GVARTBL_TYP=NEW_SPLAY_TREE()
 CMP_GLBLTBL=NEW_SPLAY_TREE()
 CMP_GFUNCTBL=NEW_SPLAY_TREE()
 CMP_GVARNUM=1
 CMP_BREAK=EMPTY()
 CMP_CONTINUE=EMPTY()
END
DEF DEFINE_VAR(NAME$,LOCAL)
 VAR TYP
 CASE RIGHT$(NAME$,1)
 WHEN "$"
  TYP=#VMT_STR
 WHEN "%"
  TYP=#VMT_INT
 WHEN "#"
  TYP=#VMT_REAL
 OTHERWISE
  IF CMP_DEFINT THEN
   TYP=#VMT_INT
  ELSE
   TYP=#VMT_REAL
  ENDIF
 ENDCASE
 ?"DEFINE VAR ";NAME$,TYP
 SPLAY_INSERT% CMP_GVARTBL_IDX,NAME$,CMP_GVARNUM
 INC CMP_GVARNUM
 SPLAY_INSERT% CMP_GVARTBL_TYP,NAME$,TYP
 RETURN CMP_GVARNUM-1
END
DEF GET_VAR_INDEX NAME$ OUT IDX
 'TODO:LOCAL
 VAR FOUND
 SPLAY_GET% CMP_GVARTBL_IDX,NAME$ OUT FOUND,IDX
 IF !FOUND THEN
  IF CMP_STRICT THEN
   UNDEFINED_VARIABLE_ERROR
  ENDIF
  IDX=DEFINE_VAR(NAME$,#FALSE)
 ENDIF
END
DEF DEFINE_LABEL NAME$
 'TODO:LOCAL
 VAR FOUND
 SPLAY_GET% CMP_GLBLTBL,NAME$ OUT FOUND,
 IF FOUND THEN
  DUPLICATE_LABEL NAME$
 ENDIF
 SPLAY_INSERT% CMP_GLBLTBL,NAME$,COMPILER_CURRENT_ADDR()
END
DEF COMPILE AST
 COMPILE_STATEMENTS AST
END
DEF COMPILE_STATEMENTS A
 VAR I
 CASE AST_TYP[A]
 WHEN #AST_STATEMENTS
  I=AST_NEXT[AST_LEFT[A]]
  WHILE I
   IF!I THEN BREAK
   COMPILE_STATEMENT AST_LEFT[I]
   I=AST_NEXT[I]
  WEND
 OTHERWISE
  COMPILE_ERROR
 ENDCASE
END
DEF COMPILE_STATEMENT A
 VAR I
 CASE AST_TYP[A]
 WHEN #AST_PRINT
  I=AST_NEXT[AST_LEFT[A]]
  IF !I THEN
   EMIT_PRINT_E
  ENDIF
  WHILE I
   IF!I THEN BREAK
   COMPILE_EXPR AST_LEFT[I]
   CASE AST_TYP[I]
   WHEN #AST_PRINT_EXPR_COMMA
    EMIT_PRINT_COMMA
   WHEN #AST_PRINT_EXPR_NEWLINE
    EMIT_PRINT
   WHEN #AST_PRINT_EXPR_SEMI
    EMIT_PRINT_SEMI
   ENDCASE
   I=AST_NEXT[I]
  WEND
 WHEN #AST_ASSIGN
  COMPILE_EXPR AST_RIGHT[A]
  COMPILE_REFEXPR AST_LEFT[A]
  EMIT_ASSIGN
 'A1:EXPR
 'A2:THEN STATEMENTS
 'A3:ELSEIF STATEMENTS
 'A4:ELSE STATEMENTS
 WHEN #AST_IF
  COMPILE_IF A
 WHEN #AST_FOR
  COMPILE_FOR A
 WHEN #AST_BREAK
  COMPILE_BREAK
 WHEN #AST_CONTINUE
  COMPILE_CONTINUE
 WHEN #AST_WHILE
  COMPILE_WHILE A
 WHEN #AST_REPEAT
  COMPILE_REPEAT A
 WHEN #AST_LOOP
  COMPILE_LOOP A
 WHEN #AST_LABEL
  COMPILE_LABEL A
 WHEN #AST_GOTO
  COMPILE_GOTO A
 WHEN #AST_GOSUB
  COMPILE_GOSUB A
 WHEN #AST_GOTOEXPR
  COMPILE_GOTOEXPR A
 WHEN #AST_GOSUBEXPR
  COMPILE_GOSUBEXPR A
 WHEN #AST_ONGOTO
  COMPILE_ONGOTO A
 WHEN #AST_ONGOSUB
  COMPILE_ONGOSUB A
 WHEN #AST_ONBREAKGOTO
  COMPILE_ONBREAKGOTO A
 WHEN #AST_ONBREAKGOTOEXPR
  COMPILE_ONBREAKGOTOEXPR A
 WHEN #AST_RETURN
  COMPILE_RETURN A
 OTHERWISE
  COMPILE_ERROR
 ENDCASE
END
DEF COMPILE_IF A
 COMPILE_EXPR AST_A1[A]
 VAR ADDR_ELSE=EMIT_BRFALSE()
 COMPILE_STATEMENTS AST_A2[A]
 IF AST_A4[A]THEN
  VAR ADDR_ENDIF=EMIT_BR()
 ENDIF
 EMIT_ADDR ADDR_ELSE
 IF AST_A3[A]THEN'ELSEIF
  DIM BRLIST[0]
  VAR I=AST_NEXT[AST_A3[A]]
  WHILE I
   COMPILE_EXPR AST_A1[I]
   VAR ADDR_AFTER_ELSEIF=EMIT_BRFALSE()
   COMPILE_STATEMENTS AST_A2[I]
   I=AST_NEXT[I]
   PUSH BRLIST,EMIT_BR()
   EMIT_ADDR ADDR_AFTER_ELSEIF
  WEND
 ENDIF
 IF AST_A4[A]THEN'ELSE
  COMPILE_STATEMENTS AST_A4[A]
  EMIT_ADDR ADDR_ENDIF
 ENDIF
 IF AST_A3[A]THEN'ELSEIF
  FOR I=0TO LAST(BRLIST)
   EMIT_ADDR BRLIST[I]
  NEXT
 ENDIF
END
DEF COMPILE_CONTINUE
 IF TYPEOF(CMP_CONTINUE)!=#T_INTARRAY THEN
  SYNTAX_ERROR
  RETURN
 ENDIF
 PUSH CMP_CONTINUE,EMIT_BR()
END
DEF COMPILE_BREAK
 IF TYPEOF(CMP_CONTINUE)!=#T_INTARRAY THEN
  SYNTAX_ERROR
  RETURN
 ENDIF
 PUSH CMP_BREAK,EMIT_BR()
END
DEF COMPILE_FOR A
 'A1:INDEXREFEXPR
 'A2:INITEXPR
 'A3:TOEXPR
 'A4:STEPEXPR
 'A5:STATEMENTS
 VAR INDEXREF=AST_A1[A]
 VAR INITEXPR=AST_A2[A]
 VAR TOEXPR=AST_A3[A]
 VAR STEPEXPR=AST_A4[A]
 VAR STATEMENTS=AST_A5[A]
 COMPILE_EXPR INITEXPR
 COMPILE_REFEXPR INDEXREF
 EMIT_ASSIGN
 'FOR INDEXREF=INITEXPR TO TOEXPR STEP STEPEXPR
 'PUSH INITEXPR
 'PUSH INDEXREF
 'ASSIGN
 '@CONT
 'PUSH INDEXREF
 'PUSH STEPEXPR
 'PUSH TOEXPR
 '*FOR STEP INSTR* @BRK
 'STATEMENTS... (GOTO @CONT,@BRK
 'GOTO @CONT
 '@BRK


 'FOR INDEXREF=INITEXPR TO TOEXPR
 'PUSH INITEXPR
 'PUSH INDEXREF
 'ASSIGN
 '@CONT
 'PUSH INDEXREF
 'PUSH TOEXPR
 '*FOR INSTR* @BRK
 'STATEMENTS... (GOTO @CONT,@BRK
 'GOTO @CONT
 '@BRK
 COMPILE_REFEXPR INDEXREF
 IF STEPEXPR THEN
  COMPILE_EXPR STEPEXPR
 ELSE
  EMIT_PUSHINT 1
 ENDIF
 COMPILE_EXPR TOEXPR
 VAR BRKADDR
 BRKADDR=EMIT_FORINIT()
 VAR LOOPADDR=COMPILER_CURRENT_ADDR()
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  COMPILE_STATEMENTS STATEMENTS
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   EMIT_ADDR CMP_CONTINUE[I]
  NEXT
  COMPILE_REFEXPR INDEXREF
  IF STEPEXPR THEN
   COMPILE_EXPR STEPEXPR
  ELSE
   EMIT_PUSHINT 1
  ENDIF
  COMPILE_EXPR TOEXPR
  VAR BRKADDR2
  BRKADDR2=EMIT_FOR()
  EMIT_ADDR BRKADDR
  EMIT_ADDR2 BRKADDR2,LOOPADDR
  FOR I=0TO LAST(CMP_BREAK)
   EMIT_ADDR CMP_BREAK[I]
  NEXT
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF COMPILE_WHILE A
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  VAR CONTADDR=COMPILER_CURRENT_ADDR()
  COMPILE_EXPR AST_A1[A]
  VAR BRL=EMIT_BRFALSE()
  COMPILE_STATEMENTS AST_A2[A]
  EMIT_ADDR2 EMIT_BR(),CONTADDR
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   EMIT_ADDR2 CMP_CONTINUE[I],CONTADDR
  NEXT
  FOR I=0TO LAST(CMP_BREAK)
   EMIT_ADDR CMP_BREAK[I]
  NEXT
  EMIT_ADDR BRL
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF COMPILE_REPEAT A
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  VAR LOOPADDR=COMPILER_CURRENT_ADDR()
  COMPILE_STATEMENTS AST_A2[A]
  VAR CONTADDR=COMPILER_CURRENT_ADDR()
  COMPILE_EXPR AST_A1[A]
  EMIT_ADDR2 EMIT_BRFALSE(),LOOPADDR
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   EMIT_ADDR2 CMP_CONTINUE[I],CONTADDR
  NEXT
  FOR I=0TO LAST(CMP_BREAK)
   EMIT_ADDR CMP_BREAK[I]
  NEXT
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF COMPILE_LOOP A
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  VAR CONTADDR=COMPILER_CURRENT_ADDR()
  COMPILE_STATEMENTS AST_A2[A]
  EMIT_ADDR2 EMIT_BR(),CONTADDR
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   EMIT_ADDR2 CMP_CONTINUE[I],CONTADDR
  NEXT
  FOR I=0TO LAST(CMP_BREAK)
   EMIT_ADDR CMP_BREAK[I]
  NEXT
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF COMPILE_REFEXPR A
 CASE AST_TYP[A]
 WHEN #AST_VAR
  EMIT_PUSHVARREF GET_VAR_INDEX(AST$[A])
 OTHERWISE
  COMPILE_ERROR
 ENDCASE
END
DEF COMPILE_EXPR A
 CASE AST_TYP[A]
 WHEN #AST_BINOP
  VAR TYP=AST%[A]
  IF TYP==#TKN_LAND THEN
   COMPILE_EXPR AST_LEFT[A]
   VAR BR1=EMIT_BRAND()
   COMPILE_EXPR AST_RIGHT[A]
   VAR BR2=EMIT_BRAND()
   EMIT_PUSHINT #TRUE
   EMIT_ADDR BR1
   EMIT_ADDR BR2
  ELSEIF TYP==#TKN_LOR THEN
   COMPILE_EXPR AST_LEFT[A]
   BR1=EMIT_BROR()
   COMPILE_EXPR AST_RIGHT[A]
   BR2=EMIT_BROR()
   EMIT_PUSHINT #FALSE
   EMIT_ADDR BR1
   EMIT_ADDR BR2
  ELSE
   COMPILE_EXPR AST_LEFT[A]
   COMPILE_EXPR AST_RIGHT[A]
   EMIT_BINOP AST%[A]
  ENDIF
 WHEN #AST_IMM_INT
  EMIT_PUSHINT AST%[A]
 WHEN #AST_IMM_DBL
  EMIT_PUSHDBL AST#[A]
 WHEN #AST_IMM_STR
  EMIT_PUSHSTR AST$[A]
 WHEN #AST_VAR
  COMPILE_REFEXPR A
  EMIT_REF
 OTHERWISE
  COMPILE_ERROR
 ENDCASE
END
DEF COMPILE_LABEL A
 DEFINE_LABEL AST$[A]
END
DEF COMPILE_GOTO A
 EMIT_GOTO_PLACEHOLDER AST$[A]
END
DEF COMPILE_GOSUB A
 EMIT_GOSUB_PLACEHOLDER AST$[A]
END
DEF COMPILE_RETURN A
 EMIT_RETURN
END
DIM VM_OPS[]
DIM VM_IMM#[]
DIM VM_IMM$[]

DIM VM_STK_TYP[]
DIM VM_STK%[]
DIM VM_STK#[]
DIM VM_STK$[]
VAR VM_STK_SIZE
VAR VM_SP
VAR VM_BP
DIM VM_GVAR_TYP[]
DIM VM_GVAR%[]
DIM VM_GVAR#[]
DIM VM_GVAR$[]
VAR VM_GLBLTBL
VAR VM_PC

DEF INIT_VM
 VM_OPS=ARRAY%(0)
 VM_IMM#=ARRAY#(0)
 VM_IMM$=ARRAY$(0)
 VM_STK_SIZE=65536
 VM_STK_TYP=ARRAY%(VM_STK_SIZE)
 VM_STK%=ARRAY%(VM_STK_SIZE)
 VM_STK#=ARRAY#(VM_STK_SIZE)
 VM_STK$=ARRAY$(VM_STK_SIZE)
END
DEF INIT_VM_RUN2 N
 IF !N THEN RETURN
 INIT_VM_RUN2 GET_SPLAYN_LEFT(N)
 VAR K$=GET_SPLAYN_KEY$(N)
 VAR TYP=GET_SPLAYN_VAL%(N)
 VAR IDX
 SPLAY_GET% CMP_GVARTBL_IDX,K$ OUT ,IDX
 VM_GVAR_TYP[IDX]=TYP
 INIT_VM_RUN2 GET_SPLAYN_RIGHT(N)
END
DEF INIT_VM_RUN
 VM_GVAR_TYP=ARRAY%(CMP_GVARNUM)
 VM_GVAR%=ARRAY%(CMP_GVARNUM)
 VM_GVAR#=ARRAY#(CMP_GVARNUM)
 VM_GVAR$=ARRAY$(CMP_GVARNUM)
 INIT_VM_RUN2 GET_SPLAY_ROOT(CMP_GVARTBL_TYP)
 VM_PC=0
 VM_GLBLTBL=CMP_GLBLTBL
END
DEF EMIT_PUSHINT V
 PUSH VM_OPS,#VM_PUSHINT
 PUSH VM_OPS,V
END
DEF VM_ADDIMMDBL(V#)
 PUSH VM_IMM#,V#
 RETURN LAST(VM_IMM#)
END
DEF VM_ADDIMMSTR(V$)
 PUSH VM_IMM$,V$
 RETURN LAST(VM_IMM$)
END
DEF EMIT_PUSHDBL V#
 PUSH VM_OPS,#VM_PUSHDBL
 PUSH VM_OPS,VM_ADDIMMDBL(V#)
END
DEF EMIT_PUSHSTR V$
 PUSH VM_OPS,#VM_PUSHSTR
 PUSH VM_OPS,VM_ADDIMMSTR(V$)
END
DEF EMIT_BINOP TYP
 PUSH VM_OPS,#VM_BINOP
 PUSH VM_OPS,TYP
END
DEF EMIT_PRINT
 PUSH VM_OPS,#VM_PRINT
END
DEF EMIT_PRINT_E
 PUSH VM_OPS,#VM_PRINT_E
END
DEF EMIT_PRINT_COMMA
 PUSH VM_OPS,#VM_PRINT_COMMA
END
DEF EMIT_PRINT_SEMI
 PUSH VM_OPS,#VM_PRINT_COMMA
END
DEF EMIT_PUSHVARREF IDX
 PUSH VM_OPS,#VM_PUSHVARREF
 PUSH VM_OPS,IDX
END
DEF EMIT_REF
 PUSH VM_OPS,#VM_REF
END
DEF EMIT_ASSIGN
 PUSH VM_OPS,#VM_ASSIGN
END
DEF EMIT_BRFALSE()
 PUSH VM_OPS,#VM_BRFALSE
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_BRTRUE()
 PUSH VM_OPS,#VM_BRTRUE
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_BR()
 PUSH VM_OPS,#VM_BR
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_FOR()
 PUSH VM_OPS,#VM_FOR
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_FORINIT()
 PUSH VM_OPS,#VM_FORINIT
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_BRAND()
 PUSH VM_OPS,#VM_BRAND
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_BROR()
 PUSH VM_OPS,#VM_BROR
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_ADDR ADDR
 VM_OPS[ADDR]=LEN(VM_OPS)
END
DEF EMIT_ADDR2 ADDR,ADDR2
 VM_OPS[ADDR]=ADDR2
END
DEF EMIT_GOTO_PLACEHOLDER LABEL$
 PUSH VM_OPS,#VM_GOTO_PLACEHOLDER
 PUSH VM_OPS,VM_ADDIMMSTR(LABEL$)
END
DEF EMIT_GOSUB_PLACEHOLDER LABEL$
 PUSH VM_OPS,#VM_GOSUB_PLACEHOLDER
 PUSH VM_OPS,VM_ADDIMMSTR(LABEL$)
END
DEF EMIT_RETURN
 PUSH VM_OPS,#VM_RETURN
END
DEF COMPILER_CURRENT_ADDR()
 RETURN LEN(VM_OPS)
END
DEF VM_PUSHINT V%
 VM_STK_TYP[VM_SP]=#VMT_INT
 VM_STK%[VM_SP]=V%
 INC VM_SP
END
DEF VM_PUSHDBL V#
 VM_STK_TYP[VM_SP]=#VMT_REAL
 VM_STK#[VM_SP]=V#
 INC VM_SP
END
DEF VM_PUSHSTR V$
 VM_STK_TYP[VM_SP]=#VMT_STR
 VM_STK$[VM_SP]=V$
 INC VM_SP
END
DEF VM_PUSHTYP V%,TYP
 VM_STK_TYP[VM_SP]=TYP
 VM_STK%[VM_SP]=V%
 INC VM_SP
END
DEF VM_PUSH V
 CASE TYPEOF(V)
 WHEN #T_INT
  VM_STK_TYP[VM_SP]=#VMT_INT
  VM_STK%[VM_SP]=V
 WHEN #T_REAL
  VM_STK_TYP[VM_SP]=#VMT_REAL
  VM_STK#[VM_SP]=V
 WHEN #T_STR
  VM_STK_TYP[VM_SP]=#VMT_STR
  VM_STK$[VM_SP]=V
 OTHERWISE
  STOP
 ENDCASE
 INC VM_SP
END
DEF VM_POP OUT T,V
 DEC VM_SP
 T=VM_STK_TYP[VM_SP]
 CASE T
 WHEN #VMT_INT
  V=VM_STK%[VM_SP]
 WHEN #VMT_REAL
  V=VM_STK#[VM_SP]
 WHEN #VMT_STR
  V=VM_STK$[VM_SP]
 OTHERWISE
  STOP
 ENDCASE
END
DEF VM_POPUNSAFE OUT T,V
 DEC VM_SP
 T=VM_STK_TYP[VM_SP]
 CASE T
 WHEN #VMT_SUBROUTINE
 WHEN #VMT_VARREF
 WHEN #VMT_INT
  V=VM_STK%[VM_SP]
 WHEN #VMT_REAL
  V=VM_STK#[VM_SP]
 WHEN #VMT_STR
  V=VM_STK$[VM_SP]
 OTHERWISE
  STOP
 ENDCASE
END
DEF VM_BINOP T
 VAR LT,LV
 VAR RT,RV
 VM_POP OUT RT,RV
 VM_POP OUT LT,LV
 CASE T
 WHEN #TKN_PLUS
  VM_PUSH LV+RV
 WHEN #TKN_MINUS
  VM_PUSH LV-RV
 WHEN #TKN_MUL
  VM_PUSH LV*RV
 WHEN #TKN_DIV
  VM_PUSH LV/RV
 WHEN #TKN_DIVINT
  VM_PUSH LV DIV RV
 WHEN #TKN_MOD
  VM_PUSH LV MOD RV
 WHEN #TKN_AND
  VM_PUSH LV AND RV
 WHEN #TKN_EQ
  VM_PUSH LV==RV
 OTHERWISE
  STOP
 ENDCASE
END
DEF VM_PRINT_E
 ?
END

DEF VM_PRINT
 VAR V
 VM_POP OUT ,V
 ?V
END
DEF VM_PRINT_COMMA
 VAR V
 VM_POP OUT ,V
 ?V,
END
DEF VM_PRINT_SEMI
 VAR V
 VM_POP OUT ,V
 ?V;
END
DEF VM_PUSHVARREF IDX
 VM_PUSHTYP IDX,#VMT_VARREF
END
DEF VM_GETVAR(IDX)
 VAR TYP=VM_GVAR_TYP[IDX]
 CASE TYP
 WHEN #VMT_REAL
  RETURN VM_GVAR#[IDX]
 WHEN #VMT_INT
  RETURN VM_GVAR%[IDX]
 WHEN #VMT_STR
  RETURN VM_GVAR$[IDX]
 ENDCASE
 VM_ERROR
END
DEF VM_GETVAR2 RTYP,IDX OUT TYP,V
 TYP=VM_GVAR_TYP[IDX]
 IF RTYP!=#VMT_VARREF THEN ERROR
 CASE TYP
 WHEN #VMT_REAL
  V=VM_GVAR#[IDX]
  RETURN
 WHEN #VMT_INT
  V=VM_GVAR%[IDX]
  RETURN
 WHEN #VMT_STR
  V=VM_GVAR$[IDX]
  RETURN
 ENDCASE
 VM_ERROR
END
DEF VM_SETVAR IDX,TYP,V
 VM_GVAR_TYP[IDX]=TYP
 CASE TYP
 WHEN #VMT_REAL
  VM_GVAR#[IDX]=V
 WHEN #VMT_INT
  VM_GVAR%[IDX]=V
 WHEN #VMT_STR
  VM_GVAR$[IDX]=V
 OTHERWISE
  VM_ERROR_NOTIMPL
 ENDCASE
END
DEF VM_REF
 VAR T,V
 VM_POPUNSAFE OUT T,V
 CASE T
 WHEN #VMT_VARREF
  VM_PUSH VM_GETVAR(V)
 OTHERWISE
  INTERNAL_VM_ERROR
 ENDCASE
END
DEF VM_ASSIGN
 VAR T,V
 VAR REFT,REFV
 VM_POPUNSAFE OUT REFT,REFV
 VM_POP OUT T,V
 CASE REFT
 WHEN #VMT_VARREF
  VM_SETVAR REFV,T,V
 OTHERWISE
  INTERNAL_VM_ERROR
 ENDCASE
END
DEF VM_ISNUMTYPE(TYP)
 RETURN TYP==#VMT_INT||TYP==#VMT_REAL
END
DEF VM_FOR INIT
 VAR BRKADDR=VM_OPS[VM_PC]
 INC VM_PC
 VAR T_TO,V_TO
 VAR T_STEP=#VMT_INT,V_STEP=1
 VAR RT_IDX,RV_IDX
 VAR T_IDX,V_IDX
 VM_POP OUT T_TO,V_TO
 VM_POP OUT T_STEP,V_STEP
 VM_POPUNSAFE OUT RT_IDX,RV_IDX
 VM_GETVAR2 RT_IDX,RV_IDX OUT T_IDX,V_IDX
 IF!VM_ISNUMTYPE(T_IDX)||!VM_ISNUMTYPE(T_STEP)||!VM_ISNUMTYPE(T_TO) THEN
  TYPEMISMATCH "FOR"
 ENDIF
 IF !INIT THEN
  V_IDX=V_IDX+V_STEP
  VM_SETVAR RV_IDX,T_IDX,V_IDX
 ENDIF
 IF V_STEP>0&&V_IDX>V_TO THEN
  IF INIT THEN
   VM_PC=BRKADDR
  ENDIF
 ELSEIF V_STEP<0&&V_IDX<V_TO THEN
  IF INIT THEN
   VM_PC=BRKADDR
  ENDIF
 ELSE
  IF !INIT THEN
   VM_PC=BRKADDR
  ENDIF
 ENDIF
END
DEF VMINSTR_BRAND ADDR
 VAR T,V
 VM_POP OUT T,V
 IF!VM_ISNUMTYPE(T) THEN
  TYPEMISMATCH "&&"
 ENDIF
 IF !V THEN
  VM_PUSHINT #FALSE
  VM_PC=ADDR
 ENDIF
END
DEF VMINSTR_BROR ADDR
 VAR T,V
 VM_POP OUT T,V
 IF!VM_ISNUMTYPE(T) THEN
  TYPEMISMATCH "||"
 ENDIF
 IF V THEN
  VM_PC=ADDR
  VM_PUSHINT #TRUE
 ENDIF
END
DEF VM_GET_LABEL_ADDR(LABEL$)
 VAR FOUND,ADDR
 SPLAY_GET% VM_GLBLTBL,LABEL$ OUT FOUND,ADDR
 IF !FOUND THEN
  UNDEFINED_LABEL LABEL$
 ENDIF
 RETURN ADDR
END
DEF VMINSTR_GOTO_PLACEHOLDER
 VAR ADDR=VM_GET_LABEL_ADDR(VM_IMM$[VM_OPS[VM_PC]])
 VM_OPS[VM_PC-1]=#VM_BR
 VM_OPS[VM_PC]=ADDR
 VM_PC=ADDR
END
DEF VMINSTR_GOSUB_PLACEHOLDER
 VAR ADDR=VM_GET_LABEL_ADDR(VM_IMM$[VM_OPS[VM_PC]])
 VM_OPS[VM_PC-1]=#VM_GOSUB
 VM_OPS[VM_PC]=ADDR
 DEC VM_PC
END
DEF VMINSTR_GOSUB
 VAR ADDR=VM_OPS[VM_PC]
 VAR RETADDR=VM_PC+1
 VM_PUSHTYP RETADDR,#VMT_SUBROUTINE
 VM_PC=ADDR
END
DEF VMINSTR_RETURN
 VAR T,V
 VM_POPUNSAFE OUT T,V
 IF T!=#VMT_SUBROUTINE THEN
  RETURN_WITHOUT_GOSUB
  RETURN
 ENDIF
 VM_PC=V
END
DEF VM_RUN
 VAR T,V
 VM_PC=0
 INIT_VM_RUN
 LOOP
  IF LEN(VM_OPS)<=VM_PC THEN BREAK
  VAR C=VM_OPS[VM_PC]
  INC VM_PC
  CASE C
  WHEN #VM_PUSHINT
   VM_PUSHINT VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_PUSHDBL
   VM_PUSHDBL VM_IMM#[VM_OPS[VM_PC]]
   INC VM_PC
  WHEN #VM_PUSHSTR
   VM_PUSHSTR (VM_IMM$[VM_OPS[VM_PC]])+""
   INC VM_PC
  WHEN #VM_BINOP
   T=VM_OPS[VM_PC]
   INC VM_PC
   VM_BINOP T
  WHEN #VM_PRINT_E
   VM_PRINT_E
  WHEN #VM_PRINT
   VM_PRINT
  WHEN #VM_PRINT_COMMA
   VM_PRINT_COMMA
  WHEN #VM_PRINT_SEMI
   VM_PRINT_SEMI
  WHEN #VM_PUSHVARREF
   VM_PUSHVARREF VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_REF
   VM_REF
  WHEN #VM_ASSIGN
   VM_ASSIGN
  WHEN #VM_BR
   VM_PC=VM_OPS[VM_PC]-1
   INC VM_PC
  WHEN #VM_BRFALSE
   VM_POP OUT T,V
   CASE T
   WHEN #VMT_INT
   WHEN #VMT_REAL
    IF !V THEN VM_PC=VM_OPS[VM_PC]-1
   OTHERWISE
    TYPEMISMATCH
   ENDCASE
   INC VM_PC
  WHEN #VM_BRTRUE
   VM_POP OUT T,V
   CASE T
   WHEN #VMT_INT
   WHEN #VMT_REAL
    IF V THEN VM_PC=VM_OPS[VM_PC]-1
   OTHERWISE
    TYPEMISMATCH
   ENDCASE
   INC VM_PC
  WHEN #VM_FOR
   VM_FOR #FALSE
  WHEN #VM_FORINIT
   VM_FOR #TRUE
  WHEN #VM_BROR
   INC VM_PC
   VMINSTR_BROR VM_OPS[VM_PC-1]
  WHEN #VM_BRAND
   INC VM_PC
   VMINSTR_BRAND VM_OPS[VM_PC-1]
  WHEN #VM_GOTO_PLACEHOLDER
   VMINSTR_GOTO_PLACEHOLDER
  WHEN #VM_GOSUB_PLACEHOLDER
   VMINSTR_GOSUB_PLACEHOLDER
  WHEN #VM_GOSUB
   VMINSTR_GOSUB
  WHEN #VM_RETURN
   VMINSTR_RETURN
  OTHERWISE
   VM_ERROR
  ENDCASE
 ENDLOOP

END







DIM SPLAYN_LEFT[]
DIM SPLAYN_RIGHT[]
DIM SPLAYN_PARENT[]
DIM SPLAYN_KEY$[]
DIM SPLAYN_VAL$[]
DIM SPLAYN_VAL%[]
DIM SPLAYN_VAL#[]
DIM SPLAY_ROOT[]
VAR SPLAY_INIT

DEF INIT_SPLAY
 VAR S=1
 SPLAYN_LEFT=ARRAY%(S)
 SPLAYN_RIGHT=ARRAY%(S)
 SPLAYN_PARENT=ARRAY%(S)
 SPLAYN_KEY$=ARRAY$(S)
 SPLAYN_VAL$=ARRAY$(S)
 SPLAYN_VAL#=ARRAY%(S)
 SPLAYN_VAL%=ARRAY%(S)
 SPLAY_ROOT=ARRAY%(S)
 SPLAY_INIT=#TRUE
END

DEF NEW_SPLAY_TREE()
 IF!SPLAY_INIT THEN
  INIT_SPLAY
 ENDIF
 PUSH SPLAY_ROOT,0
 RETURN LAST(SPLAY_ROOT)
END
DEF NEW_SPLAYN(K$)
 PUSH SPLAYN_LEFT,0
 PUSH SPLAYN_RIGHT,0
 PUSH SPLAYN_PARENT,0
 PUSH SPLAYN_KEY$,K$
 VAR E$
 PUSH SPLAYN_VAL$,E$
 PUSH SPLAYN_VAL%,0
 PUSH SPLAYN_VAL#,0
 RETURN LAST(SPLAYN_LEFT)
END
DEF NEW_SPLAYN%(K$,V%)
 VAR S=NEW_SPLAYN(K$)
 SPLAYN_VAL%[S]=V%
 RETURN S
END
DEF NEW_SPLAYN#(K$,V#)
 VAR S=NEW_SPLAYN(K$)
 SPLAYN_VAL#[S]=V#
 RETURN S
END
DEF NEW_SPLAYN$(K$,V$)
 VAR S=NEW_SPLAYN(K$)
 SPLAYN_VAL$[S]=V$
 RETURN S
END

DEF SPLAY_LEFT_ROTATE S,X
 VAR Y=SPLAYN_RIGHT[X]
 IF Y THEN
  SPLAYN_RIGHT[X]=SPLAYN_LEFT[Y]
  IF SPLAYN_LEFT[Y] THEN
   SPLAYN_PARENT[SPLAYN_LEFT[Y]]=X
  ENDIF
  SPLAYN_PARENT[Y]=SPLAYN_PARENT[X]
 ENDIF
 IF !SPLAYN_PARENT[X] THEN
  SPLAY_ROOT[S]=Y
 ELSEIF X==SPLAYN_LEFT[SPLAYN_PARENT[X]] THEN
  SPLAYN_LEFT[SPLAYN_PARENT[X]]=Y
 ELSE
  SPLAYN_RIGHT[SPLAYN_PARENT[X]]=Y
 ENDIF
 IF Y THEN
  SPLAYN_LEFT[Y]=X
 ENDIF
 SPLAYN_PARENT[X]=Y
END

DEF SPLAY_RIGHT_ROTATE S,X
 VAR Y=SPLAYN_LEFT[X]
 IF Y THEN
  SPLAYN_LEFT[X]=SPLAYN_RIGHT[Y]
  IF SPLAYN_RIGHT[Y]THEN
   SPLAYN_PARENT[SPLAYN_RIGHT[Y]]=X
  ENDIF
  SPLAYN_PARENT[Y]=SPLAYN_PARENT[X]
 ENDIF
 IF !SPLAYN_PARENT[X]THEN
  SPLAY_ROOT[S]=Y
 ELSEIF X==SPLAYN_LEFT[SPLAYN_PARENT[X]]THEN
  SPLAYN_LEFT[SPLAYN_PARENT[X]]=Y
 ELSE
  SPLAYN_RIGHT[SPLAYN_PARENT[X]]=Y
 ENDIF
 IF Y THEN
  SPLAYN_RIGHT[Y]=X
 ENDIF
 SPLAYN_PARENT[X]=Y
END

DEF SPLAY S,X
 WHILE SPLAYN_PARENT[X]
  VAR P=SPLAYN_PARENT[X]
  IF !SPLAYN_PARENT[P]THEN
   IF SPLAYN_LEFT[P]==X THEN
    SPLAY_RIGHT_ROTATE S,P
   ELSE
    SPLAY_LEFT_ROTATE S,P
   ENDIF
  ELSEIF SPLAYN_LEFT[P]==X&&SPLAYN_LEFT[SPLAYN_PARENT[P]]==P THEN
   SPLAY_RIGHT_ROTATE S,SPLAYN_PARENT[P]
   SPLAY_RIGHT_ROTATE S,SPLAYN_PARENT[X]
  ELSEIF SPLAYN_RIGHT[P]==X&&SPLAYN_RIGHT[SPLAYN_PARENT[P]]==P THEN
   SPLAY_LEFT_ROTATE S,SPLAYN_PARENT[P]
   SPLAY_LEFT_ROTATE S,SPLAYN_PARENT[X]
  ELSEIF SPLAYN_LEFT[P]==X&&SPLAYN_RIGHT[SPLAYN_PARENT[P]]==P THEN
   SPLAY_RIGHT_ROTATE S,P
   SPLAY_LEFT_ROTATE S,SPLAYN_PARENT[X]
  ELSE
   SPLAY_LEFT_ROTATE S,P
   SPLAY_RIGHT_ROTATE S,SPLAYN_PARENT[X]
  ENDIF
 WEND
END
DEF SPLAY_REPLACE S,U,V
 IF !SPLAYN_PARENT[U]THEN
  SPLAY_ROOT[S]=V
 ELSEIF U==SPLAYN_LEFT[SPLAYN_PARENT[U]]THEN
  SPLAYN_LEFT[SPLAYN_PARENT[U]]=V
 ELSE
  SPLAYN_RIGHT[SPLAYN_PARENT[U]]=V
 ENDIF
 IF V THEN
  SPLAYN_PARENT[V]=SPLAYN_PARENT[U]
 ENDIF
END

DEF SPLAY_SUBTREE_MIN(S,U)
 WHILE SPLAYN_LEFT[U]
  U=SPLAYN_LEFT[U]
 WEND
 RETURN U
END
DEF SPLAY_SUBTREE_MAX(S,U)
 WHILE SPLAYN_RIGHT[U]
  U=SPLAYN_RIGHT[U]
 WEND
 RETURN U
END

DEF SPLAY_INSERT% S,KEY$,VALUE%
 SPLAY_INSERT S,KEY$,VALUE%,#T_INT
END
DEF SPLAY_INSERT$ S,KEY$,VALUE$
 SPLAY_INSERT S,KEY$,VALUE$,#T_STR
END
DEF SPLAY_INSERT# S,KEY$,VALUE#
 SPLAY_INSERT S,KEY$,VALUE#,#T_REAL
END

DEF SPLAY_INSERT S,KEY$,VALUE,T
 VAR Z=SPLAY_ROOT[S]
 VAR P
 WHILE Z
  P=Z
  IF SPLAYN_KEY$[Z]<KEY$THEN
   Z=SPLAYN_RIGHT[Z]
  ELSE
   Z=SPLAYN_LEFT[Z]
  ENDIF
 WEND
 CASE T
 WHEN #T_INT
  Z=NEW_SPLAYN%(KEY$,VALUE)
 WHEN #T_STR
  Z=NEW_SPLAYN$(KEY$,VALUE)
 WHEN #T_REAL
  Z=NEW_SPLAYN#(KEY$,VALUE)
 ENDCASE
 SPLAYN_PARENT[Z]=P
 IF !P THEN
  SPLAY_ROOT[S]=Z
 ELSEIF SPLAYN_KEY$[P]<SPLAYN_KEY$[Z]THEN
  SPLAYN_RIGHT[P]=Z
 ELSE
  SPLAYN_LEFT[P]=Z
 ENDIF
 SPLAY S,Z
END

DEF SPLAY_FIND(S,KEY$)
 VAR Z=SPLAY_ROOT[S]
 WHILE Z
  IF SPLAYN_KEY$[Z]<KEY$THEN
   Z=SPLAYN_RIGHT[Z]
  ELSEIF SPLAYN_KEY$[Z]==KEY$THEN
   RETURN Z
  ELSE
   Z=SPLAYN_LEFT[Z]
  ENDIF
 WEND
 RETURN 0
END

DEF SPLAY_GET% S,KEY$ OUT FOUND,VALUE%
 VAR N=SPLAY_FIND(S,KEY$)
 IF !N THEN
  FOUND=#FALSE
  VALUE%=0
  RETURN
 ENDIF
 FOUND=#TRUE
 VALUE%=SPLAYN_VAL%[N]
END
DEF SPLAY_GET# S,KEY$ OUT FOUND,VALUE#
 VAR N=SPLAY_FIND(S,KEY$)
 IF !N THEN
  FOUND=#FALSE
  VALUE#=0E0
  RETURN
 ENDIF
 FOUND=#TRUE
 VALUE#=SPLAYN_VAL#[N]
END
DEF SPLAY_GET$ S,KEY$ OUT FOUND,VALUE$
 VAR N=SPLAY_FIND(S,KEY$)
 IF !N THEN
  FOUND=#FALSE
  VALUE$=""
  RETURN
 ENDIF
 FOUND=#TRUE
 VALUE$=SPLAYN_VAL$[N]
END

DEF SPLAY_ERASE S,KEY$
 VAR Z=SPLAY_FIND(S,KEY$)
 IF !Z THEN
  RETURN
 ENDIF
 SPLAY S,Z
 IF !SPLAYN_LEFT[Z]THEN
  SPLAY_REPLACE S,Z,SPLAYN_RIGHT[Z]
 ELSEIF !SPLAYN_RIGHT[Z]THEN
  SPLAY_REPLACE S,Z,SPLAYN_LEFT[Z]
 ELSE
  VAR Y=SPLAY_SUBTREE_MIN(S,SPLAYN_RIGHT[Z])
  IF SPLAYN_PARENT[Y]!=Z THEN
   SPLAY_REPLACE S,Y,SPLAYN_RIGHT[Y]
   SPLAYN_RIGHT[Y]=SPLAYN_RIGHT[Z]
   SPLAYN_PARENT[SPLAYN_RIGHT[Y]]=Y
  ENDIF
  SPLAY_REPLACE S,Z,Y
  SPLAYN_LEFT[Y]=SPLAYN_LEFT[Z]
  SPLAYN_PARENT[SPLAYN_LEFT[Y]]=Y
 ENDIF
 'DELETE Z
END

DEF SPLAY_TEST
 VAR T=NEW_SPLAY_TREE()
 SPLAY_INSERT T,"K","V1"
 SPLAY_INSERT T,"K2","V2"
 SPLAY_INSERT T,"K3","V3"
 VAR F
 SPLAY_GET T,"K" OUT ,F
 ?F
 SPLAY_GET T,"K2" OUT ,F
 ?F
 SPLAY_GET T,"K3" OUT ,F
 ?F
 SPLAY_ERASE T,"K2"
 SPLAY_GET T,"K" OUT ,F
 ?F
 SPLAY_GET T,"K2" OUT ,F
 ?F
 SPLAY_GET T,"K3" OUT ,F
 ?F
 SPLAY_ERASE T,"K3"
 SPLAY_ERASE T,"K"
 SPLAY_GET T,"K" OUT ,F
 ?F
 SPLAY_GET T,"K2" OUT ,F
 ?F
 SPLAY_GET T,"K3" OUT ,F
 ?F

 VAR I
 VAR O=50000
 DIM LST1=ARRAY$(0)
 DIM LST2=ARRAY$(0)
 FOR I=0TO O-1
  PUSH LST1,STR$(I)
  PUSH LST2,STR$(I)
 NEXT
 FOR I=0TO O*10
  SWAP LST1[RND(O)],LST1[RND(O)]
  SWAP LST2[RND(O)],LST2[RND(O)]
 NEXT
 PERFBEGIN 0
 FOR I=0TO O-1
  SPLAY_INSERT T,LST1[I],"a"
 NEXT
 ?PERFEND(0)/O
 PERFBEGIN 0
 FOR I=0TO O-1
  SPLAY_GET T,LST2[I] OUT ,
 NEXT
 ?PERFEND(0)/O
 PERFBEGIN 0
 FOR I=0TO O-1
  SPVAR #GSPRITE,LST1[I],"a"
 NEXT
 ?PERFEND(0)/O
 PERFBEGIN 0
 VAR A$
 FOR I=0TO O-1
  SPVAR #GSPRITE,LST2[I] OUT A$
 NEXT
 ?PERFEND(0)/O
END

DEF GET_SPLAY_ROOT(S)
 RETURN SPLAY_ROOT[S]
END
DEF GET_SPLAYN_LEFT(S)
 RETURN SPLAYN_LEFT[S]
END
DEF GET_SPLAYN_RIGHT(S)
 RETURN SPLAYN_RIGHT[S]
END
DEF GET_SPLAYN_VAL%(S)
 RETURN SPLAYN_VAL%[S]
END
DEF GET_SPLAYN_VAL#(S)
 RETURN SPLAYN_VAL#[S]
END
DEF GET_SPLAYN_VAL$(S)
 RETURN SPLAYN_VAL$[S]
END
DEF GET_SPLAYN_KEY$(S)
 RETURN SPLAYN_KEY$[S]
END

