OPTION STRICT
OPTION DEFINT
'Debug Monitor
IF ENVTYPE()==1 THEN
 DEBUGMON
 RETURN
ENDIF
DEF DEBUGMON
 ENVFOCUS 0
 VAR OFS_X=0
 VAR OFS_Y=0
 VAR SCR_WIDTH=1280
 VAR SCR_HEIGHT=720
 VAR WIDTH=SCR_WIDTH
 VAR HEIGHT=SCR_HEIGHT
 VAR GRPF_OFS_X=512,GRPF_OFS_Y=0
 BACKCOLOR 0
 VAR GP=0
 XSCREEN WIDTH,HEIGHT
 SPPAGE #GSPRITE,GP
 SPCHR #GSPRITE,GRPF_OFS_X,GRPF_OFS_Y,WIDTH,HEIGHT
 SPCOLOR #GSPRITE,RGB(192,255,255,255)
 SPOFS #GSPRITE,0,0
 GTARGET #GRPF
 VAR R$=""
 VAR OLDP=GPGET(2047,2047)
 VAR OLD_PONG=MILLISEC()
 XSUBSCREEN 0
 PUSHKEY "CONT"+CHR$(13)
 VAR TIMEOUT=100'ms
 LOOP
  VAR UPDATED=#FALSE
  ENVLOAD 1,#GRPF,#GRPF
  VAR P=GPGET(2047,2047)
  IF P!=OLDP&&P THEN
   XSUBSCREEN OFS_X,OFS_Y,SCR_WIDTH-OFS_X,SCR_HEIGHT-OFS_Y
   OLD_PONG=MILLISEC()
   OLDP=P
   UPDATED=#TRUE
  ENDIF
  IF UPDATED THEN
   GTARGET GP
   GCOPY #GRPF,GRPF_OFS_X,GRPF_OFS_Y,GRPF_OFS_X+WIDTH-1,GRPF_OFS_Y+HEIGHT-1,GRPF_OFS_X,GRPF_OFS_Y,#G_NORMAL
   GTARGET #GRPF
  ENDIF
  IF MILLISEC()-OLD_PONG>=TIMEOUT THEN XSUBSCREEN 0
  LOOP
   VAR K$=INKEY$()
   IF K$=="" THEN BREAK
   PUSH R$,K$
   IF K$==CHR$(10)THEN
    IF R$=="PING"+CHR$(10)THEN
     ENVFOCUS 0
     VSYNC
     PUSHKEY "PONG"+CHR$(10)+"Debug Monitor ver 1.0"+CHR$(10)
    ENDIF
    R$=""
   ENDIF
  ENDLOOP
  VSYNC
 ENDLOOP
END

'SPLAY_TEST
'END
VAR TRACE=#FALSE

'VSLOT_INIT
'VSLOT_TEST
MAIN
END
DEF GET_SLOT$(N)
 PRGEDIT N
 VAR S$=""
 VAR I,L=PRGSIZE(N)
 FOR I=1TO L
  PUSH S$,PRGGET$()
 NEXT
 RETURN S$
END
DEF GET_VSLOT$(N)
 VSLOT_PRGEDIT N,0
 VAR S$=""
 VAR I,L=VSLOT_PRGSIZE(N,0)
 FOR I=1TO L
  PUSH S$,VSLOT_PRGGET$(#TRUE)
 NEXT
 RETURN S$
END
DEF SET_VSLOT N,V$
 VSLOT_PRGEDIT N,1
 VSLOT_PRGDEL -1
 VSLOT_PRGSET V$
END
DEF SET_SLOT N,V$
 PRGEDIT N,1
 PRGDEL -1
 PRGSET V$
END
DEF MAIN
 VAR SW,SH,TS,TS2
' ACLS
 XSCREEN OUT SW,SH
 IF SW!=1280||SH!=720THEN
  XSCREEN 1280,720
 ENDIF
 TSCREEN OUT TS,TS2,,
 IF TS!=16||TS2!=16THEN
  TSCREEN 16
 ENDIF
 VSLOT_INIT
 VAR IN$=GET_SLOT$(3)
 SET_VSLOT 3,IN$
 IN$=GET_SLOT$(2)
 SET_VSLOT 2,IN$
 IN$=GET_SLOT$(1)
 SET_VSLOT 1,IN$
 LOGO
 REPL_MAIN
END
DEF LOGO
 ?"PetitComputer フ゜チコン ver4.0.2
 ?"SMILEBASIC for SMILEBASIC ";FREEMEM();" bytes free"
 ?
 ?"READY"
END
VAR LEXER_IN$
VAR LEXER_I
VAR LEXER_PREV_I2
VAR LEXER_PREV_I
VAR LEXER_LINE
VAR LEXER_LINE_POS
VAR LEXER_PREV_LINE
VAR LEXER_PREV_LINE_POS
VAR LEXER_VAL
ENUM\
 #TKN_NONE,\
 #TKN_NUM,\
 #TKN_STR,\
 #TKN_PRINT,\
 #TKN_DEF,\
 #TKN_RETURN,\
 #TKN_IDEN,\
 #TKN_PLUS,\
 #TKN_MINUS,\
 #TKN_MUL,\
 #TKN_DIV,\
 #TKN_DIVINT,\
 #TKN_COMMA,\
 #TKN_LP,\
 #TKN_RP,\
 #TKN_LB,\
 #TKN_RB,\
 #TKN_SEMI,\
 #TKN_COL,\
 #TKN_NEWLINE,\
 #TKN_EOF,\
 #TKN_MOD,\
 #TKN_LSHIFT,\
 #TKN_RSHIFT,\
 #TKN_EQ,\
 #TKN_NEQ,\
 #TKN_LESS,\
 #TKN_LEQ,\
 #TKN_GREAT,\
 #TKN_GEQ,\
 #TKN_AND,\
 #TKN_OR,\
 #TKN_XOR,\
 #TKN_LAND,\
 #TKN_LOR,\
 #TKN_ASSIGN,\
 #TKN_NOT,\
 #TKN_LNOT,\
 #TKN_OUT,\
 #TKN_CALL,\
 #TKN_VAR,\
 #TKN_IF,\
 #TKN_THEN,\
 #TKN_ENDIF,\
 #TKN_ELSE,\
 #TKN_ELSEIF,\
 #TKN_FOR,\
 #TKN_NEXT,\
 #TKN_GOTO,\
 #TKN_GOSUB,\
 #TKN_BREAK,\
 #TKN_CONTINUE,\
 #TKN_WHILE,\
 #TKN_WEND,\
 #TKN_REPEAT,\
 #TKN_UNTIL,\
 #TKN_LOOP,\
 #TKN_ENDLOOP,\
 #TKN_LABEL,\
 #TKN_ON,\
 #TKN_DATA,\
 #TKN_RESTORE,\
 #TKN_CONST,\
 #TKN_ENUM,\
 #TKN_CONSTVAR,\
 #TKN_END,\
 #TKN_TPRINT,\
 #TKN_READ,\
 #TKN_INC,\
 #TKN_DEC,\
 #TKN_CASE,\
 #TKN_WHEN,\
 #TKN_OTHERWISE,\
 #TKN_ENDCASE,\
 #TKN_SWAP,\
 #TKN_COMMON,\
 #TKN_DEFOUT,\
 #TKN_INPUT,\
 #TKN_LINPUT,\
 #TKN_EXEC,\
 #TKN_INSPECT,\
 #TKN_DIM,\
 #TKN_,\
 #TKN_LAST
DEF TKN_STR$(T)
 CASE T
 WHEN #TKN_NONE:RETURN "#TKN_NONE"WHEN #TKN_NUM:RETURN "#TKN_NUM"WHEN #TKN_STR:RETURN "#TKN_STR"WHEN #TKN_PRINT:RETURN "#TKN_PRINT"WHEN #TKN_DEF:RETURN "#TKN_DEF"WHEN #TKN_RETURN:RETURN "#TKN_RETURN"WHEN #TKN_IDEN:RETURN "#TKN_IDEN"WHEN #TKN_PLUS:RETURN "#TKN_PLUS"WHEN #TKN_MINUS:RETURN "#TKN_MINUS"WHEN #TKN_MUL:RETURN "#TKN_MUL"WHEN #TKN_DIV:RETURN "#TKN_DIV"WHEN #TKN_DIVINT:RETURN "#TKN_DIVINT"WHEN #TKN_COMMA:RETURN "#TKN_COMMA"WHEN #TKN_LP:RETURN "#TKN_LP"WHEN #TKN_RP:RETURN "#TKN_RP"WHEN #TKN_LB:RETURN "#TKN_LB"WHEN #TKN_RB:RETURN "#TKN_RB"WHEN #TKN_SEMI:RETURN "#TKN_SEMI"WHEN #TKN_COL:RETURN "#TKN_COL"WHEN #TKN_NEWLINE:RETURN "#TKN_NEWLINE"WHEN #TKN_EOF:RETURN "#TKN_EOF"WHEN #TKN_MOD:RETURN "#TKN_MOD"WHEN #TKN_LSHIFT:RETURN "#TKN_LSHIFT"WHEN #TKN_RSHIFT:RETURN "#TKN_RSHIFT"WHEN #TKN_EQ:RETURN "#TKN_EQ"WHEN #TKN_NEQ:RETURN "#TKN_NEQ"WHEN #TKN_LESS:RETURN "#TKN_LESS"WHEN #TKN_LEQ:RETURN "#TKN_LEQ"WHEN #TKN_GREAT:RETURN "#TKN_GREAT"WHEN #TKN_GEQ:RETURN "#TKN_GEQ"WHEN #TKN_AND:RETURN "#TKN_AND"WHEN #TKN_OR:RETURN "#TKN_OR"WHEN #TKN_XOR:RETURN "#TKN_XOR"WHEN #TKN_LAND:RETURN "#TKN_LAND"WHEN #TKN_LOR:RETURN "#TKN_LOR"WHEN #TKN_ASSIGN:RETURN "#TKN_ASSIGN"WHEN #TKN_NOT:RETURN "#TKN_NOT"WHEN #TKN_LNOT:RETURN "#TKN_LNOT"WHEN #TKN_OUT:RETURN "#TKN_OUT"WHEN #TKN_CALL:RETURN "#TKN_CALL"WHEN #TKN_VAR:RETURN "#TKN_VAR"WHEN #TKN_IF:RETURN "#TKN_IF"WHEN #TKN_THEN:RETURN "#TKN_THEN"WHEN #TKN_ENDIF:RETURN "#TKN_ENDIF"WHEN #TKN_ELSE:RETURN "#TKN_ELSE"WHEN #TKN_ELSEIF:RETURN "#TKN_ELSEIF"WHEN #TKN_FOR:RETURN "#TKN_FOR"WHEN #TKN_NEXT:RETURN "#TKN_NEXT"WHEN #TKN_GOTO:RETURN "#TKN_GOTO"WHEN #TKN_GOSUB:RETURN "#TKN_GOSUB"WHEN #TKN_BREAK:RETURN "#TKN_BREAK"WHEN #TKN_CONTINUE:RETURN "#TKN_CONTINUE"WHEN #TKN_WHILE:RETURN "#TKN_WHILE"WHEN #TKN_WEND:RETURN "#TKN_WEND"WHEN #TKN_REPEAT:RETURN "#TKN_REPEAT"WHEN #TKN_UNTIL:RETURN "#TKN_UNTIL"WHEN #TKN_LOOP:RETURN "#TKN_LOOP"WHEN #TKN_ENDLOOP:RETURN "#TKN_ENDLOOP"WHEN #TKN_LABEL:RETURN "#TKN_LABEL"WHEN #TKN_ON:RETURN "#TKN_ON"WHEN #TKN_DATA:RETURN "#TKN_DATA"WHEN #TKN_RESTORE:RETURN "#TKN_RESTORE"WHEN #TKN_CONST:RETURN "#TKN_CONST"WHEN #TKN_ENUM:RETURN "#TKN_ENUM"WHEN #TKN_CONSTVAR:RETURN "#TKN_CONSTVAR"WHEN #TKN_END:RETURN "#TKN_END"WHEN #TKN_TPRINT:RETURN "#TKN_TPRINT"WHEN #TKN_READ:RETURN "#TKN_READ"WHEN #TKN_INC:RETURN "#TKN_INC"WHEN #TKN_DEC:RETURN "#TKN_DEC"WHEN #TKN_CASE:RETURN "#TKN_CASE"WHEN #TKN_WHEN:RETURN "#TKN_WHEN"WHEN #TKN_OTHERWISE:RETURN "#TKN_OTHERWISE"WHEN #TKN_ENDCASE:RETURN "#TKN_ENDCASE"WHEN #TKN_SWAP:RETURN "#TKN_SWAP"WHEN #TKN_COMMON:RETURN "#TKN_COMMON"WHEN #TKN_DEFOUT:RETURN "#TKN_DEFOUT"WHEN #TKN_INPUT:RETURN "#TKN_INPUT"WHEN #TKN_LINPUT:RETURN "#TKN_LINPUT"WHEN #TKN_EXEC:RETURN "#TKN_EXEC"WHEN #TKN_INSPECT:RETURN "#TKN_INSPECT"WHEN #TKN_DIM:RETURN "#TKN_DIM"WHEN #TKN_:RETURN "#TKN_"
 OTHERWISE
  RETURN "#TKN_"+STR$(T)
 ENDCASE
END
DEF REPL_RUN SLOT
 VM_RESET
' VAR IN$=LOADV("TXT:SOS64")'

' VAR IN$=GET_VSLOT$(SLOT)'LOADV("TXT:SOS64")'
 VAR IN$=GET_SLOT$(3)'LOADV("TXT:SOS64")'
 INIT_LEXER IN$
 INIT_AST
 INIT_PARSER SLOT
 VAR AST=PARSE()
' DUMP_AST AST,0
 INIT_COMPILER SLOT
 INIT_VM
 COMPILE AST
 LOAD_VM_SLOT SLOT
 VM_RUN_SLOT SLOT
 VM_RUN
 IF VM_IS_STOPPED()THEN
  ?VM_LASTERR$()
 ENDIF
 ?"OK"
END
DEF REPL_RRUN SLOT
 VM_RESET
' VAR IN$=LOADV("TXT:SOS64")'

' VAR IN$=GET_VSLOT$(SLOT)'LOADV("TXT:SOS64")'
 VAR IN$=GET_SLOT$(1)'LOADV("TXT:SOS64")'
 INIT_LEXER IN$
 INIT_AST
 INIT_PARSER SLOT
 VAR AST=PARSE()
' DUMP_AST AST,0
 INIT_RCOMPILER SLOT
' INIT_VM
 RCOMPILE AST
' LOAD_VM_SLOT SLOT
' VM_RUN_SLOT SLOT
' VM_RUN
' IF VM_IS_STOPPED()THEN
'  ?VM_LASTERR$()
' ENDIF
 ?"OK"
 STOP
END
DEF REPL_MAIN
 INIT_VM
 VAR AST
 REPL_RRUN 0
 GDEBUG 1
 LOOP
  VAR D$
  LINPUT D$
  INIT_LEXER D$
  VAR T,V
  LEX_NEXT OUT T,V
  IF T==#TKN_IDEN&&V=="RUN"THEN
   LEX_NEXT OUT T,V
   VAR SLOT=0
   IF T==#TKN_EOF THEN
   ELSEIF T==#TKN_NUM THEN
    SLOT=V
   ELSE
    ILLEGAL_FUNCTION_CALL
    CONTINUE
   ENDIF
   VM_RESET
   VAR IN$=GET_VSLOT$(SLOT)
   INIT_LEXER IN$
   INIT_AST
   INIT_PARSER SLOT
   AST=PARSE()
   IF!PARSER_HAS_ERROR() THEN
    INIT_COMPILER SLOT
    INIT_VM
    COMPILE AST
    IF!COMPILER_HAS_ERROR() THEN
     LOAD_VM_SLOT SLOT
     VM_RUN_SLOT SLOT
     VM_RUN
    ENDIF
   ENDIF
  ELSEIF T==#TKN_IDEN&&V=="CONT"THEN
   VM_CONT
  ELSEIF T==#TKN_IDEN&&V=="DEBUG"THEN
   LEX_NEXT OUT T,V
   SLOT=0
   IF T==#TKN_EOF THEN
   ELSEIF T==#TKN_NUM THEN
    SLOT=V
   ELSE
    ILLEGAL_FUNCTION_CALL
    CONTINUE
   ENDIF
   DEBUG SLOT
  ELSEIF T==#TKN_IDEN&&V=="GDEBUG"THEN
   LEX_NEXT OUT T,V
   SLOT=0
   IF T==#TKN_EOF THEN
   ELSEIF T==#TKN_NUM THEN
    SLOT=V
   ELSE
    ILLEGAL_FUNCTION_CALL
    CONTINUE
   ENDIF
   GDEBUG SLOT
  ELSE
   INIT_LEXER D$
   INIT_AST
   INIT_PARSER SLOT
   AST=PARSE()
   INIT_COMPILER_REPL
   COMPILE AST
   LOAD_VM_SLOT_REPL
   VM_RUN
  ENDIF
  IF VM_IS_STOPPED()THEN
   ?VM_LASTERR$()
  ENDIF
  ?"OK"
 ENDLOOP
END
DEF PARSE_DBGCMD DBGC$ OUT PARSED$
 VAR I,R$=""
 PARSED$=ARRAY$(0)
 FOR I=0 TO LAST(DBGC$)
  VAR C$=DBGC$[I]
  IF C$==" "THEN
   IF LEN(R$)THEN
    PUSH PARSED$,R$
    R$=""
   ENDIF
   CONTINUE
  ELSE
   PUSH R$,C$
  ENDIF
 NEXT
 IF LEN(R$)THEN
  PUSH PARSED$,R$
  R$=""
 ENDIF
END
DEF DEBUG_INIT SLOT
 VM_RESET
 VAR IN$=GET_VSLOT$(SLOT)
 INIT_LEXER IN$
 INIT_AST
 INIT_PARSER SLOT
 VAR AST=PARSE()
 INIT_COMPILER SLOT
 INIT_VM
 COMPILE AST
 LOAD_VM_SLOT SLOT
 VM_RUN_SLOT SLOT
END
DEF DEBUG SLOT
 ?"Debugger SLOT ";SLOT
 ?"COMMAND"
 ?"BREAK|B [SLOT:]LINE -- BREAKPOINT"
 ?"BREAK|B FUNCTION -- BREAKPOINT"
 ?"DELETE -- DELETE ALL BREAKPOINTS"
 ?"NEXT|N"
 ?"STEP|S"
 ?"BACKTRACE|BT -- BACKTRACE"
 ?"RUN|R"
 ?"FRAME|F N -- SELECT A STACK FRAME"
 ?"HELP -- SHOW HELP"
 LOOP
  VAR DBGC$
  LINPUT ") ";DBGC$
  VAR ARGS$=PARSE_DBGCMD(DBGC$)
  IF LEN(ARGS$)THEN
   CASE ARGS$[0]
   WHEN "R"
   WHEN "RUN"
    DEBUG_CMD_RUN ARGS$
   WHEN "B"
   WHEN "BREAK"
    DEBUG_CMD_BREAK ARGS$
   WHEN "N"
   WHEN "NEXT"
    DEBUG_CMD_NEXT ARGS$
   WHEN "S"
   WHEN "STEP"
    DEBUG_CMD_STEP ARGS$
   WHEN "BT"
   WHEN "BACKTRACE"
    DEBUG_CMD_BACKTRACE ARGS$
    CONTINUE
   ENDCASE
  ENDIF
  IF VM_IS_STOPPED()THEN
   ?VM_LASTERR$()
  ENDIF
 ENDLOOP
END
DEF DEBUG_CMD_RUN ARGS$
 VM_RUN
 IF VMDBG_IS_STOPPED_AT_BP()THEN
  ?"Breakpoint at ";VM_GET_CURLOC$()
  VAR SLOT,LINE
  VMDBG_GET OUT SLOT,LINE,
  ?VSLOT_GETLINE$(SLOT,LINE);
 ENDIF
END
DEF DEBUG_CMD_BREAK ARGS$
 VAR SLOT=0
 VAR LINE=VAL(ARGS$[1])
 VAR PC
 VMDBG_GET_PC SLOT,LINE OUT PC
 VMDBG_SET_BP SLOT,PC
END
DEF DEBUG_GETLINESTR$(LINE)
 VAR I
 VAR E$=""
 VAR C$=""
 FOR I=0TO 2
  VAR L=LINE MOD 100
  LINE=LINE DIV 100
  IF LINE&&L<10 THEN
   C$[2-I]=CHR$(ASC("")+L)
  ELSE
   C$[2-I]=CHR$(ASC("")+L)
  ENDIF
  IF!LINE THEN BREAK
 NEXT
 RETURN C$
END
DEF DEBUG_CMD_STEP ARGS$
 VAR SLOT,LINE
 VAR OSLOT,OLINE
 VMDBG_GET OUT OSLOT,OLINE,
 LOOP
  VM_TRACE_RUN #TRUE
  IF!VM_IS_RUNNING()THEN
   ?"END"
   BREAK
  ENDIF
  VMDBG_GET OUT SLOT,LINE,
  IF VMDBG_IS_STOPPED_AT_BP()THEN
   ?"Breakpoint at ";VM_GET_CURLOC$()
   VMDBG_GET OUT SLOT,LINE,
   ?DEBUG_GETLINESTR$(LINE);VSLOT_GETLINE$(SLOT,LINE);
   VM_DUMP_CURRENT
   BREAK
  ENDIF
  IF SLOT!=OSLOT||OLINE!=LINE THEN
   ?"Step ";VM_GET_CURLOC$()
   ?DEBUG_GETLINESTR$(LINE);VSLOT_GETLINE$(SLOT,LINE);
   VM_DUMP_CURRENT
   BREAK
  ENDIF
  IF VM_IS_STOPPED()THEN
   BREAK
  ENDIF
  OSLOT=SLOT
  OLINE=LINE
 ENDLOOP
END
DEF DEBUG_CMD_NEXT ARGS$
 VAR SLOT,LINE
 VAR OSLOT,OLINE
 VMDBG_GET OUT OSLOT,OLINE,
 LOOP
  VM_TRACE_RUN #FALSE
  IF!VM_IS_RUNNING()THEN
   ?"END"
   BREAK
  ENDIF
  VMDBG_GET OUT SLOT,LINE,
  IF VMDBG_IS_STOPPED_AT_BP()THEN
   ?"Breakpoint at ";VM_GET_CURLOC$()
   VMDBG_GET OUT SLOT,LINE,
   ?DEBUG_GETLINESTR$(LINE);VSLOT_GETLINE$(SLOT,LINE);
   VM_DUMP_CURRENT
   BREAK
  ENDIF
  IF SLOT!=OSLOT||OLINE!=LINE THEN
   ?"Next ";VM_GET_CURLOC$()
   ?DEBUG_GETLINESTR$(LINE);VSLOT_GETLINE$(SLOT,LINE);
   VM_DUMP_CURRENT
   BREAK
  ENDIF
  IF VM_IS_STOPPED()THEN
   BREAK
  ENDIF
  OSLOT=SLOT
  OLINE=LINE
 ENDLOOP
END
DEF DEBUG_CMD_BACKTRACE ARGS$
 VAR SLOT,LINE,INFO$
 VM_BACKTRACE #FALSE OUT SLOT,LINE,INFO$
 VAR I
 FOR I=0TO LAST(SLOT)
  ?"#";I,SLOT[I];":";STR$(LINE[I],6);
  IF LEN(INFO$[I])THEN
   ?"(";INFO$[I];")"
  ELSE
   ?
  ENDIF
 NEXT
END
'あくまでカンイうぃんどうカンリらいぶらり
'オモいのほかフクザツなGUIをコウチクしたせいでスゴいメンドウになったけどメをツブることにする
DIM GWIN_X[]
DIM GWIN_Y[]
DIM GWIN_REL_X[]
DIM GWIN_REL_Y[]
DIM GWIN_DRAW_X[]
DIM GWIN_DRAW_Y[]
DIM GWIN_W[]
DIM GWIN_H[]
DIM GWIN_FW1[]
DIM GWIN_FH1[]
DIM GWIN_FW2[]
DIM GWIN_FH2[]
DIM GWIN_PREV[]
DIM GWIN_NEXT[]
DIM GWIN_PARENT[]
DIM GWIN_CHILD[]
DIM GWIN_NAME$[]
DIM GWIN_EVENT$[]
DIM GWIN_VAR[,]
DIM GWIN_VAR$[,]
DIM GWIN_ID[]
DIM GWIN_MENU[]
VAR GWIN_IDCNT
VAR GWIN_FREE
VAR GWIN_1[],GWIN_2[],GWIN_3[],GWIN_4[],GWIN_5[],GWIN_6[],GWIN_7[],GWIN_8[],GWIN_9[],GWIN_10[],GWIN_11[]
VAR GWIN_CAPTURE_GW
VAR GWIN_CAPTURE_FRAME
VAR GWIN_CAPTURE_X
VAR GWIN_CAPTURE_Y
VAR GWIN_UPDATED
CONST #GWIN_MAX_VAR=12
DIM GMENUI_NAME$[]
DIM GMENUI_NEXT[]
DIM GMENUI_PREV[]
DIM GMENUI_CHILD[]
DIM GMENUI_PARENT[]
DIM GMENUI_TYPE[]
VAR GMENUI_FREE

DIM GMENU_WIDTH[]
DIM GMENU_NEXT[]
DIM GMENU_CHILD[]
DIM GMENU_PARENT[]
DIM GMENU_TYPE[]
DIM GMENU_OLD_SEL[]
VAR GMENU_FREE
DEF GDEBUG_MENU_INIT
 VAR S=20
 GMENU_WIDTH=ARRAY%(S)
 GMENU_NEXT=ARRAY%(S)
 GMENU_CHILD=ARRAY%(S)
 GMENU_PARENT=ARRAY%(S)
 GMENU_TYPE=ARRAY%(S)
 GMENU_OLD_SEL=ARRAY%(S)
 VAR I
 FOR I=1TO S-2
  GMENU_NEXT[I]=I+1
 NEXT
 GMENU_FREE=1
END
DEF GDEBUG_MENUI_INIT
 VAR S=20
 GMENUI_NAME$=ARRAY$(S)
 GMENUI_NEXT=ARRAY%(S)
 GMENUI_PREV=ARRAY%(S)
 GMENUI_CHILD=ARRAY%(S)
 GMENUI_PARENT=ARRAY%(S)
 GMENUI_TYPE=ARRAY%(S)
 VAR I
 FOR I=1TO S-2
  GMENUI_NEXT[I]=I+1
 NEXT
 GMENUI_FREE=1
END
DEF NEW_GMENUI()
 IF!GMENUI_FREE THEN STOP
 VAR L=GMENUI_FREE
 GMENUI_FREE=GMENUI_NEXT[GMENUI_FREE]
 GMENUI_NEXT[L]=0
 RETURN L
END
DEF NEW_GMENU()
 IF!GMENU_FREE THEN STOP
 VAR L=GMENU_FREE
 GMENU_FREE=GMENUI_NEXT[GMENU_FREE]
 GMENU_NEXT[L]=0
 RETURN L
END
DEF GMENU_ADD_ITEM GMENU,NAME$,ID
 VAR I=NEW_GMENUI()
 GMENUI_NAME$[I]=NAME$
 IF!GMENU_CHILD[GMENU]THEN
  GMENU_CHILD[GMENU]=I
 ELSE
  VAR C=GMENU_CHILD[GMENU]
  WHILE C
   IF!GMENUI_NEXT[C]THEN BREAK
   C=GMENUI_NEXT[C]
  WEND
  GMENUI_NEXT[C]=I
  GMENUI_PREV[I]=C
 ENDIF
END
DEF GDEBUG_WIN_INIT
 GDEBUG_MENU_INIT
 GDEBUG_MENUI_INIT
 VAR S=12
 GWIN_X=ARRAY%(S)
 GWIN_Y=ARRAY%(S)
 GWIN_W=ARRAY%(S)
 GWIN_H=ARRAY%(S)
 GWIN_FW1=ARRAY%(S)
 GWIN_FH1=ARRAY%(S)
 GWIN_FW2=ARRAY%(S)
 GWIN_FH2=ARRAY%(S)
 GWIN_NEXT=ARRAY%(S)
 GWIN_PREV=ARRAY%(S)
 GWIN_NAME$=ARRAY$(S)
 GWIN_EVENT$=ARRAY$(S)
 GWIN_PARENT=ARRAY%(S)
 GWIN_CHILD=ARRAY%(S)
 GWIN_REL_X=ARRAY%(S)
 GWIN_REL_Y=ARRAY%(S)
 GWIN_DRAW_X=ARRAY%(S)
 GWIN_DRAW_Y=ARRAY%(S)
 GWIN_VAR=ARRAY%(S,#GWIN_MAX_VAR)
 GWIN_VAR$=ARRAY$(S,#GWIN_MAX_VAR)
 GWIN_ID=ARRAY%(S)
 GWIN_MENU=ARRAY%(S)
 VAR I
 FOR I=1TO S-2
  GWIN_NEXT[I]=I+1
 NEXT
 GWIN_FREE=1
END
DEF GWIN_SET_FRAME_BUF G,AR
 VAR("GWIN_"+STR$(G))=AR
END
DEF GWIN_GET_FRAME_BUF(G)
 RETURN VAR("GWIN_"+STR$(G))
END
ENUM\
 #GWIN_EVENT_PAINT,\
 #GWIN_EVENT_LDWN,\
 #GWIN_EVENT_LUP,\
 #GWIN_EVENT_MMOVE,\
 #GWIN_EVENT_NEW,\
 #GWIN_EVENT_NOTIF,\
 #GWIN_EVENT_LAST

ENUM\
 #GWIN_NOTIF_NONE,\
 #GWIN_NOTIF_BUTTON_PUSHED,\
 #GWIN_NOTIF_LAST
VAR GWIN_ROOT
ENUM #GWIN_DRAW_BUTTON_RAIS,#GWIN_DRAW_BUTTON_ETCHED,#GWIN_DRAW_BUTTON_SUNK,#GWIN_DRAW_BUTTON_RAISED,#GWIN_DRAW_BUTTON_SUNKEN

DEF GWIN_SET_VAR GW,V,K
 GWIN_VAR[GW,V]=K
END
DEF GWIN_GET_VAR(GW,V)
 RETURN GWIN_VAR[GW,V]
END
DEF GWIN_SET_VAR$ GW,V,K
 GWIN_VAR$[GW,V]=K
END
DEF GWIN_GET_VAR$(GW,V)
 RETURN GWIN_VAR$[GW,V]
END
DEF GWIN_SET_ARY GW,V,INDEX,VALUE
 VAR V$=GWIN_VAR$[GW,V]
 IF LEN(V$)<INDEX*2+2 THEN
  COPY V$,INDEX*2+2,CHR$(0),0'HACK:RESIZE STRING
 ENDIF
 V$[INDEX*2]=CHR$(VALUE)
 V$[INDEX*2+1]=CHR$(VALUE>>16)
END
DEF GWIN_GET_ARY(GW,V,INDEX)
 VAR V$=GWIN_VAR$[GW,V]
 IF LEN(V$)<INDEX*2+2 THEN
  COPY V$,INDEX*2+2,CHR$(0),0'HACK:RESIZE STRING
 ENDIF
 RETURN (ASC(V$[INDEX*2+1])<<16) OR ASC(V$[INDEX*2])
END
DEF GWIN_DELETE_CHILD GW
 WHILE GW
  VAR NXT=GWIN_NEXT[GW]
  GWIN_DELETE GW
  GW=NXT
 WEND
END
DEF GWIN_DELETE GW
 GWIN_UPDATED=#TRUE
 GWIN_DELETE_CHILD GWIN_CHILD[GW]
 VAR NXT=GWIN_NEXT[GW]
 VAR PRV=GWIN_PREV[GW]
 IF !NXT&&!PRV THEN RETURN
 VAR GWIN_BACK=GWIN_CHILD[GWIN_PARENT[GW]]
 IF GWIN_BACK==GW THEN
  GWIN_CHILD[GWIN_PARENT[GW]]=NXT
 ENDIF
 IF PRV THEN
  GWIN_NEXT[PRV]=NXT
 ENDIF
 IF NXT THEN
  GWIN_PREV[NXT]=PRV
 ENDIF
 GWIN_NEXT[GW]=GWIN_FREE
 GWIN_FREE=GW
 GWIN_ID[GW]=0
 GWIN_MENU[GW]=0
 VAR I,N$
 FOR I=0TO #GWIN_MAX_VAR-1
  GWIN_VAR[GW,I]=0
  GWIN_VAR$[GW,I]=N$
 NEXT
END
DEF GWIN_NEW(PARENT,RX,RY,W,H,NAME$,FUNC$)
 VAR G=GWIN_FREE
 IF !G THEN RETURN -1
 GWIN_FREE=GWIN_NEXT[G]
 GWIN_X[G]=RX+GWIN_X[PARENT]+GWIN_FW1[PARENT]
 GWIN_Y[G]=RY+GWIN_Y[PARENT]+GWIN_FH1[PARENT]
 IF PARENT!=GWIN_ROOT THEN
  GWIN_DRAW_X[G]=RX+GWIN_DRAW_X[PARENT]+GWIN_FW1[PARENT]
  GWIN_DRAW_Y[G]=RY+GWIN_DRAW_Y[PARENT]+GWIN_FH1[PARENT]
 ELSE
  GWIN_DRAW_X[G]=0
  GWIN_DRAW_Y[G]=0
 ENDIF
 GWIN_REL_X[G]=RX
 GWIN_REL_Y[G]=RY
 GWIN_W[G]=W
 GWIN_H[G]=H
 GWIN_FW1[G]=0
 GWIN_FH1[G]=0
 GWIN_FW2[G]=0
 GWIN_FH2[G]=0
 GWIN_NAME$[G]=NAME$
 GWIN_EVENT$[G]=FUNC$
 INC GWIN_IDCNT
 GWIN_ID[G]=GWIN_IDCNT
 IF PARENT THEN
  VAR GWIN_BACK=GWIN_CHILD[PARENT]
  GWIN_NEXT[G]=GWIN_BACK
  IF GWIN_BACK THEN
   GWIN_PREV[GWIN_BACK]=G
  ENDIF
  GWIN_CHILD[PARENT]=G
 ENDIF
 GWIN_PREV[G]=0
 GWIN_PARENT[G]=PARENT
 IF PARENT&&PARENT==GWIN_ROOT THEN
  GWIN_EVENT G,#GWIN_EVENT_NEW,0,0,0,0
 ENDIF
 CALL GWIN_EVENT$[G],G,#GWIN_EVENT_NEW,0,0,0,0
 IF PARENT&&PARENT==GWIN_ROOT THEN
  GWIN_SET_FRAME_BUF G,ARRAY%(W*H)
  GWIN_PAINT G,#TRUE
 ENDIF
 RETURN G
END
DEF GWIN_SET_MENU GW,MENU
 GWIN_MENU[GW]=MENU
END
ENUM\
 #GDEBUG_KEY_F1=58,\
 #GDEBUG_KEY_F2,\
 #GDEBUG_KEY_F3,\
 #GDEBUG_KEY_F4,\
 #GDEBUG_KEY_F5,\
 #GDEBUG_KEY_F6,\
 #GDEBUG_KEY_F7,\
 #GDEBUG_KEY_F8,\
 #GDEBUG_KEY_F9,\
 #GDEBUG_KEY_F10,\
 #GDEBUG_KEY_F11,\
 #GDEBUG_KEY_F12

ENUM \
 #CK_UP = &h10000, #CK_DOWN, #CK_LEFT, #CK_RIGHT,\
 #CK_BS, #CK_DEL, #CK_PAGEUP, #CK_PAGEDOWN, #CK_TAB,\
 #CK_LINETOP, #CK_LINEEND, #CK_LINEJUMP,\
 #CK_FILETOP, #CK_FILEEND,\
 #CK_INSLINE, #CK_DELLINE, #CK_DELRIGHT, #CK_UNDO, #CK_REDO,\
 #CK_SELECTSTART, #CK_SELECTEND,\
 #CK_COPY, #CK_CUT, #CK_PASTE, #CK_SMARTDEL,\
 #CK_RUN, #CK_EDIT, #CK_EDIT0, #CK_EDIT1, #CK_EDIT2, #CK_EDIT3,\
 #CK_STOP, #CK_EXIT, #CK_TOOL, #CK_TOOL2, #CK_TOOL3, #CK_SYSREQ,\
 #CK_LOAD, #CK_SAVE, #CK_LISTERR, #CK_SOFTKEY, #CK_ESCAPE,\
 #CK_FONT, #CK_WRAP,\
 #CK_SPLIT, #CK_SPLIT_SINGLE, #CK_SPLIT_VERTICAL, #CK_SPLIT_HORIZONAL,\
 #CK_TAB_INC, #CK_TAB_DEC, #CK_COMMENTOUT, #CK_UNCOMMENTOUT,\
 #CK_SCROLL_UP, #CK_SCROLL_DOWN, #CK_SCROLL_LEFT,\
 #CK_SCROLL_RIGHT, #CK_SCROLL_PAGEUP, #CK_SCROLL_PAGEDOWN,\
 #CK_HELP, #CK_HELP_ON, #CK_HELP_OFF,\
 #_obsolete_CK_HELP_PREVHEADER, #_obsolete_CK_HELP_NEXTHEADER, #_obsolete_CK_HELP_COPY,\
 #_obsolete_CK_HELP_UP, #_obsolete_CK_HELP_DOWN, #_obsolete_CK_HELP_UPD,\
 #CK_FIND_REPL, #_obsolete_CK_FIND_REPLALL, #_obsolete_CK_FIND_REPLNEXT,\
 #CK_FIND_REPLSWITCH, #CK_FIND_PREV, #CK_FIND_NEXT, #CK_FINDMODE,\
 #CK_FOCUS_NEXT, #CK_FOCUS_PREV, #CK_FOCUS_MAIN, #CK_FOCUS_SUB,\
 #CK_FUNC1, #CK_FUNC2, #CK_FUNC3, #CK_FUNC4, #CK_FUNC5,\
 #CK_INSERT, #CK_RESET,\
 #CK_SOFTKEY_ON, #CK_SOFTKEY_OFF, #CK_TRACE, #CK_PERFGAUGE,\
 #CK_SPLIT_GUIDE, #CK_COMPLETION_OFF,\
 #CK_SOFTKEY_RIGHT,#CK_SOFTKEY_DOWN,#CK_SOFTKEY_LEFT,#CK_SOFTKEY_UP,\
 #CK_ENUMEND

VAR GDEBUG_PRG_LINE
VAR GDEBUG_TEMP_PAGE
VAR GDEBUG_OFFSCREEN_PAGE
DEF GDEBUG_GETLINE$()
 VAR R$=""
 LOOP
  VAR K$=INKEY$()
  IF !LEN(K$) THEN RETURN R$
  PUSH R$,K$
  IF K$==CHR$(10)THEN RETURN R$
 ENDLOOP
END
VAR GDEBUG_OFFX
VAR GDEBUG_OFFY
VAR GDEBUG_WIDTH
VAR GDEBUG_HEIGHT
DEF GDEBUG_DEBUGMON_PING()
 ?"->PING"
 PUSHKEY #CK_FOCUS_SUB
 VSYNC
 PUSHKEY CHR$(10)+"PING"+CHR$(10)
 VSYNC
 PUSHKEY #CK_FOCUS_MAIN
 VSYNC 10
 VAR OK
 LOOP
  VAR LINE$=GDEBUG_GETLINE$()
  IF LINE$=="PONG"+CHR$(10)THEN
   ?"<-PONG"
   ?"<-";GDEBUG_GETLINE$();
   OK=#TRUE
  ENDIF
  IF LINE$=="" THEN BREAK
 ENDLOOP
 RETURN OK
END
CONST\
 #GDEBUG_UPDATE_BACKTRACE=1,\
 #GDEBUG_UPDATE_VAR=2,\
 #GDEBUG_UPDATE_SRC=4,\
 #GDEBUG_UPDATE_ERROR=8
VAR GDEBUG_PRG_GWIN
VAR GDEBUG_VAR_GWIN
VAR GDEBUG_BACKTRACE_GWIN
ENUM #GDEBUG_PRG_V_REQ_SCROLL
DEF GDEBUG_UPDATE_WINDOW MASK
 IF MASK AND #GDEBUG_UPDATE_BACKTRACE THEN
  GWIN_SCR_RESET GWIN_FIND(GDEBUG_BACKTRACE_GWIN,"SCRBAR")
  GWIN_PAINT GDEBUG_BACKTRACE_GWIN,#FALSE
 ENDIF
 IF MASK AND #GDEBUG_UPDATE_VAR THEN
  GWIN_SCR_RESET GWIN_FIND(GDEBUG_VAR_GWIN,"SCRBAR")
  GWIN_PAINT GDEBUG_VAR_GWIN,#FALSE
 ENDIF
 IF MASK AND #GDEBUG_UPDATE_SRC THEN
  GWIN_SET_VAR GDEBUG_PRG_GWIN,#GDEBUG_PRG_V_REQ_SCROLL,#TRUE
  GWIN_PAINT GDEBUG_PRG_GWIN,#FALSE
 ENDIF
 IF MASK AND #GDEBUG_UPDATE_ERROR THEN
  IF VM_IS_STOPPED()THEN
   ?VM_LASTERR$()
   IF !VM_IS_CONTINUABLE()THEN
    GWIN_MSG_BOX_ERR VM_LASTERR$()
   ENDIF
  ENDIF
 ENDIF
END
VAR GDEBUG_SYS_FONT_SIZE
DIM GDEBUG_SYS_FONT[]
VAR GDEBUG_CURRENT_FRAME
DEF GDEBUG SLOT
 INIT_FONT
 GDEBUG_PRG_LINE=1
 GDEBUG_SYS_FONT_SIZE=12
 GDEBUG_SYS_FONT=LOAD_FONT("SOURCEHAN-CODE-JP-N12.FONT")
 DEBUG_INIT SLOT
 'GRAPHICAL DEBUGGER
 VAR WIDTH=1280
 VAR HEIGHT=720
 VAR OFFX=512
 VAR OFFY=0
 GDEBUG_OFFX=OFFX
 GDEBUG_OFFY=OFFY
 GDEBUG_WIDTH=WIDTH
 GDEBUG_HEIGHT=HEIGHT
 VAR GPAGE=#GRPF
 GDEBUG_TEMP_PAGE=2
 GDEBUG_OFFSCREEN_PAGE=3
 GTARGET GDEBUG_OFFSCREEN_PAGE
 SYSPARAM "MOUSECURSOR",#TRUE
 VAR PCX,PCY,PCW,PCH
 VAR PRG_HEIGHT=HEIGHT DIV 2+HEIGHT DIV 4
 GDEBUG_WIN_INIT

 VAR BASEX=WIDTH DIV 2,BASEY
 GWIN_ROOT=GWIN_NEW(0,0,0,1280,720,"ROOT","GWIN_ROOT_EVENT")
 VAR PRG_GWIN=GWIN_NEW(GWIN_ROOT,BASEX,BASEY,(WIDTH-BASEX),PRG_HEIGHT,"Graphical Debugger(SLOT"+STR$(SLOT)+")","GWIN_PRG_EVENT")
 VAR VAR_GWIN=GWIN_NEW(GWIN_ROOT,BASEX,BASEY+PRG_HEIGHT,(WIDTH-BASEX)DIV 2,HEIGHT-PRG_HEIGHT,"Variable","GWIN_VAR_EVENT")
 VAR BACK_GWIN=GWIN_NEW(GWIN_ROOT,BASEX+(WIDTH-BASEX) DIV 2,PRG_HEIGHT,(WIDTH-BASEX) DIV 2,HEIGHT-PRG_HEIGHT,"Backtrace","GWIN_BACK_EVENT")
 GDEBUG_PRG_GWIN=PRG_GWIN
 GDEBUG_VAR_GWIN=VAR_GWIN
 GDEBUG_BACKTRACE_GWIN=BACK_GWIN
 GDEBUG_CONT
END
COMMON DEF GDEBUG_CONT
 IF GDEBUG_DEBUGMON_PING() THEN
 ELSE
  ?"DEBUGMONが起動していません"
  ?"F5キーまたはCTRL+Cまたはボタンを押して下さい"
  VAR PRV$=KEY(1)
  KEY 1,"SUBRUN "+CHR$(34)+"DEBUGMON"+CHR$(34)+CHR$(13)
  LOOP
   VAR OM=MILLISEC()
   PUSHKEY #CK_FUNC1
   IF MILLISEC()-OM>=100 THEN
    BREAK
   ENDIF
  ENDLOOP
  IF PRV$=="SUBRUN "+CHR$(34)+"DEBUGMON"+CHR$(34)+CHR$(13) THEN PRV$="FILES"
  KEY 1,PRV$
  IF GDEBUG_DEBUGMON_PING() THEN
  ENDIF
 ENDIF
 ?"Graphical Debugger"
 LOOP
  GWIN_UPDATE
  IF KEYBOARD(#GDEBUG_KEY_F1,2) THEN
   GDEBUG_CURRENT_FRAME=0
   GDEBUG_RUN
   GDEBUG_UPDATE_WINDOW #GDEBUG_UPDATE_BACKTRACE OR #GDEBUG_UPDATE_VAR OR #GDEBUG_UPDATE_SRC OR #GDEBUG_UPDATE_ERROR
  ENDIF
  IF KEYBOARD(#GDEBUG_KEY_F2,2) THEN
   GDEBUG_CURRENT_FRAME=0
   GDEBUG_HIDE
   GDEBUG_STEP #TRUE
   GDEBUG_SHOW
   GDEBUG_UPDATE_WINDOW #GDEBUG_UPDATE_BACKTRACE OR #GDEBUG_UPDATE_VAR OR #GDEBUG_UPDATE_SRC OR #GDEBUG_UPDATE_ERROR
  ENDIF
  IF KEYBOARD(#GDEBUG_KEY_F3,2) THEN
   GDEBUG_CURRENT_FRAME=0
   GDEBUG_HIDE
   GDEBUG_STEP #FALSE
   GDEBUG_SHOW
   GDEBUG_UPDATE_WINDOW #GDEBUG_UPDATE_BACKTRACE OR #GDEBUG_UPDATE_VAR OR #GDEBUG_UPDATE_SRC OR #GDEBUG_UPDATE_ERROR
  ENDIF
  GWIN_COMPOSE
  GWIN_MAIN_LOOP
  VSYNC
 ENDLOOP
END
DEF GWIN_MAIN_LOOP
 VAR WIDTH=1280
 VAR HEIGHT=720
 VAR OFFX=512
 VAR OFFY=0
 GWIN_UPDATE
 GWIN_COMPOSE
 GTARGET #GRPF
 GCLIP OFFX,OFFY,OFFX+WIDTH-1,OFFY+HEIGHT-1
 GCOPY GDEBUG_OFFSCREEN_PAGE,0,0,WIDTH-1,HEIGHT-1,OFFX,OFFY,#G_NORMAL
 GCLIP
 GPSET 2047,2047,RGB(RND(256),RND(256),RND(256))
 GTARGET GDEBUG_OFFSCREEN_PAGE
END
DEF GDEBUG_STEP F
 VAR SLOT,LINE,LP,BP
 VAR OSLOT,OLINE,OLP,OBP
 VMDBG_GET OUT OSLOT,OLINE,OLP
 VM_GET_BP OUT OBP
 LOOP
  VM_TRACE_RUN F
  IF!VM_IS_RUNNING()THEN
   BREAK
  ENDIF
  VMDBG_GET OUT SLOT,LINE,LP
  VM_GET_BP OUT BP
  IF VMDBG_IS_STOPPED_AT_BP()THEN
   BREAK
  ENDIF
  IF BP!=OBP||SLOT!=OSLOT||OLINE!=LINE||(1&&OLP!=LP) THEN
   BREAK
  ENDIF
  IF VM_IS_STOPPED()THEN
   BREAK
  ENDIF
  OSLOT=SLOT
  OLINE=LINE
  OLP=LP
  OBP=BP
 ENDLOOP
END
DIM GDEBUG_BUF[]
DIM GDEBUG_SP_X
DIM GDEBUG_SP_Y
DIM GDEBUG_SP_Z
DIM GDEBUG_SP_U
DIM GDEBUG_SP_V
DIM GDEBUG_SP_W
DIM GDEBUG_SP_H
DIM GDEBUG_SP_PAGE
DIM GDEBUG_GCLIP_X1
DIM GDEBUG_GCLIP_Y1
DIM GDEBUG_GCLIP_X2
DIM GDEBUG_GCLIP_Y2
VAR GDEBUG_PRG_SAVED
VAR GDEBUG_PRG_XSCREEN1,GDEBUG_PRG_XSCREEN2,GDEBUG_PRG_XSCREEN3,GDEBUG_PRG_XSCREEN4,GDEBUG_PRG_XSCREEN5
DEF GDEBUG_HIDE
 IF TYPEOF(GDEBUG_BUF)==#T_DEFAULT THEN
  GDEBUG_BUF=ARRAY%(GDEBUG_SP_W*GDEBUG_SP_H)
 ENDIF
 GSAVE GDEBUG_OFFSCREEN_PAGE,GDEBUG_OFFX,GDEBUG_OFFY,GDEBUG_OFFX+GDEBUG_WIDTH-1,GDEBUG_OFFY+GDEBUG_HEIGHT-1,GDEBUG_BUF
RETURN
 SPOFS 4094 OUT GDEBUG_SP_X,GDEBUG_SP_Y,GDEBUG_SP_Z
 SPCHR 4094 OUT GDEBUG_SP_U,GDEBUG_SP_V,GDEBUG_SP_W,GDEBUG_SP_H
 SPPAGE 4094 OUT GDEBUG_SP_PAGE
 GSAVE GDEBUG_SP_PAGE,GDEBUG_SP_U,GDEBUG_SP_V,GDEBUG_SP_W,GDEBUG_SP_H,GDEBUG_BUF
 SPCLR 4094
 GCLIP OUT GDEBUG_GCLIP_X1,GDEBUG_GCLIP_Y1,GDEBUG_GCLIP_X2,GDEBUG_GCLIP_Y2
 IF GDEBUG_PRG_SAVED THEN
  XSCREEN GDEBUG_PRG_XSCREEN1,GDEBUG_PRG_XSCREEN2,GDEBUG_PRG_XSCREEN3,GDEBUG_PRG_XSCREEN4,GDEBUG_PRG_XSCREEN5
 ENDIF
END
DEF GDEBUG_SHOW
 GTARGET GDEBUG_OFFSCREEN_PAGE
 GLOAD GDEBUG_OFFX,GDEBUG_OFFY,GDEBUG_OFFX+GDEBUG_WIDTH-1,GDEBUG_OFFY+GDEBUG_HEIGHT-1,GDEBUG_BUF,#G_NORMAL
RETURN
 GDEBUG_PRG_SAVED=#TRUE
 XSCREEN OUT GDEBUG_PRG_XSCREEN1,GDEBUG_PRG_XSCREEN2,GDEBUG_PRG_XSCREEN3,GDEBUG_PRG_XSCREEN4,GDEBUG_PRG_XSCREEN5
 XSCREEN 1280,720
 SPSET 4094,GDEBUG_SP_U,GDEBUG_SP_V,GDEBUG_SP_W,GDEBUG_SP_H
 SPOFS 4094,GDEBUG_SP_X,GDEBUG_SP_Y,GDEBUG_SP_Z
 SPPAGE 4094,GDEBUG_SP_PAGE
 GTARGET GDEBUG_SP_PAGE
 GLOAD GDEBUG_SP_U,GDEBUG_SP_V,GDEBUG_SP_W,GDEBUG_SP_H,GDEBUG_BUF,#G_NORMAL
 GCLIP GDEBUG_GCLIP_X1,GDEBUG_GCLIP_Y1,GDEBUG_GCLIP_X2,GDEBUG_GCLIP_Y2
END
DEF GDEBUG_RUN
 GDEBUG_HIDE
 VM_DEBUG_RUN
 GDEBUG_SHOW
END
DEF GWIN_COMPOSE
' IF!GWIN_UPDATED THEN RETURN
 GWIN_UPDATED=#FALSE
 GCLIP 0,0,1280-1,720-1
 GCLS
' GFILL 0,0,1279,719,RGB(16,0,0,0),#G_ALPHA2
 VAR GWIN_BACK=GWIN_CHILD[GWIN_ROOT]
 VAR GW=GWIN_BACK
 GTARGET GDEBUG_OFFSCREEN_PAGE
 WHILE GW
  IF 0 THEN
   GTARGET 2
   GLOAD GWIN_X[GW],GWIN_Y[GW],GWIN_W[GW],GWIN_H[GW],GWIN_GET_FRAME_BUF(GW),#G_NORMAL
   GTARGET GDEBUG_OFFSCREEN_PAGE
   GCOPY 2,GWIN_X[GW],GWIN_Y[GW],GWIN_X[GW]+GWIN_W[GW]-1,GWIN_Y[GW]+GWIN_H[GW]-1,GWIN_X[GW],GWIN_Y[GW],RGB(16,255,255,255),#G_ALPHA2
  ELSE
   GLOAD GWIN_X[GW],GWIN_Y[GW],GWIN_W[GW],GWIN_H[GW],GWIN_GET_FRAME_BUF(GW),#G_NORMAL
  ENDIF
  GW=GWIN_NEXT[GW]
 WEND
END
DEF GWIN_GET_WIN_FROM_POS ROOT,X,Y OUT GW,FRAME
 FRAME=#FALSE
 VAR GWIN_BACK=GWIN_CHILD[ROOT]
 GW=GWIN_BACK
 WHILE GW
  IF!GWIN_NEXT[GW] THEN BREAK
  GW=GWIN_NEXT[GW]
 WEND
 WHILE GW
  IF GWIN_X[GW]<=X&&GWIN_Y[GW]<=Y&&X<GWIN_X[GW]+GWIN_W[GW]&&Y<GWIN_Y[GW]+GWIN_H[GW] THEN
   VAR CX=GWIN_X[GW]+GWIN_FW1[GW]
   VAR CY=GWIN_Y[GW]+GWIN_FH1[GW]
   IF CX<=X&&CY<=Y&&X<CX+GWIN_GET_CW(GW)&&Y<CY+GWIN_GET_CH(GW) THEN
    IF GWIN_CHILD[GW]THEN
     VAR GW2,FRAME2
     GWIN_GET_WIN_FROM_POS GW,X,Y OUT GW2,FRAME2
     IF GW2 THEN
      GW=GW2
      FRAME=FRAME2
     ENDIF
    ENDIF
   ELSE
    FRAME=#TRUE
   ENDIF
   RETURN
  ENDIF
  GW=GWIN_PREV[GW]
 WEND
END
VAR GWIN_OLD_MX
VAR GWIN_OLD_MY
VAR GWIN_OLD_MBTN
DEF GWIN_GET_MOUSE_X(GW)
 RETURN GWIN_OLD_MX-GWIN_GET_CLIENT_X(GW)+GWIN_GET_CX(GW)
END
DEF GWIN_GET_MOUSE_Y(GW)
 RETURN GWIN_OLD_MY-GWIN_GET_CLIENT_Y(GW)+GWIN_GET_CY(GW)
END
DEF GWIN_GET_MOUSE_NCX(GW)
 RETURN GWIN_OLD_MX-GWIN_GET_X(GW)+GWIN_GET_DRAW_X(GW)
END
DEF GWIN_GET_MOUSE_NCY(GW)
 RETURN GWIN_OLD_MY-GWIN_GET_Y(GW)+GWIN_GET_DRAW_Y(GW)
END
DEF GWIN_MOUSE_L_CLK()
 RETURN GWIN_OLD_MBTN AND 1
END
DEF GWIN_UPDATE
 VAR X,Y,W
 MOUSE 1 OUT X,Y,W
 VAR CBTN=MBUTTON()
 VAR DWN_BTN=(GWIN_OLD_MBTN XOR CBTN)AND NOT GWIN_OLD_MBTN
 VAR UP_BTN=(GWIN_OLD_MBTN XOR CBTN)AND GWIN_OLD_MBTN
 GWIN_OLD_MBTN=CBTN
 IF DWN_BTN THEN
  VAR GW,FRAME
  GWIN_GET_WIN_FROM_POS GWIN_ROOT,X,Y OUT GW,FRAME
  IF FRAME&&GW THEN
   GWIN_EVENT GW,#GWIN_EVENT_LDWN,X-GWIN_X[GW],Y-GWIN_Y[GW],0,0
  ELSEIF GW THEN
   CALL GWIN_EVENT$[GW],GW,#GWIN_EVENT_LDWN,X-GWIN_GET_CLIENT_X(GW),Y-GWIN_GET_CLIENT_Y(GW),0,0
  ENDIF
 ENDIF
 IF UP_BTN THEN
  IF GWIN_CAPTURE_GW THEN
   GW=GWIN_CAPTURE_GW
   FRAME=GWIN_CAPTURE_FRAME
  ELSE
   GWIN_GET_WIN_FROM_POS GWIN_ROOT,X,Y OUT GW,FRAME
  ENDIF
  IF GW&&FRAME THEN
   GWIN_EVENT GW,#GWIN_EVENT_LUP,X-GWIN_X[GW],Y-GWIN_Y[GW],0,0
  ELSEIF GW THEN
   CALL GWIN_EVENT$[GW],GW,#GWIN_EVENT_LUP,X-GWIN_GET_CLIENT_X(GW),Y-GWIN_GET_CLIENT_Y(GW),0,0
  ENDIF
 ENDIF
 IF GWIN_OLD_MX!=X||GWIN_OLD_MY!=Y THEN
  GWIN_OLD_MX=X
  GWIN_OLD_MY=Y
  IF GWIN_CAPTURE_GW THEN
   GW=GWIN_CAPTURE_GW
   FRAME=GWIN_CAPTURE_FRAME
  ELSE
   GWIN_GET_WIN_FROM_POS GWIN_ROOT,X,Y OUT GW,FRAME
  ENDIF
  IF FRAME&&GW THEN
   GWIN_EVENT GW,#GWIN_EVENT_MMOVE,X-GWIN_X[GW],Y-GWIN_Y[GW],0,0
  ELSEIF GW THEN
   CALL GWIN_EVENT$[GW],GW,#GWIN_EVENT_MMOVE,X-GWIN_GET_CLIENT_X(GW),Y-GWIN_GET_CLIENT_Y(GW),0,0
  ENDIF
 ENDIF
 IF !CBTN THEN
  GWIN_CAPTURE_GW=0
 ENDIF
END
DEF GWIN_PAINT GW,FRAME
 GWIN_UPDATED=#TRUE
 IF !GWIN_PARENT[GW]THEN RETURN
 WHILE GWIN_PARENT[GW]!=GWIN_ROOT
  GW=GWIN_PARENT[GW]
 WEND
 GTARGET GDEBUG_TEMP_PAGE
 IF FRAME||1 THEN
  GCLIP 0,0,GWIN_W[GW]-1,GWIN_H[GW]-1
  GWIN_EVENT GW,#GWIN_EVENT_PAINT,0,0,0,0
 ENDIF
 GCLIP GWIN_FW1[GW],GWIN_FH1[GW],GWIN_W[GW]-GWIN_FW2[GW]-1,GWIN_H[GW]-GWIN_FH2[GW]-1
 GWIN_PAINT_CALL GW
 GSAVE 0,0,GWIN_W[GW],GWIN_H[GW],GWIN_GET_FRAME_BUF(GW)
END
DEF GWIN_PAINT_CALL GW
 CALL GWIN_EVENT$[GW],GW,#GWIN_EVENT_PAINT,0,0,0,0
 VAR C=GWIN_CHILD[GW]
 WHILE C
  IF GWIN_CHILD[C] THEN GWIN_PAINT_CALL GWIN_CHILD[C]
  GCLIP GWIN_GET_CX(C),GWIN_GET_CY(C),GWIN_GET_CX(C)+GWIN_GET_CW(C)-1,GWIN_GET_CY(C)+GWIN_GET_CH(C)-1
  CALL GWIN_EVENT$[C],C,#GWIN_EVENT_PAINT,0,0,0,0
  C=GWIN_NEXT[C]
 WEND
END
DEF GWIN_SET_CAPTURE GW,FRAME
 GWIN_CAPTURE_GW=GW
 GWIN_CAPTURE_FRAME=FRAME
 GWIN_CAPTURE_X=GWIN_OLD_MX-GWIN_X[GW]
 GWIN_CAPTURE_Y=GWIN_OLD_MY-GWIN_Y[GW]
 IF !FRAME THEN
  DEC GWIN_CAPTURE_X,GWIN_FW1[GW]
  DEC GWIN_CAPTURE_Y,GWIN_FH1[GW]
 ENDIF
END
DEF GWIN_GET_CAPTURE OUT GW,FRAME,X,Y
 GW=GWIN_CAPTURE_GW
 FRAME=GWIN_CAPTURE_FRAME
 X=GWIN_CAPTURE_X
 Y=GWIN_CAPTURE_Y
END
DEF GWIN_FRONT GW
 GWIN_UPDATED=#TRUE
 VAR NXT=GWIN_NEXT[GW]
 VAR PRV=GWIN_PREV[GW]
 IF !NXT&&!PRV THEN RETURN
 VAR GWIN_BACK=GWIN_CHILD[GWIN_PARENT[GW]]
 IF GWIN_BACK==GW THEN
  GWIN_CHILD[GWIN_PARENT[GW]]=NXT
 ENDIF
 IF PRV THEN
  GWIN_NEXT[PRV]=NXT
 ENDIF
 IF NXT THEN
  GWIN_PREV[NXT]=PRV
 ENDIF
 VAR FGW=GWIN_BACK
 WHILE FGW
  IF!GWIN_NEXT[FGW] THEN BREAK
  FGW=GWIN_NEXT[FGW]
 WEND
 GWIN_NEXT[FGW]=GW
 GWIN_PREV[GW]=FGW
 GWIN_NEXT[GW]=0
END
DEF GWIN_FIND(GW,EVENT$)
 GW=GWIN_CHILD[GW]
 WHILE GW
  IF GWIN_NAME$[GW]==EVENT$ THEN BREAK
  GW=GWIN_NEXT[GW]
 WEND
 RETURN GW
END
'FIXME:CHILD W
DEF GWIN_MOVE GW,X,Y
 GWIN_UPDATED=#TRUE
 GWIN_X[GW]=X+GWIN_X[GWIN_PARENT[GW]]+GWIN_FW1[GWIN_PARENT[GW]]
 GWIN_Y[GW]=Y+GWIN_Y[GWIN_PARENT[GW]]+GWIN_FH1[GWIN_PARENT[GW]]
 VAR PARENT=GWIN_PARENT[GW]
 IF PARENT!=GWIN_ROOT THEN
  GWIN_DRAW_X[GW]=X+GWIN_DRAW_X[PARENT]+GWIN_FW1[PARENT]
  GWIN_DRAW_Y[GW]=Y+GWIN_DRAW_Y[PARENT]+GWIN_FH1[PARENT]
 ENDIF
 GWIN_REL_X[GW]=X
 GWIN_REL_Y[GW]=Y
 GWIN_MOVE_CHILDREN GWIN_CHILD[GW]
END
DEF GWIN_MOVERESIZE GW,X,Y,W,H
 GWIN_UPDATED=#TRUE
 GWIN_X[GW]=X+GWIN_X[GWIN_PARENT[GW]]+GWIN_FW1[GWIN_PARENT[GW]]
 GWIN_Y[GW]=Y+GWIN_Y[GWIN_PARENT[GW]]+GWIN_FH1[GWIN_PARENT[GW]]
 VAR PARENT=GWIN_PARENT[GW]
 IF PARENT!=GWIN_ROOT THEN
  GWIN_DRAW_X[GW]=X+GWIN_DRAW_X[PARENT]+GWIN_FW1[PARENT]
  GWIN_DRAW_Y[GW]=Y+GWIN_DRAW_Y[PARENT]+GWIN_FH1[PARENT]
 ENDIF
 GWIN_REL_X[GW]=X
 GWIN_REL_Y[GW]=Y
 GWIN_W[GW]=W
 GWIN_H[GW]=H
 GWIN_MOVE_CHILDREN GWIN_CHILD[GW]
END
DEF GWIN_MOVE_CHILDREN GW
 WHILE GW
  GWIN_X[GW]=GWIN_REL_X[GW]+GWIN_X[GWIN_PARENT[GW]]+GWIN_FW1[GWIN_PARENT[GW]]
  GWIN_Y[GW]=GWIN_REL_Y[GW]+GWIN_Y[GWIN_PARENT[GW]]+GWIN_FH1[GWIN_PARENT[GW]]
  VAR PARENT=GWIN_PARENT[GW]
  IF PARENT!=GWIN_ROOT THEN
   GWIN_DRAW_X[GW]=GWIN_REL_X[GW]+GWIN_DRAW_X[PARENT]+GWIN_FW1[PARENT]
   GWIN_DRAW_Y[GW]=GWIN_REL_Y[GW]+GWIN_DRAW_Y[PARENT]+GWIN_FH1[PARENT]
  ENDIF
  IF GWIN_CHILD[GW] THEN
   GWIN_MOVE_CHILDREN GWIN_CHILD[GW]
  ENDIF
  GW=GWIN_NEXT[GW]
 WEND
END
DEF GWIN_SET_FRAME GW,FW1,FH1,FW2,FH2
 IF GWIN_FW1[GW]!=FW1||GWIN_FH1[GW]!=FH1||GWIN_FW2[GW]!=FW2||GWIN_FH2[GW]!=FH2 THEN
  GWIN_FW1[GW]=FW1
  GWIN_FH1[GW]=FH1
  GWIN_FW2[GW]=FW2
  GWIN_FH2[GW]=FH2
  GWIN_MOVE_CHILDREN GWIN_CHILD[GW]
 ENDIF
END
DEF GWIN_EVENT GW,EVENT,A1,A2,A3,A4
 CASE EVENT
 WHEN #GWIN_EVENT_NEW
 WHEN #GWIN_EVENT_PAINT
  VAR FCX,FCY,FCW,FCH
  GWIN_DRAW_WINDOW GW,EVENT,GWIN_GET_DRAW_X(GW),GWIN_GET_DRAW_Y(GW),GWIN_W[GW],GWIN_H[GW],GWIN_NAME$[GW] OUT FCX,FCY,FCW,FCH
  GWIN_SET_FRAME GW,FCX-GWIN_DRAW_X[GW],\
                 FCY-GWIN_DRAW_Y[GW],\
                 GWIN_W[GW]-FCW-(FCX-GWIN_DRAW_X[GW]),\
                 GWIN_H[GW]-FCH-(FCY-GWIN_DRAW_Y[GW])
 WHEN #GWIN_EVENT_LDWN
  GWIN_SET_CAPTURE GW,#TRUE
  GWIN_FRONT GW
  GWIN_DRAW_WINDOW GW,EVENT,GWIN_GET_DRAW_X(GW),GWIN_GET_DRAW_Y(GW),GWIN_W[GW],GWIN_H[GW],GWIN_NAME$[GW] OUT FCX,FCY,FCW,FCH
 WHEN #GWIN_EVENT_MMOVE
  GWIN_DRAW_WINDOW GW,EVENT,GWIN_GET_DRAW_X(GW),GWIN_GET_DRAW_Y(GW),GWIN_W[GW],GWIN_H[GW],GWIN_NAME$[GW] OUT FCX,FCY,FCW,FCH
  VAR CGW,FRAME,X,Y
  GWIN_GET_CAPTURE OUT CGW,FRAME,X,Y
  IF FRAME&&CGW&&GW THEN
   GWIN_MOVE GW,GWIN_GET_X(GW)+A1-X,GWIN_GET_Y(GW)+A2-Y
  ENDIF
 ENDCASE
END

DEF GWIN_SEND_NOTIF GW,NOTIF_TYP,A3,A4
 CALL GWIN_EVENT$[GWIN_PARENT[GW]],GWIN_PARENT[GW],#GWIN_EVENT_NOTIF,NOTIF_TYP,GW,A3,A4
END
DEF GWIN_GET_ID(GW)
 RETURN GWIN_ID[GW]
END
DEF GWIN_GET_DRAW_X(GW)
 RETURN GWIN_DRAW_X[GW]
END
DEF GWIN_GET_DRAW_Y(GW)
 RETURN GWIN_DRAW_Y[GW]
END
DEF GWIN_GET_CX(GW)
 RETURN GWIN_DRAW_X[GW]+GWIN_FW1[GW]
END
DEF GWIN_GET_CY(GW)
 RETURN GWIN_DRAW_Y[GW]+GWIN_FH1[GW]
END
DEF GWIN_GET_CLIENT_X(GW)
 RETURN GWIN_X[GW]+GWIN_FW1[GW]
END
DEF GWIN_GET_CLIENT_Y(GW)
 RETURN GWIN_Y[GW]+GWIN_FH1[GW]
END
DEF GWIN_GET_CW(GW)
 RETURN GWIN_W[GW]-GWIN_FW1[GW]-GWIN_FW2[GW]
END
DEF GWIN_GET_CH(GW)
 RETURN GWIN_H[GW]-GWIN_FH1[GW]-GWIN_FH2[GW]
END
DEF GWIN_GET_CLIENT_W(GW)
 RETURN GWIN_W[GW]-GWIN_FW1[GW]-GWIN_FW2[GW]
END
DEF GWIN_GET_CLIENT_H(GW)
 RETURN GWIN_H[GW]-GWIN_FH1[GW]-GWIN_FH2[GW]
END
DEF GWIN_GET_X(GW)
 RETURN GWIN_X[GW]
END
DEF GWIN_GET_Y(GW)
 RETURN GWIN_Y[GW]
END
DEF GWIN_GET_W(GW)
 RETURN GWIN_W[GW]
END
DEF GWIN_GET_H(GW)
 RETURN GWIN_H[GW]
END
DEF GWIN_GET_NAME$(GW)
 RETURN GWIN_NAME$[GW]
END
DEF GWIN_SET_NAME GW,N$
 GWIN_NAME$[GW]=N$
END
DEF GWIN_ROOT_EVENT GW,EVENT,A1,A2,A3,A4
END
DEF GWIN_MSG_BOX_ERR ERR$
 VAR MSGBOX_WIDTH=300
 VAR MSGBOX_HEIGHT=114
 VAR SCRW=1280
 VAR SCRH=720
 VAR GWIN=GWIN_NEW(GWIN_ROOT,(SCRW-MSGBOX_WIDTH)DIV 2,(SCRH-MSGBOX_HEIGHT)DIV 2,MSGBOX_WIDTH,MSGBOX_HEIGHT,"Error","GWIN_MSGBOX_EVENT")
 GWIN_SET_NAME GWIN_FIND(GWIN,""),ERR$
 GWIN_PAINT GWIN,#FALSE
 GWIN_FRONT GWIN
 VAR ID=GWIN_GET_ID(GWIN)
 LOOP
  IF GWIN_GET_ID(GWIN)!=ID THEN BREAK
  GWIN_MAIN_LOOP
  VSYNC
 ENDLOOP
END

DEF GWIN_MSGBOX_EVENT GW,EVENT,A1,A2,A3,A4
 CASE EVENT
 WHEN #GWIN_EVENT_NEW
  VAR BUTTON_GWIN=GWIN_NEW(GW,(GWIN_GET_CLIENT_W(GW)-88) DIV 2,GWIN_GET_CLIENT_H(GW)-30,88,21,"OK","GWIN_BUTTON_EVENT")
  VAR LABEL_GWIN=GWIN_NEW(GW,12+32+16,10,GWIN_GET_CLIENT_W(GW)-(12+32+16),GWIN_GET_CLIENT_H(GW)-40,"","GWIN_LABEL_EVENT")
 WHEN #GWIN_EVENT_PAINT
  VAR X=GWIN_GET_CX(GW),Y=GWIN_GET_CY(GW)
  GCLS RGB(192,192,192)
  GWIN_DRAW_ERR_ICON GW,X+12,Y+12
 WHEN #GWIN_EVENT_NOTIF
  CASE A1
  WHEN #GWIN_NOTIF_BUTTON_PUSHED
   GWIN_DELETE GW
  ENDCASE
 ENDCASE
END
DIM GWIN_ERR_ICON[,]
DEF GWIN_DRAW_ERR_ICON GW,X,Y
 IF TYPEOF(GWIN_ERR_ICON)==#T_DEFAULT THEN
  VAR B=RGB(0,0,0)
  VAR C=RGB(192,192,192)
  VAR R=RGB(255,0,0)
  C=R
  VAR W=RGB(255,255,255)
  DIM A%[29,29]=[\
   0,0,0,0,0,0,0,0,0,0,0,B,B,B,B,B,B,B,0,0,0,0,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,0,0,B,B,B,C,C,C,C,C,C,C,B,B,B,0,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,B,B,C,C,C,R,R,R,R,R,R,R,C,C,C,B,B,0,0,0,0,0,0,\
   0,0,0,0,0,B,C,C,R,R,R,R,R,R,R,R,R,R,R,R,R,C,C,B,0,0,0,0,0,\
   0,0,0,0,B,C,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,C,B,0,0,0,0,\
   0,0,0,B,C,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,C,B,0,0,0,\
   0,0,B,C,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,C,B,0,0,\
   0,0,B,C,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,C,B,0,0,\
   0,B,C,R,R,R,R,R,R,R,W,R,R,R,R,R,R,R,W,R,R,R,R,R,R,R,C,B,0,\
   0,B,C,R,R,R,R,R,R,W,W,W,R,R,R,R,R,W,W,W,R,R,R,R,R,R,C,B,0,\
   0,B,C,R,R,R,R,R,W,W,W,W,W,R,R,R,W,W,W,W,W,R,R,R,R,R,C,B,0,\
   B,C,R,R,R,R,R,R,R,W,W,W,W,W,R,W,W,W,W,W,R,R,R,R,R,R,R,C,B,\
   B,C,R,R,R,R,R,R,R,R,W,W,W,W,W,W,W,W,W,R,R,R,R,R,R,R,R,C,B,\
   B,C,R,R,R,R,R,R,R,R,R,W,W,W,W,W,W,W,R,R,R,R,R,R,R,R,R,C,B,\
   B,C,R,R,R,R,R,R,R,R,R,R,W,W,W,W,W,R,R,R,R,R,R,R,R,R,R,C,B,\
   B,C,R,R,R,R,R,R,R,R,R,W,W,W,W,W,W,W,R,R,R,R,R,R,R,R,R,C,B,\
   B,C,R,R,R,R,R,R,R,R,W,W,W,W,W,W,W,W,W,R,R,R,R,R,R,R,R,C,B,\
   B,C,R,R,R,R,R,R,R,W,W,W,W,W,R,W,W,W,W,W,R,R,R,R,R,R,R,C,B,\
   0,B,C,R,R,R,R,R,W,W,W,W,W,R,R,R,W,W,W,W,W,R,R,R,R,R,C,B,0,\
   0,B,C,R,R,R,R,R,R,W,W,W,R,R,R,R,R,W,W,W,R,R,R,R,R,R,C,B,0,\
   0,B,C,R,R,R,R,R,R,R,W,R,R,R,R,R,R,R,W,R,R,R,R,R,R,R,C,B,0,\
   0,0,B,C,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,C,B,0,0,\
   0,0,B,C,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,C,B,0,0,\
   0,0,0,B,C,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,C,B,0,0,0,\
   0,0,0,0,B,C,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,C,B,0,0,0,0,\
   0,0,0,0,0,B,C,C,R,R,R,R,R,R,R,R,R,R,R,R,R,C,C,B,0,0,0,0,0,\
   0,0,0,0,0,0,B,B,C,C,C,R,R,R,R,R,R,R,C,C,C,B,B,0,0,0,0,0,0,\
   0,0,0,0,0,0,0,0,B,B,B,C,C,C,C,C,C,C,B,B,B,0,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,0,0,0,0,0,B,B,B,B,B,B,B,0,0,0,0,0,0,0,0,0,0,0\
  ]
  GWIN_ERR_ICON=A%
 ENDIF
 GLOAD X+1,Y+1,29,29,GWIN_ERR_ICON,#G_NORMAL2
END
ENUM #GWIN_BUTTON_V_PUSH
DEF GWIN_BUTTON_EVENT GW,EVENT,A1,A2,A3,A4
 CASE EVENT
 WHEN #GWIN_EVENT_LDWN
  GWIN_SET_VAR GW,#GWIN_BUTTON_V_PUSH,#TRUE
  GWIN_SET_CAPTURE GW,#FALSE
  GWIN_PAINT GW,#FALSE
 WHEN #GWIN_EVENT_LUP
  VAR C_GW
  GWIN_GET_CAPTURE OUT C_GW,,,
  GWIN_SET_VAR GW,#GWIN_BUTTON_V_PUSH,#FALSE
  GWIN_PAINT GW,#FALSE
  IF C_GW==GW THEN
   IF\
      A1>=0&&A1<GWIN_GET_W(GW)&&\
      A2>=0&&A2<GWIN_GET_H(GW) THEN
    GWIN_SEND_NOTIF GW,#GWIN_NOTIF_BUTTON_PUSHED,0,0
   ENDIF
  ENDIF
 WHEN #GWIN_EVENT_PAINT
  VAR N$=GWIN_GET_NAME$(GW)
  VAR X=GWIN_GET_CX(GW),Y=GWIN_GET_CY(GW)
  VAR W=GWIN_GET_CW(GW),H=GWIN_GET_CH(GW)
  VAR PUSH=GWIN_GET_VAR(GW,#GWIN_BUTTON_V_PUSH),ST
  IF PUSH THEN
   ST=#GWIN_DRAW_BUTTON_SUNKEN
  ELSE
   ST=#GWIN_DRAW_BUTTON_RAISED
  ENDIF
  GWIN_DRAW_BUTTON2 X,Y,W,H,ST
  VAR FW=FONT_CALC_WIDTH(GDEBUG_SYS_FONT,N$)
  GPUTCHR_FONT GDEBUG_SYS_FONT,PUSH+X+(W-FW) DIV 2,PUSH+Y+(H-GDEBUG_SYS_FONT_SIZE) DIV 2,#FALSE,N$,RGB(0,0,0)
 ENDCASE
END
DEF GWIN_LABEL_EVENT GW,EVENT,A1,A2,A3,A4
 CASE EVENT
 WHEN #GWIN_EVENT_PAINT
  GCLS RGB(192,192,192)
  VAR N$=GWIN_GET_NAME$(GW)
  VAR I
  VAR X=GWIN_GET_CX(GW),Y=GWIN_GET_CY(GW)
  VAR W=GWIN_GET_CW(GW)
  LOOP
   VAR NI=INSTR(I,N$,CHR$(10))
   IF NI==-1 THEN NI=LEN(N$)
   VAR T$=MID$(N$,I,NI-I)
   GPUTCHR_FONT GDEBUG_SYS_FONT,X,Y,#FALSE,T$,RGB(0,0,0)
   IF NI==LEN(N$)THEN BREAK
   I=NI+1
   INC Y,FONT_GET_LINE_HEIGHT(GDEBUG_SYS_FONT)
  ENDLOOP
 ENDCASE
END

DEF GWIN_PRG_EVENT GW,EVENT,A1,A2,A3,A4
 CASE EVENT
 WHEN #GWIN_EVENT_NEW
  VAR MENU=NEW_GMENU()
  GMENU_ADD_ITEM MENU,"File",0
  GMENU_ADD_ITEM MENU,"Debug",0
  GMENU_ADD_ITEM MENU,"Window",0
  GMENU_ADD_ITEM MENU,"Help",0
'  GMENU_ADD_ITEM MENU,"ファイル",0
'  GMENU_ADD_ITEM MENU,"デバッグ",0
'  GMENU_ADD_ITEM MENU,"ヘルプ",0
  GWIN_SET_MENU GW,MENU
  VAR SCR_GWIN=GWIN_NEW(GW,0,0,0,0,"SCRBAR","GWIN_SCR_EVENT")
  VAR SCR_GWIN2=GWIN_NEW(GW,0,0,0,0,"SCRBAR_H","GWIN_SCR_EVENT")
 WHEN #GWIN_EVENT_PAINT
  GDEBUG_DRAW_PRG GW,EVENT,0,GDEBUG_PRG_LINE,GWIN_GET_CX(GW),GWIN_GET_CY(GW),GWIN_GET_CW(GW),GWIN_GET_CH(GW) OUT GDEBUG_PRG_LINE
 WHEN #GWIN_EVENT_LDWN
  GDEBUG_DRAW_PRG GW,EVENT,0,GDEBUG_PRG_LINE,GWIN_GET_CX(GW),GWIN_GET_CY(GW),GWIN_GET_CW(GW),GWIN_GET_CH(GW) OUT GDEBUG_PRG_LINE
  GWIN_FRONT GW
 ENDCASE
END

ENUM #GWIN_SCR_V_PAGE,#GWIN_SCR_V_SIZE,#GWIN_SCR_V_POS,#GWIN_SCR_V_STATE
ENUM #GWIN_SCR_STATE_NONE,#GWIN_SCR_STATE_UP,#GWIN_SCR_STATE_DOWN,#GWIN_SCR_STATE_THUMB,#GWIN_SCR_STATE_THUMB_OLD
DEF GWIN_SCR_RESET GW
 GWIN_SCR_SET GW,0,0,0
END
DEF GWIN_SCR_SET GW,PAGE,SIZE,POS
 IF TYPEOF(PAGE)THEN
  GWIN_SET_VAR GW,#GWIN_SCR_V_PAGE,PAGE
 ENDIF
 IF TYPEOF(SIZE)THEN
  GWIN_SET_VAR GW,#GWIN_SCR_V_SIZE,SIZE
 ENDIF
 IF TYPEOF(POS)THEN
  GWIN_SET_VAR GW,#GWIN_SCR_V_POS,POS
 ENDIF
 GWIN_SCR_GET GW OUT PAGE,SIZE,POS
 IF SIZE THEN
  POS=MAX(0,MIN(POS,SIZE-PAGE+1))
  GWIN_SET_VAR GW,#GWIN_SCR_V_POS,POS
 ENDIF
END
DEF GWIN_SCR_GET GW OUT PAGE,SIZE,POS
 GWIN_GET_VAR GW,#GWIN_SCR_V_PAGE OUT PAGE
 GWIN_GET_VAR GW,#GWIN_SCR_V_SIZE OUT SIZE
 GWIN_GET_VAR GW,#GWIN_SCR_V_POS OUT POS
END
DEF GWIN_SCR_EVENT GW,EVENT,A1,A2,A3,A4
 CASE EVENT
 WHEN #GWIN_EVENT_PAINT
 WHEN #GWIN_EVENT_LDWN
 WHEN #GWIN_EVENT_MMOVE
  GDEBUG_DRAW_SCRBAR GW,EVENT,GWIN_GET_CX(GW),GWIN_GET_CY(GW),GWIN_GET_CW(GW),GWIN_GET_CH(GW)
 ENDCASE
END
DEF GWIN_VAR_EVENT GW,TYP,A1,A2,A3,A4
 CASE TYP
 WHEN #GWIN_EVENT_NEW
  VAR SCR_GWIN=GWIN_NEW(GW,0,0,0,0,"SCRBAR","GWIN_SCR_EVENT")
 WHEN #GWIN_EVENT_PAINT
  GDEBUG_DRAW_VAR GW,TYP,GWIN_GET_CX(GW),GWIN_GET_CY(GW),GWIN_GET_CW(GW),GWIN_GET_CH(GW)
 WHEN #GWIN_EVENT_LDWN
  GWIN_FRONT GW
  GDEBUG_DRAW_VAR GW,TYP,GWIN_GET_CX(GW),GWIN_GET_CY(GW),GWIN_GET_CW(GW),GWIN_GET_CH(GW)
 ENDCASE
END

DEF GWIN_BACK_EVENT GW,TYP,A1,A2,A3,A4
 CASE TYP
 WHEN #GWIN_EVENT_NEW
  VAR SCR_GWIN=GWIN_NEW(GW,0,0,0,0,"SCRBAR","GWIN_SCR_EVENT")
 WHEN #GWIN_EVENT_PAINT
  GDEBUG_DRAW_BACKTRACE GW,TYP,GWIN_GET_CX(GW),GWIN_GET_CY(GW),GWIN_GET_CW(GW),GWIN_GET_CH(GW)
 WHEN #GWIN_EVENT_LDWN
  GWIN_FRONT GW
  GDEBUG_DRAW_BACKTRACE GW,TYP,GWIN_GET_CX(GW),GWIN_GET_CY(GW),GWIN_GET_CW(GW),GWIN_GET_CH(GW)
 ENDCASE
END

DIM GDEBUG_DISABLED_CLOSE_BUTTON[]
DEF GWIN_DRAW_WINDOW GW,EVENT,X,Y,W,H,TITLE$ OUT CX,CY,CW,CH
 VAR X2=X+W-1
 VAR Y2=Y+H-1
 GCLIP X,Y,X2,Y2
 VAR BACK_C=RGB(0,0,0)
 VAR BORDER_C2=RGB(255,255,255)
 VAR TITLE_BACK_C=RGB(0,0,128)
 VAR TITLE_FORE_C=RGB(255,255,255)
 VAR TITLE_BORDER_C=RGB(255,255,255)
 VAR TITLE_H=19
 VAR TITLE_BORDER_H=1
 VAR B=1
 VAR BORDER_W1=3+B
 VAR BORDER_W2=3+B
 VAR BORDER_H1=3+B
 VAR BORDER_H2=3+B
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GLINE X,Y,X,Y2-1,RGB(223,223,223)
  GLINE X,Y,X2-1,Y,RGB(223,223,223)
  GLINE X2,Y,X2,Y2,RGB(0,0,0)
  GLINE X,Y2,X2,Y2,RGB(0,0,0)
  GLINE X+1,Y+1,X2-2,Y+1,RGB(255,255,255)
  GLINE X+1,Y+1,X+1,Y2-2,RGB(255,255,255)
  GLINE X+1,Y2-1,X2-1,Y2-1,RGB(128,128,128)
  GLINE X2-1,Y+1,X2-1,Y2-1,RGB(128,128,128)
  GFILL X+2,Y+2,X+2+B,Y2-2,RGB(192,192,192)
  GFILL X+2,Y+2,X2-2,Y+2+B,RGB(192,192,192)
  GFILL X2-2-B,Y+2,X2-2,Y2-2,RGB(192,192,192)
  GFILL X+2,Y2-2-B,X2-2,Y2-2,RGB(192,192,192)
 ENDIF
 TITLE_BORDER_C=RGB(192,192,192)

 INC X,BORDER_W1
 DEC X2,BORDER_W2
 INC Y,BORDER_H1
 DEC Y2,BORDER_H2
 VAR FONT_H=12
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GFILL X,Y,X2,Y+TITLE_H-1,TITLE_BACK_C
  GDEBUG_DRAW_BUTTON_EDGE X2-17,Y+2,16,14
  GPUTCHR_FONT GDEBUG_SYS_FONT,X+2,Y+((TITLE_H-TITLE_BORDER_H)-FONT_H) DIV 2-1,#FALSE,TITLE$,TITLE_FORE_C
  GLINE X,Y+TITLE_H-1,X2,Y+TITLE_H-1,TITLE_BORDER_C
  GDEBUG_DRAW_DISABLED_CLOSE_BUTTON X2-13,Y+5
 ENDIF
 INC Y,TITLE_H
 IF GWIN_MENU[GW] THEN
  VAR MENU_H=19
  GWIN_DRAW_MENU GW,EVENT,X,Y,X2-X+1,MENU_H,GWIN_MENU[GW]
  INC Y,MENU_H
 ENDIF
 CX=X
 CY=Y
 CW=X2-X+1
 CH=Y2-Y+1
END
DEF GWIN_DRAW_MENU GW,EVENT,X,Y,W,H,MENU
 VAR X2=X+W-1
 VAR Y2=Y+H-1
 VAR MENU_BACK_C=RGB(192,192,192)
 VAR MENU_FORE_C=RGB(0,0,0)
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GFILL X,Y,X2,Y2,MENU_BACK_C
 ENDIF
 VAR MX=GWIN_GET_MOUSE_NCX(GW),MY=GWIN_GET_MOUSE_NCY(GW)
 VAR MENUI=GMENU_CHILD[MENU]
 VAR SEL
 WHILE MENUI
  VAR FW
  VAR SX=X+5
  VAR SY=Y+1
  IF GMENU_OLD_SEL[MENU]==MENUI THEN
'   INC SX,1
'   INC SY,1
  ENDIF
  IF EVENT==#GWIN_EVENT_PAINT THEN
   FW=GPUTCHR_FONT_W(GDEBUG_SYS_FONT,SX,SY,#FALSE,GMENUI_NAME$[MENUI],MENU_FORE_C)+12
   IF GMENU_OLD_SEL[MENU]==MENUI THEN
    VAR C1=RGB(128,128,128)
    VAR C2=RGB(255,255,255)
    GLINE X,Y,X+FW-2,Y,C2
    GLINE X,Y,X,Y2-2,C2
    GLINE X,Y2-1,X+FW-1,Y2-1,C1
    GLINE X+FW-1,Y,X+FW-1,Y2-1,C1
   ENDIF
  ELSE
   FW=FONT_CALC_WIDTH(GDEBUG_SYS_FONT,GMENUI_NAME$[MENUI])+12
  ENDIF
  IF X<=MX&&X+FW>MX&&Y<=MY&&Y+H>MY THEN
   SEL=#TRUE
   IF EVENT!=#GWIN_EVENT_PAINT THEN
    IF GMENU_OLD_SEL[MENU]!=MENUI THEN
     GMENU_OLD_SEL[MENU]=MENUI
     GWIN_PAINT GW,#TRUE
     RETURN
    ENDIF
   ENDIF
  ENDIF
  INC X,FW
  MENUI=GMENUI_NEXT[MENUI]
 WEND
 IF EVENT!=#GWIN_EVENT_PAINT THEN
  IF !SEL&&GMENU_OLD_SEL[MENU] THEN
   GMENU_OLD_SEL[MENU]=0
   GWIN_PAINT GW,#TRUE
   RETURN
  ENDIF
 ENDIF
END
DEF GDEBUG_DRAW_DISABLED_CLOSE_BUTTON X,Y
 IF TYPEOF(GDEBUG_DISABLED_CLOSE_BUTTON)==#T_DEFAULT THEN
  VAR GRAY=RGB(128,128,128)
  VAR WHITE=RGB(255,255,255)
  DIM BMP%[]=[\
  GRAY, GRAY,    0,    0,    0,    0, GRAY, GRAY,    0,\
     0, GRAY, GRAY,    0,    0, GRAY, GRAY,WHITE,WHITE,\
     0,    0, GRAY, GRAY, GRAY, GRAY,WHITE,WHITE,    0,\
     0,    0,    0, GRAY, GRAY,WHITE,WHITE,    0,    0,\
     0,    0, GRAY, GRAY, GRAY, GRAY,    0,    0,    0,\
     0, GRAY, GRAY,WHITE,WHITE, GRAY, GRAY,    0,    0,\
  GRAY, GRAY,WHITE,WHITE,    0,    0, GRAY, GRAY,    0,\
     0,WHITE,WHITE,    0,    0,    0,    0,WHITE,WHITE]
  GDEBUG_DISABLED_CLOSE_BUTTON=BMP%
 ENDIF
 GLOAD X,Y,9,8,GDEBUG_DISABLED_CLOSE_BUTTON,#G_NORMAL2
END
DEF GDEBUG_DRAW_BUTTON_EDGE X,Y,W,H
 VAR X2=X+W-1
 VAR Y2=Y+H-1
 GFILL X+1,Y+1,X2-2,Y2-2,RGB(192,192,192)
 GLINE X,Y,X2-1,Y,RGB(255,255,255)
 GLINE X,Y,X,Y2-1,RGB(255,255,255)
 GLINE X2,Y,X2,Y2,RGB(0,0,0)
 GLINE X,Y2,X2,Y2,RGB(0,0,0)
 GLINE X+1,Y2-1,X2-1,Y2-1,RGB(128,128,128)
 GLINE X2-1,Y+1,X2-1,Y2-1,RGB(128,128,128)
END
DEF GDEBUG_DRAW_TAB X,Y,W,H,DRAW_LEFT,DRAW_RIGHT,REVERSED
 VAR X2=X+W-1
 VAR Y2=Y+H-1
 IF DRAW_LEFT THEN
  IF REVERSED THEN
   GPSET X+1,Y2-1,RGB(255,255,255)
   GLINE X,Y2-2,X,Y,RGB(255,255,255)
   GLINE X+1,Y2-2,X+1,Y,RGB(223,223,223)
  ELSE
   GPSET X+1,Y+1,RGB(255,255,255)
   GLINE X,Y+2,X,Y2,RGB(255,255,255)
   GLINE X+1,Y+2,X+1,Y2,RGB(223,223,223)
  ENDIF
 ENDIF
 IF REVERSED THEN
  GLINE X+2,Y2,X2-2,Y2,RGB(0,0,0)
  GLINE X+2,Y2-1,X2-2,Y2-1,RGB(128,128,128)
  GLINE X+2,Y2-1,X2-2,Y2-1,RGB(223,223,223)
 ELSE
  GLINE X+2,Y,X2-2,Y,RGB(255,255,255)
  GLINE X+2,Y+1,X2-2,Y+1,RGB(223,223,223)
 ENDIF
 IF DRAW_RIGHT THEN
  IF REVERSED THEN
   GPSET X2-1,Y2-1,RGB(0,0,0)
   GLINE X2,Y2-2,X2,Y,RGB(0,0,0)
   GLINE X2-1,Y2-2,X2-1,Y,RGB(128,128,128)
  ELSE
   GPSET X2-1,Y+1,RGB(0,0,0)
   GLINE X2,Y+2,X2,Y2,RGB(0,0,0)
   GLINE X2-1,Y+2,X2-1,Y2,RGB(128,128,128)
  ENDIF
 ENDIF
 VAR FX1=X+2,FX2=X2-2
 IF !DRAW_LEFT THEN
  FX1=X+2
 ENDIF
 IF !DRAW_RIGHT THEN
  FX2=X2-3
 ENDIF
 IF REVERSED THEN
  GFILL FX1,Y2-2,FX2,Y,RGB(192,192,192)
 ELSE
  GFILL FX1,Y+3,FX2,Y2,RGB(192,192,192)
 ENDIF
END
DEF GDEBUG_DRAW_TABS GW,EVENT,X,Y,W,H,TABS$[],SEL_TAB,REVERSED,TABS_COL[] OUT SEL_TAB_UPD
 VAR X2=X+W-1
 VAR Y2=Y+H-1
 VAR DRW_EDGE=0
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GFILL X,Y,X2,Y2,RGB(192,192,192)
  IF DRW_EDGE&&REVERSED THEN
   GLINE X,Y,X2,Y,RGB(128,128,128)
   GLINE X,Y+1,X2,Y+1,RGB(0,0,0)
  ELSEIF DRW_EDGE THEN
   GLINE X,Y2,X2,Y2,RGB(223,223,223)
   GLINE X,Y2-1,X2,Y2-1,RGB(255,255,255)
  ENDIF
 ENDIF
 VAR TABW
 VAR I
 VAR ADD_Y=2
 IF REVERSED THEN ADD_Y=0
 VAR MX=GWIN_GET_MOUSE_X(GW)
 VAR MY=GWIN_GET_MOUSE_Y(GW)
 FOR I=0 TO LAST(TABS$)
  VAR TABX=X
  TABW=FONT_CALC_WIDTH(GDEBUG_SYS_FONT,TABS$[I])+5
  VAR TABX2=X+TABW
  VAR TABY=Y
  VAR TABH=H
  VAR DRWL=#TRUE
  VAR DRWR=#TRUE
  IF SEL_TAB==I THEN
   IF REVERSED THEN
    TABY=Y-1
    TABH=TABH+1
   ENDIF
   TABW=TABW+2
  ELSEIF SEL_TAB==I-1 THEN
   TABY=Y+ADD_Y
   TABW=TABW+2
   TABH=H-1-2*DRW_EDGE
   DRWL=#FALSE
   IF REVERSED&&DRW_EDGE THEN TABY=TABY+2
  ELSEIF SEL_TAB==I+1 THEN
   TABX=X+2
   TABY=Y+ADD_Y
   TABH=H-1-2*DRW_EDGE
   DRWR=#FALSE
   IF REVERSED&&DRW_EDGE THEN TABY=TABY+2
  ELSE
   TABX=X+2
   TABY=Y+ADD_Y
   TABH=H-1-2*DRW_EDGE
   IF REVERSED&&DRW_EDGE THEN TABY=TABY+2
  ENDIF
  IF EVENT==#GWIN_EVENT_PAINT THEN
   GDEBUG_DRAW_TAB TABX,TABY,TABW,TABH,DRWL,DRWR,REVERSED
   IF SEL_TAB==I&&REVERSED THEN
    GLINE TABX+2,Y-1,TABX+TABW-3,Y-1,RGB(192,192,192)
   ENDIF
   IF TYPEOF(TABS_COL) THEN
    VAR C=TABS_COL[I]
   ELSE
    C=RGB(0,0,0)
   ENDIF
   IF SEL_TAB==I THEN
    IF REVERSED THEN
     GPUTCHR_FONT GDEBUG_SYS_FONT,X+4,Y2-15,#FALSE,TABS$[I],C
    ELSE
     GPUTCHR_FONT GDEBUG_SYS_FONT,X+4,Y2-16,#FALSE,TABS$[I],C
    ENDIF
   ELSE
    IF REVERSED THEN
     GPUTCHR_FONT GDEBUG_SYS_FONT,X+4,Y2-16,#FALSE,TABS$[I],C
    ELSE
     GPUTCHR_FONT GDEBUG_SYS_FONT,X+4,Y2-14,#FALSE,TABS$[I],C
    ENDIF
   ENDIF
  ELSEIF EVENT==#GWIN_EVENT_LDWN THEN
   IF MX>=TABX&&MX<TABX+TABW&&MY>=TABY&&MY<TABY+TABH THEN
    SEL_TAB_UPD=I
    BREAK
   ENDIF
  ENDIF
  X=TABX2
 NEXT
END
DEF GDEBUG_DRAW_SUNKEN_EDGE EVENT,X,Y,W,H OUT X_OUT,Y_OUT,W_OUT,H_OUT
 VAR X2=X+W-1
 VAR Y2=Y+H-1
 X_OUT=X+2
 Y_OUT=Y+2
 W_OUT=W-4
 H_OUT=H-4
 IF EVENT!=#GWIN_EVENT_PAINT THEN RETURN
 GLINE X,Y,X2-1,Y,RGB(128,128,128)
 GLINE X,Y,X,Y2-1,RGB(128,128,128)
 GLINE X+1,Y+1,X2-2,Y+1,RGB(0,0,0)
 GLINE X+1,Y+1,X+1,Y2-2,RGB(0,0,0)
 GLINE X+1,Y2-1,X2-1,Y2-1,RGB(192,192,192)
 GLINE X2-1,Y+1,X2-1,Y2-1,RGB(192,192,192)
 GLINE X,Y2,X2,Y2,RGB(255,255,255)
 GLINE X2,Y,X2,Y2,RGB(255,255,255)
END
DEF GCLIP_SAFE X1,Y1,X2,Y2
 GCLIP MAX(0,X1),MAX(0,Y1),MAX(0,X2),MAX(0,Y2)
END
'FIXME:GLOBAL
VAR GDEBUG_PRG_SLOT
VAR GDEBUG_PRG_SLOT_MAX_W
DEF GDEBUG_DRAW_PRG GW,EVENT,SLOT,LINE,X,Y,W,H OUT LLINE
 VAR FH=16
 VAR TABH=20
 DIM TABS$[]=["SLOT0","SLOT1","SLOT2","SLOT3"]
 DIM TABS_COL%[4]
 VAR I
 FOR I=0TO 3
  IF VM_IS_SLOT_COMPILED(I)THEN
   TABS_COL%[I]=RGB(0,0,0)
  ELSE
   TABS_COL%[I]=RGB(128,128,128)
  ENDIF
 NEXT
 VAR VSLOT,VLINE,VLINE_POS
 VAR VPC
 VMDBG_FIND_FRAME GDEBUG_CURRENT_FRAME OUT ,,VSLOT,VPC
 VMDBG_GET_LINE VSLOT,VPC OUT VLINE,VLINE_POS
 VLINE=MAX(VLINE,1)
 VAR SCRBAR_GW=GWIN_FIND(GW,"SCRBAR")
 VAR SCRBAR_H_GW=GWIN_FIND(GW,"SCRBAR_H")
 VAR GDEBUG_PRG_SLOT_SEL
 VAR SCROLL_REQUESTED=GWIN_GET_VAR(GW,#GDEBUG_PRG_V_REQ_SCROLL)
 IF SCROLL_REQUESTED THEN
  GDEBUG_PRG_SLOT=VSLOT
 ENDIF
 GDEBUG_DRAW_TABS GW,EVENT,X,Y,W,TABH,TABS$,GDEBUG_PRG_SLOT,#FALSE,TABS_COL% OUT GDEBUG_PRG_SLOT_SEL
 IF TYPEOF(GDEBUG_PRG_SLOT_SEL) THEN
  GDEBUG_PRG_SLOT=GDEBUG_PRG_SLOT_SEL
  GWIN_PAINT GW,#FALSE
 ENDIF
 SLOT=GDEBUG_PRG_SLOT
 INC Y,TABH
 DEC H,TABH
 GDEBUG_DRAW_SUNKEN_EDGE EVENT,X,Y,W,H OUT X,Y,W,H
 VAR X2=X+W-1
 VAR SCRBAR_W=16
 DEC H,SCRBAR_W
 VAR Y2=Y+H-1
 VAR BACK_COLOR=RGB(0,0,0)
 VAR FONT_TYPE=16,FONT_SCALE_X=1,FONT_SCALE_Y=1
 VAR FS=FONT_TYPE*FONT_SCALE_Y
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GCLIP X,Y,X2,Y2
  GFILL X,Y,X2,Y2,BACK_COLOR
 ENDIF
 VAR OFF_Y=0
 VAR SLOT_LINE_COUNT=MAX(1,VSLOT_PRGSIZE(SLOT,0))
 VAR CUR_RUN_LOC_COLOR=RGB(128,128,0)
 VAR CUR_RUN_LOC_COLOR2=RGB(64,64,0)
 VAR BP_COLOR=RGB(128,0,0)
 VAR LINES=H DIV (FONT_TYPE*FONT_SCALE_Y)
 VAR END_LINE=LINE+LINES
 VAR SCRBAR_POS,SCRBAR_H_POS
 GWIN_SCR_GET SCRBAR_GW OUT ,,SCRBAR_POS
 LINE=SCRBAR_POS DIV FS+1
 IF SCROLL_REQUESTED THEN
  GWIN_SET_VAR GW,#GDEBUG_PRG_V_REQ_SCROLL,#FALSE
  IF LINE>VLINE THEN
   LINE=VLINE-LINES DIV 2
  ELSEIF END_LINE<VLINE THEN
   LINE=VLINE-LINES DIV 2
  ENDIF
  GWIN_SCR_SET SCRBAR_GW,,,(LINE-1)*FS
  GWIN_SCR_GET SCRBAR_GW OUT ,,SCRBAR_POS
  LINE=SCRBAR_POS DIV FS+1
 ENDIF
 OFF_Y=SCRBAR_POS MOD FS
 GWIN_SCR_GET SCRBAR_H_GW OUT ,,SCRBAR_H_POS
 VSLOT_SEEKLINE SLOT,LINE
 LLINE=LINE
 VAR SX=X
 VAR SY=Y
 VAR PC
 Y=Y-OFF_Y
 DEC X,SCRBAR_H_POS
 LOOP
  IF Y>=Y2 THEN BREAK
  VAR L$=VSLOT_PRGGET_SLOT$(SLOT,#TRUE)
  IF!LEN(L$)THEN BREAK
  VAR LS$=DEBUG_GETLINESTR$(LINE)
  VAR TX=X+LEN(LS$)*FONT_TYPE*FONT_SCALE_X
  IF EVENT!=#GWIN_EVENT_PAINT THEN
   IF EVENT==#GWIN_EVENT_LDWN THEN
    VAR MX=GWIN_GET_MOUSE_X(GW)
    VAR MY=GWIN_GET_MOUSE_Y(GW)
    IF Y<=MY&&Y+FONT_TYPE*FONT_SCALE_Y>MY THEN
     IF X<=MX&&TX>MX THEN
      VMDBG_GET_PC_LIST SLOT,LINE OUT PC
      VMDBG_TOGGLE_BP_LIST SLOT,PC
      GWIN_PAINT GW,#FALSE
     ENDIF
    ENDIF
   ENDIF
   GOTO @CONTINUE
  ENDIF
  VMDBG_GET_PC SLOT,LINE OUT PC
  VAR HAS_BP=VMDBG_HAS_BP(SLOT,PC)
  VAR TCOL=RGB(255,255,255)
  GCLIP SX,SY,X2,Y2
  IF HAS_BP THEN
   GFILL SX,Y,X2,Y+FONT_TYPE*FONT_SCALE_Y-1,BP_COLOR
  ENDIF
  IF VSLOT==SLOT&&VLINE==LINE THEN
   VAR DBG_LINE,DBG_LINE_POS,DBG_LINE_END,DBG_LINE_POS_END
   VMDBG_GET_LINE2 SLOT,VPC OUT DBG_LINE,DBG_LINE_POS,DBG_LINE_END,DBG_LINE_POS_END
   GFILL SX,Y,X2,Y+FONT_TYPE*FONT_SCALE_Y-1,CUR_RUN_LOC_COLOR
   GCLIP_SAFE X+SCRBAR_H_POS+LEN(LS$)*FONT_TYPE*FONT_SCALE_X,SY,X2,Y2
   GFILL TX+(DBG_LINE_POS-1)*FONT_TYPE*FONT_SCALE_X,Y,TX+(DBG_LINE_POS_END-1)*FONT_TYPE*FONT_SCALE_X,Y+FONT_TYPE*FONT_SCALE_Y-1,CUR_RUN_LOC_COLOR2
   TCOL=RGB(255,255,0)
   GCLIP SX,SY,X2,Y2
  ENDIF
  IF HAS_BP THEN
   GBOX SX,Y,X2,Y+FONT_TYPE*FONT_SCALE_Y-1,BP_COLOR
   TCOL=RGB(255,0,0)
  ENDIF
  GPUTCHR X+SCRBAR_H_POS,Y,LS$,FONT_TYPE,FONT_SCALE_X,FONT_SCALE_Y,TCOL,#G_ALPHA2
  GCLIP_SAFE X+SCRBAR_H_POS+LEN(LS$)*FONT_TYPE*FONT_SCALE_X,SY,X2,Y2
'  TXTED_PRGPRINT TX,Y,L$,(X2-(X+SCRBAR_H_POS+LEN(LS$)*FONT_TYPE*FONT_SCALE_X)) DIV (FONT_TYPE*FONT_SCALE_X),FONT_TYPE
  TXTED_PRGPRINT TX,Y,L$,1000,FONT_TYPE
  GDEBUG_PRG_SLOT_MAX_W=MAX(GDEBUG_PRG_SLOT_MAX_W,(LEN(L$)+1)*FONT_TYPE*FONT_SCALE_X)
  @CONTINUE
  INC Y,FONT_TYPE*FONT_SCALE_Y
  INC LINE
 ENDLOOP
 SCRBAR_POS=(LLINE-1)*FONT_TYPE*FONT_SCALE_Y
 VAR PAGE_SIZE=H
 IF SCRBAR_GW THEN
  GWIN_SCR_SET SCRBAR_GW,PAGE_SIZE,SLOT_LINE_COUNT*FS,
  GWIN_MOVERESIZE SCRBAR_GW,SX+W-1-SCRBAR_W+1-GWIN_GET_CX(GW),SY-GWIN_GET_CY(GW),SCRBAR_W,H
  GWIN_SCR_SET SCRBAR_H_GW,W-LEN(LS$)*FONT_TYPE*FONT_SCALE_X,GDEBUG_PRG_SLOT_MAX_W,
  GWIN_MOVERESIZE SCRBAR_H_GW,SX-GWIN_GET_CX(GW),SY-GWIN_GET_CY(GW)+H,W-SCRBAR_W,SCRBAR_W
 ENDIF
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GCLIP SX,SY,SX+W-1,SY+H-1
  LOOP
   IF Y>=Y2 THEN BREAK
   LS$=""
   GPUTCHR X+SCRBAR_H_POS,Y,LS$,FONT_TYPE,FONT_SCALE_X,FONT_SCALE_Y,RGB(255,255,255),#G_ALPHA2
   INC Y,FONT_TYPE*FONT_SCALE_Y
  ENDLOOP
  GCLIP
  GFILL SX+W-1-SCRBAR_W+1,SY+H,SX+W-1,SY+H-1+SCRBAR_W,RGB(192,192,192)
 ENDIF
END
DEF GWIN_DRAW_BUTTON2 X1,Y1,W,H,STATE
 VAR BTNX2=X1+W-1
 VAR BTNY2=Y1+H-1
 IF STATE==#GWIN_DRAW_BUTTON_ETCHED THEN
  GBOX X1,Y1,BTNX2,BTNY2,RGB(128,128,128)
  GFILL X1+1,Y1+1,BTNX2-1,BTNY2-1,RGB(192,192,192)
  RETURN
 ENDIF
 VAR C5=RGB(192,192,192)
 IF STATE==#GWIN_DRAW_BUTTON_RAIS THEN
  VAR C1=RGB(223,223,223)
  VAR C2=RGB(0,0,0)
  VAR C3=RGB(128,128,128)
  VAR C4=RGB(255,255,255)
 ELSEIF STATE==#GWIN_DRAW_BUTTON_SUNK THEN
  C4=RGB(0,0,0)
  C2=RGB(255,255,255)
  C1=RGB(128,128,128)
  C3=RGB(223,223,223)
 ELSEIF STATE==#GWIN_DRAW_BUTTON_RAISED THEN
  C1=RGB(255,255,255)
  C2=RGB(0,0,0)
  C3=RGB(128,128,128)
  C4=RGB(223,223,223)
 ELSEIF  STATE==#GWIN_DRAW_BUTTON_SUNKEN THEN
  C1=RGB(0,0,0)
  C2=RGB(255,255,255)
  C3=RGB(192,192,192)
  C4=RGB(128,128,128)
 ENDIF
 GFILL X1+2,Y1+2,BTNX2-2,BTNY2-2,C1
 GBOX X1,Y1,BTNX2,BTNY2,C2
 GBOX X1,Y1,BTNX2-1,BTNY2-1,C1
 GBOX X1+1,Y1+1,BTNX2-1,BTNY2-1,C3
 GBOX X1+1,Y1+1,BTNX2-2,BTNY2-2,C4
 GFILL X1+2,Y1+2,BTNX2-2,BTNY2-2,C5
END
VAR GDEBUG_SCRBAR_PAT_W
VAR GDEBUG_SCRBAR_PAT_H
DIM GDEBUG_SCRBAR_PAT[]
DIM GDEBUG_SCRBAR_PAT2[]
DEF GDEBUG_DRAW_SCRBAR GW,EVENT,X1,Y1,W,H
 VAR X2=X1+W-1
 VAR Y2=Y1+H-1
 VAR PAGE,SIZE,POS
 GWIN_GET_VAR GW,#GWIN_SCR_V_PAGE OUT PAGE
 GWIN_GET_VAR GW,#GWIN_SCR_V_SIZE OUT SIZE
 GWIN_GET_VAR GW,#GWIN_SCR_V_POS OUT POS
 VAR C_GW,C_FRAME,C_X,C_Y
 GWIN_GET_CAPTURE OUT C_GW,C_FRAME,C_X,C_Y
 IF EVENT==#GWIN_EVENT_MMOVE THEN
  IF C_GW!=GW THEN
   RETURN
  ENDIF
 ENDIF
 IF TYPEOF(GDEBUG_SCRBAR_PAT)==#T_DEFAULT THEN
  GDEBUG_SCRBAR_PAT_H=64
  GDEBUG_SCRBAR_PAT_W=16
  GDEBUG_SCRBAR_PAT=ARRAY%(GDEBUG_SCRBAR_PAT_H,GDEBUG_SCRBAR_PAT_W)
  GDEBUG_SCRBAR_PAT2=ARRAY%(GDEBUG_SCRBAR_PAT_W,GDEBUG_SCRBAR_PAT_H)
  VAR I
  FOR I=0TO GDEBUG_SCRBAR_PAT_W-2 STEP 2
   GDEBUG_SCRBAR_PAT[0,I]=RGB(192,192,192)
   GDEBUG_SCRBAR_PAT[0,I+1]=RGB(255,255,255)
   GDEBUG_SCRBAR_PAT[1,I]=RGB(255,255,255)
   GDEBUG_SCRBAR_PAT[1,I+1]=RGB(192,192,192)
  NEXT
  FOR I=0TO GDEBUG_SCRBAR_PAT_H-2 STEP 2
   GDEBUG_SCRBAR_PAT2[0,I]=RGB(192,192,192)
   GDEBUG_SCRBAR_PAT2[0,I+1]=RGB(255,255,255)
   GDEBUG_SCRBAR_PAT2[1,I]=RGB(255,255,255)
   GDEBUG_SCRBAR_PAT2[1,I+1]=RGB(192,192,192)
  NEXT
  FOR I=2TO GDEBUG_SCRBAR_PAT_H-2 STEP 2
   COPY GDEBUG_SCRBAR_PAT,I*GDEBUG_SCRBAR_PAT_W,GDEBUG_SCRBAR_PAT,0,GDEBUG_SCRBAR_PAT_W*2
  NEXT
  FOR I=2TO GDEBUG_SCRBAR_PAT_W-2 STEP 2
   COPY GDEBUG_SCRBAR_PAT2,I*GDEBUG_SCRBAR_PAT_H,GDEBUG_SCRBAR_PAT2,0,GDEBUG_SCRBAR_PAT_H*2
  NEXT
 ENDIF
 VAR BUTTON_H=16
 VAR HORIZ=#FALSE
 VAR AREA=H-BUTTON_H*2
 IF H<W THEN
  HORIZ=#TRUE
  AREA=W-BUTTON_H*2
 ENDIF
 VAR BTN2Y=Y2-15
 VAR BTN2X=X2-15
 VAR STATE=GWIN_GET_VAR(GW,#GWIN_SCR_V_STATE)

 VAR BTN1_X,BTN2_X,BTN1_Y,BTN2_Y
 BTN1_X=X1
 BTN1_Y=Y1
 VAR BTN1_W=BUTTON_H
 VAR BTN1_H=BUTTON_H
 IF HORIZ THEN
  BTN2_X=X2-BUTTON_H+1
  BTN2_Y=Y1
 ELSE
  BTN2_X=X1
  BTN2_Y=Y2-BUTTON_H+1
 ENDIF
 VAR BTN2_W=BUTTON_H
 VAR BTN2_H=BUTTON_H
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GCLIP X1,Y1,X2,Y2
  IF HORIZ THEN
   FOR I=X1+16 TO X2-16 STEP GDEBUG_SCRBAR_PAT_H
    GLOAD I,Y1,GDEBUG_SCRBAR_PAT_H,GDEBUG_SCRBAR_PAT_W,GDEBUG_SCRBAR_PAT2,#G_NORMAL
   NEXT
  ELSE
   FOR I=Y1+16 TO Y2-16 STEP GDEBUG_SCRBAR_PAT_H-1
    GLOAD X1,I,GDEBUG_SCRBAR_PAT_W,MIN(GDEBUG_SCRBAR_PAT_H,BTN2Y-I),GDEBUG_SCRBAR_PAT,#G_NORMAL
   NEXT
  ENDIF
  GWIN_DRAW_BUTTON2 BTN1_X,BTN1_Y,BTN1_W,BTN1_H,STATE==#GWIN_SCR_STATE_UP
  GWIN_DRAW_BUTTON2 BTN2_X,BTN2_Y,BTN2_W,BTN2_H,STATE==#GWIN_SCR_STATE_DOWN
  IF STATE==#GWIN_SCR_STATE_UP THEN
   INC X1
   INC Y1
  ENDIF
  IF HORIZ THEN
   GPSET X1+5,Y1+7,#C_BLACK
   GLINE X1+6,Y1+6,X1+6,Y1+8,#C_BLACK
   GLINE X1+7,Y1+5,X1+7,Y1+9,#C_BLACK
   GLINE X1+8,Y1+4,X1+8,Y1+10,#C_BLACK
  ELSE
   GPSET X1+7,Y1+6,#C_BLACK
   GLINE X1+6,Y1+7,X1+8,Y1+7,#C_BLACK
   GLINE X1+5,Y1+8,X1+9,Y1+8,#C_BLACK
   GLINE X1+4,Y1+9,X1+10,Y1+9,#C_BLACK
  ENDIF
  IF STATE==#GWIN_SCR_STATE_UP THEN
   DEC X1
   DEC Y1
  ENDIF
  IF STATE==#GWIN_SCR_STATE_DOWN THEN
   INC X1
   INC BTN2Y
   INC BTN2X
   INC Y1
  ENDIF
  IF HORIZ THEN
   GPSET BTN2X+9,Y1+7,#C_BLACK
   GLINE BTN2X+8,Y1+6,BTN2X+8,Y1+8,#C_BLACK
   GLINE BTN2X+7,Y1+5,BTN2X+7,Y1+9,#C_BLACK
   GLINE BTN2X+6,Y1+4,BTN2X+6,Y1+10,#C_BLACK
  ELSE
   GPSET X1+7,BTN2Y+9,#C_BLACK
   GLINE X1+6,BTN2Y+8,X1+8,BTN2Y+8,#C_BLACK
   GLINE X1+5,BTN2Y+7,X1+9,BTN2Y+7,#C_BLACK
   GLINE X1+4,BTN2Y+6,X1+10,BTN2Y+6,#C_BLACK
  ENDIF
  IF STATE==#GWIN_SCR_STATE_DOWN THEN
   DEC X1
   DEC BTN2Y
   DEC BTN2X
   DEC Y1
  ENDIF
 ENDIF
 VAR MX=GWIN_GET_MOUSE_X(GW)
 VAR MY=GWIN_GET_MOUSE_Y(GW)
 IF EVENT==#GWIN_EVENT_LDWN THEN
  IF MX>=BTN1_X&&MX<BTN1_X+BTN1_W&&MY>=BTN1_Y&&MY<BTN1_Y+BTN1_H THEN
   GWIN_SET_VAR GW,#GWIN_SCR_V_STATE,#GWIN_SCR_STATE_UP
   'メインループマワすとかキタナいけど カンイテキなのでこれでいいコトにする(アトでシにそうだけどキにしない)
   VAR DIFF=1
   VAR FIRST=#TRUE
   WHILE GWIN_MOUSE_L_CLK()
    VAR OM=MAINCNT()
    VAR OP=POS
    DEC POS,DIFF
    POS=MAX(0,MIN(POS,SIZE-PAGE+1))
    GWIN_SET_VAR GW,#GWIN_SCR_V_POS,POS
    GWIN_PAINT GW,#FALSE
    GWIN_MAIN_LOOP
    VSYNC
    DIFF=(MAINCNT()-OM)*4
    IF FIRST THEN
     FOR I=0TO 20
      GWIN_MAIN_LOOP
      IF !GWIN_MOUSE_L_CLK() THEN BREAK
      VSYNC
     NEXT
     FIRST=#FALSE
    ENDIF
   WEND
   GWIN_SET_VAR GW,#GWIN_SCR_V_STATE,#GWIN_SCR_STATE_NONE
   GWIN_PAINT GW,#FALSE
   RETURN
  ELSEIF MX>=BTN2_X&&MX<BTN2_X+BTN2_W&&MY>=BTN2_Y&&MY<BTN2_Y+BTN2_H THEN
   GWIN_SET_VAR GW,#GWIN_SCR_V_STATE,#GWIN_SCR_STATE_DOWN
   DIFF=1
   FIRST=#TRUE
   WHILE GWIN_MOUSE_L_CLK()
    OM=MAINCNT()
    OP=POS
    INC POS,DIFF
    POS=MAX(0,MIN(POS,SIZE-PAGE+1))
    GWIN_SET_VAR GW,#GWIN_SCR_V_POS,POS
    GWIN_PAINT GW,#FALSE
    GWIN_MAIN_LOOP
    VSYNC
    DIFF=(MAINCNT()-OM)*4
    IF FIRST THEN
     FOR I=0TO 20
      GWIN_MAIN_LOOP
      IF !GWIN_MOUSE_L_CLK() THEN BREAK
      VSYNC
     NEXT
     FIRST=#FALSE
    ENDIF
   WEND
   GWIN_SET_VAR GW,#GWIN_SCR_V_STATE,#GWIN_SCR_STATE_NONE
   GWIN_PAINT GW,#FALSE
   RETURN
  ENDIF
 ENDIF
 IF SIZE THEN
  VAR THUMB_SIZE=AREA*PAGE DIV SIZE
  VAR MIN_THUMB_SIZE=16
  THUMB_SIZE=MAX(MIN_THUMB_SIZE,THUMB_SIZE)
  VAR AREA2=AREA-THUMB_SIZE
  VAR MAX=SIZE-MAX(PAGE-1,0)
  VAR THUMB_POS
  IF 0>=MAX THEN
   THUMB_POS=0
   THUMB_SIZE=AREA
  ELSE
   IF STATE==#GWIN_SCR_STATE_THUMB&&C_GW!=GW THEN
    GWIN_SET_VAR GW,#GWIN_SCR_V_STATE,#GWIN_SCR_STATE_NONE
    STATE=#GWIN_SCR_STATE_NONE
   ENDIF
   IF STATE==#GWIN_SCR_STATE_THUMB THEN
    IF HORIZ THEN
     THUMB_POS=MX-C_X-X1+GWIN_GET_VAR(GW,#GWIN_SCR_STATE_THUMB_OLD)
    ELSE
     THUMB_POS=MY-C_Y-Y1+GWIN_GET_VAR(GW,#GWIN_SCR_STATE_THUMB_OLD)
    ENDIF
    POS=MAX*THUMB_POS DIV AREA2
    THUMB_POS=AREA2*POS DIV MAX
   ENDIF
   POS=MIN(MAX(0,POS),SIZE-PAGE+1)
   GWIN_SET_VAR GW,#GWIN_SCR_V_POS,POS
   THUMB_POS=AREA2*POS DIV MAX
  ENDIF
  VAR THUMB_X,THUMB_W,THUMB_Y,THUMB_H
  IF HORIZ THEN
   THUMB_X=X1+BUTTON_H+THUMB_POS
   THUMB_Y=Y1
   THUMB_W=THUMB_SIZE
   THUMB_H=16
  ELSE
   THUMB_X=X1
   THUMB_Y=Y1+BUTTON_H+THUMB_POS
   THUMB_W=16
   THUMB_H=THUMB_SIZE
  ENDIF
  IF EVENT==#GWIN_EVENT_PAINT THEN
   GWIN_DRAW_BUTTON2 THUMB_X,THUMB_Y,THUMB_W,THUMB_H,#FALSE
  ELSEIF EVENT==#GWIN_EVENT_LDWN THEN
   IF MX>=THUMB_X&&MX<THUMB_X+THUMB_W&&MY>=THUMB_Y&&MY<THUMB_Y+THUMB_H THEN
    GWIN_SET_VAR GW,#GWIN_SCR_V_STATE,#GWIN_SCR_STATE_THUMB
    GWIN_SET_VAR GW,#GWIN_SCR_STATE_THUMB_OLD,THUMB_POS
    GWIN_SET_CAPTURE GW,#FALSE
   ENDIF
  ENDIF
 ENDIF
 IF EVENT==#GWIN_EVENT_MMOVE THEN
  GWIN_PAINT GW,#FALSE
 ENDIF
END
DEF GDEBUG_SELECT_FRAME I
 GDEBUG_CURRENT_FRAME=I
 GDEBUG_UPDATE_WINDOW #GDEBUG_UPDATE_BACKTRACE OR #GDEBUG_UPDATE_VAR OR #GDEBUG_UPDATE_SRC
END
DEF GDEBUG_DRAW_BACKTRACE GW,EVENT,X,Y,W,H
 VAR FH=16
 VAR SCRBAR_W=16
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GCLIP X,Y,X+W-1,Y+H-1
 ENDIF
 GDEBUG_DRAW_SUNKEN_EDGE EVENT,X,Y,W,H OUT X,Y,W,H
 VAR SY=Y
 VAR SCRBAR_GW=GWIN_FIND(GW,"SCRBAR")
 VAR LIST_H=GDEBUG_SYS_FONT_SIZE+4
 IF SCRBAR_GW THEN
  GWIN_MOVERESIZE SCRBAR_GW,X+W-1-SCRBAR_W+1-GWIN_GET_CX(GW),Y-GWIN_GET_CY(GW),SCRBAR_W,H
  GWIN_SCR_SET SCRBAR_GW,H-LIST_H,,
 ENDIF
 DEC W,SCRBAR_W
 VAR X2=X+W-1
 VAR Y2=Y+H-1
 VAR BACK_COLOR=RGB(0,0,0)
 VAR FONT_TYPE=GDEBUG_SYS_FONT_SIZE,FONT_SCALE_X=1,FONT_SCALE_Y=1
 DIM LIST$[]=["Slot","Line","Name"]
 DIM LIST_W%[]=[40,60,W-40-60]
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GCLIP X,Y,X2,Y2
  GFILL X,Y,X2,Y2,BACK_COLOR
  GDEBUG_DRAW_LIST_HEADER X,Y,W,LIST_H,LIST$,LIST_W%
 ENDIF
 INC Y,LIST_H
 DEC H,LIST_H
 VAR SLOT,LINE,INFO$
 VM_BACKTRACE #FALSE OUT SLOT,LINE,INFO$
 VAR I
 VAR SCRBAR_POS
 GWIN_SCR_GET SCRBAR_GW OUT ,,SCRBAR_POS
 VAR OFF_Y=SCRBAR_POS MOD GDEBUG_SYS_FONT_SIZE
 SY=Y-OFF_Y
 VAR CURRENT_FRAME=GDEBUG_CURRENT_FRAME
 GWIN_SCR_SET SCRBAR_GW,,LEN(SLOT)*GDEBUG_SYS_FONT_SIZE,
 GCLIP X,Y,X+W-1,Y+H-1
 Y=SY
 FOR I=SCRBAR_POS DIV GDEBUG_SYS_FONT_SIZE TO LAST(SLOT)
  IF EVENT==#GWIN_EVENT_PAINT THEN
   IF I==CURRENT_FRAME THEN
    GFILL X,Y,X2,Y+FONT_TYPE*FONT_SCALE_Y,RGB(0,0,128)
   ENDIF
  ELSEIF EVENT==#GWIN_EVENT_LDWN THEN
   IF Y<=GWIN_GET_MOUSE_Y(GW)&&Y+FONT_TYPE*FONT_SCALE_Y>GWIN_GET_MOUSE_Y(GW)THEN
    GDEBUG_SELECT_FRAME I
    GWIN_PAINT GW,#FALSE
   ENDIF
  ENDIF
  INC Y,FONT_TYPE*FONT_SCALE_Y
 NEXT
 Y=SY
 VAR LINE_X=X+LIST_W%[0]
 VAR NAME_X=LINE_X+LIST_W%[1]
 FOR I=SCRBAR_POS DIV GDEBUG_SYS_FONT_SIZE TO LAST(SLOT)
  IF EVENT==#GWIN_EVENT_PAINT THEN
   GPUTCHR_FONT GDEBUG_SYS_FONT,X,Y,#FALSE,STR$(SLOT[I]),RGB(255,255,255)
   GPUTCHR_FONT GDEBUG_SYS_FONT,LINE_X,Y,#FALSE,STR$(LINE[I]),RGB(255,255,255)
   GPUTCHR_FONT GDEBUG_SYS_FONT,NAME_X,Y,#FALSE,INFO$[I],RGB(255,255,255)
  ENDIF
  INC Y,FONT_TYPE*FONT_SCALE_Y
 NEXT
END
DEF GDEBUG_ARRAY$(V)
 VAR I
 VAR R$=""
 PUSH R$,"["
 FOR I=0TO LAST(V)
  IF LEN(R$)>=50 THEN PUSH R$,"…]":RETURN R$
  IF I THEN
   PUSH R$,","
  ENDIF
  CASE TYPEOF(V[I])
  WHEN #T_STR
   PUSH R$,VSLOT_TEST_ESCAPE$(V[I])
  WHEN #T_INT
   PUSH R$,STR$(V[I])
  WHEN #T_REAL
   PUSH R$,STR$(V[I])
  ENDCASE
 NEXT
 PUSH R$,"]"
 RETURN R$
END
DEF GDEBUG_MOUSE_VAR MX,MY,MW,MBTN,X,Y,W,H
END
DEF GDEBUG_DRAW_LIST_HEADER X,Y,W,H,LIST$[],LIST_W[]
 VAR I
 VAR Y2=Y+H-1
 FOR I=0TO LAST(LIST_W)
  VAR X2=X+LIST_W[I]-1
  GLINE X,Y,X,Y2-1,RGB(255,255,255)
  GLINE X,Y,X2-1,Y,RGB(255,255,255)
  GLINE X,Y2,X2,Y2,RGB(0,0,0)
  GLINE X2,Y,X2,Y2,RGB(0,0,0)
  GLINE X+1,Y2-1,X2-1,Y2-1,RGB(128,128,128)
  GLINE X2-1,Y+1,X2-1,Y2-1,RGB(128,128,128)
  GFILL X+1,Y+1,X2-2,Y2-2,RGB(192,192,192)
  GPUTCHR_FONT GDEBUG_SYS_FONT,X+2,Y,#FALSE,LIST$[I],RGB(0,0,0)
  X=X2+1
 NEXT
END
ENUM #GDEBUG_VAR_TAB_LOCALS,#GDEBUG_VAR_TAB_GLOBALS,#GDEBUG_VAR_TAB_SLOT0,#GDEBUG_VAR_TAB_SLOT1,#GDEBUG_VAR_TAB_SLOT2,#GDEBUG_VAR_TAB_SLOT3,#GDEBUG_VAR_TAB_CONSTS,#GDEBUG_VAR_TAB_C0,#GDEBUG_VAR_TAB_C1,#GDEBUG_VAR_TAB_C2,#GDEBUG_VAR_TAB_C3
'FIXME:GLOBAL
VAR GDEBUG_VAR_TAB
DEF GDEBUG_DRAW_VAR GW,EVENT,X,Y,W,H
 VAR FH=16
 VAR TABH=20
 VAR LIST_H=GDEBUG_SYS_FONT_SIZE+4
 VAR SCRBAR_W=16
 GCLIP X,Y,X+W-1,Y+H-1
 VAR TABY=Y+H-TABH
 VAR TABX=X
 VAR TABW=W
 GDEBUG_DRAW_SUNKEN_EDGE EVENT,X,Y,W,H-TABH OUT X,Y,W,H
 VAR SW=W
 INC H,TABH
 VAR SCRBAR_GW=GWIN_FIND(GW,"SCRBAR")
 IF SCRBAR_GW THEN
  GWIN_MOVERESIZE SCRBAR_GW,X+W-1-SCRBAR_W+1-GWIN_GET_CX(GW),Y-GWIN_GET_CY(GW),SCRBAR_W,H-TABH
  GWIN_SCR_SET SCRBAR_GW,H-TABH-LIST_H,,
 ENDIF
 DEC W,SCRBAR_W
 VAR X2=X+W-1
 VAR Y2=Y+H-1-TABH
 GCLIP X,Y,X2,Y2
 VAR BACK_COLOR=RGB(0,0,0)
 VAR FONT_TYPE=GDEBUG_SYS_FONT_SIZE,FONT_SCALE_X=1,FONT_SCALE_Y=1
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GFILL X,Y,X2,Y2,BACK_COLOR
 ENDIF
 VAR VNAME$,VIDX
 VAR CURRENT_FRAME=GDEBUG_CURRENT_FRAME
 VAR BP,FUNC
 CASE GDEBUG_VAR_TAB
 WHEN #GDEBUG_VAR_TAB_LOCALS
  VMDBG_FIND_FRAME CURRENT_FRAME OUT FUNC,BP,,
  VMDBG_GET_VAR_LIST FUNC,BP OUT VNAME$,VIDX
 WHEN #GDEBUG_VAR_TAB_GLOBALS
  VMDBG_GET_VAR_LIST 0,0 OUT VNAME$,VIDX
 WHEN #GDEBUG_VAR_TAB_SLOT0
  VMDBG_GET_SLOT_VAR_LIST 0 OUT VNAME$,VIDX
 WHEN #GDEBUG_VAR_TAB_SLOT1
  VMDBG_GET_SLOT_VAR_LIST 1 OUT VNAME$,VIDX
 WHEN #GDEBUG_VAR_TAB_SLOT2
  VMDBG_GET_SLOT_VAR_LIST 2 OUT VNAME$,VIDX
 WHEN #GDEBUG_VAR_TAB_SLOT3
  VMDBG_GET_SLOT_VAR_LIST 3 OUT VNAME$,VIDX
 WHEN #GDEBUG_VAR_TAB_CONSTS
  VMDBG_GET_SLOT_CONST_LIST VM_GET_SLOT() OUT VNAME$,VIDX
 WHEN #GDEBUG_VAR_TAB_C0
  VMDBG_GET_SLOT_CONST_LIST 0 OUT VNAME$,VIDX
 WHEN #GDEBUG_VAR_TAB_C1
  VMDBG_GET_SLOT_CONST_LIST 1 OUT VNAME$,VIDX
 WHEN #GDEBUG_VAR_TAB_C2
  VMDBG_GET_SLOT_CONST_LIST 2 OUT VNAME$,VIDX
 WHEN #GDEBUG_VAR_TAB_C3
  VMDBG_GET_SLOT_CONST_LIST 3 OUT VNAME$,VIDX
 ENDCASE
 VAR SCRBAR_POS
 IF SCRBAR_GW THEN
  GWIN_SCR_SET SCRBAR_GW,,LEN(VNAME$)*GDEBUG_SYS_FONT_SIZE,
  GWIN_SCR_GET SCRBAR_GW OUT ,,SCRBAR_POS
 ENDIF
 VAR I=SCRBAR_POS DIV GDEBUG_SYS_FONT_SIZE
 VAR OFF_Y=SCRBAR_POS MOD GDEBUG_SYS_FONT_SIZE
 DIM LIST$[]=["Name","Value","Type"]
 DIM LIST_W%[]=[60,W-60-60,60]
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GDEBUG_DRAW_LIST_HEADER X,Y,W,LIST_H,LIST$,LIST_W%
 ENDIF
 VAR VALUE_X=X+LIST_W%[0]
 VAR NAME_X2=VALUE_X-1
 VAR TYPE_X=X+LIST_W%[0]+LIST_W%[1]
 VAR VALUE_X2=TYPE_X-1
 VAR TYPE_X2=X+LIST_W%[0]+LIST_W%[1]+LIST_W%[2]-1
 INC Y,LIST_H
 DEC H,LIST_H
 VAR SY=Y
 Y=Y-OFF_Y
 Y2=SY+H-TABH-1
 FOR I=I TO LAST(VNAME$)
  IF Y>Y2 THEN BREAK
  VAR LS$=VNAME$[I]
  IF EVENT!=#GWIN_EVENT_PAINT THEN
   GOTO@CONTINUE
  ENDIF
  GCLIP X,MIN(MAX(SY,Y),Y2),NAME_X2,Y2
  IF LS$[0]=="#"THEN
   GPUTCHR_FONT GDEBUG_SYS_FONT,X,Y,#FALSE,LS$,RGB(176,208,208)
  ELSE
   GPUTCHR_FONT GDEBUG_SYS_FONT,X,Y,#FALSE,LS$,RGB(255,255,255)
  ENDIF
  VAR V
  CASE GDEBUG_VAR_TAB
  WHEN #GDEBUG_VAR_TAB_LOCALS
  WHEN #GDEBUG_VAR_TAB_GLOBALS
   V=VMDBG_GET_VAR(FUNC,BP,VIDX[I])
  WHEN #GDEBUG_VAR_TAB_SLOT0
   V=VMDBG_GET_SLOT_VAR(0,VIDX[I])
  WHEN #GDEBUG_VAR_TAB_SLOT1
   V=VMDBG_GET_SLOT_VAR(1,VIDX[I])
  WHEN #GDEBUG_VAR_TAB_SLOT2
   V=VMDBG_GET_SLOT_VAR(2,VIDX[I])
  WHEN #GDEBUG_VAR_TAB_SLOT3
   V=VMDBG_GET_SLOT_VAR(3,VIDX[I])
  WHEN #GDEBUG_VAR_TAB_CONSTS
   V=VMDBG_GET_SLOT_CONST(VM_GET_SLOT(),VIDX[I])
  WHEN #GDEBUG_VAR_TAB_C0
   V=VMDBG_GET_SLOT_CONST(0,VIDX[I])
  WHEN #GDEBUG_VAR_TAB_C1
   V=VMDBG_GET_SLOT_CONST(1,VIDX[I])
  WHEN #GDEBUG_VAR_TAB_C2
   V=VMDBG_GET_SLOT_CONST(2,VIDX[I])
  WHEN #GDEBUG_VAR_TAB_C3
   V=VMDBG_GET_SLOT_CONST(3,VIDX[I])
  ENDCASE
  VAR TS$
  VAR TYPE$
  VAR C=RGB(255,255,255)
  CASE TYPEOF(V)
  WHEN #T_DEFAULT
   TS$="EMPTY"
   TYPE$="DEFAULT"
  WHEN #T_REAL
   TS$=STR$(V)
   TYPE$="REAL"
   C=RGB(240,64,144)
  WHEN #T_INT
   TS$=STR$(V)
   TYPE$="INT"
   C=RGB(240,64,144)
  WHEN #T_STR
   TS$=VSLOT_TEST_ESCAPE$(MID$(V,0,100))
   TYPE$="STR"
   C=RGB(96,128,240)
  WHEN #T_INTARRAY
   TYPE$="INT[]"
  WHEN #T_REALARRAY
   TYPE$="REAL[]"
  WHEN #T_STRARRAY
   TYPE$="STR[]"
  ENDCASE
  GCLIP VALUE_X,MIN(MAX(SY,Y),Y2),VALUE_X2,Y2
  VAR TXT_W=0
  IF TYPEOF(V)==#T_INTARRAY||TYPEOF(V)==#T_REALARRAY||TYPEOF(V)==#T_STRARRAY THEN
   TXT_W=GDEBUG_DRAW_ARRAY(VALUE_X,Y,V,LIST_W%[1])
  ELSE
   TXT_W=GPUTCHR_FONT_W(GDEBUG_SYS_FONT,VALUE_X,Y,#FALSE,TS$,C)
  ENDIF
  IF TXT_W>=LIST_W%[1] THEN
   VAR DOTDOT_W=FONT_CALC_WIDTH(GDEBUG_SYS_FONT,"…")
   GFILL TYPE_X-DOTDOT_W,Y,VALUE_X2,Y+GDEBUG_SYS_FONT_SIZE+4,BACK_COLOR
   GPUTCHR_FONT GDEBUG_SYS_FONT,TYPE_X-DOTDOT_W,Y,#FALSE,"…",RGB(255,255,255)
  ENDIF
  GCLIP TYPE_X,MIN(MAX(SY,Y),Y2),TYPE_X2,Y2
  GPUTCHR_FONT GDEBUG_SYS_FONT,TYPE_X,Y,#FALSE,TYPE$,RGB(176,208,208)'RGB(0,192,240)
  @CONTINUE
  INC Y,FONT_TYPE*FONT_SCALE_Y
 NEXT
 DIM TABS$[]=["Locals","Globals","0","1","2","3","Consts","C0","C1","C2","C3"]
 GCLIP TABX,TABY-1,TABX+TABW-1,TABY+TABH-1
 VAR GDEBUG_VAR_TAB_SEL
 GDEBUG_DRAW_TABS GW,EVENT,TABX,TABY,TABW,TABH,TABS$,GDEBUG_VAR_TAB,#TRUE, OUT GDEBUG_VAR_TAB_SEL
 IF TYPEOF(GDEBUG_VAR_TAB_SEL) THEN
  GDEBUG_VAR_TAB=GDEBUG_VAR_TAB_SEL
  GWIN_PAINT GW,#FALSE
 ENDIF
END
DEF GDEBUG_DRAW_ARRAY(X,Y,V,MAX_W)
 VAR SX=X
 INC X,GPUTCHR_FONT_W(GDEBUG_SYS_FONT,X,Y,#FALSE,"[",RGB(255,255,255))
 IF X-SX>MAX_W THEN RETURN X-SX
 VAR I
 FOR I=0TO LAST(V)
   IF I THEN
    INC X,GPUTCHR_FONT_W(GDEBUG_SYS_FONT,X,Y,#FALSE,",",RGB(255,255,255))
   ENDIF
   IF TYPEOF(V)==#T_STRARRAY THEN
    INC X,GPUTCHR_FONT_W(GDEBUG_SYS_FONT,X,Y,#FALSE,VSLOT_TEST_ESCAPE$(MID$(V[I],0,100)),RGB(96,128,240))
   ELSE
    INC X,GPUTCHR_FONT_W(GDEBUG_SYS_FONT,X,Y,#FALSE,STR$(V[I]),RGB(240,64,144))
   ENDIF
   IF X-SX>MAX_W THEN RETURN X-SX
 NEXT
 INC X,GPUTCHR_FONT_W(GDEBUG_SYS_FONT,X,Y,#FALSE,"]",RGB(255,255,255))
 RETURN X-SX
END

'OTWヨリ
'===syntax highlighting===
'HashSet
VAR RTXTEDTRUE
VAR RTXTEDFALSE
VAR RTXTEDVAR
VAR RTXTEDDIM
VAR RTXTEDFOR
VAR RTXTEDNEXT
VAR RTXTEDBREAK
VAR RTXTEDCONTINUE
VAR RTXTEDREPEAT
VAR RTXTEDUNTIL
VAR RTXTEDWHILE
VAR RTXTEDWEND
VAR RTXTEDDATA
VAR RTXTEDREAD
VAR RTXTEDCOMMON
VAR RTXTEDDEF
VAR RTXTEDOUT
VAR RTXTEDEND
VAR RTXTEDRETURN
VAR RTXTEDIF
VAR RTXTEDTHEN
VAR RTXTEDELSE
VAR RTXTEDENDIF
VAR RTXTEDPRINT
VAR RTXTEDREM
VAR RTXTEDINC
VAR RTXTEDDEC
VAR RTXTEDGOTO
VAR RTXTEDGOSUB
VAR RTXTEDRESTORE
VAR RTXTEDAND
VAR RTXTEDOR
VAR RTXTEDXOR
VAR RTXTEDNOT
VAR RTXTEDMOD
VAR RTXTEDDIV
VAR RTXTEDCALL

VAR RTXTEDTO
VAR RTXTEDSTEP
VAR RTXTEDDEFOUT
VAR RTXTEDCONST
VAR RTXTEDLOOP
VAR RTXTEDENDLOOP
VAR RTXTEDCASE
VAR RTXTEDWHEN
VAR RTXTEDENDCASE
VAR RTXTEDENUM
VAR RTXTEDEXEC

VAR QTXTEDOPTION
VAR QTXTEDSTOP
COMMON DEF TXTED_PRGPRINT X,Y,P$,W,FONSIZE
 W=W*FONSIZE+X
 VAR OFSX=X
 VAR L=LEN(P$)-1,I,A
 VAR _0=ASC("0"),_9=ASC("9"),_Q=34
 VAR _S=ASC("'"),_A=ASC("A"),_Z=ASC("Z")
 VAR _LA=ASC("a"),_LZ=ASC("z"),__=ASC("_")
 VAR _AT=ASC("@"),_AND=ASC("&"),_B=ASC("B")
 VAR _H=ASC("H"),_1=ASC("1"),_F=ASC("F")
 VAR _HASH=ASC("#")
 VAR _LF=10
 VAR S
 FOR I=0TO L
  A=ASC(P$[I])
  IF A>=_A&&A<=_Z||A>=_LA&&A<=_LZ||A==__||A==_HASH THEN
   S=I
   VAR IS_HASH=A==_HASH
   FOR I=I+1 TO L
    A=ASC(P$[I])
    IF A>=_A&&A<=_Z||A>=_LA&&A<=_LZ||A==__ THEN CONTINUE
    IF A>=_0&&A<=_9 THEN CONTINUE
    BREAK
   NEXT
   VAR I$=MID$(P$,S,I-S)
   VAR C=RGB(0,198,247)
   IF IS_HASH THEN
    C=RGB(176,208,208)
   ELSEIF CHKVAR("RTXTED"+I$)THEN
    C=RGB(0,198,247)
   ELSEIF CHKCALL("3:"+I$)||((I$[0]=="S"||I$[0]=="s"||I$[0]=="O"||I$[0]=="o")&&CHKVAR("QTXTED"+I$))THEN
    C=RGB(123,123,247)
   ELSE
    C=-1
   ENDIF
   VAR S2=0
   VAR CL=(W-X)DIV FONSIZE
   WHILE 1
    IF CL>=LEN(I$)-S2 THEN
     I$=MID$(I$,S2,CL)
     GPUTCHR X,Y,I$,FONSIZE,C,#G_ALPHA2
     INC X,LEN(I$)*FONSIZE
     IF X>=W THEN X=OFSX:Y=Y+FONSIZE
     BREAK
    ELSE
     GPUTCHR X,Y,MID$(I$,S2,CL),FONSIZE,C,#G_ALPHA2
     X=OFSX
     INC Y,FONSIZE
     INC S2,CL
     CL=(W-OFSX) DIV FONSIZE
    ENDIF
   WEND
   DEC I
   CONTINUE
  ENDIF
  IF A==_Q THEN
   GPUTCHR X,Y,A,FONSIZE,RGB(99,132,247),#G_ALPHA2
   INC X,FONSIZE
   IF X>=W THEN X=OFSX:Y=Y+FONSIZE
   FOR I=I+1 TO L
    A=ASC(P$[I])
    IF A==_LF THEN GPUTCHR X,Y,A,FONSIZE,-1,#G_ALPHA2:BREAK
    GPUTCHR X,Y,A,FONSIZE,RGB(99,132,247),#G_ALPHA2
    INC X,FONSIZE
    IF X>=W THEN X=OFSX:Y=Y+FONSIZE
    IF A==_Q THEN BREAK
   NEXT
   IF A!=_Q THEN BREAK
   IF I==L THEN BREAK
   CONTINUE
  ENDIF
  IF A==_S THEN
   FOR I=I TO L
    A=ASC(P$[I])
    IF A==_LF THEN GPUTCHR X,Y,A,FONSIZE,-1,#G_ALPHA2:BREAK
    GPUTCHR X,Y,A,FONSIZE,RGB(33,247,16),#G_ALPHA2
    INC X,FONSIZE
    IF X>=W THEN X=OFSX:Y=Y+FONSIZE
   NEXT
   BREAK
  ENDIF
  IF A==_AT THEN
   FOR I=I TO L
    A=ASC(P$[I])
    IF!(A>=_A&&A<=_Z||A>=_LA&&A<=_LZ||A==__||A>=_0&&A<=_9||A==_AT)THEN DEC I:BREAK
    GPUTCHR X,Y,A,FONSIZE,RGB(247,167,0),#G_ALPHA2
    INC X,FONSIZE
    IF X>=W THEN X=OFSX:Y=Y+FONSIZE
   NEXT
   CONTINUE
  ENDIF
  IF A==_AND THEN
   S=ASC(P$[I])
   FOR I=I+1 TO L
    A=ASC(P$[I])
    INC X,FONSIZE
    IF A==_B THEN
     GPUTCHR X-FONSIZE,Y,S,FONSIZE,RGB(247,69,149),#G_ALPHA2
     IF X>=W THEN X=OFSX:Y=Y+FONSIZE
     GPUTCHR X,Y,A,FONSIZE,RGB(247,69,149),#G_ALPHA2
     INC X,FONSIZE
     IF X>=W THEN X=OFSX:Y=Y+FONSIZE
     S=0
     FOR I=I+1 TO L
      A=ASC(P$[I])
      IF A>_1&&A<=_9 THEN
       GPUTCHR X,Y,A,FONSIZE,-1,#G_ALPHA2'RGB(0,0,0)
       INC X,FONSIZE
       IF X>=W THEN X=OFSX:Y=Y+FONSIZE
       S=1
       CONTINUE
      ENDIF
      IF A!=_0&&A!=_1||S THEN DEC I:BREAK
      GPUTCHR X,Y,A,FONSIZE,RGB(247,69,149),#G_ALPHA2
      INC X,FONSIZE
      IF X>=W THEN X=OFSX:Y=Y+FONSIZE
     NEXT
     DEC I
     BREAK
    ENDIF
    IF A==_H THEN
     GPUTCHR X-FONSIZE,Y,S,FONSIZE,RGB(247,69,149),#G_ALPHA2
     IF X>=W THEN X=OFSX:Y=Y+FONSIZE
     GPUTCHR X,Y,A,FONSIZE,RGB(247,69,149),#G_ALPHA2
     INC X,FONSIZE
     IF X>=W THEN X=OFSX:Y=Y+FONSIZE
     FOR I=I+1 TO L
      A=ASC(P$[I])
      IF!(A>=_0&&A<=_9||A>=_A&&A<=_F)THEN DEC I:BREAK
      GPUTCHR X,Y,A,FONSIZE,RGB(247,69,149),#G_ALPHA2
      INC X,FONSIZE
      IF X>=W THEN X=OFSX:Y=Y+FONSIZE
     NEXT
     BREAK
    ENDIF
    GPUTCHR X-FONSIZE,Y,S,FONSIZE,RGB(255,255,255),#G_ALPHA2
    IF X>=W THEN X=OFSX:Y=Y+8
    DEC I
    BREAK
   NEXT
   CONTINUE
  ENDIF
  IF A>=_0&&A<=_9 THEN
   GPUTCHR X,Y,A,FONSIZE,RGB(247,69,149),#G_ALPHA2
  ELSE
   IF A==_LF THEN GPUTCHR X,Y,A,FONSIZE,RGB(0,0,0),#G_ALPHA2',RGB(0,184,255)BREAK
   GPUTCHR X,Y,A,FONSIZE,-1,#G_ALPHA2'RGV(0,0,0)
  ENDIF
  INC X,FONSIZE
  IF X>=W THEN X=OFSX:Y=Y+FONSIZE
 NEXT
END
VAR LEXER_TKN
DEF INIT_LEXER IN$
 LEXER_I=0
 LEXER_IN$=IN$
 LEXER_LINE=1
 LEXER_LINE_POS=0
END
DEF EMPTY OUT A
 RETURN A
END
DEF IS_NUM(C)
 RETURN C>=48&&C<=57
END
DEF IS_ALPHA(C)
 RETURN (C>=65&&C<=90)||(C>=97&&C<=122)
END
DEF TO_UPPER$(S$)
 VAR I
 VAR NS$=COPY(S$)
 FOR I=0TO LAST(S$)
  VAR C=ASC(S$[I])
  IF C>=97&&C<=122THEN
   NS$[I]=CHR$(C-97+65)
  ENDIF
 NEXT
 RETURN NS$
END
DEF LEX_CUR OUT T,V
 T=LEXER_TKN
 V=LEXER_VAL
END
DEF LEX_NEXT OUT T,V
 LEXER_PREV_I2=LEXER_I
 LEXER_PREV_LINE=LEXER_LINE
 LEXER_PREV_LINE_POS=LEXER_LINE_POS
 LEX_NEXT_IMPL
 LEX_CUR OUT T,V
 IF TRACE THEN
  ?TKN_STR$(T)
  ??V
 ENDIF
END
DEF LEX_SAVE OUT I,PI,PI2,T,V,L,P,PL,PP
 I=LEXER_I
 PI=LEXER_PREV_I
 PI2=LEXER_PREV_I2
 T=LEXER_TKN
 V=LEXER_VAL
 L=LEXER_LINE
 P=LEXER_LINE_POS
 PL=LEXER_PREV_LINE
 PP=LEXER_PREV_LINE_POS
END
DEF LEX_LOAD I,PI,PI2,T,V,L,P,PL,PP
 LEXER_I=I
 LEXER_PREV_I=PI
 LEXER_PREV_I2=PI2
 LEXER_TKN=T
 LEXER_VAL=V
 LEXER_LINE=L
 LEXER_LINE_POS=P
 LEXER_PREV_LINE=PL
 LEXER_PREV_LINE_POS=PP
END
DEF IS_VARSUFFIX(C$)
 CASE C$
 WHEN "$":WHEN "#":WHEN "%":RETURN #TRUE
 OTHERWISE RETURN #FALSE
 ENDCASE
END
DEF LEX_NEXT_IMPL
 @LOOP
 VAR C$,C
 LEXER_TKN=#TKN_NONE
 LEXER_VAL=EMPTY()
 FOR LEXER_I=LEXER_I TO LAST(LEXER_IN$)
  C$=LEXER_IN$[LEXER_I]
  C=ASC(C$)
  IF C==13||C==10THEN
   LEXER_TKN=#TKN_NEWLINE
   IF C==10THEN
    INC LEXER_LINE
    LEXER_LINE_POS=LEXER_I+1
   ENDIF
   CONTINUE
  ENDIF
  IF C==32||C==9THEN
   CONTINUE
  ENDIF
  BREAK
 NEXT
 LEXER_PREV_I=LEXER_I
 IF LEXER_I>=LEN(LEXER_IN$)THEN
  LEXER_TKN=#TKN_EOF
  RETURN
 ENDIF
 IF LEXER_TKN!=#TKN_NONE THEN
  RETURN
 ENDIF
  VAR N$=MID$(LEXER_IN$,LEXER_I+1,1)
 VAR SI=LEXER_I
 CASE C$
 WHEN "+"
  INC LEXER_I
  LEXER_TKN=#TKN_PLUS
 WHEN "-"
  INC LEXER_I
  LEXER_TKN=#TKN_MINUS
 WHEN "*"
  INC LEXER_I
  LEXER_TKN=#TKN_MUL
 WHEN "/"
  INC LEXER_I
  LEXER_TKN=#TKN_DIV
 WHEN ","
  INC LEXER_I
  LEXER_TKN=#TKN_COMMA
 WHEN "("
  INC LEXER_I
  LEXER_TKN=#TKN_LP
 WHEN ")"
  INC LEXER_I
  LEXER_TKN=#TKN_RP
 WHEN "["
  INC LEXER_I
  LEXER_TKN=#TKN_LB
 WHEN "]"
  INC LEXER_I
  LEXER_TKN=#TKN_RB
 WHEN ";"
  INC LEXER_I
  LEXER_TKN=#TKN_SEMI
 WHEN ":"
  INC LEXER_I
  LEXER_TKN=#TKN_COL
 WHEN "T"
  IF N$=="?"THEN
   INC LEXER_I,2
   LEXER_TKN=#TKN_TPRINT
  ENDIF
 WHEN "?"
  INC LEXER_I
  IF N$=="?"THEN
   INC LEXER_I
   LEXER_TKN=#TKN_INSPECT
  ELSE
   LEXER_TKN=#TKN_PRINT
  ENDIF
 WHEN "!"
  INC LEXER_I
  IF N$=="="THEN
   INC LEXER_I
   LEXER_TKN=#TKN_NEQ
  ELSE
   LEXER_TKN=#TKN_LNOT
  ENDIF
 WHEN "="
  INC LEXER_I
  IF N$=="="THEN
   INC LEXER_I
   LEXER_TKN=#TKN_EQ
  ELSE
   LEXER_TKN=#TKN_ASSIGN
  ENDIF
 WHEN "<"
  INC LEXER_I
  IF N$=="="THEN
   INC LEXER_I
   LEXER_TKN=#TKN_GEQ
  ELSEIF N$=="<"THEN
   INC LEXER_I
   LEXER_TKN=#TKN_LSHIFT
  ELSE
   LEXER_TKN=#TKN_GREAT
  ENDIF
 WHEN ">"
  INC LEXER_I
  IF N$=="="THEN
   INC LEXER_I
   LEXER_TKN=#TKN_LEQ
  ELSEIF N$==">"THEN
   INC LEXER_I
   LEXER_TKN=#TKN_RSHIFT
  ELSE
   LEXER_TKN=#TKN_LESS
  ENDIF
 WHEN "&"
  IF N$=="&"THEN
   INC LEXER_I,2
   LEXER_TKN=#TKN_LAND
  ELSEIF N$=="H"||N$=="h"THEN
   FOR LEXER_I=LEXER_I+2 TO LAST(LEXER_IN$)
    C$=LEXER_IN$[LEXER_I]
    C=ASC(C$)
    IF IS_NUM(C)||(C$>="A"&&C$<="F")||(C$>="a"&&C$<="f")THEN
     CONTINUE
    ENDIF
    BREAK
   NEXT
   LEXER_TKN=#TKN_NUM
   LEXER_VAL=VAL(MID$(LEXER_IN$,SI,LEXER_I-SI))
   RETURN
  ELSEIF N$=="B"||N$=="b"THEN
   FOR LEXER_I=LEXER_I+2 TO LAST(LEXER_IN$)
    C$=LEXER_IN$[LEXER_I]
    IF C$>="0"&&C$<="1"THEN
     CONTINUE
    ENDIF
    BREAK
   NEXT
   LEXER_TKN=#TKN_NUM
   LEXER_VAL=VAL(MID$(LEXER_IN$,SI,LEXER_I-SI))
   RETURN
  ENDIF
 WHEN "|"
  IF N$=="|"THEN
   INC LEXER_I,2
   LEXER_TKN=#TKN_LOR
  ENDIF
 ENDCASE
 IF LEXER_TKN!=#TKN_NONE THEN
  RETURN
 ENDIF
 IF IS_NUM(C) THEN
  'n.nEn
  VAR HAS_POINT,HAS_EXP
  FOR LEXER_I=LEXER_I TO LAST(LEXER_IN$)
   C$=LEXER_IN$[LEXER_I]
   C=ASC(C$)
   IF!HAS_EXP&&!HAS_POINT&&C$=="."THEN
    HAS_POINT=#TRUE
    CONTINUE
   ENDIF
   IF !HAS_EXP&&C$=="E"||C$=="e"THEN
    HAS_EXP=#TRUE
    CONTINUE
   ENDIF
   IF IS_NUM(C)THEN
    CONTINUE
   ENDIF
   BREAK
  NEXT
  LEXER_TKN=#TKN_NUM
  LEXER_VAL=VAL(MID$(LEXER_IN$,SI,LEXER_I-SI))
  RETURN
 ELSEIF C$=="#"||C$=="@"||IS_ALPHA(C)||C$=="_"THEN
  VAR ISLBL=C$=="@"
  VAR ISCNST=C$=="#"
  VAR ADD1=ISLBL||ISCNST
  FOR LEXER_I=LEXER_I+ADD1 TO LAST(LEXER_IN$)
   C$=LEXER_IN$[LEXER_I]
   C=ASC(C$)
   IF IS_ALPHA(C)||C$=="_"||IS_NUM(C)THEN
    CONTINUE
   ENDIF
   BREAK
  NEXT
  IF !ISLBL&&IS_VARSUFFIX(MID$(LEXER_IN$,LEXER_I,1))THEN
   INC LEXER_I
  ENDIF
  LEXER_VAL=MID$(LEXER_IN$,SI,LEXER_I-SI)
  LEXER_VAL=TO_UPPER$(LEXER_VAL)
  IF ISLBL THEN
   LEXER_TKN=#TKN_LABEL
  ELSEIF ISCNST THEN
   LEXER_TKN=#TKN_CONSTVAR
  ELSE
   LEXER_TKN=LEX_RECOG_IDEN(LEXER_VAL)
  ENDIF
  RETURN
 ELSEIF C==34 THEN'STRING
  LEXER_VAL=""
  FOR LEXER_I=LEXER_I+1 TO LAST(LEXER_IN$)
   C$=LEXER_IN$[LEXER_I]
   C=ASC(C$)
   IF C==34||C==10||C==13 THEN
    IF C==34 THEN INC LEXER_I
    BREAK
   ENDIF
   PUSH LEXER_VAL,C$
  NEXT
  LEXER_TKN=#TKN_STR
  RETURN
 ELSEIF C$=="'"THEN
  FOR LEXER_I=LEXER_I+1 TO LAST(LEXER_IN$)
   C$=LEXER_IN$[LEXER_I]
   C=ASC(C$)
   IF C==10 THEN BREAK
   IF C==13 THEN BREAK
  NEXT
  GOTO @LOOP
 ELSEIF C$=="\"THEN
  IF ASC(N$)==10||ASC(N$)==13 THEN
   IF ASC(N$)==10 THEN
    INC LEXER_LINE
   ENDIF
   LEXER_LINE_POS=LEXER_I+2
   INC LEXER_I,2
   GOTO @LOOP
  ENDIF
 ENDIF
 ?"Synt
 STOP
END
DEF LEX_RECOG_IDEN(V)
 CASE V
 WHEN "PRINT"
  RETURN #TKN_PRINT
 WHEN "DIV"
  RETURN #TKN_DIVINT
 WHEN "MOD"
  RETURN #TKN_MOD
 WHEN "AND"
  RETURN #TKN_AND
 WHEN "OR"
  RETURN #TKN_OR
 WHEN "XOR"
  RETURN #TKN_XOR
 WHEN "NOT"
  RETURN #TKN_NOT
 WHEN "OUT"
  RETURN #TKN_OUT
 WHEN "CALL"
  RETURN #TKN_CALL
 WHEN "DIM"
  RETURN #TKN_DIM
 WHEN "VAR"
  RETURN #TKN_VAR
 WHEN "IF"
  RETURN #TKN_IF
 WHEN "THEN"
  RETURN #TKN_THEN
 WHEN "ENDIF"
  RETURN #TKN_ENDIF
 WHEN "ELSE"
  RETURN #TKN_ELSE
 WHEN "ELSEIF"
  RETURN #TKN_ELSEIF
 WHEN "FOR"
  RETURN #TKN_FOR
 WHEN "NEXT"
  RETURN #TKN_NEXT
 WHEN "GOTO"
  RETURN #TKN_GOTO
 WHEN "GOSUB"
  RETURN #TKN_GOSUB
 WHEN "BREAK"
  RETURN #TKN_BREAK
 WHEN "CONTINUE"
  RETURN #TKN_CONTINUE
 WHEN "REPEAT"
  RETURN #TKN_REPEAT
 WHEN "UNTIL"
  RETURN #TKN_UNTIL
 WHEN "WHILE"
  RETURN #TKN_WHILE
 WHEN "WEND"
  RETURN #TKN_WEND
 WHEN "REPEAT"
  RETURN #TKN_REPEAT
 WHEN "UNTIL"
  RETURN #TKN_UNTIL
 WHEN "LOOP"
  RETURN #TKN_LOOP
 WHEN "ENDLOOP"
  RETURN #TKN_ENDLOOP
 WHEN "RETURN"
  RETURN #TKN_RETURN
 WHEN "DATA"
  RETURN #TKN_DATA
 WHEN "RESTORE"
  RETURN #TKN_RESTORE
 WHEN "CONST"
  RETURN #TKN_CONST
 WHEN "ENUM"
  RETURN #TKN_ENUM
 WHEN "DEF"
  RETURN #TKN_DEF
 WHEN "END"
  RETURN #TKN_END
 WHEN "TPRINT"
  RETURN #TKN_TPRINT
 WHEN "READ"
  RETURN #TKN_READ
 WHEN "INC"
  RETURN #TKN_INC
 WHEN "DEC"
  RETURN #TKN_DEC
 WHEN "ON"
  RETURN #TKN_ON
 WHEN "CASE"
  RETURN #TKN_CASE
 WHEN "WHEN"
  RETURN #TKN_WHEN
 WHEN "OTHERWISE"
  RETURN #TKN_OTHERWISE
 WHEN "ENDCASE"
  RETURN #TKN_ENDCASE
 WHEN "SWAP"
  RETURN #TKN_SWAP
 WHEN "COMMON"
  RETURN #TKN_COMMON
 WHEN "DEFOUT"
  RETURN #TKN_DEFOUT
 WHEN "INPUT"
  RETURN #TKN_INPUT
 WHEN "LINPUT"
  RETURN #TKN_LINPUT
 WHEN "EXEC"
  RETURN #TKN_EXEC
 OTHERWISE
  RETURN #TKN_IDEN
 ENDCASE
END



DIM AST_TYP[]
DIM AST%[]
DIM AST#[]
DIM AST$[]
DIM AST_LEFT[]
DIM AST_RIGHT[]
DIM AST_NEXT[]
DIM AST_PREV[]
DIM AST_A1[]
DIM AST_A2[]
DIM AST_A3[]
DIM AST_A4[]
DIM AST_A5[]
DIM AST_LINE[]
DIM AST_POS[]
DIM AST_LINE_END[]
DIM AST_POS_END[]
DEF INIT_AST
 VAR S=1
 AST_TYP=ARRAY%(S)
 AST%=ARRAY%(S)
 AST#=ARRAY#(S)
 AST$=ARRAY$(S)
 AST_LEFT=ARRAY%(S)
 AST_NEXT=ARRAY%(S)
 AST_RIGHT=ARRAY%(S)
 AST_PREV=ARRAY%(S)
 AST_A1=ARRAY%(S)
 AST_A2=ARRAY%(S)
 AST_A3=ARRAY%(S)
 AST_A4=ARRAY%(S)
 AST_A5=ARRAY%(S)
 AST_LINE=ARRAY%(S)
 AST_POS=ARRAY%(S)
 AST_LINE_END=ARRAY%(S)
 AST_POS_END=ARRAY%(S)
END

'BINOP:AST%-TKN
ENUM\
 #AST_ITEM,\
 #AST_BINOP,\
 #AST_UNAOP,\
 #AST_PRINT,\
 #AST_IMM_INT,\
 #AST_IMM_DBL,\
 #AST_IMM_STR,\
 #AST_STATEMENTS,\
 #AST_PRINT_EXPR_NEWLINE,\
 #AST_PRINT_EXPR_COMMA,\
 #AST_PRINT_EXPR_SEMI,\
 #AST_ASSIGN,\
 #AST_VAR,\
 #AST_IF,\
 #AST_FOR,\
 #AST_BREAK,\
 #AST_CONTINUE,\
 #AST_WHILE,\
 #AST_REPEAT,\
 #AST_LOOP,\
 #AST_LABEL,\
 #AST_GOTO,\
 #AST_GOSUB,\
 #AST_GOTOEXPR,\
 #AST_GOSUBEXPR,\
 #AST_ONGOTO,\
 #AST_ONGOSUB,\
 #AST_ONBREAKGOTO,\
 #AST_ONBREAKGOTOEXPR,\
 #AST_RETURN,\
 #AST_RETURNFUNC,\
 #AST_CALLFUNC,\
 #AST_CALLFUNCEXPR,\
 #AST_OPTIONSTRICT,\
 #AST_OPTIONDEFINT,\
 #AST_RESTORE,\
 #AST_RESTOREEXPR,\
 #AST_DATA,\
 #AST_CONST,\
 #AST_ENUM,\
 #AST_CONSTVAR,\
 #AST_CALLSPRITE,\
 #AST_CALLTEXT,\
 #AST_ARRAYEXPR,\
 #AST_DEF,\
 #AST_END,\
 #AST_TPRINT,\
 #AST_EMPTYEXPR,\
 #AST_DEFVAR,\
 #AST_READ,\
 #AST_DEC,\
 #AST_INC,\
 #AST_CASE,\
 #AST_SWAP,\
 #AST_INPUT,\
 #AST_LINPUT,\
 #AST_DEFOUT,\
 #AST_EXEC,\
 #AST_STOP,\
 #AST_VARREF,\
 #AST_VAREXPR,\
 #AST_,\
 #AST_LAST
DEF AST_STR$(TYP)
 CASE TYP
 WHEN #AST_ITEM:RETURN "#AST_ITEM"WHEN #AST_BINOP:RETURN "#AST_BINOP"WHEN #AST_UNAOP:RETURN "#AST_UNAOP"WHEN #AST_PRINT:RETURN "#AST_PRINT"WHEN #AST_IMM_INT:RETURN "#AST_IMM_INT"WHEN #AST_IMM_DBL:RETURN "#AST_IMM_DBL"WHEN #AST_IMM_STR:RETURN "#AST_IMM_STR"WHEN #AST_STATEMENTS:RETURN "#AST_STATEMENTS"WHEN #AST_PRINT_EXPR_NEWLINE:RETURN "#AST_PRINT_EXPR_NEWLINE"WHEN #AST_PRINT_EXPR_COMMA:RETURN "#AST_PRINT_EXPR_COMMA"WHEN #AST_PRINT_EXPR_SEMI:RETURN "#AST_PRINT_EXPR_SEMI"WHEN #AST_ASSIGN:RETURN "#AST_ASSIGN"WHEN #AST_VAR:RETURN "#AST_VAR"WHEN #AST_IF:RETURN "#AST_IF"WHEN #AST_FOR:RETURN "#AST_FOR"WHEN #AST_BREAK:RETURN "#AST_BREAK"WHEN #AST_CONTINUE:RETURN "#AST_CONTINUE"WHEN #AST_WHILE:RETURN "#AST_WHILE"WHEN #AST_REPEAT:RETURN "#AST_REPEAT"WHEN #AST_LOOP:RETURN "#AST_LOOP"WHEN #AST_LABEL:RETURN "#AST_LABEL"WHEN #AST_GOTO:RETURN "#AST_GOTO"WHEN #AST_GOSUB:RETURN "#AST_GOSUB"WHEN #AST_GOTOEXPR:RETURN "#AST_GOTOEXPR"WHEN #AST_GOSUBEXPR:RETURN "#AST_GOSUBEXPR"WHEN #AST_ONGOTO:RETURN "#AST_ONGOTO"WHEN #AST_ONGOSUB:RETURN "#AST_ONGOSUB"WHEN #AST_ONBREAKGOTO:RETURN "#AST_ONBREAKGOTO"WHEN #AST_ONBREAKGOTOEXPR:RETURN "#AST_ONBREAKGOTOEXPR"WHEN #AST_RETURN:RETURN "#AST_RETURN"WHEN #AST_RETURNFUNC:RETURN "#AST_RETURNFUNC"WHEN #AST_CALLFUNC:RETURN "#AST_CALLFUNC"WHEN #AST_CALLFUNCEXPR:RETURN "#AST_CALLFUNCEXPR"WHEN #AST_OPTIONSTRICT:RETURN "#AST_OPTIONSTRICT"WHEN #AST_OPTIONDEFINT:RETURN "#AST_OPTIONDEFINT"WHEN #AST_RESTORE:RETURN "#AST_RESTORE"WHEN #AST_RESTOREEXPR:RETURN "#AST_RESTOREEXPR"WHEN #AST_DATA:RETURN "#AST_DATA"WHEN #AST_CONST:RETURN "#AST_CONST"WHEN #AST_ENUM:RETURN "#AST_ENUM"WHEN #AST_CONSTVAR:RETURN "#AST_CONSTVAR"WHEN #AST_CALLSPRITE:RETURN "#AST_CALLSPRITE"WHEN #AST_CALLTEXT:RETURN "#AST_CALLTEXT"WHEN #AST_ARRAYEXPR:RETURN "#AST_ARRAYEXPR"WHEN #AST_DEF:RETURN "#AST_DEF"WHEN #AST_END:RETURN "#AST_END"WHEN #AST_TPRINT:RETURN "#AST_TPRINT"WHEN #AST_EMPTYEXPR:RETURN "#AST_EMPTYEXPR"WHEN #AST_DEFVAR:RETURN "#AST_DEFVAR"WHEN #AST_READ:RETURN "#AST_READ"WHEN #AST_DEC:RETURN "#AST_DEC"WHEN #AST_INC:RETURN "#AST_INC"WHEN #AST_CASE:RETURN "#AST_CASE"WHEN #AST_SWAP:RETURN "#AST_SWAP"WHEN #AST_INPUT:RETURN "#AST_INPUT"WHEN #AST_LINPUT:RETURN "#AST_LINPUT"WHEN #AST_DEFOUT:RETURN "#AST_DEFOUT"WHEN #AST_EXEC:RETURN "#AST_EXEC"WHEN #AST_STOP:RETURN "#AST_STOP"WHEN #AST_VARREF:RETURN "#AST_VARREF"WHEN #AST_VAREXPR:RETURN "#AST_VAREXPR"WHEN #AST_:RETURN "#AST_"
 OTHERWISE
  RETURN "#AST"+STR$(TYP)
 ENDCASE
END
DEF NEW_AST(TYP)
 PUSH AST_TYP,TYP
 VAR E$
 PUSH AST%,0
 PUSH AST#,0
 PUSH AST$,E$
 PUSH AST_LEFT,0
 PUSH AST_RIGHT,0
 PUSH AST_NEXT,0
 PUSH AST_PREV,0
 PUSH AST_A1,0
 PUSH AST_A2,0
 PUSH AST_A3,0
 PUSH AST_A4,0
 PUSH AST_A5,0
 PUSH AST_LINE,LEXER_LINE
 PUSH AST_POS,LEXER_PREV_I-LEXER_LINE_POS+1
 PUSH AST_LINE_END,LEXER_LINE
 PUSH AST_POS_END,LEXER_I-LEXER_LINE_POS+1
 RETURN LAST(AST_TYP)
END

DEF AST_SET_POS AST
 AST_LINE[AST]=LEXER_LINE
 AST_POS[AST]=LEXER_PREV_I-LEXER_LINE_POS+1
END
DEF AST_SET_POS_END AST
 AST_LINE_END[AST]=LEXER_PREV_LINE
 AST_POS_END[AST]=LEXER_PREV_I2-LEXER_PREV_LINE_POS+1
END

DEF NEW_AST_LR(TYP,L,R)
 VAR A=NEW_AST(TYP)
 AST_LEFT[A]=L
 AST_RIGHT[A]=R
 RETURN A
END

DEF NEW_AST_APPEND(TYP,PREV)
 VAR A=NEW_AST(TYP)
 AST_PREV[A]=PREV
 AST_NEXT[PREV]=LAST(AST_TYP)
 RETURN LAST(AST_TYP)
END

DEF NEW_AST_INT(TYP,V%)
 VAR A=NEW_AST(TYP)
 AST%[A]=V%
 RETURN A
END

DEF NEW_AST_DBL(TYP,V#)
 VAR A=NEW_AST(TYP)
 AST#[A]=V#
 RETURN A
END
DEF NEW_AST_STR(TYP,V$)
 VAR A=NEW_AST(TYP)
 AST$[A]=V$
 RETURN A
END

DEF NEW_AST_IMM(V)
 VAR A
 CASE TYPEOF(V)
 WHEN #T_INT
  A=NEW_AST_INT(#AST_IMM_INT,V)
 WHEN #T_REAL
  A=NEW_AST_DBL(#AST_IMM_DBL,V)
 WHEN #T_STR
  A=NEW_AST_STR(#AST_IMM_STR,V)
 OTHERWISE
  STOP
 ENDCASE
 RETURN A
END
VAR AST_DUMPAST_END
DEF AST_IND IND
 VAR Y,H
 LOCATE OUT ,Y
 TSCREEN OUT ,,,H
 IF 0&&Y>=H-2 THEN
  LOOP
   VAR K$=INKEY$()
   IF LEN(K$)THEN
    IF K$=="A" THEN
     AST_DUMPAST_END=#TRUE
     BREAK
    ENDIF
    CLS
    BREAK
   ENDIF
   VSYNC
  ENDLOOP
 ENDIF
 ?" "*IND;
END
DEF DUMP_AST A,IND
 IF IND==0 THEN AST_DUMPAST_END=#FALSE
 IF!A THEN RETURN
 IF AST_DUMPAST_END THEN RETURN
 VAR I,J
 CASE AST_TYP[A]
 WHEN #AST_STATEMENTS
  AST_IND IND:?"STATEMENTS"
  I=AST_NEXT[AST_LEFT[A]]
  WHILE I
   IF!I THEN BREAK
   DUMP_AST AST_LEFT[I],IND+1
   I=AST_NEXT[I]
  WEND
 WHEN #AST_TPRINT
 WHEN #AST_PRINT
  VAR P$="PRINT"
  IF AST_TYP[A]==#AST_TPRINT THEN P$="TPRINT"
  AST_IND IND:?P$
  INC IND
  I=AST_NEXT[AST_LEFT[A]]
  WHILE I
   IF!I THEN BREAK
   CASE AST_TYP[I]
   WHEN #AST_PRINT_EXPR_COMMA
    AST_IND IND:?P$;" COMMA"
   WHEN #AST_PRINT_EXPR_NEWLINE
    AST_IND IND:?P$;" NEWLINE"
   WHEN #AST_PRINT_EXPR_SEMI
    AST_IND IND:?P$;" SEMI"
   ENDCASE
   DUMP_AST AST_LEFT[I],IND+1
   I=AST_NEXT[I]
  WEND
 WHEN #AST_IF
  AST_IND IND:?"IF"
  INC IND
  AST_IND IND:?"IF EXPR"
  DUMP_AST AST_A1[A],IND+1
  AST_IND IND:?"IF THEN STATEMENTS"
  DUMP_AST AST_A2[A],IND+1
  IF AST_A3[A] THEN
   I=AST_NEXT[AST_A3[A]]
   WHILE I
    AST_IND IND:?"IF ELSEIF EXPR[";J;"]"
    DUMP_AST AST_A1[I],IND+1
    AST_IND IND:?"IF ELSEIF STATEMENTS[";J;"]"
    DUMP_AST AST_A2[I],IND+1
    INC J
    I=AST_NEXT[I]
   WEND
  ENDIF
  AST_IND IND:?"IF ELSE STATEMENTS"
  DUMP_AST AST_A4[A],IND+1
 WHEN #AST_ASSIGN
  AST_IND IND:?"ASSIGN"
  DUMP_AST AST_LEFT[A],IND+1
  DUMP_AST AST_RIGHT[A],IND+1
 WHEN #AST_FOR
  AST_IND IND:?"FOR"
  DUMP_AST AST_A1[A],IND+1
  DUMP_AST AST_A2[A],IND+1
  DUMP_AST AST_A3[A],IND+1
  DUMP_AST AST_A4[A],IND+1
  DUMP_AST AST_A5[A],IND+1
 WHEN #AST_BINOP
  AST_IND IND:?"BINOP ";TKN_STR$(AST%[A])
  DUMP_AST AST_LEFT[A],IND+1
  DUMP_AST AST_RIGHT[A],IND+1
 WHEN #AST_UNAOP
  AST_IND IND:?"UNAOP ";TKN_STR$(AST%[A])
  DUMP_AST AST_LEFT[A],IND+1
 WHEN #AST_IMM_INT
  AST_IND IND:?"INT ";AST%[A]
 WHEN #AST_IMM_DBL
  AST_IND IND:?"DOUBLE ";AST#[A]
 WHEN #AST_IMM_STR
  AST_IND IND:?"STR ";AST$[A]
 WHEN #AST_VAR
  AST_IND IND:?"VAR ";AST$[A]
 WHEN #AST_CONSTVAR
  AST_IND IND:?"CONST ";AST$[A]
 WHEN #AST_EMPTYEXPR
  AST_IND IND:?"EMPTYEXPR"
 WHEN #AST_DEF
 '$:NAME
 'A1:IN LIST
 'A2:OUT LIST
 'A3:STATEMENTS
 'A4:HAS RETURN VALUE
  IF AST_A4[A] THEN
   AST_IND IND:?"DEF(";AST$[A];")"
  ELSE
   AST_IND IND:?"DEF ";AST$[A]
  ENDIF
  AST_IND IND:?"DEF ARGS(IN)"
  I=AST_NEXT[AST_A1[A]]
  WHILE I
   AST_IND IND+1:?AST$[I]
   INC J
   I=AST_NEXT[I]
  WEND
  AST_IND IND:?"DEF ARGS(OUT)"
  I=AST_NEXT[AST_A2[A]]
  WHILE I
   AST_IND IND+1:?AST$[I]
   INC J
   I=AST_NEXT[I]
  WEND
  AST_IND IND:?"DEF STATEMENTS"
  DUMP_AST AST_A3[A],IND+1
 WHEN #AST_CALLFUNC
  I=AST_NEXT[AST_A1[A]]
  AST_IND IND:?"CALLFUNC ";AST$[A]
  INC IND
  AST_IND IND:?"CALLFUNC ARGS(IN)"
  WHILE I
   DUMP_AST AST_A1[I],IND+1
   INC J
   I=AST_NEXT[I]
  WEND
  I=AST_NEXT[AST_A2[A]]
  AST_IND IND:?"CALLFUNC ARGS(OUT)"
  WHILE I
   DUMP_AST AST_A1[I],IND+1
   INC J
   I=AST_NEXT[I]
  WEND
 WHEN #AST_CALLFUNCEXPR
  I=AST_NEXT[AST_A1[A]]
  AST_IND IND:?"CALLFUNCEXPR ";AST$[A]
  WHILE I
   DUMP_AST AST_A1[I],IND+1
   INC J
   I=AST_NEXT[I]
  WEND
 WHEN #AST_LABEL
  AST_IND IND:?"LABEL ";AST$[A]
 WHEN #AST_DATA
  I=AST_NEXT[AST_A1[A]]
  AST_IND IND:?"DATA"
  WHILE I
   DUMP_AST AST_A1[I],IND+1
   INC J
   I=AST_NEXT[I]
  WEND
 WHEN #AST_RETURN
  AST_IND IND:?"RETURN FROM SUBROUTINE"
 WHEN #AST_RETURNFUNC
  AST_IND IND:?"RETURN FROM FUNCTION"
  DUMP_AST AST_LEFT[A],IND+1
 WHEN #AST_OPTIONSTRICT
  AST_IND IND:?"OPTION STRICT"
 WHEN #AST_OPTIONDEFINT
  AST_IND IND:?"OPTION DEFINT"
 WHEN #AST_END
  AST_IND IND:?"END"
 WHEN #AST_CALLSPRITE
  AST_IND IND:?"CALL SPRITE"
 WHEN #AST_CALLTEXT
  AST_IND IND:?"CALL TEXT"
 WHEN #AST_DEFVAR
  AST_IND IND:?"VAR DEFINITION"
  I=AST_NEXT[AST_A1[A]]
  INC IND
  WHILE I
   AST_IND IND:?"VAR DEFINITION ";AST$[I]
   DUMP_AST AST_A1[I],IND+1
   IF AST_A2[I] THEN
    AST_IND IND:?"ARRAY DIMENSIONS ";AST$[I]
    J=AST_NEXT[AST_A2[I]]
    WHILE J
     DUMP_AST AST_A1[J],IND+2
     J=AST_NEXT[J]
    WEND
   ENDIF
   IF AST_A3[I]THEN
    AST_IND IND:?"ARRAY INITIALIZER ";AST$[I]
    J=AST_NEXT[AST_A3[I]]
    WHILE J
     DUMP_AST AST_A1[J],IND+2
     J=AST_NEXT[J]
    WEND
   ENDIF
   I=AST_NEXT[I]
  WEND
 WHEN #AST_CONST
  I=AST_NEXT[AST_A1[A]]
  INC IND
  WHILE I
   AST_IND IND:?"CONSTANT DEFINITION ";AST$[I]
   DUMP_AST AST_A1[I],IND+1
   I=AST_NEXT[I]
  WEND
 WHEN #AST_ENUM
  I=AST_NEXT[AST_A1[A]]
  INC IND
  WHILE I
   AST_IND IND:?"ENUM DEFINITION ";AST$[I]
   DUMP_AST AST_A1[I],IND+1
   I=AST_NEXT[I]
  WEND
 WHEN #AST_WHILE
  AST_IND IND:?"WHILE"
  DUMP_AST AST_A1[A],IND+1
  DUMP_AST AST_A2[A],IND+1
 OTHERWISE
  AST_IND IND:?AST_STR$(AST_TYP[A])
 ENDCASE
END

VAR PARSER_RETURN_EXPR
VAR PARSER_IN_FUNC
VAR PARSER_HAS_ERR
VAR PARSER_SLOT
DEF INIT_PARSER SLOT
 PARSER_SLOT=SLOT
 PARSER_RETURN_EXPR=#FALSE
 PARSER_IN_FUNC=#FALSE
 PARSER_HAS_ERR=#FALSE
END
DEF PARSER_HAS_ERROR()
 RETURN PARSER_HAS_ERR
END
DEF PARSE()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LEX_NEXT OUT T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_EOF THEN
   RETURN ROOT
  ENDIF
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_STATEMENT()
 LOOP
  VAR T
  LEX_CUR OUT T,
  CASE T
  WHEN #TKN_TPRINT
   RETURN PARSE_PRINT(#TRUE)
  WHEN #TKN_PRINT
   RETURN PARSE_PRINT(#FALSE)
  WHEN #TKN_IDEN
   RETURN PARSE_IDEN()
  WHEN #TKN_IF
   RETURN PARSE_IF()
  WHEN #TKN_FOR
   RETURN PARSE_FOR()
  WHEN #TKN_BREAK
   LEX_NEXT OUT ,
   RETURN NEW_AST(#AST_BREAK)
  WHEN #TKN_CONTINUE
   LEX_NEXT OUT ,
   RETURN NEW_AST(#AST_CONTINUE)
  WHEN #TKN_REPEAT
   RETURN PARSE_REPEAT()
  WHEN #TKN_WHILE
   RETURN PARSE_WHILE()
  WHEN #TKN_LOOP
   RETURN PARSE_LOOP()
  WHEN #TKN_LABEL
   RETURN PARSE_LABEL()
  WHEN #TKN_GOTO
   RETURN PARSE_GOTO()
  WHEN #TKN_GOSUB
   RETURN PARSE_GOSUB()
  WHEN #TKN_ON
   RETURN PARSE_ON()
  WHEN #TKN_RETURN
   RETURN PARSE_RETURN()
  WHEN #TKN_DATA
   RETURN PARSE_DATA()
  WHEN #TKN_RESTORE
   RETURN PARSE_RESTORE()
  WHEN #TKN_VAR
  WHEN #TKN_DIM
  WHEN #TKN_CONST
  WHEN #TKN_ENUM
   RETURN PARSE_VAR()
  WHEN #TKN_INSPECT
   LEX_NEXT OUT ,
   RETURN PARSE_CALLFUNC(NEW_AST(#AST_CALLFUNC),"INSPECT",#FALSE)
  WHEN #TKN_CALL
   RETURN PARSE_CALL()
  WHEN #TKN_EXEC
   RETURN PARSE_EXEC()
  WHEN #TKN_DEFOUT
   RETURN PARSE_DEFOUT()
  WHEN #TKN_COMMON
  WHEN #TKN_DEF
   RETURN PARSE_DEF()
  WHEN #TKN_END
   RETURN PARSE_END()
  WHEN #TKN_READ
   RETURN PARSE_READ()
  WHEN #TKN_DEC
  WHEN #TKN_INC
   RETURN PARSE_INC()
  WHEN #TKN_CASE
   RETURN PARSE_CASE()
  WHEN #TKN_SWAP
   RETURN PARSE_SWAP()
  WHEN #TKN_INPUT
   RETURN PARSE_INPUT()
  WHEN #TKN_LINPUT
   RETURN PARSE_LINPUT()
  WHEN #TKN_LP
   RETURN PARSE_ASSIGN_EXPR()
  WHEN #TKN_ENDIF
   PARSER_ENDIF_WITHOUT_IF
   GOTO @ERR
  WHEN #TKN_WEND
   PARSER_WEND_WITHOUT_WHILE
   GOTO @ERR
  WHEN #TKN_UNTIL
   PARSER_UNTIL_WITHOUT_REPEAT
   GOTO @ERR
  WHEN #TKN_ENDCASE
   PARSER_ENDCASE_WITHOUT_CASE
   GOTO @ERR
  WHEN #TKN_WHEN
   PARSER_WHEN_WITHOUT_CASE
   GOTO @ERR
  WHEN #TKN_ENDLOOP
   PARSER_ENDLOOP_WITHOUT_LOOP
   GOTO @ERR
  ENDCASE
  PARSER_SYNTAX_ERROR "(STATEMENT)"
  IF T==#TKN_EOF THEN RETURN 0
  @ERR
  LEX_NEXT OUT ,
 ENDLOOP
END
DEF PARSE_ASSIGN_EXPR()
 VAR AST=NEW_AST(#AST_ASSIGN)
 VAR EXPR=PARSE_EXPR()
 VAR T,V
 LEX_CUR OUT T,V
 IF T!=#TKN_ASSIGN THEN
  PARSER_SYNTAX_ERROR "EXPECTED '='(ASSIGN)"
  RETURN AST
 ENDIF
 RETURN PARSE_ASSIGN(AST,EXPR)
END
DEF PARSE_DEFOUT()
 VAR AST=NEW_AST(#AST_DEFOUT)
 IF!PARSER_IN_FUNC THEN
  CANT_USE_OUTSIDE_DEF "DEFOUT"
 ENDIF
 VAR T,V
 LEX_NEXT OUT ,
 AST_A1[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T!=#TKN_COMMA THEN
  PARSER_SYNTAX_ERROR "EXPECTED ','"
  RETURN AST
 ENDIF
 LEX_NEXT OUT ,
 AST_A2[AST]=PARSE_EXPR()
 RETURN AST
END
DEF PARSE_EXEC()
 VAR AST=NEW_AST(#AST_EXEC)
 VAR T,V
 LEX_NEXT OUT ,
 AST_A1[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T!=#TKN_COMMA THEN
  RETURN AST
 ENDIF
 LEX_NEXT OUT ,
 AST_A2[AST]=PARSE_EXPR()
 RETURN AST
END
DEF PARSE_INPUT()
 VAR AST=NEW_AST(#AST_INPUT)
 VAR T,V
 LEX_NEXT OUT ,
 VAR GUIDE_EXPR=PARSE_EXPR()
 AST_A1[AST]=GUIDE_EXPR
 LEX_CUR OUT T,V
 VAR ITEM=NEW_AST(#AST_ITEM)
 VAR P=ITEM
 VAR FIRST=ITEM
 AST_A2[AST]=ITEM
 IF T==#TKN_SEMI THEN
  AST_A3[AST]=#TRUE
 ELSEIF T==#TKN_COMMA THEN
  AST_A3[AST]=#FALSE
  IF AST_TYP[GUIDE_EXPR]!=#AST_IMM_STR THEN
   AST_A1[AST]=0
   ITEM=NEW_AST(#AST_ITEM)
   AST_NEXT[P]=ITEM
   AST_PREV[ITEM]=P
   P=ITEM
   AST_A1[ITEM]=GUIDE_EXPR
  ENDIF
 ELSE
  AST_A1[AST]=0
  ITEM=NEW_AST(#AST_ITEM)
  AST_NEXT[P]=ITEM
  AST_PREV[ITEM]=P
  P=ITEM
  AST_A1[ITEM]=GUIDE_EXPR
  AST_PREV[FIRST]=P
  RETURN AST
 ENDIF
 LOOP
  LEX_NEXT OUT ,
  VAR EXPR=PARSE_EXPR()
  ITEM=NEW_AST(#AST_ITEM)
  AST_NEXT[P]=ITEM
  AST_PREV[ITEM]=P
  P=ITEM
  AST_A1[ITEM]=EXPR
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN
   BREAK
  ENDIF
 ENDLOOP
 AST_PREV[FIRST]=P
 RETURN AST
END
DEF PARSE_LINPUT()
 VAR AST=NEW_AST(#AST_LINPUT)
 LEX_NEXT OUT ,
 VAR EXPR=PARSE_EXPR()
 VAR T,V
 LEX_CUR OUT T,V
 IF T==#TKN_SEMI THEN
  LEX_NEXT OUT ,
  AST_A1[AST]=EXPR
  AST_A2[AST]=PARSE_EXPR()
 ELSE
  AST_A2[AST]=EXPR
 ENDIF
 RETURN AST
END
DEF PARSE_SWAP()
 VAR AST=NEW_AST(#AST_SWAP)
 LEX_NEXT OUT ,
 AST_LEFT[AST]=PARSE_EXPR()
 VAR T,V
 LEX_CUR OUT T,V
 IF T!=#TKN_COMMA THEN
  PARSER_SYNTAX_ERROR "EXPECTED ','"
  RETURN AST
 ENDIF
 LEX_NEXT OUT ,
 AST_RIGHT[AST]=PARSE_EXPR()
 RETURN AST
END
DEF PARSE_CASE()
 VAR AST=NEW_AST(#AST_CASE)
 VAR T,V
 LEX_NEXT OUT ,
 AST_A1[AST]=PARSE_EXPR()
 VAR ITEM=NEW_AST(#AST_ITEM)
 VAR P=ITEM
 AST_A2[AST]=ITEM
 VAR HAS_OTHERWISE
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_COL||T==#TKN_NEWLINE THEN
   LEX_NEXT OUT ,
   CONTINUE
  ENDIF
  IF T==#TKN_WHEN THEN
   IF HAS_OTHERWISE THEN
    PARSER_SYNTAX_ERROR "EXPECTED 'ENDCASE', ':' or '\n'"
   ENDIF
   LEX_NEXT OUT ,
   ITEM=NEW_AST(#AST_ITEM)
   AST_NEXT[P]=ITEM
   P=ITEM
   AST_A1[ITEM]=PARSE_EXPR()
   AST_A2[ITEM]=PARSE_WHEN_STATEMENTS()
  ELSEIF T==#TKN_OTHERWISE THEN
   LEX_NEXT OUT ,
   HAS_OTHERWISE=#TRUE
   ITEM=NEW_AST(#AST_ITEM)
   AST_NEXT[P]=ITEM
   P=ITEM
   AST_A2[ITEM]=PARSE_WHEN_STATEMENTS()
  ELSEIF T==#TKN_ENDCASE THEN
   LEX_NEXT OUT ,
   BREAK
  ELSE
   PARSER_SYNTAX_ERROR "EXPECTED 'WHEN', 'OTHERWISE', 'ENDCASE', ':' or '\n'"
  ENDIF
 ENDLOOP
 RETURN AST
END

DEF PARSE_WHEN_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_ENDCASE THEN RETURN ROOT
  IF T==#TKN_WHEN THEN RETURN ROOT
  IF T==#TKN_OTHERWISE THEN RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'WEND', 'ENDCASE' or 'OTHERWISE', but EOF"
   RETURN ROOT
  ENDIF
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_INC()
 VAR T,V,AST
 LEX_CUR OUT T,V
 IF T==#TKN_INC THEN
  AST=NEW_AST(#AST_INC)
 ELSE
  AST=NEW_AST(#AST_DEC)
 ENDIF
 LEX_NEXT OUT ,
 AST_LEFT[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T==#TKN_COMMA THEN
  LEX_NEXT OUT ,
  AST_RIGHT[AST]=PARSE_EXPR()
 ENDIF
 RETURN AST
END
DEF PARSE_READ()
 VAR T,V
 VAR AST=NEW_AST(#AST_READ)
 VAR P=NEW_AST(#AST_ITEM)
 AST_A1[AST]=P
 LOOP
  LEX_NEXT OUT ,
  VAR EXPR=PARSE_EXPR()
  VAR ITEM=NEW_AST(#AST_ITEM)
  AST_A1[ITEM]=EXPR
  AST_NEXT[P]=ITEM
  P=ITEM
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN
   BREAK
  ENDIF
 ENDLOOP
 RETURN AST
END
DEF PARSE_IDEN()
 VAR T,NAME$,V
 VAR AST=NEW_AST(#AST_CALLFUNC)
 LEX_CUR OUT T,NAME$
 IF NAME$=="OPTION"THEN
  RETURN PARSE_OPTION(AST)
 ELSEIF NAME$=="STOP"THEN
  RETURN PARSE_STOP(AST)
 ENDIF
 VAR SI,SPI,SPI2,ST,SV,SL,SP,SPL,SPP
 LEX_SAVE OUT SI,SPI,SPI2,ST,SV,SL,SP,SPL,SPP
 VAR EXPR=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T==#TKN_ASSIGN THEN
  RETURN PARSE_ASSIGN(AST,EXPR)
 ELSE
  LEX_LOAD SI,SPI,SPI2,ST,SV,SL,SP,SPL,SPP
  RETURN PARSE_CALLFUNC(AST,NAME$,#TRUE)
 ENDIF
 'IDEN=EXPR
 'IDEN [EXPR,EXPR...] [OUT REF-EXPR...]
END
DEF PARSE_STOP(AST)
 AST_TYP[AST]=#AST_STOP
 VAR T,V
 LEX_NEXT OUT T,V
 IF IS_EXPR_TKN(T)THEN
  AST_A1[AST]=PARSE_EXPR()
 ENDIF
 RETURN AST
END
DEF PARSE_OPTION(AST)
 VAR T,V
 LEX_NEXT OUT T,V
 IF T==#TKN_IDEN&&TO_UPPER$(V)=="STRICT"THEN
  LEX_NEXT OUT T,V
  AST_TYP[AST]=#AST_OPTIONSTRICT
  RETURN AST
 ELSEIF T==#TKN_IDEN&&TO_UPPER$(V)=="DEFINT"THEN
  LEX_NEXT OUT T,V
  AST_TYP[AST]=#AST_OPTIONDEFINT
  RETURN AST
 ENDIF
 PARSER_SYNTAX_ERROR "EXPECTED 'STRICT' or 'DEFINT' (OPTION)"
END
DEF PARSE_RESTORE()
 VAR T,V,AST
 LEX_NEXT OUT T,V
 IF T==#TKN_LABEL THEN
  AST=NEW_AST(#AST_RESTORE)
  AST$[AST]=V
  LEX_NEXT OUT T,V
 ELSEIF IS_EXPR_TKN(T) THEN
  AST=NEW_AST(#AST_RESTOREEXPR)
  AST_LEFT[AST]=PARSE_EXPR()
 ELSE
  AST=NEW_AST(#AST_RESTORE)
 ENDIF
 RETURN AST
END
DEF PARSE_CALL()
 VAR T,V
 VAR AST=NEW_AST(#AST_CALLFUNC)
 LEX_NEXT OUT T,V
 IF T==#TKN_IDEN&&TO_UPPER$(V)=="SPRITE"THEN
  LEX_NEXT OUT T,V
  AST_TYP[AST]=#AST_CALLSPRITE
  RETURN AST
 ELSEIF T==#TKN_IDEN&&TO_UPPER$(V)=="TEXT"THEN
  LEX_NEXT OUT T,V
  AST_TYP[AST]=#AST_CALLTEXT
  RETURN AST
 ELSE
  RETURN PARSE_CALLFUNC(AST,"CALL",#FALSE)
 ENDIF
END
DEF PARSE_CALLFUNC(AST,NAME$,NXT)
 VAR T,V
 'A1:IN ARGS
 'A2:OUT ARGS
 VAR P=NEW_AST(#AST_ITEM)
 AST_A1[AST]=P
 AST$[AST]=NAME$
 VAR FIRST=P
 IF TRACE THEN ?"callfunc",NAME$
 VAR FRST=#TRUE,ITEM
 VAR EXPR
 LOOP
  IF NXT THEN
   LEX_NEXT OUT T,V
  ELSE
   LEX_CUR OUT T,V
   NXT=#TRUE
  ENDIF
  IF T==#TKN_COMMA THEN
   EXPR=NEW_AST(#AST_EMPTYEXPR)
  ELSEIF!IS_EXPR_TKN(T) THEN
   IF !FRST THEN
    EXPR=NEW_AST(#AST_EMPTYEXPR)
    ITEM=NEW_AST(#AST_ITEM)
    AST_PREV[ITEM]=P
    AST_A1[ITEM]=EXPR
    AST_NEXT[P]=ITEM
    P=ITEM
   ENDIF
   BREAK
  ELSE
   EXPR=PARSE_EXPR()
  ENDIF
  FRST=#FALSE
  ITEM=NEW_AST(#AST_ITEM)
  AST_A1[ITEM]=EXPR
  AST_PREV[ITEM]=P
  AST_NEXT[P]=ITEM
  LEX_CUR OUT T,V
  P=ITEM
  IF T!=#TKN_COMMA THEN
   BREAK
  ENDIF
 ENDLOOP
 AST_PREV[FIRST]=P
 IF T!=#TKN_OUT THEN
  AST_SET_POS_END AST
  RETURN AST
 ENDIF
 P=NEW_AST(#AST_ITEM)
 AST_A2[AST]=P
 FIRST=P
 FRST=#TRUE
 LOOP
  IF NXT THEN
   LEX_NEXT OUT T,V
  ELSE
   LEX_CUR OUT T,V
   NXT=#TRUE
  ENDIF
  IF T==#TKN_COMMA THEN
   EXPR=NEW_AST(#AST_EMPTYEXPR)
  ELSEIF!IS_EXPR_TKN(T) THEN
   IF !FRST THEN
    EXPR=NEW_AST(#AST_EMPTYEXPR)
    ITEM=NEW_AST(#AST_ITEM)
    AST_PREV[ITEM]=P
    AST_A1[ITEM]=EXPR
    AST_NEXT[P]=ITEM
    P=ITEM
   ENDIF
   BREAK
  ELSE
   EXPR=PARSE_EXPR()
  ENDIF
  FRST=#FALSE
  ITEM=NEW_AST(#AST_ITEM)
  AST_A1[ITEM]=EXPR
  AST_PREV[ITEM]=P
  AST_NEXT[P]=ITEM
  LEX_CUR OUT T,V
  P=ITEM
  IF T!=#TKN_COMMA THEN
   BREAK
  ENDIF
 ENDLOOP
 AST_SET_POS_END AST
 AST_PREV[FIRST]=P
 RETURN AST
END
DEF PARSE_ASSIGN(AST,EXPR)
 AST_TYP[AST]=#AST_ASSIGN
 LEX_NEXT OUT ,
 AST_LEFT[AST]=EXPR
 IF TRACE THEN ?"assign
 AST_RIGHT[AST]=PARSE_EXPR()
 AST_SET_POS_END AST
 RETURN AST
END
DEF PARSE_IF()
 VAR AST=NEW_AST(#AST_IF)
 LEX_NEXT OUT ,
 VAR EXPR=PARSE_EXPR()
 VAR T,V
 LEX_CUR OUT T,V
 CASE T
 WHEN #TKN_GOTO
  AST_SET_POS_END AST
  RETURN PARSE_MULTILINE_IF(AST,EXPR,#FALSE)
 WHEN #TKN_THEN
  LEX_NEXT OUT T,V
  AST_SET_POS_END AST
  IF T==#TKN_NEWLINE THEN
   RETURN PARSE_MULTILINE_IF(AST,EXPR,#TRUE)
  ENDIF
  RETURN PARSE_MULTILINE_IF(AST,EXPR,#FALSE)
 OTHERWISE
  PARSER_SYNTAX_ERROR "EXPECTED 'THEN' or 'GOTO'"
 ENDCASE
END
DEF PARSE_MULTILINE_IF(AST,EXPR,MULT)
 VAR THENSTMTS=PARSE_MULTILINE_IF_STATEMENTS(MULT)
 VAR T,V
 AST_A1[AST]=EXPR
 AST_A2[AST]=THENSTMTS
 LEX_CUR OUT T,V
 LEX_NEXT OUT ,
 IF !MULT&&T==#TKN_NEWLINE THEN
  RETURN AST
 ENDIF
 IF T==#TKN_ENDIF THEN
  RETURN AST
 ENDIF
 IF T==#TKN_ELSE THEN
  AST_A4[AST]=PARSE_MULTILINE_ELSE_STATEMENTS(MULT)
  LEX_NEXT OUT ,
  RETURN AST
 ENDIF
 IF T==#TKN_ELSEIF THEN
  IF !MULT THEN
   LEX_NEXT OUT ,
  ENDIF
  VAR P=NEW_AST(#AST_ITEM)
  AST_A3[AST]=P
  LOOP
   VAR ELIFEXPR=PARSE_EXPR()
   LEX_CUR OUT T,V
   IF T!=#TKN_THEN THEN
    PARSER_SYNTAX_ERROR "EXPECTED 'THEN'"
    RETURN AST
   ENDIF
   LEX_NEXT OUT ,
   VAR ELIFSTMTS=PARSE_MULTILINE_IF_STATEMENTS(MULT)
   VAR ITEM=NEW_AST(#AST_ITEM)
   AST_A1[ITEM]=ELIFEXPR
   AST_A2[ITEM]=ELIFSTMTS
   AST_NEXT[P]=ITEM
   P=ITEM
   LEX_CUR OUT T,V
   LEX_NEXT OUT ,
   IF !MULT&&T==#TKN_NEWLINE THEN
    RETURN AST
   ENDIF
   IF T==#TKN_ENDIF THEN
    RETURN AST
   ENDIF
   IF T==#TKN_ELSE THEN
    AST_A4[AST]=PARSE_MULTILINE_ELSE_STATEMENTS(MULT)
    LEX_NEXT OUT ,
    RETURN AST
   ENDIF
  ENDLOOP
  RETURN AST
 ENDIF
 PARSER_SYNTAX_ERROR "EXPECTED 'ENDIF', 'ELSE' or 'ELSEIF'"
 RETURN AST
END
DEF PARSE_MULTILINE_IF_STATEMENTS(MULT)
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LEX_CUR OUT T,V
 VAR S
 IF !MULT&&T==#TKN_LABEL THEN
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=NEW_AST_STR(#AST_GOTO,V)
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
  LEX_NEXT OUT ,
 ENDIF
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE&&!MULT THEN RETURN ROOT
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_ENDIF THEN RETURN ROOT
  IF T==#TKN_ELSE THEN RETURN ROOT
  IF T==#TKN_ELSEIF THEN RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'ENDIF', 'ELSE' or 'ELSEIF'"
   RETURN ROOT
  ENDIF
  S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_MULTILINE_ELSE_STATEMENTS(MULT)
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 VAR S
 IF !MULT&&T==#TKN_LABEL THEN
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=NEW_AST_STR(#AST_GOTO,V)
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
  LEX_NEXT OUT ,
 ENDIF
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE&&!MULT THEN RETURN ROOT
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_ENDIF THEN RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'ENDIF'"
   RETURN ROOT
  ENDIF
  S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_FOR_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_NEXT THEN RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'NEXT'"
   RETURN ROOT
  ENDIF
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_FOR()
 'A1:INDEXREFEXPR
 'A2:INITEXPR
 'A3:TOEXPR
 'A4:STEPEXPR
 'A5:STATEMENTS
 VAR T,V
 VAR AST=NEW_AST(#AST_FOR)
 LEX_NEXT OUT ,
 'REFEXPR
 AST_A1[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T!=#TKN_ASSIGN THEN
  PARSER_SYNTAX_ERROR "EXPECTED '='"
 ENDIF
 LEX_NEXT OUT ,
 'INITEXPR
 AST_A2[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T!=#TKN_IDEN||V!="TO" THEN
  PARSER_SYNTAX_ERROR "EXPECTED 'TO'"
 ENDIF
 LEX_NEXT OUT ,
 'TOEXPR
 AST_A3[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T==#TKN_IDEN&&V=="STEP" THEN
  LEX_NEXT OUT ,
  'STEPEXPR
  AST_A4[AST]=PARSE_EXPR()
 ENDIF
 AST_SET_POS_END AST
 AST_A5[AST]=PARSE_FOR_STATEMENTS()
 LEX_NEXT OUT T,V
 'NEXT [IDEN]
 'NEXT IDEN1,IDEN2 NOT ALLOWED
 IF T==#TKN_IDEN THEN LEX_NEXT OUT ,
 RETURN AST
END

DEF PARSE_WHILE()
 VAR AST=NEW_AST(#AST_WHILE)
 VAR T,V
 LEX_NEXT OUT ,
 AST_A1[AST]=PARSE_EXPR()
 AST_A2[AST]=PARSE_WHILE_STATEMENTS()
 RETURN AST
END
DEF PARSE_WHILE_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_WEND THEN LEX_NEXT OUT,:RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'WEND'"
   RETURN ROOT
  ENDIF
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END

DEF PARSE_REPEAT()
 VAR AST=NEW_AST(#AST_REPEAT)
 VAR T,V
 LEX_NEXT OUT ,
 AST_A2[AST]=PARSE_REPEAT_STATEMENTS()
 AST_A1[AST]=PARSE_EXPR()
 RETURN AST
END
DEF PARSE_REPEAT_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_UNTIL THEN LEX_NEXT OUT ,:RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'UNTIL'"
   RETURN ROOT
  ENDIF
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_LOOP()
 VAR AST=NEW_AST(#AST_LOOP)
 VAR T,V
 LEX_NEXT OUT ,
 AST_A2[AST]=PARSE_LOOP_STATEMENTS()
 RETURN AST
END
DEF PARSE_LOOP_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_ENDLOOP THEN LEX_NEXT OUT ,:RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'ENDLOOP'"
   RETURN ROOT
  ENDIF
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_LABEL()
 VAR T,V
 LEX_CUR OUT T,V
 LEX_NEXT OUT ,
 VAR AST=NEW_AST(#AST_LABEL)
 AST$[AST]=V
 RETURN AST
END
DEF PARSE_GOTO()
 VAR T,V,AST
 AST=NEW_AST(#AST_GOTO)
 LEX_NEXT OUT T,V
 IF T==#TKN_LABEL THEN
  AST$[AST]=V
  LEX_NEXT OUT T,V
  AST_SET_POS_END AST
 ELSE
  AST_TYP[AST]=#AST_GOTOEXPR
  AST_LEFT[AST]=PARSE_EXPR()
  AST_SET_POS_END AST
 ENDIF
 RETURN AST
END
DEF PARSE_GOSUB()
 VAR T,V,AST
 AST=NEW_AST(#AST_GOSUB)
 LEX_NEXT OUT T,V
 IF T==#TKN_LABEL THEN
  AST$[AST]=V
  LEX_NEXT OUT T,V
  AST_SET_POS_END AST
 ELSE
  AST_TYP[AST]=#AST_GOSUBEXPR
  AST_LEFT[AST]=PARSE_EXPR()
  AST_SET_POS_END AST
 ENDIF
 RETURN AST
END
DEF PARSE_ON()
 VAR T,V,AST
 LEX_NEXT OUT T,V
 IF T==#TKN_BREAK THEN
  LEX_NEXT OUT T,V
  IF T==#TKN_LABEL THEN
   AST=NEW_AST(#AST_ONBREAKGOTO)
   AST$[AST]=V
  ELSE
   AST=NEW_AST(#AST_ONBREAKGOTOEXPR)
   AST_LEFT[AST]=PARSE_EXPR()
  ENDIF
 ELSE
  VAR EXPR=PARSE_EXPR()
  LEX_CUR OUT T,V
  IF T==#TKN_GOTO THEN
   AST=NEW_AST(#AST_ONGOTO)
  ELSEIF T==#TKN_GOSUB THEN
   AST=NEW_AST(#AST_ONGOSUB)
  ELSE
   PARSER_SYNTAX_ERROR "EXPECTED 'GOTO' or 'GOSUB'(ON GOTO)"
   RETURN AST
  ENDIF
  AST_A1[AST]=EXPR
  VAR P=NEW_AST(#AST_ITEM)
  AST_A2[AST]=P
  LOOP
   LEX_NEXT OUT T,V
   IF T!=#TKN_LABEL THEN
    PARSER_SYNTAX_ERROR "EXPECTED @LABEL(ON GOTO)"
    RETURN AST
   ENDIF
   VAR ITEM=NEW_AST(#AST_ITEM)
   AST$[ITEM]=V
   AST_NEXT[P]=ITEM
   P=ITEM
   LEX_NEXT OUT T,V
   IF T!=#TKN_COMMA THEN BREAK
  ENDLOOP
 ENDIF
 RETURN AST
END
DEF PARSE_RETURN()
 VAR AST
 IF PARSER_IN_FUNC THEN
  AST=NEW_AST(#AST_RETURNFUNC)
 ELSE
  AST=NEW_AST(#AST_RETURN)
 ENDIF
 VAR T,V
 LEX_NEXT OUT T,V
 IF IS_EXPR_TKN(T)&&PARSER_RETURN_EXPR THEN
  AST_LEFT[AST]=PARSE_EXPR()
 ENDIF
 AST_SET_POS_END AST
 RETURN AST
END
DEF PARSE_DATA()
 VAR AST=NEW_AST(#AST_DATA)
 VAR T,V
 VAR P=NEW_AST(#AST_ITEM)
 AST_A1[AST]=P
 LOOP
  LEX_NEXT OUT ,
  VAR EXPR=PARSE_EXPR()
  VAR ITEM=NEW_AST(#AST_ITEM)
  AST_A1[ITEM]=EXPR
  AST_NEXT[P]=ITEM
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN BREAK
  P=ITEM
 ENDLOOP
 RETURN AST
END
DEF PARSE_ARRAY_INDEX()
 VAR T,V
 VAR P=NEW_AST(#AST_ITEM)
 VAR R=P
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_RB THEN
   LEX_NEXT OUT T,V
   BREAK
  ENDIF
  IF TRACE THEN ?"PARSE_ARRAY_INDEX==
  VAR EXPR=PARSE_EXPR()
  IF TRACE THEN ?"PARSE_ARRAY_INDEX==~~
  VAR ITEM=NEW_AST(#AST_ITEM)
  AST_A1[ITEM]=EXPR
  AST_NEXT[P]=ITEM
  AST_PREV[ITEM]=P
  P=ITEM
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN
   IF T==#TKN_RB THEN
    LEX_NEXT OUT T,V
   ELSE
    PARSER_SYNTAX_ERROR "EXPECTED ']'"
   ENDIF
   BREAK
  ENDIF
  LEX_NEXT OUT T,V
 ENDLOOP
 AST_PREV[R]=P
 RETURN R
END
DEF PARSE_VAR()
 VAR T,V
 VAR SI,SPI,SPI2,ST,SV,SL,SP,SPL,SPP
 LEX_SAVE OUT SI,SPI,SPI2,ST,SV,SL,SP,SPL,SPP
 LEX_CUR OUT T,V
 VAR AST
 VAR VAR_
 VAR CONST_
 CASE T
 WHEN #TKN_DIM
 WHEN #TKN_VAR
  AST=NEW_AST(#AST_DEFVAR)
  VAR_=#TRUE
 WHEN #TKN_CONST
  AST=NEW_AST(#AST_CONST)
  CONST_=#TRUE
 WHEN #TKN_ENUM
  AST=NEW_AST(#AST_ENUM)
 ENDCASE
 'VAR IDEN[\[EXPR[,EXPR[,EXPR[,EXPR]]]\]](=EXPR|=\[EXPR...\]|)...
 'DIM ARY[N]=[]'TYPEMISMATCH
 LEX_NEXT OUT T,V
 IF T==#TKN_LP THEN
  LEX_LOAD SI,SPI,SPI2,ST,SV,SL,SP,SPL,SPP
  RETURN PARSE_ASSIGN(AST,PARSE_EXPR())
 ENDIF
 VAR P=NEW_AST(#AST_ITEM)
 AST_A1[AST]=P
 VAR HAS
 LOOP
  IF VAR_&&T!=#TKN_IDEN THEN
   'VAR HA KETSU COMMA OK
   IF HAS THEN
    BREAK
   ENDIF
   PARSER_SYNTAX_ERROR "EXPECTED IDENTIFIER(VAR)"
   RETURN AST
  ENDIF
  HAS=#TRUE
  IF !VAR_&&T!=#TKN_CONSTVAR THEN
   PARSER_SYNTAX_ERROR "EXPECTED IDENTIFIER(CONST/ENUM)"
   RETURN AST
  ENDIF
  VAR ITEM=NEW_AST(#AST_ITEM)
  AST_NEXT[P]=ITEM
  AST$[ITEM]=V
  P=ITEM
  '$:NAME
  'A1:INIT EXPR
  'A2:ARRAY DIM
  'A3:ARRAY INIT LIST
  LEX_NEXT OUT T,V
  IF VAR_&&T==#TKN_LB THEN
   'DEFINE ARRAY
   LEX_NEXT OUT T,V
   AST_A2[ITEM]=PARSE_ARRAY_INDEX()
   IF TRACE THEN ?"END ARRAY INDEX INIT"
   LEX_CUR OUT T,V
  ENDIF
  IF T==#TKN_ASSIGN THEN
   LEX_NEXT OUT T,V
   'INIT ARRAY
   IF VAR_&&T==#TKN_LB THEN
    LEX_NEXT OUT T,V
    AST_A3[ITEM]=PARSE_ARRAY_INDEX()
    LEX_CUR OUT T,V
   ELSE
    AST_A1[ITEM]=PARSE_EXPR()
   ENDIF
  ELSEIF CONST_ THEN
   PARSER_SYNTAX_ERROR "EXPECTED '='(CONST)"
  ENDIF
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN
   BREAK
  ENDIF
  LEX_NEXT OUT T,V
 ENDLOOP
 AST_SET_POS_END AST
 RETURN AST
END
DEF PARSE_DEF_ARG$()
 VAR T,V
 VAR VN$
 LEX_CUR OUT T,V
 IF T!=#TKN_IDEN THEN
  PARSER_SYNTAX_ERROR
  RETURN ""
 ENDIF
 VN$=V
 LEX_NEXT OUT T,V
 IF T==#TKN_LB THEN
  LEX_NEXT OUT T,V
  IF T!=#TKN_RB THEN
   PARSER_SYNTAX_ERROR "EXPECTED ']'(DEF ARGUMENT)"
  ENDIF
  LEX_NEXT OUT T,V
 ENDIF
 RETURN VN$
END
DEF PARSE_DEF_LIST()
 VAR T,V
 VAR P=NEW_AST(#AST_ITEM)
 VAR R=P
 LOOP
  LEX_CUR OUT T,V
  IF T!=#TKN_IDEN THEN
   BREAK
  ENDIF
  VAR V$=PARSE_DEF_ARG$()
  VAR ITEM=NEW_AST(#AST_ITEM)
  AST$[ITEM]=V$
  AST_NEXT[P]=ITEM
  AST_PREV[ITEM]=P
  P=ITEM
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN
   BREAK
  ENDIF
  LEX_NEXT OUT T,V
 ENDLOOP
 AST_PREV[R]=P
 RETURN R
END
CONST #AST_DEF_A4_HAS_RET_VAL=&B0000001
CONST #AST_DEF_A4_IN_VAARGS  =&B0000010
CONST #AST_DEF_A4_OUT_VAARGS =&B0000100
CONST #AST_DEF_A4_COMMON_DEF =&B0001000
DEF PARSE_DEF()
 'DEF IDEN ([IDEN[\[\]]...]|*) OUT ([IDEN[\[\]]...]|*)
 VAR AST=NEW_AST(#AST_DEF)
 '$:NAME
 'A1:IN LIST
 'A2:OUT LIST
 'A3:STATEMENTS
 'A4:FLGS
 VAR T,V
 LEX_CUR OUT T,V
 IF T==#TKN_COMMON THEN
  AST_A4[AST]=AST_A4[AST]OR #AST_DEF_A4_COMMON_DEF
  LEX_NEXT OUT T,V
  IF T!=#TKN_DEF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'DEF'(COMMON DEF)"
   RETURN AST
  ENDIF
 ENDIF
 LEX_NEXT OUT T,V
 IF PARSER_IN_FUNC THEN
  NESTED_DEF
 ENDIF
 PARSER_IN_FUNC=#TRUE
 AST$[AST]=PARSE_DEF_ARG$()
 LEX_CUR OUT T,V
 IF T==#TKN_LP THEN
  PARSER_RETURN_EXPR=#TRUE
  LEX_NEXT OUT T,V
 ENDIF
 IF T==#TKN_MUL THEN
  AST_A4[AST]=AST_A4[AST]OR #AST_DEF_A4_IN_VAARGS
  LEX_NEXT OUT ,
 ELSE
  AST_A1[AST]=PARSE_DEF_LIST()
 ENDIF
 LEX_CUR OUT T,V
 IF PARSER_RETURN_EXPR THEN
  AST_A4[AST]=AST_A4[AST]OR #AST_DEF_A4_HAS_RET_VAL
  IF T!=#TKN_RP THEN
   PARSER_SYNTAX_ERROR "EXPECTED ')'(DEF)"
  ELSE
   LEX_NEXT OUT ,
  ENDIF
 ELSE
  LEX_CUR OUT T,V
  IF T==#TKN_OUT THEN
   LEX_NEXT OUT T,V
   IF T==#TKN_MUL THEN
    AST_A4[AST]=AST_A4[AST]OR #AST_DEF_A4_OUT_VAARGS
    LEX_NEXT OUT ,
   ELSE
    AST_A2[AST]=PARSE_DEF_LIST()
    IF !AST_NEXT[AST_A2[AST]]THEN
     PARSER_SYNTAX_ERROR "EXPECTED PARAMETER(DEF OUT)"
    ENDIF
   ENDIF
  ENDIF
 ENDIF
 AST_A3[AST]=PARSE_DEF_STATEMENTS()
 PARSER_IN_FUNC=#FALSE
 PARSER_RETURN_EXPR=#FALSE
 RETURN AST
END

DEF PARSE_DEF_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V,S
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_EOF THEN PARSER_SYNTAX_ERROR:RETURN ROOT
  IF T==#TKN_END THEN
   S=NEW_AST(#AST_RETURNFUNC)
   LEX_NEXT OUT ,
  ELSE
   S=PARSE_STATEMENT()
  ENDIF
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
  IF T==#TKN_END THEN
   RETURN ROOT
  ENDIF
 ENDLOOP
END
DEF PARSE_END()
 VAR AST=NEW_AST(#AST_END)
 LEX_NEXT OUT ,
 RETURN AST
END
DEF IS_EXPR_TKN(T)
 CASE T
 WHEN #TKN_NUM
 WHEN #TKN_STR
 WHEN #TKN_IDEN
 WHEN #TKN_LP
 WHEN #TKN_MINUS
 WHEN #TKN_NOT
 WHEN #TKN_LNOT
 WHEN #TKN_LABEL
 WHEN #TKN_CONSTVAR
 WHEN #TKN_VAR
 WHEN #TKN_DIM
  RETURN #TRUE
 ENDCASE
 RETURN #FALSE
END
DEF PARSE_PRINT(TPRNT)
 VAR T,V
 VAR AST
 IF TPRNT THEN
  AST=NEW_AST(#AST_TPRINT)
 ELSE
  AST=NEW_AST(#AST_PRINT)
 ENDIF
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[AST]=PRV
 LEX_NEXT OUT T,V
 IF !IS_EXPR_TKN(T)THEN
  IF TRACE THEN ?"PRINT_E"
  RETURN AST
 ENDIF
 WHILE 1
  VAR EXPR=PARSE_EXPR()
  LEX_CUR OUT T,V
  VAR A
  IF T==#TKN_COMMA THEN
   IF TRACE THEN ?"PRINT_COMMA"
   A=NEW_AST(#AST_PRINT_EXPR_COMMA)
   LEX_NEXT OUT ,
  ELSEIF T==#TKN_SEMI THEN
   IF TPRNT&&AST_LEFT[AST]==PRV THEN
    PARSER_SYNTAX_ERROR "EXPECTED ','(TPRINT)"
   ENDIF
   IF TRACE THEN ?"PRINT_SEMI"
   A=NEW_AST(#AST_PRINT_EXPR_SEMI)
   LEX_NEXT OUT ,
  ELSE
   IF TRACE THEN ?"PRINT"
   A=NEW_AST(#AST_PRINT_EXPR_NEWLINE)
  ENDIF
  AST_LEFT[A]=EXPR
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
  IF T!=#TKN_COMMA&&T!=#TKN_SEMI THEN
   AST_SET_POS_END AST
   RETURN AST
  ENDIF
  LEX_CUR OUT T,V
  IF !IS_EXPR_TKN(T)THEN
   AST_SET_POS_END AST
   RETURN AST
  ENDIF
 WEND
END

ENUM\
 #OPRANK_NOTANOP,\
 #OPRANK_MIN,\
 #OPRANK_PARENT,\
 #OPRANK_UNA,\
 #OPRANK_MUL,\
 #OPRANK_PLUS,\
 #OPRANK_SHIFT,\
 #OPRANK_EQ,\
 #OPRANK_BIT,\
 #OPRANK_LOG,\
 #OPRANK_MAX
DEF GET_OP_RANK(T)
 CASE T
 WHEN #TKN_LP
 WHEN #TKN_LB
  RETURN #OPRANK_PARENT
 WHEN #TKN_MUL
 WHEN #TKN_DIV
 WHEN #TKN_DIVINT
 WHEN #TKN_MOD
  RETURN #OPRANK_MUL
 WHEN #TKN_PLUS
 WHEN #TKN_MINUS
  RETURN #OPRANK_PLUS
 WHEN #TKN_LSHIFT
 WHEN #TKN_RSHIFT
  RETURN #OPRANK_SHIFT
 WHEN #TKN_EQ
 WHEN #TKN_NEQ
 WHEN #TKN_LESS
 WHEN #TKN_LEQ
 WHEN #TKN_GREAT
 WHEN #TKN_GEQ
  RETURN #OPRANK_EQ
 WHEN #TKN_AND
 WHEN #TKN_OR
 WHEN #TKN_XOR
  RETURN #OPRANK_BIT
 WHEN #TKN_LAND
 WHEN #TKN_LOR
  RETURN #OPRANK_LOG
 ENDCASE
 RETURN #OPRANK_NOTANOP
END
DEF PARSE_TERM()
 VAR T,V
 LEX_CUR OUT T,V
 VAR AST
 CASE T
 WHEN #TKN_LNOT
 WHEN #TKN_NOT
 WHEN #TKN_MINUS
  AST=NEW_AST(#AST_UNAOP)
  LEX_NEXT OUT ,
  AST%[AST]=T
  AST_LEFT[AST]=PARSE_EXPR0(#OPRANK_UNA)
  IF TRACE THEN ?"UNARY"
 'FIXME:EXPND CONST EXPR
 WHEN #TKN_NUM
  IF TRACE THEN ?"IMM",V
  IF TYPEOF(V)==#T_INT THEN
   AST=NEW_AST_INT(#AST_IMM_INT,V)
   LEX_NEXT OUT ,
  ELSEIF TYPEOF(V)==#T_REAL THEN
   AST=NEW_AST_DBL(#AST_IMM_DBL,V)
   LEX_NEXT OUT ,
  ELSE
  STOP
  ENDIF
 WHEN #TKN_LABEL
 WHEN #TKN_STR
  IF TRACE THEN ?"IMM",V
  AST=NEW_AST_STR(#AST_IMM_STR,V)
  LEX_NEXT OUT ,
 WHEN #TKN_CONSTVAR
  IF TRACE THEN ?"CONSTVAR",V
  AST=NEW_AST_STR(#AST_CONSTVAR,V)
  LEX_NEXT OUT ,
 WHEN #TKN_VAR
  VAR T2,V2
  AST=NEW_AST(#AST_VAREXPR)
  LEX_NEXT OUT T2,V2
  IF T2==#TKN_LP THEN
   LEX_NEXT OUT ,
   AST_LEFT[AST]=PARSE_EXPR()
   LEX_CUR OUT T2,V2
   IF T2==#TKN_RP THEN
    LEX_NEXT OUT ,
   ELSE
    PARSER_SYNTAX_ERROR "EXPECTED '('(VAR())"
   ENDIF
  ELSE
   PARSER_SYNTAX_ERROR "EXPECTED '('(VAR())"
  ENDIF
 
 WHEN #TKN_DIM
  LEX_NEXT OUT T2,V2
  IF T2==#TKN_LP THEN
   AST=PARSE_CALLFUNCEXPR("DIM")
  ELSE
   PARSER_SYNTAX_ERROR "EXPECTED '('(DIM())"
  ENDIF
 WHEN #TKN_IDEN
  LEX_NEXT OUT T2,V2
  IF T2==#TKN_LP THEN
   AST=PARSE_CALLFUNCEXPR(V)
  ELSE
   IF TRACE THEN ?"VAR",V
   AST=NEW_AST_STR(#AST_VAR,V)
  ENDIF
 WHEN #TKN_LP
  LEX_NEXT OUT ,
  AST=PARSE_EXPR()
  LEX_CUR OUT T,V
  IF T!=#TKN_RP THEN
   PARSER_SYNTAX_ERROR "EXPECTED ')'(EXPRESSION)"
  ELSE
   LEX_NEXT OUT ,
  ENDIF
 OTHERWISE
  PARSER_SYNTAX_ERROR "(EXPRESSION)"
  LEX_NEXT OUT ,
 ENDCASE
 RETURN AST
END
DEF PARSE_CALLFUNCEXPR(NAME$)
 VAR AST=NEW_AST_STR(#AST_CALLFUNCEXPR,NAME$)
 VAR T,V
 VAR P=NEW_AST(#AST_ITEM)
 AST_A1[AST]=P
 AST$[AST]=NAME$
 VAR FIRST=P
 LOOP
  LEX_NEXT OUT T,V
  IF T==#TKN_RP THEN
   LEX_NEXT OUT T,V
   BREAK
  ENDIF
  VAR EXPR=PARSE_EXPR()
  VAR ITEM=NEW_AST(#AST_ITEM)
  AST_A1[ITEM]=EXPR
  AST_PREV[ITEM]=P
  AST_NEXT[P]=ITEM
  P=ITEM
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN
   IF T==#TKN_RP THEN
    LEX_NEXT OUT T,V
   ELSE
    PARSER_SYNTAX_ERROR "EXPECTED ')'"
   ENDIF
   BREAK
  ENDIF
 ENDLOOP
 AST_PREV[FIRST]=P
 RETURN AST
END
VAR PPP
DEF PARSE_EXPR()
 RETURN PARSE_EXPR0(#OPRANK_MAX)
END
DEF PARSE_EXPR0(RANK)
 IF RANK==#OPRANK_MIN THEN
  RETURN PARSE_TERM()
 ENDIF
 VAR T,V
 VAR LEFT=PARSE_EXPR0(RANK-1)
 LOOP
  LEX_CUR OUT T,V
  IF GET_OP_RANK(T)==RANK THEN
   LEX_NEXT OUT ,
   VAR RIGHT
   IF T==#TKN_LB THEN
    RIGHT=PARSE_ARRAY_INDEX()
    IF TRACE THEN ?"BINARY OP",TKN_STR$(T)
    LEFT=NEW_AST_LR(#AST_BINOP,LEFT,RIGHT)
    AST%[LEFT]=T
   ELSE
    RIGHT=PARSE_EXPR0(RANK-1)
    IF TRACE THEN ?"BINARY OP",TKN_STR$(T)
    LEFT=NEW_AST_LR(#AST_BINOP,LEFT,RIGHT)
    AST%[LEFT]=T
   ENDIF
   CONTINUE
  ENDIF
  BREAK
 ENDLOOP
 RETURN LEFT
END

DEF PARSER_GET_CURLOC$()
 RETURN " in "+STR$(PARSER_SLOT)+":"+STR$(LEXER_PREV_LINE)+":"+STR$(LEXER_PREV_I2-LEXER_PREV_LINE_POS+1)
END
DEF PARSER_RAISE_ERR2 E1$,E2$
 ?E1$;PARSER_GET_CURLOC$()
 ?E2$
 PARSER_HAS_ERR=#TRUE
END
DEF PARSER_SYNTAX_ERROR *
 VAR I,T,V
 LEX_CUR OUT T,V
 PARSER_RAISE_ERR2 "Syntax error","文法まちがい"
 ?"UNEXPECTED ";TKN_STR$(T)
 FOR I=0TO DEFARGC()-1
  ?DEFARG(I);
 NEXT
 IF DEFARGC() THEN
  ?
 ENDIF
END

DEF PARSER_ENDIF_WITHOUT_IF
 PARSER_RAISE_ERR2 "ENDIF without IF","ENDIFに対応するIFがありません"
END
DEF PARSER_WEND_WITHOUT_WHILE
 PARSER_RAISE_ERR2 "WEND without WHILE","WENDに対応するWHILEがありません"
END
DEF PARSER_UNTIL_WITHOUT_REPEAT
 PARSER_RAISE_ERR2 "UNTIL without REPEAT","UNTILに対応するREPEATがありません"
END
DEF PARSER_ENDCASE_WITHOUT_CASE
 PARSER_RAISE_ERR2 "ENDCASE without CASE","ENDCASEに対応するCASEがありません"
END
DEF PARSER_WHEN_WITHOUT_CASE
 PARSER_RAISE_ERR2 "WHEN without CASE","WHENに対応するCASEがありません"
END
DEF PARSER_ENDLOOP_WITHOUT_LOOP
 PARSER_RAISE_ERR2 "ENDLOOP without LOOP","ENDLOOPに対応するLOOPがありません"
END

ENUM\
 #VMT_DEFAULT,\
 #VMT_INT,\
 #VMT_REAL,\
 #VMT_STR,\
 #VMT_NONE,\
 #VMT_INTARRAY,\
 #VMT_REALARRAY,\
 #VMT_STRARRAY,\
 #VMT_VARREF,\
 #VMT_VARREFSLOT,\
 #VMT_LVARREF,\
 #VMT_EMPTYREF,\
 #VMT_ARYREF,\
 #VMT_SUBROUTINE,\
 #VMT_LAST
DEF VMT_STR$(T)
 CASE T
 WHEN #VMT_DEFAULT:RETURN "#VMT_DEFAULT"WHEN #VMT_INT:RETURN "#VMT_INT"WHEN #VMT_REAL:RETURN "#VMT_REAL"WHEN #VMT_STR:RETURN "#VMT_STR"WHEN #VMT_INTARRAY:RETURN "#VMT_INTARRAY"WHEN #VMT_REALARRAY:RETURN "#VMT_REALARRAY"WHEN #VMT_STRARRAY:RETURN "#VMT_STRARRAY"WHEN #VMT_VARREF:RETURN "#VMT_VARREF"WHEN #VMT_VARREFSLOT:RETURN "#VMT_VARREFSLOT"WHEN #VMT_LVARREF:RETURN "#VMT_LVARREF"WHEN #VMT_EMPTYREF:RETURN "#VMT_EMPTYREF"WHEN #VMT_ARYREF:RETURN "#VMT_ARYREF"WHEN #VMT_SUBROUTINE:RETURN "#VMT_SUBROUTINE"
 OTHERWISE
  RETURN "#VMT_"+STR$(T)
 ENDCASE
END
ENUM\
 #VMPRINT_EMPTY,\
 #VMPRINT_COMMA,\
 #VMPRINT_NEWLINE,\
 #VMPRINT_SEMI

VAR CMP_STRICT
VAR CMP_DEFINT
VAR CMP_GVARTBL
VAR CMP_GLBLTBL
VAR CMP_FUNCTBL
VAR CMP_CONSTTBL
VAR CMP_BCONSTTBL

VAR CMP_GVARNUM

DIM CMP_BREAK[]
DIM CMP_CONTINUE[]
VAR CMP_CURFUNC

DIM FUNC_NAME$[]
DIM FUNC_ADDR[]
'-1:VAARGS
DIM FUNC_INCNT[]
DIM FUNC_OUTCNT[]
DIM FUNC_VARTBL[]
DIM FUNC_LBLTBL[]
DIM FUNC_VARNUM[]
DIM FUNC_SLOT[]
DIM FUNC_COMMON[]
VAR FUNC_FREE

DIM VAR_IDX[]
DIM VAR_TYP[]
VAR VAR_FREE

DIM LABEL_ADDR[]
DIM LABEL_DATA_ADDR[]
VAR LABEL_FREE

DIM CMP_DATA_TYP[]
DIM CMP_DATA%[]
DIM CMP_DATA#[]
DIM CMP_DATA$[]

DIM CMP_CONST_TYP[]
DIM CMP_CONST%[]
DIM CMP_CONST#[]
DIM CMP_CONST$[]
VAR CONST_FREE

VAR CMP_SLOT
VAR CMP_FILENAME$
VAR CMP_HAS_ERR
DEF INIT_COMPILER_VAR
 VAR S=1
 VAR_IDX=ARRAY%(S)
 VAR_TYP=ARRAY%(S)
 VAR_FREE=0
END
DEF NEW_VAR(IDX,TYP)
 IF VAR_FREE THEN
  VAR L=VAR_FREE
  VAR_FREE=VAR_IDX[VAR_FREE]
  VAR_IDX[L]=IDX
  VAR_TYP[L]=TYP
  RETURN L
 ENDIF
 PUSH VAR_IDX,IDX
 PUSH VAR_TYP,TYP
 RETURN LAST(VAR_IDX)
END
DEF DELETE_VAR V
 VAR_IDX[V]=VAR_FREE
 VAR_FREE=V
END
DEF INIT_COMPILER_LABEL
 VAR S=1
 LABEL_ADDR=ARRAY%(S)
 LABEL_DATA_ADDR=ARRAY%(S)
 LABEL_FREE=0
END
DEF NEW_LABEL(ADDR,DADDR)
 IF LABEL_FREE THEN
  VAR L=LABEL_FREE
  LABEL_FREE=LABEL_ADDR[LABEL_FREE]
  LABEL_ADDR[L]=ADDR
  LABEL_DATA_ADDR[L]=DADDR
  RETURN L
 ENDIF
 PUSH LABEL_ADDR,ADDR
 PUSH LABEL_DATA_ADDR,DADDR
 RETURN LAST(LABEL_ADDR)
END
DEF DELETE_LABEL LABEL
 LABEL_ADDR[LABEL]=LABEL_FREE
 LABEL_FREE=LABEL
END
DEF INIT_COMPILER_FUNC
 VAR S=1
 FUNC_NAME$=ARRAY$(S)
 FUNC_ADDR=ARRAY%(S)
 FUNC_INCNT=ARRAY%(S)
 FUNC_OUTCNT=ARRAY%(S)
 FUNC_VARTBL=ARRAY%(S)
 FUNC_LBLTBL=ARRAY%(S)
 FUNC_VARNUM=ARRAY%(S)
 FUNC_SLOT=ARRAY%(S)
 FUNC_COMMON=ARRAY%(S)
 FUNC_FREE=0
END
DEF NEW_FUNC(NAME$,ADDR,INCNT,OUTCNT,SLOT,COMMO)
 IF FUNC_FREE THEN
  VAR L=FUNC_FREE
  FUNC_FREE=FUNC_ADDR[FUNC_FREE]
  FUNC_NAME$[L]=NAME$
  FUNC_ADDR[L]=ADDR
  FUNC_INCNT[L]=INCNT
  FUNC_OUTCNT[L]=OUTCNT
  FUNC_VARTBL[L]=NEW_SPLAY_TREE()
  FUNC_LBLTBL[L]=NEW_SPLAY_TREE()
  FUNC_VARNUM[L]=0
  FUNC_SLOT[L]=SLOT
  FUNC_COMMON[L]=COMMO
  RETURN L
 ENDIF
 PUSH FUNC_NAME$,NAME$
 PUSH FUNC_ADDR,ADDR
 PUSH FUNC_INCNT,INCNT
 PUSH FUNC_OUTCNT,OUTCNT
 PUSH FUNC_VARTBL,NEW_SPLAY_TREE()
 PUSH FUNC_LBLTBL,NEW_SPLAY_TREE()
 PUSH FUNC_VARNUM,0
 PUSH FUNC_SLOT,SLOT
 PUSH FUNC_COMMON,COMMO
 RETURN LAST(FUNC_LBLTBL)
END
DEF DELETE_FUNC FUNC
 FUNC_ADDR[FUNC]=FUNC_FREE
 FUNC_FREE=FUNC
END
DEF INIT_COMPILER_CONST
 VAR S=1
 CMP_BCONSTTBL=NEW_SPLAY_TREE()
 CMP_CONST_TYP=ARRAY%(S)
 CMP_CONST%=ARRAY%(S)
 CMP_CONST#=ARRAY#(S)
 CMP_CONST$=ARRAY$(S)
 CONST_FREE=0
 ADD_BCONST "#ON",#ON:ADD_BCONST "#OFF",#OFF:ADD_BCONST "#YES",#YES:ADD_BCONST "#NO",#NO:ADD_BCONST "#TRUE",#TRUE:ADD_BCONST "#FALSE",#FALSE:ADD_BCONST "#PI",#PI:ADD_BCONST "#EXP",#EXP:ADD_BCONST "#C_CLEAR",#C_CLEAR:ADD_BCONST "#C_AQUA",#C_AQUA:ADD_BCONST "#C_BLACK",#C_BLACK:ADD_BCONST "#C_BLUE",#C_BLUE:ADD_BCONST "#C_CYAN",#C_CYAN:ADD_BCONST "#C_FUCHSIA",#C_FUCHSIA:ADD_BCONST "#C_GRAY",#C_GRAY:ADD_BCONST "#C_GREEN",#C_GREEN:ADD_BCONST "#C_LIME",#C_LIME:ADD_BCONST "#C_MAGENTA",#C_MAGENTA:ADD_BCONST "#C_MAROON",#C_MAROON:ADD_BCONST "#C_NAVY",#C_NAVY:ADD_BCONST "#C_OLIVE",#C_OLIVE:ADD_BCONST "#C_PURPLE",#C_PURPLE:ADD_BCONST "#C_RED",#C_RED:ADD_BCONST "#C_SILVER",#C_SILVER:ADD_BCONST "#C_TEAL",#C_TEAL:ADD_BCONST "#C_WHITE",#C_WHITE:ADD_BCONST "#C_YELLOW",#C_YELLOW:ADD_BCONST "#B_RUP",#B_RUP:ADD_BCONST "#B_RDOWN",#B_RDOWN:ADD_BCONST "#B_RLEFT",#B_RLEFT:ADD_BCONST "#B_RRIGHT",#B_RRIGHT:ADD_BCONST "#B_LUP",#B_LUP:ADD_BCONST "#B_LDOWN",#B_LDOWN:ADD_BCONST "#B_LLEFT",#B_LLEFT:ADD_BCONST "#B_LRIGHT",#B_LRIGHT:ADD_BCONST "#B_L1",#B_L1:ADD_BCONST "#B_R1",#B_R1:ADD_BCONST "#B_L2",#B_L2:ADD_BCONST "#B_R2",#B_R2:ADD_BCONST "#B_SL",#B_SL:ADD_BCONST "#B_SR",#B_SR:ADD_BCONST "#B_S1",#B_S1:ADD_BCONST "#B_S2",#B_S2:ADD_BCONST "#B_LSTICK",#B_LSTICK:ADD_BCONST "#B_RSTICK",#B_RSTICK:ADD_BCONST "#B_RANY",#B_RANY:ADD_BCONST "#B_LANY",#B_LANY:ADD_BCONST "#B_ANY",#B_ANY:ADD_BCONST "#A_ROT0",#A_ROT0:ADD_BCONST "#A_ROT90",#A_ROT90:ADD_BCONST "#A_ROT180",#A_ROT180:ADD_BCONST "#A_ROT270",#A_ROT270:ADD_BCONST "#A_REVH",#A_REVH:ADD_BCONST "#A_REVV",#A_REVV:ADD_BCONST "#A_ADD",#A_ADD:ADD_BCONST "#CHKXY",#CHKXY:ADD_BCONST "#CHKZ",#CHKZ:ADD_BCONST "#CHKR",#CHKR:ADD_BCONST "#CHKS",#CHKS:ADD_BCONST "#CHKC",#CHKC:ADD_BCONST "#CHKV",#CHKV:ADD_BCONST "#CHKUV",#CHKUV:ADD_BCONST "#CHKI",#CHKI:ADD_BCONST "#T_DEFAULT",#T_DEFAULT:ADD_BCONST "#T_INT",#T_INT:ADD_BCONST "#T_REAL",#T_REAL:ADD_BCONST "#T_STR",#T_STR:ADD_BCONST "#T_INTARRAY",#T_INTARRAY:ADD_BCONST "#T_REALARRAY",#T_REALARRAY:ADD_BCONST "#T_STRARRAY",#T_STRARRAY:ADD_BCONST "#G_NORMAL",#G_NORMAL:ADD_BCONST "#G_NORMAL2",#G_NORMAL2:ADD_BCONST "#G_ALPHA",#G_ALPHA:ADD_BCONST "#G_ALPHA2",#G_ALPHA2:ADD_BCONST "#G_ADD",#G_ADD:ADD_BCONST "#BQAPF",#BQAPF:ADD_BCONST "#BQLPF",#BQLPF:ADD_BCONST "#BQHPF",#BQHPF:ADD_BCONST "#BQBPF",#BQBPF:ADD_BCONST "#BQBSF",#BQBSF:ADD_BCONST "#BQLSF",#BQLSF:ADD_BCONST "#BQHSF",#BQHSF:ADD_BCONST "#BQPEQ",#BQPEQ:ADD_BCONST "#WFRECT",#WFRECT:ADD_BCONST "#WFHAMM",#WFHAMM:ADD_BCONST "#WFHANN",#WFHANN:ADD_BCONST "#WFBLKM",#WFBLKM:ADD_BCONST "#AOPADD",#AOPADD:ADD_BCONST "#AOPSUB",#AOPSUB:ADD_BCONST "#AOPMUL",#AOPMUL:ADD_BCONST "#AOPDIV",#AOPDIV:ADD_BCONST "#AOPMAD",#AOPMAD:ADD_BCONST "#AOPLIP",#AOPLIP:ADD_BCONST "#AOPCLP",#AOPCLP:ADD_BCONST "#EFCOFF",#EFCOFF:ADD_BCONST "#EFCON",#EFCON:ADD_BCONST "#EFCBATH",#EFCBATH:ADD_BCONST "#EFCCAVE",#EFCCAVE:ADD_BCONST "#EFCSPACE",#EFCSPACE:ADD_BCONST "#EFCREFSROOM",#EFCREFSROOM:ADD_BCONST "#EFCREFLROOM",#EFCREFLROOM:ADD_BCONST "#EFCREFHALL",#EFCREFHALL:ADD_BCONST "#EFCREFCAVE",#EFCREFCAVE:ADD_BCONST "#EFCREFNONE",#EFCREFNONE:ADD_BCONST "#EFCREVROOM",#EFCREVROOM:ADD_BCONST "#EFCREVHALL",#EFCREVHALL:ADD_BCONST "#EFCREVMETAL",#EFCREVMETAL:ADD_BCONST "#EFCREVCAVE",#EFCREVCAVE:ADD_BCONST "#EFCREVREV",#EFCREVREV:ADD_BCONST "#PVLEFT",#PVLEFT:ADD_BCONST "#PVRIGHT",#PVRIGHT:ADD_BCONST "#GRPWIDTH",#GRPWIDTH:ADD_BCONST "#GRPHEIGHT",#GRPHEIGHT:ADD_BCONST "#GRPF",#GRPF:ADD_BCONST "#GSPRITE",#GSPRITE:ADD_BCONST "#TCONSOLE",#TCONSOLE:ADD_BCONST "#MAXT",#MAXT:ADD_BCONST "#MAXSP",#MAXSP:ADD_BCONST "#MAXGRP",#MAXGRP:ADD_BCONST "#HARDWARE",#HARDWARE
 ADD_BCONST "#VERSION",#VERSION
 ADD_BCONST "#_SLOT",0
 ADD_BCONST "#_LINE",0
 ADD_BCONST "#_FILENAME",""
END
DEF NEW_CONST(C)
 VAR N$
 IF !CONST_FREE THEN
  PUSH CMP_CONST_TYP,0
  PUSH CMP_CONST%,0
  PUSH CMP_CONST#,0
  PUSH CMP_CONST$,N$
  VAR L=LAST(CMP_CONST%)
 ELSE
  L=CONST_FREE
  CONST_FREE=CMP_CONST_TYP[CONST_FREE]
  CMP_CONST_TYP[L]=0
  CMP_CONST%[L]=0
  CMP_CONST#[L]=0
  CMP_CONST$[L]=N$
 ENDIF
 CASE TYPEOF(C)
 WHEN #T_INT
  CMP_CONST%[L]=C
  CMP_CONST_TYP[L]=#VMT_INT
 WHEN #T_REAL
  CMP_CONST#[L]=C
  CMP_CONST_TYP[L]=#VMT_REAL
 WHEN #T_STR
  CMP_CONST$[L]=C
  CMP_CONST_TYP[L]=#VMT_STR
 ENDCASE
 RETURN L
END
DEF DELETE_CONST C
 CMP_CONST_TYP[C]=CONST_FREE
 CONST_FREE=C
END
DEF COMPILER_GET_CURLOC$()
 VAR LINE,POS,LINE_END,POS_END,PC
 VMDBG_GET_SRC_INFO OUT LINE,POS,LINE_END,POS_END,PC
 RETURN STR$(CMP_SLOT)+":"+STR$(LINE)+":"+STR$(POS)
END
DEF COMPILER_HAS_ERROR()
 RETURN CMP_HAS_ERR
END
DEF COMPILER_RAISE_ERR2 E1$,E2$
 ?E1$;" in ";COMPILER_GET_CURLOC$()
 ?E2$
 CMP_HAS_ERR=#TRUE
END

DEF COMPILER_DUPLICATE_VARIABLE V$
 COMPILER_RAISE_ERR2 "Duplicate variable","同じ名前の変数はすでに定義されています"
END
DEF COMPILER_DUPLICATE_LABEL V$
 COMPILER_RAISE_ERR2 "Duplicate label","同じ名前のラベルはすでに定義されています"
END
DEF COMPILER_DUPLICATE_FUNCTION V$
 COMPILER_RAISE_ERR2 "Duplicate function","同じ名前の命令はすでに定義されています"
END
DEF COMPILER_DUPLICATE_CONSTANT V$
 COMPILER_RAISE_ERR2 "Duplicate constant","同じ名前の定数はすでに定義されています"
END
DEF COMPILER_UNDEFINED_CONSTANT V$
 COMPILER_RAISE_ERR2 "Undefined constant","未定義定数"
END
DEF INIT_COMPILER SLOT
 CMP_STRICT=#FALSE
 CMP_DEFINT=#FALSE
 CMP_GVARTBL=NEW_SPLAY_TREE()
 CMP_GLBLTBL=NEW_SPLAY_TREE()
 CMP_FUNCTBL=NEW_SPLAY_TREE()
 CMP_CONSTTBL=NEW_SPLAY_TREE()
 CMP_GVARNUM=1
 CMP_BREAK=EMPTY()
 CMP_CONTINUE=EMPTY()
 CMP_DATA%=ARRAY%(0)
 CMP_DATA#=ARRAY#(0)
 CMP_DATA$=ARRAY$(0)
 CMP_DATA_TYP=ARRAY%(0)
 INIT_VM_CODEGEN
 CMP_SLOT=SLOT
 CMP_HAS_ERR=#FALSE
END
DEF ADD_DATA V
 VAR N$
 PUSH CMP_DATA%,0
 PUSH CMP_DATA#,0
 PUSH CMP_DATA$,N$
 PUSH CMP_DATA_TYP,0
 CASE TYPEOF(V)
 WHEN #T_INT
  CMP_DATA_TYP[LAST(CMP_DATA_TYP)]=#VMT_INT
  CMP_DATA%[LAST(CMP_DATA%)]=V
 WHEN #T_REAL
  CMP_DATA_TYP[LAST(CMP_DATA_TYP)]=#VMT_REAL
  CMP_DATA#[LAST(CMP_DATA#)]=V
 WHEN #T_STR
  CMP_DATA_TYP[LAST(CMP_DATA_TYP)]=#VMT_STR
  CMP_DATA$[LAST(CMP_DATA$)]=V
 OTHERWISE
  INTERNAL_COMPILER_ERROR
 ENDCASE
END
DEF DETER_VAR_TYPE NAME$,ARY OUT TYP
 CASE RIGHT$(NAME$,1)
 WHEN "$"
  IF ARY THEN
   TYP=#VMT_STRARRAY
  ELSE
   TYP=#VMT_STR
  ENDIF
 WHEN "%"
  IF ARY THEN
   TYP=#VMT_INTARRAY
  ELSE
   TYP=#VMT_INT
  ENDIF
 WHEN "#"
  IF ARY THEN
   TYP=#VMT_REALARRAY
  ELSE
   TYP=#VMT_REAL
  ENDIF
 OTHERWISE
  IF CMP_DEFINT THEN
   IF ARY THEN
    TYP=#VMT_INTARRAY
   ELSE
    TYP=#VMT_INT
   ENDIF
  ELSE
   IF ARY THEN
    TYP=#VMT_REALARRAY
   ELSE
    TYP=#VMT_REAL
   ENDIF
  ENDIF
 ENDCASE
END
DEF DEFINE_VAR NAME$,ARY OUT IDX,LOCAL
 VAR TYP
 VAR FOUND,VA
 DETER_VAR_TYPE NAME$,ARY OUT TYP
 IF ARY THEN TYP=#VMT_DEFAULT
 IF CMP_CURFUNC THEN
  LOCAL=#TRUE
  SPLAY_GET% FUNC_VARTBL[CMP_CURFUNC],NAME$ OUT FOUND,VA
  IF FOUND THEN
   COMPILER_DUPLICATE_VARIABLE NAME$
   IDX=VAR_IDX[VA]
   RETURN
  ENDIF
  SPLAY_INSERT% FUNC_VARTBL[CMP_CURFUNC],NAME$,NEW_VAR(FUNC_VARNUM[CMP_CURFUNC],TYP)
  INC FUNC_VARNUM[CMP_CURFUNC]
  IDX=FUNC_VARNUM[CMP_CURFUNC]-1
 ELSE
  LOCAL=#FALSE
  SPLAY_GET% CMP_GVARTBL,NAME$ OUT FOUND,VA
  IF FOUND THEN
   COMPILER_DUPLICATE_VARIABLE NAME$
   IDX=VAR_IDX[VA]
   RETURN
  ENDIF
  SPLAY_INSERT% CMP_GVARTBL,NAME$,NEW_VAR(CMP_GVARNUM,TYP)
  INC CMP_GVARNUM
  IDX=CMP_GVARNUM-1
 ENDIF
END
DEF GET_VAR_INDEX NAME$ OUT IDX,LOCAL
 VAR FOUND,V
 IF CMP_CURFUNC THEN
  LOCAL=#TRUE
  SPLAY_GET% FUNC_VARTBL[CMP_CURFUNC],NAME$ OUT FOUND,V
 ENDIF
 IF !FOUND THEN
  LOCAL=#FALSE
  SPLAY_GET% CMP_GVARTBL,NAME$ OUT FOUND,V
 ENDIF
 IF !FOUND THEN
  IF CMP_STRICT THEN
   UNDEFINED_VARIABLE_ERROR
  ENDIF
  DEFINE_VAR NAME$,#FALSE OUT IDX,LOCAL
 ELSE
  IDX=VAR_IDX[V]
 ENDIF
END
DEF DEFINE_LABEL NAME$
 'TODO:LOCAL
 VAR FOUND
 VAR TBL
 IF CMP_CURFUNC THEN
  TBL=FUNC_LBLTBL[CMP_CURFUNC]
 ELSE
  TBL=CMP_GLBLTBL
 ENDIF
 SPLAY_GET% TBL,NAME$ OUT FOUND,
 IF FOUND THEN
  COMPILER_DUPLICATE_LABEL NAME$
 ENDIF
 SPLAY_INSERT% TBL,NAME$,NEW_LABEL(COMPILER_CURRENT_ADDR(),LEN(CMP_DATA_TYP))
END
DEF COMPILE AST
 COMPILE_STATEMENTS AST
END
DEF COMPILE_STATEMENTS A
 VAR I
 CASE AST_TYP[A]
 WHEN #AST_STATEMENTS
  I=AST_NEXT[AST_LEFT[A]]
  WHILE I
   IF!I THEN BREAK
   COMPILE_STATEMENT AST_LEFT[I]
   I=AST_NEXT[I]
  WEND
 OTHERWISE
  COMPILE_ERROR
 ENDCASE
END
DEF COMPILE_STATEMENT A
 IF AST_TYP[A]!=#AST_DEF THEN
  VMDBG_ADD_SRC_INFO AST_LINE[A],AST_POS[A],AST_LINE_END[A],AST_POS_END[A]
 ENDIF
 CASE AST_TYP[A]
 WHEN #AST_PRINT
  COMPILE_PRINT A
 WHEN #AST_ASSIGN
  COMPILE_EXPR AST_RIGHT[A]
  COMPILE_REFEXPR AST_LEFT[A]
  EMIT_ASSIGN
 'A1:EXPR
 'A2:THEN STATEMENTS
 'A3:ELSEIF STATEMENTS
 'A4:ELSE STATEMENTS
 WHEN #AST_IF
  COMPILE_IF A
 WHEN #AST_FOR
  COMPILE_FOR A
 WHEN #AST_BREAK
  COMPILE_BREAK
 WHEN #AST_CONTINUE
  COMPILE_CONTINUE
 WHEN #AST_WHILE
  COMPILE_WHILE A
 WHEN #AST_REPEAT
  COMPILE_REPEAT A
 WHEN #AST_LOOP
  COMPILE_LOOP A
 WHEN #AST_LABEL
  COMPILE_LABEL A
 WHEN #AST_GOTO
  COMPILE_GOTO A
 WHEN #AST_GOSUB
  COMPILE_GOSUB A
 WHEN #AST_GOTOEXPR
  COMPILE_GOTOEXPR A
 WHEN #AST_GOSUBEXPR
  COMPILE_GOSUBEXPR A
 WHEN #AST_ONGOTO
 WHEN #AST_ONGOSUB
  COMPILE_ONGOTO A
 WHEN #AST_ONBREAKGOTO
  COMPILE_ONBREAKGOTO A
 WHEN #AST_ONBREAKGOTOEXPR
  COMPILE_ONBREAKGOTOEXPR A
 WHEN #AST_RETURN
  COMPILE_RETURN A
 WHEN #AST_CALLFUNC
  COMPILE_CALLFUNC A
 WHEN #AST_DEF
  COMPILE_DEF A
 WHEN #AST_RETURNFUNC
  COMPILE_RETURNFUNC A
 WHEN #AST_DEFVAR
  COMPILE_DEFVAR A
 WHEN #AST_END
  COMPILE_END A
 WHEN #AST_OPTIONSTRICT
  CMP_STRICT=#TRUE
 WHEN #AST_OPTIONDEFINT
  CMP_DEFINT=#TRUE
 WHEN #AST_DATA
  COMPILE_DATA A
 WHEN #AST_CONST
  COMPILE_CONST A
 WHEN #AST_ENUM
  COMPILE_ENUM A
 WHEN #AST_READ
  COMPILE_READ A
 WHEN #AST_RESTORE
  COMPILE_RESTORE A
 WHEN #AST_RESTOREEXPR
  COMPILE_RESTOREEXPR A
 WHEN #AST_CALLSPRITE
  EMIT_CALLSPRITE
 WHEN #AST_CALLTEXT
  EMIT_CALLTEXT
 WHEN #AST_TPRINT
  COMPILE_TPRINT A
 WHEN #AST_INC
 WHEN #AST_DEC
  COMPILE_INC A
 WHEN #AST_CASE
  COMPILE_CASE A
 WHEN #AST_SWAP
  COMPILE_SWAP A
 WHEN #AST_INPUT
  COMPILE_INPUT A
 WHEN #AST_LINPUT
  COMPILE_LINPUT A
 WHEN #AST_DEFOUT
  COMPILE_DEFOUT A
 WHEN #AST_EXEC
  COMPILE_EXEC A
 WHEN #AST_STOP
  COMPILE_STOP A
 OTHERWISE
  ?AST_STR$(AST_TYP[A])
  COMPILE_ERROR
 ENDCASE
END

DEF COMPILE_STOP A
 IF AST_A1[A]THEN
  COMPILE_EXPR AST_A1[A]
  EMIT_STOP2
 ELSE
  EMIT_STOP1
 ENDIF
END
DEF COMPILE_EXEC A
 'RIGHT TO LEFT
 IF AST_A2[A]THEN
  COMPILE_EXPR AST_A2[A]
  COMPILE_EXPR AST_A1[A]
  EMIT_EXEC2
 ELSE
  COMPILE_EXPR AST_A1[A]
  EMIT_EXEC1
 ENDIF
END
DEF COMPILE_DEFOUT A
 'RIGHT TO LEFT
 COMPILE_EXPR AST_A2[A]
 COMPILE_EXPR AST_A1[A]
 EMIT_DEFOUT
END
DEF COMPILE_INPUT A
 'RIGHT TO LEFT
 VAR I=AST_PREV[AST_A2[A]]
 VAR CNT
 WHILE I!=AST_A2[A]
  COMPILE_REFEXPR AST_A1[I]
  INC CNT
  I=AST_PREV[I]
 WEND
 IF AST_A1[A]THEN
  COMPILE_EXPR AST_A1[A]
  EMIT_INPUT #TRUE,AST_A3[A],CNT
 ELSE
  EMIT_INPUT #FALSE,AST_A3[A],CNT
 ENDIF
END
DEF COMPILE_LINPUT A
 IF AST_A1[A]THEN
  COMPILE_EXPR AST_A1[A]
  EMIT_LINPUT #TRUE
 ELSE
  EMIT_LINPUT #FALSE
 ENDIF
 COMPILE_REFEXPR AST_A2[A]
 EMIT_ASSIGN
END
DEF COMPILE_SWAP A
 'RIGHT TO LEFT
 COMPILE_REFEXPR AST_RIGHT[A]
 COMPILE_REFEXPR AST_LEFT[A]
 EMIT_SWAP
END
DEF AST_IS_EMPTY_STMTS(A)
 RETURN AST_NEXT[AST_LEFT[A]]==0
END
DEF COMPILE_CASE A
 COMPILE_EXPR AST_A1[A]
 VAR I
 I=AST_NEXT[AST_A2[A]]
 VAR LBL
 DIM BRLIST=ARRAY%(0)
 DIM ENDCASELIST=ARRAY%(0)
 VAR EXPR,STMTS
 VAR HAS_OTHERWISE
 WHILE I
  EXPR=AST_A1[I]
  STMTS=AST_A2[I]
  IF EXPR THEN
   COMPILE_EXPR EXPR
   PUSH BRLIST,EMIT_WHEN()
  ELSE
   HAS_OTHERWISE=#TRUE
   EMIT_POP 1
   PUSH BRLIST,EMIT_BR()
  ENDIF
  I=AST_NEXT[I]
 WEND
 IF !HAS_OTHERWISE THEN
  EMIT_POP 1
  PUSH ENDCASELIST,EMIT_BR()
 ENDIF
 I=AST_NEXT[AST_A2[A]]
 VAR J
 WHILE I
  EXPR=AST_A1[I]
  STMTS=AST_A2[I]
  EMIT_ADDR BRLIST[J]
  IF EXPR THEN
   IF !AST_IS_EMPTY_STMTS(STMTS)THEN
    COMPILE_STATEMENTS STMTS
    PUSH ENDCASELIST,EMIT_BR()
   ENDIF
  ELSE
   COMPILE_STATEMENTS STMTS
  ENDIF
  INC J
  I=AST_NEXT[I]
 WEND
 FOR I=0TO LAST(ENDCASELIST)
  EMIT_ADDR ENDCASELIST[I]
 NEXT
END
DEF COMPILE_ONGOTO A
 COMPILE_EXPR AST_A1[A]
 VAR I=AST_NEXT[AST_A2[A]]
 DIM LBL$[]
 WHILE I
  PUSH LBL$,AST$[I]
  I=AST_NEXT[I]
 WEND
 EMIT_ONGOTO LBL$,AST_TYP[A]==#AST_ONGOSUB
END
DEF COMPILE_INC A
 'RIGHT TO LEFT
 IF AST_RIGHT[A] THEN
  COMPILE_EXPR AST_RIGHT[A]
 ELSE
  EMIT_PUSHINT 1
 ENDIF
 COMPILE_REFEXPR AST_LEFT[A]
 IF AST_TYP[A]==#AST_INC THEN
  EMIT_INC
 ELSE
  EMIT_DEC
 ENDIF
END
DEF COMPILE_TPRINT A
 VAR I=AST_NEXT[AST_LEFT[A]]
 IF !I THEN
  TYPE_MISMATCH'FIXME:RUNTIME ERROR
 ENDIF
 COMPILE_EXPR AST_LEFT[I]
 I=AST_NEXT[I]
 IF !I THEN
  EMIT_TPRINT #VMPRINT_EMPTY
 ENDIF
 WHILE I
  IF!I THEN BREAK
  COMPILE_EXPR AST_LEFT[I]
  CASE AST_TYP[I]
  WHEN #AST_PRINT_EXPR_COMMA
   EMIT_TPRINT #VMPRINT_COMMA
  WHEN #AST_PRINT_EXPR_NEWLINE
   EMIT_TPRINT #VMPRINT_NEWLINE
  WHEN #AST_PRINT_EXPR_SEMI
   EMIT_TPRINT #VMPRINT_SEMI
  ENDCASE
  I=AST_NEXT[I]
 WEND
 EMIT_POP 1
END
DEF COMPILE_PRINT A
 VAR I=AST_NEXT[AST_LEFT[A]]
 IF !I THEN
  EMIT_PRINT #VMPRINT_EMPTY
 ENDIF
 WHILE I
  IF!I THEN BREAK
  COMPILE_EXPR AST_LEFT[I]
  CASE AST_TYP[I]
  WHEN #AST_PRINT_EXPR_COMMA
   EMIT_PRINT #VMPRINT_COMMA
  WHEN #AST_PRINT_EXPR_NEWLINE
   EMIT_PRINT #VMPRINT_NEWLINE
  WHEN #AST_PRINT_EXPR_SEMI
   EMIT_PRINT #VMPRINT_SEMI
  ENDCASE
  I=AST_NEXT[I]
 WEND
END
DEF FOLD_CONSTEXPR_ARGS(A)
 VAR I=AST_NEXT[A]
 DIM RESULT=ARRAY%(0)
 WHILE I
  PUSH RESULT,FOLD_CONSTEXPR(AST_A1[I])
  I=AST_NEXT[I]
 WEND
 RETURN RESULT
END
DEF AST_IS_NUM(A)
 RETURN AST_TYP[A]==#AST_IMM_INT||AST_TYP[A]==#AST_IMM_DBL
END
DEF AST_IMM(A)
 CASE AST_TYP[A]
 WHEN #AST_IMM_INT
  RETURN AST%[A]
 WHEN #AST_IMM_DBL
  RETURN AST#[A]
 WHEN #AST_IMM_STR
  RETURN AST$[A]
 OTHERWISE
  STOP
 ENDCASE
END
DEF FOLD_CONSTEXPR(A)
 IF !A THEN RETURN 0
 CASE AST_TYP[A]
 WHEN #AST_IMM_INT
 WHEN #AST_IMM_DBL
 WHEN #AST_IMM_STR
  RETURN A
 WHEN #AST_CONSTVAR
  VAR FOUND,C
  SPLAY_GET% CMP_CONSTTBL,AST$[A] OUT FOUND,C
  IF AST$[A]=="#_LINE"THEN
   RETURN NEW_AST_INT(#AST_IMM_INT,AST_LINE[A])
  ELSEIF AST$[A]=="#_SLOT"THEN
   RETURN NEW_AST_INT(#AST_IMM_INT,CMP_SLOT)
  ELSEIF AST$[A]=="#_FILENAME"THEN
    RETURN NEW_AST_STR(#AST_IMM_STR,CMP_FILENAME$)
  ENDIF
  IF!FOUND THEN
   SPLAY_GET% CMP_BCONSTTBL,AST$[A] OUT FOUND,C
  ENDIF
  IF!FOUND THEN
   COMPILER_UNDEFINED_CONSTANT AST$[A]
   RETURN NEW_AST_INT(#AST_IMM_INT,0)
  ELSE
   CASE CMP_CONST_TYP[C]
   WHEN #VMT_INT
    RETURN NEW_AST_INT(#AST_IMM_INT,CMP_CONST%[C])
   WHEN #VMT_REAL
    RETURN NEW_AST_DBL(#AST_IMM_DBL,CMP_CONST#[C])
   WHEN #VMT_STR
    RETURN NEW_AST_STR(#AST_IMM_STR,CMP_CONST$[C])
   OTHERWISE
    INTERNAL_COMPILER_ERROR
   ENDCASE
  ENDIF
 WHEN #AST_CALLFUNCEXPR
  VAR ARGS=FOLD_CONSTEXPR_ARGS(AST_A1[A])
  CASE AST$[A]
  WHEN "RGB"
   IF LEN(ARGS)!=3&&LEN(ARGS)!=4 THEN
    RETURN A
   ENDIF
   IF AST_IS_NUM(ARGS[0])&&AST_IS_NUM(ARGS[1])&&AST_IS_NUM(ARGS[2])THEN
    IF LEN(ARGS)==4 THEN
     IF!AST_IS_NUM(ARGS[3])THEN
      RETURN A
     ELSE
      RETURN NEW_AST_INT(#AST_IMM_INT,RGB(AST_IMM(ARGS[0]),AST_IMM(ARGS[1]),AST_IMM(ARGS[2]),AST_IMM(ARGS[3])))
     ENDIF
    ENDIF
    RETURN NEW_AST_INT(#AST_IMM_INT,RGB(AST_IMM(ARGS[0]),AST_IMM(ARGS[1]),AST_IMM(ARGS[2])))
   ELSE
    RETURN A
   ENDIF
  WHEN "DEG"
   IF ARGS!=1 THEN
    RETURN A
   ENDIF
   RETURN NEW_AST_DBL(#AST_IMM_DBL,DEG(AST_IMM(ARGS[0])))
  WHEN "RAD"
   IF ARGS!=1 THEN
    RETURN A
   ENDIF
   RETURN NEW_AST_DBL(#AST_IMM_DBL,RAD(AST_IMM(ARGS[0])))
  WHEN "CHR$"
   IF ARGS!=1 THEN
    RETURN A
   ENDIF
   RETURN NEW_AST_STR(#AST_IMM_STR,RAD(AST_IMM(ARGS[0])))
  ENDCASE
 WHEN #AST_UNAOP
  VAR L=FOLD_CONSTEXPR(AST_LEFT[A])
  IF AST_IS_NUM(L) THEN
   L=AST_IMM(L)
   CASE AST%[A]
   WHEN #TKN_LNOT
    RETURN NEW_AST_IMM(!L)
   WHEN #TKN_MINUS
    RETURN NEW_AST_IMM(-L)
   WHEN #TKN_NOT
    RETURN NEW_AST_IMM(NOT L)
   ENDCASE
  ELSE
   RETURN A
  ENDIF
 WHEN #AST_BINOP
  L=FOLD_CONSTEXPR(AST_LEFT[A])
  VAR R=FOLD_CONSTEXPR(AST_RIGHT[A])
  VAR LV=AST_IMM(L)
  VAR RV=AST_IMM(R)
  CASE AST%[A]
  WHEN #TKN_PLUS
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV+RV)
   ENDIF
  WHEN #TKN_MINUS
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV-RV)
   ENDIF
  WHEN #TKN_MUL
   IF AST_IS_NUM(L)&&(AST_IS_NUM(R)||AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV*RV)
   ENDIF
  WHEN #TKN_DIV
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV/RV)
   ENDIF
  WHEN #TKN_DIVINT
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV DIV RV)
   ENDIF
  WHEN #TKN_MOD
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV MOD RV)
   ENDIF
  WHEN #TKN_AND
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV AND RV)
   ENDIF
  WHEN #TKN_OR
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV OR RV)
   ENDIF
  WHEN #TKN_EQ
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV==RV)
   ENDIF
  WHEN #TKN_NEQ
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV!=RV)
   ENDIF
  WHEN #TKN_LSHIFT
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV<<RV)
   ENDIF
  WHEN #TKN_RSHIFT
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV>>RV)
   ENDIF
  WHEN #TKN_GREAT
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV<RV)
   ENDIF
  WHEN #TKN_LESS
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV>RV)
   ENDIF
  WHEN #TKN_GEQ
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV<=RV)
   ENDIF
  WHEN #TKN_LEQ
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV>=RV)
   ENDIF
  OTHERWISE
   RETURN A
  ENDCASE
 OTHERWISE
  RETURN A
 ENDCASE
 RETURN A
END
DEF COMPILE_RESTORE A
 IF LEN(AST$[A])THEN
  EMIT_RESTORE_PLACEHOLDER AST$[A]
 ELSE
  'CURRENT SLOT??FIXME
  EMIT_RESTORE CMP_SLOT,0'4.0.1,4.0.2:TYPEMISMATCH
 ENDIF
END
DEF COMPILE_RESTOREEXPR A
 COMPILE_EXPR AST_LEFT[A]
 EMIT_RESTOREEXPR
END
DEF COMPILE_GOTOEXPR A
 COMPILE_EXPR AST_LEFT[A]
 EMIT_GOTOEXPR
END
DEF COMPILE_GOSUBEXPR A
 COMPILE_EXPR AST_LEFT[A]
 EMIT_GOSUBEXPR
END
DEF COMPILE_READ A
 VAR I=AST_NEXT[AST_A1[A]]
 WHILE I
  COMPILE_REFEXPR AST_A1[I]
  ' BAD:READ->EVAL REFEXPR->ASSIGN
  'GOOD:EVAL REFEXPR->READ->ASSIGN
  EMIT_READ
  I=AST_NEXT[I]
 WEND
END
DEF COMPILE_DATA A
 VAR I=AST_NEXT[AST_A1[A]]
 WHILE I
  VAR EXPR=FOLD_CONSTEXPR(AST_A1[I])
  CASE AST_TYP[EXPR]
  WHEN #AST_IMM_INT
   ADD_DATA AST%[EXPR]
  WHEN #AST_IMM_DBL
   ADD_DATA AST#[EXPR]
  WHEN #AST_IMM_STR
   ADD_DATA AST$[EXPR]
  OTHERWISE
   SYNTAX_ERROR "DATA"
  ENDCASE
  I=AST_NEXT[I]
 WEND
END
DEF ADD_CONST N$,C
 VAR FOUND
 SPLAY_GET% CMP_CONSTTBL,N$ OUT FOUND,
 IF FOUND THEN
  COMPILER_DUPLICATE_CONSTANT N$
  RETURN
 ENDIF
 SPLAY_INSERT% CMP_CONSTTBL,N$,NEW_CONST(C)
END
DEF ADD_BCONST N$,C
 VAR FOUND
 SPLAY_GET% CMP_BCONSTTBL,N$ OUT FOUND,
 IF FOUND THEN
  COMPILER_DUPLICATE_CONSTANT N$
  RETURN
 ENDIF
 SPLAY_INSERT% CMP_BCONSTTBL,N$,NEW_CONST(C)
END
DEF COMPILE_END A
 EMIT_END
END
DEF COMPILE_CONST A
 VAR I=AST_NEXT[AST_A1[A]]
 WHILE I
  VAR NAME$=AST$[I]
  VAR EXPR=FOLD_CONSTEXPR(AST_A1[I])
  CASE AST_TYP[EXPR]
  WHEN #AST_IMM_INT
   ADD_CONST NAME$,AST%[EXPR]
  WHEN #AST_IMM_DBL
   ADD_CONST NAME$,AST#[EXPR]
  WHEN #AST_IMM_STR
   ADD_CONST NAME$,AST$[EXPR]
  OTHERWISE
   SYNTAX_ERROR "CONST"
  ENDCASE
  I=AST_NEXT[I]
 WEND
END
DEF COMPILE_ENUM A
 VAR I=AST_NEXT[AST_A1[A]]
 VAR C%
 WHILE I
  VAR NAME$=AST$[I]
  VAR EXPR=FOLD_CONSTEXPR(AST_A1[I])
  IF!EXPR THEN
   ADD_CONST NAME$,C%
   INC C%
  ELSE
   CASE AST_TYP[EXPR]
   WHEN #AST_IMM_INT
    C%=AST%[EXPR]
    ADD_CONST NAME$,C%
    INC C%
   WHEN #AST_IMM_DBL
   WHEN #AST_IMM_STR
    SYNTAX_ERROR "TYPE MISMATCH"
   OTHERWISE
    SYNTAX_ERROR "ENUM"
   ENDCASE
  ENDIF
  I=AST_NEXT[I]
 WEND
END
DEF COMPILE_DEFVAR A
 'A1:LIST
  '$:NAME
  'A1:INIT EXPR
  'A2:ARRAY DIM
  'A3:ARRAY INIT LIST 
 'LEFT TO RIGHT
 VAR I=AST_NEXT[AST_A1[A]]
 WHILE I
  VAR NAME$=AST$[I]
  VAR IDX,LOCAL,ARY
  IF AST_A2[I] THEN
   ARY=#TRUE
  ENDIF
  DEFINE_VAR NAME$,ARY OUT IDX,LOCAL
  IF AST_A1[I] THEN
   COMPILE_EXPR AST_A1[I]
   'FIXME:EXTRACT FUNCTION
   IF LOCAL THEN
    EMIT_PUSHLVARREF IDX
   ELSE
    EMIT_PUSHVARREF IDX
   ENDIF
   EMIT_ASSIGN
  ELSEIF ARY THEN
   'RIGHT TO LEFT
   VAR DM=COMPILE_ARRAY_INDEX_EXPR(AST_A2[I])
   IF DM==0THEN
    DM=1
    EMIT_PUSHINT AST_GET_ITEM_COUNT(AST_A3[I])
   ENDIF
   EMIT_NEWARRAY DM,DETER_VAR_TYPE(NAME$,#TRUE)
   IF LOCAL THEN
    EMIT_PUSHLVARREF IDX
   ELSE
    EMIT_PUSHVARREF IDX
   ENDIF
   EMIT_ASSIGN
   IF AST_A3[I]THEN
    'RIGHT TO LEFT
    VAR INITCOUNT=COMPILE_ARRAY_INDEX_EXPR(AST_A3[I])
    IF LOCAL THEN
     EMIT_PUSHLVARREF IDX
    ELSE
     EMIT_PUSHVARREF IDX
    ENDIF
    EMIT_REF
    EMIT_INITARRAY INITCOUNT
   ENDIF
  ENDIF
  I=AST_NEXT[I]
 WEND
END
'RET:DIM
DEF AST_GET_ITEM_COUNT(A)
 IF!A THEN RETURN 0
 VAR I=AST_NEXT[A]
 VAR CNT
 WHILE I
  INC CNT
  I=AST_NEXT[I]
 WEND
 RETURN CNT
END
DEF COMPILE_ARRAY_INDEX_EXPR(A)
 VAR I=AST_PREV[A]
 VAR DM
 WHILE I!=A
  INC DM
  COMPILE_EXPR AST_A1[I]
  I=AST_PREV[I]
 WEND
 RETURN DM
END
CONST #VM_LVAROFF=-7
DEF COMPILE_RETURNFUNC A
 VAR EXPR=AST_LEFT[A]
 IF EXPR THEN
  COMPILE_EXPR EXPR
  IF FUNC_INCNT[CMP_CURFUNC]==-1 THEN
   EMIT_PUSHLVARREF #VM_LVAROFF
   EMIT_ASSIGN
  ELSE
   EMIT_PUSHLVARREF #VM_LVAROFF-FUNC_INCNT[CMP_CURFUNC]
   EMIT_ASSIGN
  ENDIF
 ENDIF
 EMIT_RETURNFUNC
END
DEF COMPILE_DEF A
 '$:NAME
 'A1:IN LIST
 'A2:OUT LIST
 'A3:STATEMENTS
 'A4:HAS RETURN VALUE
 VAR SKIP=EMIT_BR()
 VAR FN$=AST$[A]
 VAR INCNT
 VAR I
 VAR OUTCNT
 VAR CMN
 INCNT=AST_GET_ITEM_COUNT(AST_A1[A])
 OUTCNT=AST_GET_ITEM_COUNT(AST_A2[A])
 IF AST_A4[A]AND #AST_DEF_A4_HAS_RET_VAL THEN
  INC OUTCNT
 ENDIF
 IF AST_A4[A]AND #AST_DEF_A4_OUT_VAARGS THEN
  OUTCNT=-1
 ENDIF
 IF AST_A4[A]AND #AST_DEF_A4_IN_VAARGS THEN
  INCNT=-1
 ENDIF
 IF AST_A4[A]AND #AST_DEF_A4_COMMON_DEF THEN
  CMN=#TRUE
 ENDIF
 CMP_CURFUNC=DEFINE_FUNC(FN$,COMPILER_CURRENT_ADDR(),INCNT,OUTCNT,CMN)
 IF CMN THEN
  VM_DEFINE_COMMON_DEF FN$,CMP_CURFUNC
 ENDIF
 I=AST_NEXT[AST_A1[A]]
 VAR IDX=#VM_LVAROFF+1
 WHILE I
  DEC IDX
  DEFINE_LOCAL_VAR CMP_CURFUNC,AST$[I],IDX
  I=AST_NEXT[I]
 WEND
 I=AST_PREV[AST_A2[A]]
 WHILE I!=AST_A2[A]
  DEC IDX
  DEFINE_LOCAL_VAR CMP_CURFUNC,AST$[I],IDX
  I=AST_PREV[I]
 WEND
 COMPILE_STATEMENTS AST_A3[A]
' EMIT_RETURNFUNC
 EMIT_ADDR SKIP
 CMP_CURFUNC=0
END
DEF DEFINE_LOCAL_VAR FUNC,V$,IDX
 VAR FOUND
 SPLAY_GET% FUNC_VARTBL[FUNC],V$ OUT FOUND,
 IF FOUND THEN
  'NO ERROR!?
  'IF VER<4.0.2 THEN RETURN
  COMPILER_DUPLICATE_VARIABLE V$
  RETURN
 ENDIF
 SPLAY_INSERT% FUNC_VARTBL[FUNC],V$,NEW_VAR(IDX,#VMT_DEFAULT)
END
DEF DEFINE_FUNC(FN$,ADDR,INCNT,OUTCNT,CMN)
 VAR FOUND
 SPLAY_GET% CMP_FUNCTBL,FN$ OUT FOUND,
 IF FOUND THEN
  COMPILER_DUPLICATE_FUNCTION FN$
 ENDIF
 VAR F=NEW_FUNC(FN$,ADDR,INCNT,OUTCNT,CMP_SLOT,CMN)
 SPLAY_INSERT% CMP_FUNCTBL,FN$,F
 RETURN F
END
DEF COMPILE_CALLFUNC A
 'A1:IN ARGS
 'A2:OUT ARGS
 VAR FN$=AST$[A]
 VAR INCNT=0
 VAR I
 VAR OUTCNT
 IF AST_TYP[A]==#AST_CALLFUNC THEN
  OUTCNT=AST_GET_ITEM_COUNT(AST_A2[A])
 ELSE
  OUTCNT=1
 ENDIF
 EMIT_PUSHEMPTY OUTCNT
 I=AST_PREV[AST_A1[A]]
 WHILE I!=AST_A1[A]
  COMPILE_EXPR AST_A1[I]
  I=AST_PREV[I]
  INC INCNT
 WEND
 EMIT_CALLFUNC FN$,INCNT,OUTCNT
 IF AST_TYP[A]==#AST_CALLFUNC THEN
  I=AST_PREV[AST_A2[A]]
  WHILE I!=AST_A2[A]
   COMPILE_REFEXPR AST_A1[I]
   EMIT_ASSIGN
   I=AST_PREV[I]
   INC OUTCNT
  WEND
 ENDIF
END
DEF COMPILE_IF A
 COMPILE_EXPR AST_A1[A]
 VAR ADDR_ELSE=EMIT_BRFALSE()
 COMPILE_STATEMENTS AST_A2[A]
 IF AST_A4[A]||AST_A3[A]THEN
  VAR ADDR_ENDIF=EMIT_BR()
 ENDIF
 EMIT_ADDR ADDR_ELSE
 IF AST_A3[A]THEN'ELSEIF
  DIM BRLIST[0]
  VAR I=AST_NEXT[AST_A3[A]]
  WHILE I
   COMPILE_EXPR AST_A1[I]
   VAR ADDR_AFTER_ELSEIF=EMIT_BRFALSE()
   COMPILE_STATEMENTS AST_A2[I]
   I=AST_NEXT[I]
   PUSH BRLIST,EMIT_BR()
   EMIT_ADDR ADDR_AFTER_ELSEIF
  WEND
 ENDIF
 IF AST_A4[A]THEN'ELSE
  COMPILE_STATEMENTS AST_A4[A]
 ENDIF
 IF AST_A4[A]||AST_A3[A]THEN
  EMIT_ADDR ADDR_ENDIF
 ENDIF
 IF AST_A3[A]THEN'ELSEIF
  FOR I=0TO LAST(BRLIST)
   EMIT_ADDR BRLIST[I]
  NEXT
 ENDIF
END
DEF COMPILE_CONTINUE
 IF TYPEOF(CMP_CONTINUE)!=#T_INTARRAY THEN
  SYNTAX_ERROR
  RETURN
 ENDIF
 PUSH CMP_CONTINUE,EMIT_BR()
END
DEF COMPILE_BREAK
 IF TYPEOF(CMP_CONTINUE)!=#T_INTARRAY THEN
  SYNTAX_ERROR
  RETURN
 ENDIF
 PUSH CMP_BREAK,EMIT_BR()
END
DEF COMPILE_FOR A
 'A1:INDEXREFEXPR
 'A2:INITEXPR
 'A3:TOEXPR
 'A4:STEPEXPR
 'A5:STATEMENTS
 VAR INDEXREF=AST_A1[A]
 VAR INITEXPR=AST_A2[A]
 VAR TOEXPR=AST_A3[A]
 VAR STEPEXPR=AST_A4[A]
 VAR STATEMENTS=AST_A5[A]
 COMPILE_EXPR INITEXPR
 COMPILE_REFEXPR INDEXREF
 EMIT_ASSIGN
 'FOR INDEXREF=INITEXPR TO TOEXPR STEP STEPEXPR
 'PUSH INITEXPR
 'PUSH INDEXREF
 'ASSIGN
 '@CONT
 'PUSH INDEXREF
 'PUSH STEPEXPR
 'PUSH TOEXPR
 '*FOR STEP INSTR* @BRK
 'STATEMENTS... (GOTO @CONT,@BRK
 'GOTO @CONT
 '@BRK


 'FOR INDEXREF=INITEXPR TO TOEXPR
 'PUSH INITEXPR
 'PUSH INDEXREF
 'ASSIGN
 '@CONT
 'PUSH INDEXREF
 'PUSH TOEXPR
 '*FOR INSTR* @BRK
 'STATEMENTS... (GOTO @CONT,@BRK
 'GOTO @CONT
 '@BRK
 COMPILE_REFEXPR INDEXREF
 IF STEPEXPR THEN
  COMPILE_EXPR STEPEXPR
 ELSE
  EMIT_PUSHINT 1
 ENDIF
 COMPILE_EXPR TOEXPR
 VAR BRKADDR
 BRKADDR=EMIT_FORINIT()
 VAR LOOPADDR=COMPILER_CURRENT_ADDR()
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  COMPILE_STATEMENTS STATEMENTS
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   EMIT_ADDR CMP_CONTINUE[I]
  NEXT
  VMDBG_ADD_SRC_INFO AST_LINE[A],AST_POS[A],AST_LINE_END[A],AST_POS_END[A]
  COMPILE_REFEXPR INDEXREF
  IF STEPEXPR THEN
   COMPILE_EXPR STEPEXPR
  ELSE
   EMIT_PUSHINT 1
  ENDIF
  COMPILE_EXPR TOEXPR
  VAR BRKADDR2
  BRKADDR2=EMIT_FOR()
  EMIT_ADDR BRKADDR
  EMIT_ADDR2 BRKADDR2,LOOPADDR
  FOR I=0TO LAST(CMP_BREAK)
   EMIT_ADDR CMP_BREAK[I]
  NEXT
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF COMPILE_WHILE A
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  VAR CONTADDR=COMPILER_CURRENT_ADDR()
  COMPILE_EXPR AST_A1[A]
  VAR BRL=EMIT_BRFALSE()
  COMPILE_STATEMENTS AST_A2[A]
  EMIT_ADDR2 EMIT_BR(),CONTADDR
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   EMIT_ADDR2 CMP_CONTINUE[I],CONTADDR
  NEXT
  FOR I=0TO LAST(CMP_BREAK)
   EMIT_ADDR CMP_BREAK[I]
  NEXT
  EMIT_ADDR BRL
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF COMPILE_REPEAT A
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  VAR LOOPADDR=COMPILER_CURRENT_ADDR()
  COMPILE_STATEMENTS AST_A2[A]
  VAR CONTADDR=COMPILER_CURRENT_ADDR()
  COMPILE_EXPR AST_A1[A]
  EMIT_ADDR2 EMIT_BRFALSE(),LOOPADDR
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   EMIT_ADDR2 CMP_CONTINUE[I],CONTADDR
  NEXT
  FOR I=0TO LAST(CMP_BREAK)
   EMIT_ADDR CMP_BREAK[I]
  NEXT
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF COMPILE_LOOP A
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  VAR CONTADDR=COMPILER_CURRENT_ADDR()
  COMPILE_STATEMENTS AST_A2[A]
  EMIT_ADDR2 EMIT_BR(),CONTADDR
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   EMIT_ADDR2 CMP_CONTINUE[I],CONTADDR
  NEXT
  FOR I=0TO LAST(CMP_BREAK)
   EMIT_ADDR CMP_BREAK[I]
  NEXT
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF COMPILE_REFEXPR A
 CASE AST_TYP[A]
 WHEN #AST_VAR
  VAR IDX,LC
  GET_VAR_INDEX AST$[A] OUT IDX,LC
  IF LC THEN
   EMIT_PUSHLVARREF IDX
  ELSE
   EMIT_PUSHVARREF IDX
  ENDIF
 WHEN #AST_EMPTYEXPR
  EMIT_PUSHEMPTYREF
 WHEN #AST_BINOP
  VAR TYP=AST%[A]
  IF TYP!=#TKN_LB THEN
   SYNTAX_ERROR "EXPECTED '['"
   RETURN
  ENDIF
  VAR DM=COMPILE_ARRAY_INDEX_EXPR(AST_RIGHT[A])
  COMPILE_EXPR AST_LEFT[A]
  EMIT_PUSHARYREF DM
 WHEN #AST_VAREXPR
  COMPILE_EXPR AST_LEFT[A]
  EMIT_PUSHVAREXPRREF
 OTHERWISE
  COMPILE_ERROR
 ENDCASE
END
DEF COMPILE_EXPR A
 CASE AST_TYP[A]
 WHEN #AST_BINOP
  VAR TYP=AST%[A]
  IF TYP==#TKN_LAND THEN
   COMPILE_EXPR AST_LEFT[A]
   VAR BR1=EMIT_BRAND()
   COMPILE_EXPR AST_RIGHT[A]
   VAR BR2=EMIT_BRAND()
   EMIT_PUSHINT #TRUE
   EMIT_ADDR BR1
   EMIT_ADDR BR2
  ELSEIF TYP==#TKN_LOR THEN
   COMPILE_EXPR AST_LEFT[A]
   BR1=EMIT_BROR()
   COMPILE_EXPR AST_RIGHT[A]
   BR2=EMIT_BROR()
   EMIT_PUSHINT #FALSE
   EMIT_ADDR BR1
   EMIT_ADDR BR2
  ELSEIF TYP==#TKN_LB THEN
   VAR DM=COMPILE_ARRAY_INDEX_EXPR(AST_RIGHT[A])
   COMPILE_EXPR AST_LEFT[A]
   EMIT_PUSHARYREF DM
   EMIT_REF
  ELSE
   COMPILE_EXPR AST_LEFT[A]
   COMPILE_EXPR AST_RIGHT[A]
   EMIT_BINOP AST%[A]
  ENDIF
 WHEN #AST_IMM_INT
  EMIT_PUSHINT AST%[A]
 WHEN #AST_IMM_DBL
  EMIT_PUSHDBL AST#[A]
 WHEN #AST_IMM_STR
  EMIT_PUSHSTR AST$[A]
 WHEN #AST_VAR
  COMPILE_REFEXPR A
  EMIT_REF
 WHEN #AST_CALLFUNCEXPR
  COMPILE_CALLFUNC A
 WHEN #AST_CONSTVAR
  COMPILE_EXPR FOLD_CONSTEXPR(A)
 WHEN #AST_UNAOP
  COMPILE_EXPR AST_LEFT[A]
  EMIT_UNAOP AST%[A]
 WHEN #AST_EMPTYEXPR
  EMIT_PUSHEMPTY 1
 WHEN #AST_VAREXPR
  COMPILE_EXPR AST_LEFT[A]
  EMIT_PUSHVAREXPR
 OTHERWISE
  ?AST_STR$(AST_TYP[A])
  COMPILE_ERROR
 ENDCASE
END
DEF COMPILE_LABEL A
 DEFINE_LABEL AST$[A]
END
DEF COMPILE_GOTO A
 EMIT_GOTO_PLACEHOLDER AST$[A]
END
DEF COMPILE_GOSUB A
 EMIT_GOSUB_PLACEHOLDER AST$[A]
END
DEF COMPILE_RETURN A
 EMIT_RETURN
END
DIM VM_OPS[]
DIM VMDBG_LINE_PC[]
DIM VMDBG_LINE[]
DIM VMDBG_LINE_POS[]
DIM VMDBG_LINE_END[]
DIM VMDBG_LINE_POS_END[]
DIM VM_IMM#[]
DIM VM_IMM$[]

DIM VM_STK_TYP[]
DIM VM_STK%[]
DIM VM_STK#[]
DIM VM_STK$[]
VAR VM_STK_SIZE
VAR VM_SP
VAR VM_BP
DIM VM_GVAR_TYP[]
DIM VM_GVAR%[]
DIM VM_GVAR#[]
DIM VM_GVAR$[]
VAR VM_GLBLTBL
VAR VM_GVARTBL
VAR VM_CFUNCTBL
VAR VM_FUNCTBL
VAR VM_PC
VAR VM_PREV_PC
VAR VM_RUNNING

DIM VM_DATA_TYP[]
DIM VM_DATA%[]
DIM VM_DATA#[]
DIM VM_DATA$[]
DIM VM_DATA_IDX
VAR VM_CURFUNC
VAR VM_CURSLOT
VAR VM_CURDATASLOT

VAR VM_ALLOC_ARRAY
DEF VM_ALLOC_ARRAY(ARY)

 IF TYPEOF(ARY)<#T_INTARRAY THEN
  STOP
 ENDIF
 VAR S=AllocSBArray()
'?"Akic!";S,TYPEOF(ARY)
'IF LEN(ARY)<10THEN
'??ARY
'ENDIF
 SetSBArray S,ARY
 RETURN S
 SPVAR #GSPRITE,VM_ALLOC_ARRAY,ARY
 INC VM_ALLOC_ARRAY
 RETURN VM_ALLOC_ARRAY-1
END
DEF VM_FREE_ARRAY ARY
 VAR B=GetSBArray(ARY)
'?"free!";ARY
'IF LEN(B)<10THEN
'??B
'ENDIF
 FreeSBArray ARY
' SPVAR #GSPRITE,ARY,EMPTY()
END
DEF VM_GET_ARRAY(ARY)
' ?"get";ARY
 RETURN GetSBArray(ARY)
 RETURN SPVAR(#GSPRITE,ARY)
END

DEF VM_GETFREE_ARRAY(ARY)
 VAR B=GetSBArray(ARY)
'?"free!";ARY
'IF LEN(B)<10THEN
'??B
'ENDIF
 FreeSBArray ARY
 RETURN B
 VAR A=SPVAR(#GSPRITE,ARY)
' SPVAR #GSPRITE,ARY,EMPTY()
 RETURN A
END

ENUM\
 #VM_NOP,\
 #VM_PUSHINT,\
 #VM_PUSHDBL,\
 #VM_PUSHSTR,\
 #VM_BINOP,\
 #VM_PRINT,\
 #VM_TPRINT,\
 #VM_ASSIGN,\
 #VM_PUSHVARREF,\
 #VM_PUSHLVARREF,\
 #VM_REF,\
 #VM_BR,\
 #VM_BRTRUE,\
 #VM_BRFALSE,\
 #VM_FOR,\
 #VM_FORINIT,\
 #VM_BRAND,\
 #VM_BROR,\
 #VM_GOTO_PLACEHOLDER,\
 #VM_GOSUB_PLACEHOLDER,\
 #VM_GOSUB,\
 #VM_GOTOEXPR,\
 #VM_GOSUBEXPR,\
 #VM_ONGOTO,\
 #VM_ONGOSUB,\
 #VM_RETURN,\
 #VM_CALLFUNC,\
 #VM_PUSHEMPTY,\
 #VM_RETURNFUNC,\
 #VM_PUSHEMPTYREF,\
 #VM_PUSHARYREF,\
 #VM_END,\
 #VM_NEWARRAY,\
 #VM_INITARRAY,\
 #VM_READ,\
 #VM_RESTORE,\
 #VM_RESTORE_PLACEHOLDER,\
 #VM_RESTOREEXPR,\
 #VM_UNAOP,\
 #VM_CALLSPRITE,\
 #VM_CALLTEXT,\
 #VM_INC,\
 #VM_DEC,\
 #VM_POP,\
 #VM_WHEN,\
 #VM_SWAP,\
 #VM_INPUT,\
 #VM_LINPUT,\
 #VM_DEFOUT,\
 #VM_EXEC1,\
 #VM_EXEC2,\
 #VM_STOP1,\
 #VM_STOP2,\
 #VM_PUSHVAREXPR,\
 #VM_PUSHVAREXPRREF,\
 #VM_RETURNFUNCEXPR,\
 #VM_,\
 #VM_LAST

DIM VM_SLOT_OPS[]
DIM VMDBG_SLOT_LINE[]
DIM VMDBG_SLOT_LINE_PC[]
DIM VMDBG_SLOT_LINE_POS[]
DIM VMDBG_SLOT_LINE_END[]
DIM VMDBG_SLOT_LINE_POS_END[]
DIM VM_SLOT_IMM#[]
DIM VM_SLOT_IMM$[]
DIM VM_SLOT_GVARTBL[]
DIM VM_SLOT_GLBLTBL[]
DIM VM_SLOT_FUNCTBL[]
DIM VM_SLOT_CONSTTBL[]
DIM VM_SLOT_CONST_TYP[]
DIM VM_SLOT_CONST%[]
DIM VM_SLOT_CONST#[]
DIM VM_SLOT_CONST$[]
DIM VM_SLOT_GVAR_TYP[]
DIM VM_SLOT_GVAR%[]
DIM VM_SLOT_GVAR#[]
DIM VM_SLOT_GVAR$[]
DIM VM_SLOT_DATA_TYP[]
DIM VM_SLOT_DATA%[]
DIM VM_SLOT_DATA#[]
DIM VM_SLOT_DATA$[]
DIM VM_SLOT_EXEC_ADDR[]
DIM VM_SLOT_EXEC_FUNC[]
DIM VM_SLOT_EXEC_SLOT[]
DEF VM_IS_SLOT_COMPILED(SLOT)
 RETURN VM_SLOT_OPS[SLOT]!=0
END
DEF VM_GET_MAX_SLOT()
 RETURN LAST(VM_SLOT_OPS)
END
DEF VM_SWITCH_SLOT SLOT
 VM_OPS=VM_GET_ARRAY(VM_SLOT_OPS[SLOT])
 VM_IMM#=VM_GET_ARRAY(VM_SLOT_IMM#[SLOT])
 VM_IMM$=VM_GET_ARRAY(VM_SLOT_IMM$[SLOT])
 VM_GVAR_TYP=VM_GET_ARRAY(VM_SLOT_GVAR_TYP[SLOT])
 VM_GVAR%=VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT])
 VM_GVAR#=VM_GET_ARRAY(VM_SLOT_GVAR#[SLOT])
 VM_GVAR$=VM_GET_ARRAY(VM_SLOT_GVAR$[SLOT])
 VM_GVARTBL=VM_SLOT_GVARTBL[SLOT]
 VM_GLBLTBL=VM_SLOT_GLBLTBL[SLOT]
 VM_FUNCTBL=VM_SLOT_FUNCTBL[SLOT]
END
DEF VM_SWITCH_SLOT_DATA SLOT
 VM_DATA_TYP=VM_GET_ARRAY(VM_SLOT_DATA_TYP[SLOT])
 VM_DATA%=VM_GET_ARRAY(VM_SLOT_DATA%[SLOT])
 VM_DATA#=VM_GET_ARRAY(VM_SLOT_DATA#[SLOT])
 VM_DATA$=VM_GET_ARRAY(VM_SLOT_DATA$[SLOT])
END
DEF INIT_VM_CODEGEN
 VM_OPS=ARRAY%(0)
 VM_IMM#=ARRAY#(0)
 VM_IMM$=ARRAY$(0)
 VMDBG_LINE=ARRAY%(0)
 VMDBG_LINE_PC=ARRAY%(0)
 VMDBG_LINE_POS=ARRAY%(0)
 VMDBG_LINE_END=ARRAY%(0)
 VMDBG_LINE_POS_END=ARRAY%(0)
END
DEF INIT_VM
 VM_STK_SIZE=65536
 VM_STK_TYP=ARRAY%(VM_STK_SIZE)
 VM_STK%=ARRAY%(VM_STK_SIZE)
 VM_STK#=ARRAY#(VM_STK_SIZE)
 VM_STK$=ARRAY$(VM_STK_SIZE)
 VM_PC=0
 VM_DATA_IDX=0
 VM_CURFUNC=0
 VM_BP=0
 VM_SP=0
 INIT_COMPILER_VAR
 INIT_COMPILER_LABEL
 INIT_COMPILER_FUNC
 INIT_COMPILER_CONST
 OTX_INIT_SBARRAY
 VM_CFUNCTBL=NEW_SPLAY_TREE()

 VM_CURSLOT=0
 VM_CURDATASLOT=0
 VAR MAX_SLOT=4
 VM_SLOT_OPS=ARRAY%(MAX_SLOT)
 VMDBG_SLOT_LINE=ARRAY%(MAX_SLOT)
 VMDBG_SLOT_LINE_PC=ARRAY%(MAX_SLOT)
 VMDBG_SLOT_LINE_POS=ARRAY%(MAX_SLOT)
 VMDBG_SLOT_LINE_END=ARRAY%(MAX_SLOT)
 VMDBG_SLOT_LINE_POS_END=ARRAY%(MAX_SLOT)
 VM_SLOT_IMM#=ARRAY%(MAX_SLOT)
 VM_SLOT_IMM$=ARRAY%(MAX_SLOT)
 VM_SLOT_GVARTBL=ARRAY%(MAX_SLOT)
 VM_SLOT_GLBLTBL=ARRAY%(MAX_SLOT)
 VM_SLOT_FUNCTBL=ARRAY%(MAX_SLOT)
 VM_SLOT_CONSTTBL=ARRAY%(MAX_SLOT)
 VM_SLOT_CONST_TYP=ARRAY%(MAX_SLOT)
 VM_SLOT_CONST%=ARRAY%(MAX_SLOT)
 VM_SLOT_CONST#=ARRAY%(MAX_SLOT)
 VM_SLOT_CONST$=ARRAY%(MAX_SLOT)
 VM_SLOT_GVAR_TYP=ARRAY%(MAX_SLOT)
 VM_SLOT_GVAR%=ARRAY%(MAX_SLOT)
 VM_SLOT_GVAR#=ARRAY%(MAX_SLOT)
 VM_SLOT_GVAR$=ARRAY%(MAX_SLOT)
 VM_SLOT_DATA_TYP=ARRAY%(MAX_SLOT)
 VM_SLOT_DATA%=ARRAY%(MAX_SLOT)
 VM_SLOT_DATA#=ARRAY%(MAX_SLOT)
 VM_SLOT_DATA$=ARRAY%(MAX_SLOT)
 VM_SLOT_EXEC_FUNC=ARRAY%(MAX_SLOT)
 VM_SLOT_EXEC_ADDR=ARRAY%(MAX_SLOT)
 VM_SLOT_EXEC_SLOT=ARRAY%(MAX_SLOT)
END
DEF VM_RESET
 INIT_VM
END
DEF INIT_VM_GLOBAL_VAR TYPA,N
 IF !N THEN RETURN
 INIT_VM_GLOBAL_VAR TYPA,GET_SPLAYN_LEFT(N)
 VAR K$=GET_SPLAYN_KEY$(N)
 VAR V=GET_SPLAYN_VAL%(N)
 TYPA[VAR_IDX[V]]=VAR_TYP[V]
 INIT_VM_GLOBAL_VAR TYPA,GET_SPLAYN_RIGHT(N)
END
DEF LOAD_VM_SLOT SLOT
 VAR TYP=ARRAY%(CMP_GVARNUM)
 VAR G%=ARRAY%(CMP_GVARNUM)
 VAR G#=ARRAY#(CMP_GVARNUM)
 VAR G$=ARRAY$(CMP_GVARNUM)
 VM_SLOT_OPS[SLOT]=VM_ALLOC_ARRAY(VM_OPS)
 VMDBG_SLOT_LINE[SLOT]=VM_ALLOC_ARRAY(VMDBG_LINE)
 VMDBG_SLOT_LINE_PC[SLOT]=VM_ALLOC_ARRAY(VMDBG_LINE_PC)
 VMDBG_SLOT_LINE_POS[SLOT]=VM_ALLOC_ARRAY(VMDBG_LINE_POS)
 VMDBG_SLOT_LINE_END[SLOT]=VM_ALLOC_ARRAY(VMDBG_LINE_END)
 VMDBG_SLOT_LINE_POS_END[SLOT]=VM_ALLOC_ARRAY(VMDBG_LINE_POS_END)
 VM_SLOT_IMM#[SLOT]=VM_ALLOC_ARRAY(VM_IMM#)
 VM_SLOT_IMM$[SLOT]=VM_ALLOC_ARRAY(VM_IMM$)
 VM_SLOT_GVAR_TYP[SLOT]=VM_ALLOC_ARRAY(TYP)
 VM_SLOT_GVAR%[SLOT]=VM_ALLOC_ARRAY(G%)
 VM_SLOT_GVAR#[SLOT]=VM_ALLOC_ARRAY(G#)
 VM_SLOT_GVAR$[SLOT]=VM_ALLOC_ARRAY(G$)
 INIT_VM_GLOBAL_VAR TYP,GET_SPLAY_ROOT(CMP_GVARTBL)
 VM_SLOT_GLBLTBL[SLOT]=CMP_GLBLTBL
 VM_SLOT_FUNCTBL[SLOT]=CMP_FUNCTBL
 VM_SLOT_GVARTBL[SLOT]=CMP_GVARTBL
 VM_SLOT_CONSTTBL[SLOT]=CMP_CONSTTBL
 VM_SLOT_DATA_TYP[SLOT]=VM_ALLOC_ARRAY(CMP_DATA_TYP)
 VM_SLOT_DATA%[SLOT]=VM_ALLOC_ARRAY(CMP_DATA%)
 VM_SLOT_DATA#[SLOT]=VM_ALLOC_ARRAY(CMP_DATA#)
 VM_SLOT_DATA$[SLOT]=VM_ALLOC_ARRAY(CMP_DATA$)
 VM_SLOT_EXEC_SLOT[SLOT]=-1
 VM_SLOT_EXEC_ADDR[SLOT]=-1
 VM_SLOT_EXEC_FUNC[SLOT]=-1
 IF !LEN(VM_OPS)||VM_OPS[LAST(VM_OPS)]!=#VM_END THEN
  PUSH VM_OPS,#VM_END
 ENDIF
END
VAR VM_REPL_NEW_VAR_IDX
DEF INIT_COMPILER_REPL
 IF TYPEOF(VM_GVAR_TYP)==#T_DEFAULT THEN
  INIT_COMPILER 0
  RETURN
 ENDIF
 CMP_HAS_ERR=#FALSE
 VMDBG_LINE=ARRAY%(0)
 VMDBG_LINE_PC=ARRAY%(0)
 VMDBG_LINE_POS=ARRAY%(0)
 CMP_DATA_TYP=VM_DATA_TYP
 CMP_DATA%=VM_DATA%
 CMP_DATA#=VM_DATA#
 CMP_DATA$=VM_DATA$
 CMP_GLBLTBL=VM_GLBLTBL
 CMP_FUNCTBL=VM_FUNCTBL
 CMP_GVARTBL=VM_GVARTBL
 CMP_CONSTTBL=VM_SLOT_CONSTTBL[VM_CURSLOT]
 CMP_GVARNUM=LEN(VM_GVAR_TYP)
 VM_REPL_NEW_VAR_IDX=CMP_GVARNUM
 CMP_STRICT=#FALSE
 CMP_DEFINT=#FALSE
 CMP_BREAK=EMPTY()
 CMP_CONTINUE=EMPTY()
 CMP_SLOT=VM_CURSLOT
 VM_PC=LEN(VM_OPS)
END

DEF INIT_VM_GLOBAL_VAR_REPL NEW_VAR_IDX,TYPA,N
 IF !N THEN RETURN
 INIT_VM_GLOBAL_VAR_REPL NEW_VAR_IDX,TYPA,GET_SPLAYN_LEFT(N)
 VAR V=GET_SPLAYN_VAL%(N)
 IF VAR_IDX[V]>=NEW_VAR_IDX THEN
  VAR K$=GET_SPLAYN_KEY$(N)
  TYPA[VAR_IDX[V]]=VAR_TYP[V]
 ENDIF
 INIT_VM_GLOBAL_VAR_REPL NEW_VAR_IDX,TYPA,GET_SPLAYN_RIGHT(N)
END
DEF LOAD_VM_SLOT_REPL
 IF TYPEOF(VM_GVAR_TYP)==#T_DEFAULT THEN
  LOAD_VM_SLOT 0
  VM_RUN_SLOT 0
  RETURN
 ENDIF
 IF !LEN(VM_OPS)||VM_OPS[LAST(VM_OPS)]!=#VM_END THEN
  PUSH VM_OPS,#VM_END
 ENDIF
 VAR NEW_VAR_IDX=LEN(VM_GVAR_TYP)
 RESIZE VM_GVAR_TYP,CMP_GVARNUM
 RESIZE VM_GVAR%,CMP_GVARNUM
 RESIZE VM_GVAR#,CMP_GVARNUM
 RESIZE VM_GVAR$,CMP_GVARNUM
 INIT_VM_GLOBAL_VAR_REPL NEW_VAR_IDX,VM_GVAR_TYP,GET_SPLAY_ROOT(CMP_GVARTBL)
END

DEF VM_DEFINE_COMMON_DEF N$,FUNC
 VAR FOUND
 SPLAY_GET% VM_CFUNCTBL,N$ OUT FOUND,
 IF FOUND THEN
  COMPILER_DUPLICATE_FUNCTION N$
  RETURN
 ENDIF
 SPLAY_INSERT% VM_CFUNCTBL,N$,FUNC
END

DEF VM_RUN_SLOT SLOT
 VM_SWITCH_SLOT SLOT
 VM_SWITCH_SLOT_DATA SLOT
 VM_PC=0
 VM_PREV_PC=0
 VM_DATA_IDX=0
 VM_CURFUNC=0
 VM_BP=0
 VM_SP=0
 VM_CURSLOT=SLOT
 VM_CURDATASLOT=SLOT
END

DEF VM_STR$(T)
 CASE T
 WHEN #VM_NOP:RETURN "#VM_NOP"WHEN #VM_PUSHINT:RETURN "#VM_PUSHINT"WHEN #VM_PUSHDBL:RETURN "#VM_PUSHDBL"WHEN #VM_PUSHSTR:RETURN "#VM_PUSHSTR"WHEN #VM_BINOP:RETURN "#VM_BINOP"WHEN #VM_PRINT:RETURN "#VM_PRINT"WHEN #VM_TPRINT:RETURN "#VM_TPRINT"WHEN #VM_ASSIGN:RETURN "#VM_ASSIGN"WHEN #VM_PUSHVARREF:RETURN "#VM_PUSHVARREF"WHEN #VM_PUSHLVARREF:RETURN "#VM_PUSHLVARREF"WHEN #VM_REF:RETURN "#VM_REF"WHEN #VM_BR:RETURN "#VM_BR"WHEN #VM_BRTRUE:RETURN "#VM_BRTRUE"WHEN #VM_BRFALSE:RETURN "#VM_BRFALSE"WHEN #VM_FOR:RETURN "#VM_FOR"WHEN #VM_FORINIT:RETURN "#VM_FORINIT"WHEN #VM_BRAND:RETURN "#VM_BRAND"WHEN #VM_BROR:RETURN "#VM_BROR"WHEN #VM_GOTO_PLACEHOLDER:RETURN "#VM_GOTO_PLACEHOLDER"WHEN #VM_GOSUB_PLACEHOLDER:RETURN "#VM_GOSUB_PLACEHOLDER"WHEN #VM_GOSUB:RETURN "#VM_GOSUB"WHEN #VM_GOTOEXPR:RETURN "#VM_GOTOEXPR"WHEN #VM_GOSUBEXPR:RETURN "#VM_GOSUBEXPR"WHEN #VM_ONGOTO:RETURN "#VM_ONGOTO"WHEN #VM_ONGOSUB:RETURN "#VM_ONGOSUB"WHEN #VM_RETURN:RETURN "#VM_RETURN"WHEN #VM_CALLFUNC:RETURN "#VM_CALLFUNC"WHEN #VM_PUSHEMPTY:RETURN "#VM_PUSHEMPTY"WHEN #VM_RETURNFUNC:RETURN "#VM_RETURNFUNC"WHEN #VM_PUSHEMPTYREF:RETURN "#VM_PUSHEMPTYREF"WHEN #VM_PUSHARYREF:RETURN "#VM_PUSHARYREF"WHEN #VM_END:RETURN "#VM_END"WHEN #VM_NEWARRAY:RETURN "#VM_NEWARRAY"WHEN #VM_INITARRAY:RETURN "#VM_INITARRAY"WHEN #VM_READ:RETURN "#VM_READ"WHEN #VM_RESTORE:RETURN "#VM_RESTORE"WHEN #VM_RESTORE_PLACEHOLDER:RETURN "#VM_RESTORE_PLACEHOLDER"WHEN #VM_RESTOREEXPR:RETURN "#VM_RESTOREEXPR"WHEN #VM_UNAOP:RETURN "#VM_UNAOP"WHEN #VM_CALLSPRITE:RETURN "#VM_CALLSPRITE"WHEN #VM_CALLTEXT:RETURN "#VM_CALLTEXT"WHEN #VM_INC:RETURN "#VM_INC"WHEN #VM_DEC:RETURN "#VM_DEC"WHEN #VM_POP:RETURN "#VM_POP"WHEN #VM_:RETURN "#VM_"WHEN #VM_LAST:RETURN "#VM_LAST" OTHERWISE
  RETURN "#VM_"+STR$(T)
 ENDCASE
END

'CODE GEN INTERFACE
DEF EMIT_PUSHINT V
 PUSH VM_OPS,#VM_PUSHINT
 PUSH VM_OPS,V
END
DEF VM_ADDIMMDBL(V#)
 PUSH VM_IMM#,V#
 RETURN LAST(VM_IMM#)
END
DEF VM_ADDIMMSTR(V$)
 PUSH VM_IMM$,V$
 RETURN LAST(VM_IMM$)
END
DEF EMIT_PUSHDBL V#
 PUSH VM_OPS,#VM_PUSHDBL
 PUSH VM_OPS,VM_ADDIMMDBL(V#)
END
DEF EMIT_PUSHSTR V$
 PUSH VM_OPS,#VM_PUSHSTR
 PUSH VM_OPS,VM_ADDIMMSTR(V$)
END
DEF EMIT_BINOP TYP
 PUSH VM_OPS,#VM_BINOP
 PUSH VM_OPS,TYP
END
DEF EMIT_PRINT TYP
 PUSH VM_OPS,#VM_PRINT
 PUSH VM_OPS,TYP
END
DEF EMIT_TPRINT TYP
 PUSH VM_OPS,#VM_TPRINT
 PUSH VM_OPS,TYP
END
DEF EMIT_PUSHVARREF IDX
 PUSH VM_OPS,#VM_PUSHVARREF
 PUSH VM_OPS,IDX
END
DEF EMIT_PUSHLVARREF IDX
 PUSH VM_OPS,#VM_PUSHLVARREF
 PUSH VM_OPS,IDX
END
DEF EMIT_REF
 PUSH VM_OPS,#VM_REF
END
DEF EMIT_ASSIGN
 PUSH VM_OPS,#VM_ASSIGN
END
DEF EMIT_BRFALSE()
 PUSH VM_OPS,#VM_BRFALSE
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_BRTRUE()
 PUSH VM_OPS,#VM_BRTRUE
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_BR()
 PUSH VM_OPS,#VM_BR
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_FOR()
 PUSH VM_OPS,#VM_FOR
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_FORINIT()
 PUSH VM_OPS,#VM_FORINIT
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_BRAND()
 PUSH VM_OPS,#VM_BRAND
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_BROR()
 PUSH VM_OPS,#VM_BROR
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_WHEN()
 PUSH VM_OPS,#VM_WHEN
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_ADDR ADDR
 VM_OPS[ADDR]=LEN(VM_OPS)
END
DEF EMIT_ADDR2 ADDR,ADDR2
 VM_OPS[ADDR]=ADDR2
END
DEF EMIT_GOTO_PLACEHOLDER LABEL$
 PUSH VM_OPS,#VM_GOTO_PLACEHOLDER
 PUSH VM_OPS,VM_ADDIMMSTR(LABEL$)
END
DEF EMIT_GOSUB_PLACEHOLDER LABEL$
 PUSH VM_OPS,#VM_GOSUB_PLACEHOLDER
 PUSH VM_OPS,VM_ADDIMMSTR(LABEL$)
END
DEF EMIT_RETURN
 PUSH VM_OPS,#VM_RETURN
END
DEF EMIT_CALLFUNC FN$,INCNT,OUTCNT
 PUSH VM_OPS,#VM_CALLFUNC
 PUSH VM_OPS,VM_ADDIMMSTR(FN$)
 PUSH VM_OPS,INCNT
 PUSH VM_OPS,OUTCNT
END
DEF EMIT_RETURNFUNC
 PUSH VM_OPS,#VM_RETURNFUNC
END
DEF EMIT_RETURNFUNCEXPR
 PUSH VM_OPS,#VM_RETURNFUNCEXPR
END
DEF EMIT_PUSHEMPTY N
 PUSH VM_OPS,#VM_PUSHEMPTY
 PUSH VM_OPS,N
END
DEF EMIT_PUSHEMPTYREF
 PUSH VM_OPS,#VM_PUSHEMPTYREF
END
DEF EMIT_END
 PUSH VM_OPS,#VM_END
END
DEF EMIT_NEWARRAY DM,TYP
 PUSH VM_OPS,#VM_NEWARRAY
 PUSH VM_OPS,DM
 PUSH VM_OPS,TYP
END
DEF EMIT_INITARRAY CNT
 PUSH VM_OPS,#VM_INITARRAY
 PUSH VM_OPS,CNT
END
DEF EMIT_PUSHARYREF DM
 PUSH VM_OPS,#VM_PUSHARYREF
 PUSH VM_OPS,DM
END
DEF EMIT_READ
 PUSH VM_OPS,#VM_READ
END
DEF EMIT_RESTORE_PLACEHOLDER LABEL$
 PUSH VM_OPS,#VM_RESTORE_PLACEHOLDER
 PUSH VM_OPS,VM_ADDIMMSTR(LABEL$)
END
DEF EMIT_RESTORE SLOT,ADDR
 PUSH VM_OPS,#VM_RESTORE
 PUSH VM_OPS,SLOT
 PUSH VM_OPS,ADDR
END
DEF EMIT_UNAOP TYP
 PUSH VM_OPS,#VM_UNAOP
 PUSH VM_OPS,TYP
END
DEF EMIT_CALLSPRITE
 PUSH VM_OPS,#VM_CALLSPRITE
END
DEF EMIT_CALLTEXT
 PUSH VM_OPS,#VM_CALLTEXT
END
DEF EMIT_RESTOREEXPR
 PUSH VM_OPS,#VM_RESTOREEXPR
END
DEF EMIT_GOTOEXPR
 PUSH VM_OPS,#VM_GOTOEXPR
END
DEF EMIT_GOSUBEXPR
 PUSH VM_OPS,#VM_GOSUBEXPR
END
DEF EMIT_INC
 PUSH VM_OPS,#VM_INC
END
DEF EMIT_DEC
 PUSH VM_OPS,#VM_DEC
END
DEF EMIT_POP N
 PUSH VM_OPS,#VM_POP
 PUSH VM_OPS,N
END
DEF EMIT_SWAP
 PUSH VM_OPS,#VM_SWAP
END
DEF EMIT_INPUT GUIDE,SEMI,CNT
 PUSH VM_OPS,#VM_INPUT
 PUSH VM_OPS,GUIDE
 PUSH VM_OPS,SEMI
 PUSH VM_OPS,CNT
END
DEF EMIT_LINPUT GUIDE
 PUSH VM_OPS,#VM_LINPUT
 PUSH VM_OPS,GUIDE
END
DEF EMIT_ONGOTO LBL$[],GSB
 IF!GSB THEN
  PUSH VM_OPS,#VM_ONGOTO
 ELSE
  PUSH VM_OPS,#VM_ONGOSUB
 ENDIF
 PUSH VM_OPS,LEN(LBL$)
 VAR I
 FOR I=0TO LAST(LBL$)
  PUSH VM_OPS,VM_ADDIMMSTR(LBL$[I])
 NEXT
END
DEF EMIT_DEFOUT
 PUSH VM_OPS,#VM_DEFOUT
END
DEF EMIT_EXEC1
 PUSH VM_OPS,#VM_EXEC1
END
DEF EMIT_EXEC2
 PUSH VM_OPS,#VM_EXEC2
END
DEF EMIT_STOP1
 PUSH VM_OPS,#VM_STOP1
END
DEF EMIT_STOP2
 PUSH VM_OPS,#VM_STOP2
END
DEF EMIT_PUSHVAREXPR
 PUSH VM_OPS,#VM_PUSHVAREXPR
END
DEF EMIT_PUSHVAREXPRREF
 PUSH VM_OPS,#VM_PUSHVAREXPRREF
END
DEF COMPILER_CURRENT_ADDR()
 RETURN LEN(VM_OPS)
END
DEF VMDBG_ADD_SRC_INFO LINE,POS,LINE_END,POS_END
 VAR L=LAST(VMDBG_LINE)
 IF L>=0&&VMDBG_LINE_PC[L]==LEN(VM_OPS) THEN
  '?
  VMDBG_LINE[L]=LINE
  VMDBG_LINE_PC[L]=LEN(VM_OPS)
  VMDBG_LINE_POS[L]=POS
  VMDBG_LINE_END[L]=LINE_END
  VMDBG_LINE_POS_END[L]=POS_END
  RETURN
 ENDIF
 PUSH VMDBG_LINE,LINE
 PUSH VMDBG_LINE_PC,LEN(VM_OPS)
 PUSH VMDBG_LINE_POS,POS
 PUSH VMDBG_LINE_END,LINE_END
 PUSH VMDBG_LINE_POS_END,POS_END
END
DEF VMDBG_GET_SRC_INFO OUT LINE,POS,LINE_END,POS_END,PC
 VAR L=LAST(VMDBG_LINE)
 LINE=VMDBG_LINE[L]
 POS=VMDBG_LINE_POS[L]
 LINE_END=VMDBG_LINE_END[L]
 POS_END=VMDBG_LINE_POS_END[L]
 PC=VMDBG_LINE_PC[L]
END

'CODE GEN INTERFACE END




DEF VM_GET_PC()
 RETURN VM_PC
END
DEF VM_GET_BP()
 RETURN VM_BP
END
DEF VM_GET_SLOT()
 RETURN VM_CURSLOT
END
'VM
DEF VM_PUSHINT V%
 VM_STK_TYP[VM_SP]=#VMT_INT
 VM_STK%[VM_SP]=V%
 INC VM_SP
END
DEF VM_PUSHDBL V#
 VM_STK_TYP[VM_SP]=#VMT_REAL
 VM_STK#[VM_SP]=V#
 INC VM_SP
END
DEF VM_PUSHSTR V$
 VM_STK_TYP[VM_SP]=#VMT_STR
 VM_STK$[VM_SP]=V$
 INC VM_SP
END
DEF VM_V(TYP,V)
 IF TYP==#VMT_INTARRAY||TYP==#VMT_REALARRAY||TYP==#VMT_STRARRAY THEN
  V=VM_ALLOC_ARRAY(V)
 ENDIF
 RETURN V
END
DEF VM_GETV(TYP,V)
 IF TYP==#VMT_INTARRAY||TYP==#VMT_REALARRAY||TYP==#VMT_STRARRAY THEN
  V=VM_GET_ARRAY(V)
 ENDIF
 IF TYP==#VMT_DEFAULT THEN
  RETURN EMPTY()
 ENDIF
 RETURN V
END
DEF VM_PUSHTYP V,TYP
 VM_STK_TYP[VM_SP]=TYP
 VAR A=VM_GETSTKARY(TYP)
 IF TYP==#VMT_INTARRAY||TYP==#VMT_REALARRAY||TYP==#VMT_STRARRAY THEN
  V=VM_ALLOC_ARRAY(V)
 ENDIF
 IF TYP==#VMT_DEFAULT THEN
  INC VM_SP
  RETURN
 ENDIF
 A[VM_SP]=V
 INC VM_SP
END
DEF VM_PUSH V
 CASE TYPEOF(V)
 WHEN #T_DEFAULT
  VM_STK_TYP[VM_SP]=#VMT_DEFAULT
 WHEN #T_INT
  VM_STK_TYP[VM_SP]=#VMT_INT
  VM_STK%[VM_SP]=V
 WHEN #T_REAL
  VM_STK_TYP[VM_SP]=#VMT_REAL
  VM_STK#[VM_SP]=V
 WHEN #T_STR
  VM_STK_TYP[VM_SP]=#VMT_STR
  VM_STK$[VM_SP]=V
 WHEN #T_INTARRAY
  VM_STK_TYP[VM_SP]=#VMT_INTARRAY
  VM_STK%[VM_SP]=VM_ALLOC_ARRAY(V)
 WHEN #T_REALARRAY
  VM_STK_TYP[VM_SP]=#VMT_REALARRAY
  VM_STK%[VM_SP]=VM_ALLOC_ARRAY(V)
 WHEN #T_STRARRAY
  VM_STK_TYP[VM_SP]=#VMT_STRARRAY
  VM_STK%[VM_SP]=VM_ALLOC_ARRAY(V)
 OTHERWISE
  STOP
 ENDCASE
 INC VM_SP
END
DEF VM_POP * OUT T,V
 DEC VM_SP
 T=VM_STK_TYP[VM_SP]
 V=VM_GETSTKARY(T)[VM_SP]
 CASE T
 WHEN #VMT_INTARRAY
 WHEN #VMT_REALARRAY
 WHEN #VMT_STRARRAY
  IF DEFARGC()==1&&DEFARG(0)THEN
   V=VM_GET_ARRAY(V)
   RETURN
  ENDIF
  V=VM_GETFREE_ARRAY(V)
 ENDCASE
END
DEF VMINSTR_BINOP T
 VAR LT,LV
 VAR RT,RV
 VM_POP OUT RT,RV
 VM_POP OUT LT,LV
 CASE T
 WHEN #TKN_PLUS
  VM_PUSH LV+RV
 WHEN #TKN_MINUS
  VM_PUSH LV-RV
 WHEN #TKN_MUL
  VM_PUSH LV*RV
 WHEN #TKN_DIV
  VM_PUSH LV/RV
 WHEN #TKN_DIVINT
  VM_PUSH LV DIV RV
 WHEN #TKN_MOD
  VM_PUSH LV MOD RV
 WHEN #TKN_AND
  VM_PUSH LV AND RV
 WHEN #TKN_OR
  VM_PUSH LV OR RV
 WHEN #TKN_XOR
  VM_PUSH LV XOR RV
 WHEN #TKN_EQ
  VM_PUSH LV==RV
 WHEN #TKN_NEQ
  VM_PUSH LV!=RV
 WHEN #TKN_LSHIFT
  VM_PUSH LV<<RV
 WHEN #TKN_RSHIFT
  VM_PUSH LV>>RV
 WHEN #TKN_GREAT
  VM_PUSH LV<RV
 WHEN #TKN_LESS
  VM_PUSH LV>RV
 WHEN #TKN_GEQ
  VM_PUSH LV<=RV
 WHEN #TKN_LEQ
  VM_PUSH LV>=RV
 OTHERWISE
  STOP
 ENDCASE
END
DEF VMINSTR_UNAOP T
 VAR LT,LV
 VM_POP OUT LT,LV
 CASE T
 WHEN #TKN_MINUS
  VM_PUSH -LV
 WHEN #TKN_LNOT
  VM_PUSH !LV
 WHEN #TKN_NOT
  VM_PUSH NOT LV
 OTHERWISE
  STOP
 ENDCASE
END

DEF VM_PRINT IS_TPRINT,TYP
 VAR TP=#TCONSOLE
 VAR OFF=-2
 IF TYP==#VMPRINT_EMPTY THEN
  OFF=-1
 ENDIF
 IF IS_TPRINT THEN
  TP=VM_GETSTK(OFF)
 ENDIF
 IF TYP==#VMPRINT_EMPTY THEN
  TPRINT TP
  RETURN
 ENDIF
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_STR&&T!=#VMT_INT&&T!=#VMT_REAL THEN
  TYPE_MISMATCH "PRINT"
  RETURN
 ENDIF
 CASE TYP
 WHEN #VMPRINT_COMMA
  TPRINT TP,V,
 WHEN #VMPRINT_NEWLINE
  TPRINT TP,V
 WHEN #VMPRINT_SEMI
  TPRINT TP,V;
 ENDCASE
END
DEF VMINSTR_PUSHVARREF IDX
 VM_PUSHTYP IDX,#VMT_VARREF
END
DEF VMINSTR_PUSHLVARREF IDX
 VM_PUSHTYP IDX,#VMT_LVARREF
END
DEF VM_GETVAR(IDX)
 VAR TYP=VM_GVAR_TYP[IDX]
 CASE TYP
 WHEN #VMT_REAL
  RETURN VM_GVAR#[IDX]
 WHEN #VMT_DEFAULT
  RETURN
 WHEN #VMT_INT
  RETURN VM_GVAR%[IDX]
 WHEN #VMT_STR
  RETURN VM_GVAR$[IDX]
 WHEN #VMT_INTARRAY
 WHEN #VMT_REALARRAY
 WHEN #VMT_STRARRAY
  RETURN VM_GET_ARRAY(VM_GVAR%[IDX])
 ENDCASE
 VM_ERROR
END
DEF VM_GETVAR2 IDX OUT TYP,V
 TYP=VM_GVAR_TYP[IDX]
 CASE TYP
 WHEN #VMT_REAL
  V=VM_GVAR#[IDX]
  RETURN
 WHEN #VMT_DEFAULT
  RETURN
 WHEN #VMT_INT
  V=VM_GVAR%[IDX]
  RETURN
 WHEN #VMT_STR
  V=VM_GVAR$[IDX]
  RETURN
 WHEN #VMT_INTARRAY
 WHEN #VMT_REALARRAY
 WHEN #VMT_STRARRAY
  STOP
  RETURN VM_ALLOC_ARRAY(VM_GET_ARRAY(VM_GVAR%[IDX]))
 ENDCASE
 VM_ERROR
END
DEF VM_GETVAR2_SLOT SLOT,VIDX OUT TYP,V
 TYP=VM_GET_ARRAY(VM_SLOT_GVAR_TYP[SLOT])[VIDX]
 CASE TYP
 WHEN #VMT_INT
  V=VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT])[VIDX]
  RETURN
 WHEN #VMT_REAL
  V=VM_GET_ARRAY(VM_SLOT_GVAR#[SLOT])[VIDX]
  RETURN
 WHEN #VMT_STR
  V=VM_GET_ARRAY(VM_SLOT_GVAR$[SLOT])[VIDX]
  RETURN
 WHEN #VMT_INTARRAY
 WHEN #VMT_REALARRAY
 WHEN #VMT_STRARRAY
  V=VM_GET_ARRAY(VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT])[VIDX])
  RETURN
 WHEN #VMT_DEFAULT
  RETURN
 ENDCASE
 VM_ERROR
END
DEF VM_SETVAR_SLOT SLOT,VIDX,TYP,V
 VAR VM_GVAR_TYP=VM_GET_ARRAY(VM_SLOT_GVAR_TYP[SLOT])
 VM_GVAR_TYP[VIDX]=TYP
 CASE TYP
 WHEN #VMT_INT
  VAR GV=VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT])
  GV[VIDX]=V
  RETURN
 WHEN #VMT_REAL
  GV=VM_GET_ARRAY(VM_SLOT_GVAR#[SLOT])
  GV[VIDX]=V
  RETURN
 WHEN #VMT_STR
  GV=VM_GET_ARRAY(VM_SLOT_GVAR$[SLOT])
  GV[VIDX]=V
  RETURN
 WHEN #VMT_INTARRAY
 WHEN #VMT_REALARRAY
 WHEN #VMT_STRARRAY
  GV=VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT])
  GV[VIDX]=VM_ALLOC_ARRAY(V)
  RETURN
 WHEN #VMT_DEFAULT
  RETURN
 ENDCASE
 VM_ERROR
END
DEF VM_SETVAR IDX,TYP,V
 IF VM_GVAR_TYP[IDX]>=#VMT_INTARRAY&&VM_GVAR_TYP[IDX]<=#VMT_STRARRAY THEN
  VM_FREE_ARRAY VM_GVAR%[IDX]
 ENDIF
 VM_GVAR_TYP[IDX]=TYP
 CASE TYP
 WHEN #VMT_REAL
  VM_GVAR#[IDX]=V
 WHEN #VMT_INT
  VM_GVAR%[IDX]=V
 WHEN #VMT_STR
  VM_GVAR$[IDX]=V
 WHEN #VMT_INTARRAY
 WHEN #VMT_STRARRAY
 WHEN #VMT_REALARRAY
  VM_GVAR%[IDX]=VM_ALLOC_ARRAY(V)
 WHEN #VMT_DEFAULT
  RETURN
 OTHERWISE
  VM_ERROR_NOTIMPL
 ENDCASE
END
DEF VM_GETSTKARY(TYP)
 CASE TYP
 WHEN #VMT_REAL
  RETURN VM_STK#
 WHEN #VMT_ARYREF
 WHEN #VMT_INTARRAY
 WHEN #VMT_REALARRAY
 WHEN #VMT_STRARRAY
 WHEN #VMT_EMPTYREF
 WHEN #VMT_VARREF
 WHEN #VMT_VARREFSLOT
 WHEN #VMT_LVARREF
 WHEN #VMT_INT
 WHEN #VMT_SUBROUTINE
 WHEN #VMT_DEFAULT
  RETURN VM_STK%
 WHEN #VMT_STR
  RETURN VM_STK$
 OTHERWISE
  STOP
 ENDCASE
END
DEF VM_GETLVAR IDX OUT T,V
 T=VM_STK_TYP[VM_BP+IDX]
 V=VM_GETV(T,VM_GETSTKARY(T)[VM_BP+IDX])
END
DEF VM_SETSTK IDX,V
 IF VM_STK_TYP[VM_SP+IDX]>=#VMT_INTARRAY&&VM_STK_TYP[VM_SP+IDX]<=#VMT_STRARRAY THEN
  VM_FREE_ARRAY VM_STK%[VM_SP+IDX]
 ENDIF
 VAR T=VM_TYPE(V)
 VM_STK_TYP[VM_SP+IDX]=T
 VAR A=VM_GETSTKARY(T)
 A[VM_SP+IDX]=VM_V(T,V)
END
DEF VM_GETSTK IDX OUT V
 VAR T=VM_STK_TYP[VM_SP+IDX]
 V=VM_GETV(T,VM_GETSTKARY(T)[VM_SP+IDX])
END
ENUM\
 #VMSTK_STARTARGS=#VM_LVAROFF,\
 #VMSTK_OUTCNT,\
 #VMSTK_INCNT,\
 #VMSTK_FUNC,\
 #VMSTK_BP,\
 #VMSTK_SLOT,\
 #VMSTK_PC
DEF VM_SETLVAR IDX,T,V
 IF IDX<0&&FUNC_INCNT[VM_CURFUNC]==-1 THEN
  'VAARGS
  VAR IC=VM_STK%[VM_BP+#VMSTK_INCNT]
  DEC IDX,IC
 ENDIF
 IF VM_STK_TYP[VM_BP+IDX]>=#VMT_INTARRAY&&VM_STK_TYP[VM_BP+IDX]<=#VMT_STRARRAY THEN
  VM_FREE_ARRAY VM_STK%[VM_BP+IDX]
 ENDIF
 VM_STK_TYP[VM_BP+IDX]=T
 VAR A=VM_GETSTKARY(T)
 A[VM_BP+IDX]=VM_V(T,V)
END
DEF VM_TYPE(V)
 CASE TYPEOF(V)
 WHEN #T_DEFAULT
  RETURN #VMT_DEFAULT
 WHEN #T_INT
  RETURN #VMT_INT
 WHEN #T_REAL
  RETURN #VMT_REAL
 WHEN #T_STR
  RETURN #VMT_STR
 WHEN #T_INTARRAY
  RETURN #VMT_INTARRAY
 WHEN #T_REALARRAY
  RETURN #VMT_REALARRAY
 WHEN #T_STRARRAY
  RETURN #VMT_STRARRAY
 OTHERWISE
  STOP
 ENDCASE
END
DEF VMINSTR_REF
 VAR T,V
 VM_POP OUT T,V
 CASE T
 WHEN #VMT_VARREF
  VM_PUSH VM_GETVAR(V)
 WHEN #VMT_VARREFSLOT
  VAR SLOT_V
  VM_POP OUT ,SLOT_V
  VM_GETVAR2_SLOT SLOT_V,V OUT T,V
  VM_PUSHTYP V,T
 WHEN #VMT_LVARREF
  VM_GETLVAR V OUT T,V
  VM_PUSHTYP V,T
 WHEN #VMT_ARYREF
  VAR DM1,DM2,DM3,DM4
  VAR ARYT,ARYV
  VM_POP OUT ARYT,ARYV
  IF!VM_ISARYTYP(ARYT)THEN
   TYPE_MISMATCH "ARRAY EXPECTED BUT "+VMT_STR$(ARYT)
   RETURN
  ENDIF
  VAR ERR
  VM_POP_DIMS V OUT DM1,DM2,DM3,DM4,ERR
  IF ERR THEN RETURN
  IF ARYT==#VMT_STR THEN
   IF V!=1THEN
    SYNTAX_ERROR "DIM MISMATCH"
    RETURN
   ENDIF
  ELSEIF ARYT==#VMT_INTARRAY||ARYT==#VMT_STRARRAY||ARYT==#VMT_REALARRAY THEN
   IF V!=1&&DIM(ARYV)!=V THEN
    SYNTAX_ERROR "DIM MISMATCH"
    RETURN
   ENDIF
  ENDIF
  CASE V
  WHEN 1
   IF LEN(ARYV)<=DM1 THEN
    SUBSCRIPT_OUT_OF_RANGE "REF ARRAY"
    RETURN
   ENDIF
   VM_PUSH ARYV[DM1]
  WHEN 2
   IF DIM(ARYV,0)<=DM1||DIM(ARYV,1)<=DM2 THEN
    SUBSCRIPT_OUT_OF_RANGE "REF ARRAY(2D)"
    RETURN
   ENDIF
   VM_PUSH ARYV[DM1,DM2]
  WHEN 3
   IF DIM(ARYV,0)<=DM1||DIM(ARYV,1)<=DM2||DIM(ARYV,2)<=DM3 THEN
    SUBSCRIPT_OUT_OF_RANGE "REF ARRAY(3D)"
    RETURN
   ENDIF
   VM_PUSH ARYV[DM1,DM2,DM3]
  WHEN 4
   IF DIM(ARYV,0)<=DM1||DIM(ARYV,1)<=DM2||DIM(ARYV,2)<=DM3||DIM(ARYV,3)<=DM4 THEN
    SUBSCRIPT_OUT_OF_RANGE "REF ARRAY(4D)"
    RETURN
   ENDIF
   VM_PUSH ARYV[DM1,DM2,DM3,DM4]
  OTHERWISE
   INTERNAL_VM_ERROR
  ENDCASE
 OTHERWISE
  INTERNAL_VM_ERROR
 ENDCASE
END
DEF VMINSTR_ASSIGN
 VAR T,V
 VAR REFT,REFV
 VM_POP OUT REFT,REFV
 VM_ASSIGN REFT,REFV,#TRUE,T,V,
END
DEF VM_ASSIGN REFT,REFV,POP,T,V,ERR
 ERR=#FALSE
 CASE REFT
 WHEN #VMT_LVARREF
  IF POP THEN VM_POP OUT T,V
  VM_SETLVAR REFV,T,V
 WHEN #VMT_VARREF
  IF POP THEN VM_POP OUT T,V
  VM_SETVAR REFV,T,V
 WHEN #VMT_VARREFSLOT
  VAR SLOT_V
  VM_POP OUT ,SLOT_V
  IF POP THEN VM_POP OUT T,V
  VM_SETVAR_SLOT SLOT_V,REFV,T,V
 WHEN #VMT_EMPTYREF
  IF POP THEN VM_POP OUT T,V
  RETURN
 WHEN #VMT_ARYREF
  VAR DM1,DM2,DM3,DM4
  VAR ARYT,ARYV
  VM_POP OUT ARYT,ARYV
  IF!VM_ISARYTYP(ARYT)THEN
   ERR=#TRUE
   TYPE_MISMATCH "ARRAY EXPECTED BUT "+VMT_STR$(ARYT)
   RETURN
  ENDIF
  VM_POP_DIMS REFV OUT DM1,DM2,DM3,DM4,ERR
  IF ERR THEN RETURN
  IF POP THEN VM_POP OUT T,V
  IF ARYT==#VMT_STR||ARYT==#VMT_STRARRAY THEN
   IF T!=#VMT_STR THEN
    ERR=#TRUE
    TYPE_MISMATCH "ASSIGN ARRAY"
    RETURN
   ENDIF
  ELSEIF !VM_ISNUMTYPE(T) THEN
   ERR=#TRUE
   TYPE_MISMATCH "ASSIGN ARRAY"
   RETURN
  ENDIF
  IF REFV!=1&&DIM(ARYV)!=REFV THEN
   ERR=#TRUE
   SYNTAX_ERROR "DIM MISMATCH"
   RETURN
  ENDIF
  CASE REFV
  WHEN 1
   IF LEN(ARYV)<=DM1 THEN
   STOP
    ERR=#TRUE
    SUBSCRIPT_OUT_OF_RANGE "ASSIGN ARRAY"
    RETURN
   ENDIF
   ARYV[DM1]=V
  WHEN 2
   IF DIM(ARYV,0)<=DM1||DIM(ARYV,1)<=DM2 THEN
    ERR=#TRUE
    SUBSCRIPT_OUT_OF_RANGE "ASSIGN ARRAY(2D)"
    RETURN
   ENDIF
   ARYV[DM1,DM2]=V
  WHEN 3
   IF DIM(ARYV,0)<=DM1||DIM(ARYV,1)<=DM2||DIM(ARYV,2)<=DM3 THEN
    ERR=#TRUE
    SUBSCRIPT_OUT_OF_RANGE "ASSIGN ARRAY(3D)"
    RETURN
   ENDIF
   ARYV[DM1,DM2,DM3]=V
  WHEN 4
   IF DIM(ARYV,0)<=DM1||DIM(ARYV,1)<=DM2||DIM(ARYV,2)<=DM3||DIM(ARYV,3)<=DM4 THEN
    ERR=#TRUE
    SUBSCRIPT_OUT_OF_RANGE "ASSIGN ARRAY(4D)"
    RETURN
   ENDIF
   ARYV[DM1,DM2,DM3,DM4]=V
  OTHERWISE
   INTERNAL_VM_ERROR
  ENDCASE
 OTHERWISE
  INTERNAL_VM_ERROR
 ENDCASE
END
DEF VM_REF OUT REFT,REFV,T,V,ERR
 ERR=#FALSE
 VM_POP OUT REFT,REFV
 CASE REFT
 WHEN #VMT_LVARREF
  VM_GETLVAR REFV OUT T,V
 WHEN #VMT_VARREF
  VM_GETVAR2 REFV OUT T,V
 WHEN #VMT_VARREFSLOT
  VAR SLOT_V
  VM_POP OUT ,SLOT_V
  VM_GETVAR2_SLOT SLOT_V,REFV OUT T,V
 WHEN #VMT_EMPTYREF
  RETURN
 WHEN #VMT_ARYREF
  VAR DM1,DM2,DM3,DM4
  VAR ARYT,ARYV
  VM_POP #TRUE OUT ARYT,ARYV
  IF!VM_ISARYTYP(ARYT)THEN
   ERR=#TRUE
   TYPE_MISMATCH "ARRAY EXPECTED BUT "+VMT_STR$(ARYT)
   RETURN
  ENDIF
  VM_POP_DIMS REFV OUT DM1,DM2,DM3,DM4,ERR
  IF ERR THEN RETURN
  CASE REFV
  WHEN 1
   V=ARYV[DM1]
  WHEN 2
   V=ARYV[DM1,DM2]
  WHEN 3
   V=ARYV[DM1,DM2,DM3]
  WHEN 4
   V=ARYV[DM1,DM2,DM3,DM4]
  OTHERWISE
   INTERNAL_VM_ERROR
  ENDCASE
  T=VM_TYPE(V)
 OTHERWISE
  INTERNAL_VM_ERROR
 ENDCASE
END
DEF VM_ISNUMTYPE(TYP)
 RETURN TYP==#VMT_INT||TYP==#VMT_REAL
END
DEF VMINSTR_FOR INIT
 VAR BRKADDR=VM_OPS[VM_PC]
 INC VM_PC
 VAR T_TO,V_TO
 VAR T_STEP=#VMT_INT,V_STEP=1
 VAR RT_IDX,RV_IDX
 VAR T_IDX,V_IDX
 VM_POP OUT T_TO,V_TO
 VM_POP OUT T_STEP,V_STEP
 VAR OSP=VM_SP
 VAR ERR
 VM_REF OUT RT_IDX,RV_IDX,T_IDX,V_IDX,ERR
 IF ERR THEN RETURN
 VM_SP=OSP-1
 IF!VM_ISNUMTYPE(T_IDX)||!VM_ISNUMTYPE(T_STEP)||!VM_ISNUMTYPE(T_TO) THEN
  TYPEMISMATCH "FOR"
  RETURN
 ENDIF
 IF !INIT THEN
  V_IDX=V_IDX+V_STEP
  VM_ASSIGN RT_IDX,RV_IDX,#FALSE,T_IDX,V_IDX,ERR
  IF ERR THEN RETURN
 ENDIF
 IF V_STEP>0&&V_IDX>V_TO THEN
  IF INIT THEN
   VM_PC=BRKADDR
  ENDIF
 ELSEIF V_STEP<0&&V_IDX<V_TO THEN
  IF INIT THEN
   VM_PC=BRKADDR
  ENDIF
 ELSE
  IF !INIT THEN
   VM_PC=BRKADDR
  ENDIF
 ENDIF
END
DEF VMINSTR_BRAND ADDR
 VAR T,V
 VM_POP OUT T,V
 IF!VM_ISNUMTYPE(T) THEN
  TYPEMISMATCH "&&"
  RETURN
 ENDIF
 IF !V THEN
  VM_PUSHINT #FALSE
  VM_PC=ADDR
 ENDIF
END
DEF VMINSTR_BROR ADDR
 VAR T,V
 VM_POP OUT T,V
 IF!VM_ISNUMTYPE(T) THEN
  TYPEMISMATCH "||"
  RETURN
 ENDIF
 IF V THEN
  VM_PC=ADDR
  VM_PUSHINT #TRUE
 ENDIF
END

DEF VM_CHKLABEL(LABEL$,F)
 'FIXME:SLOT
 VAR HAS_SLOT
 IF INSTR(LABEL$,":")!=-1 THEN
  LABEL$=MID$(LABEL$,INSTR(LABEL$,":")+1,&H7FFFFFFF)
  HAS_SLOT=#TRUE
  F=#TRUE
 ENDIF
 VAR FOUND
 IF !HAS_SLOT&&VM_CURFUNC THEN
  SPLAY_GET% FUNC_LBLTBL[VM_CURFUNC],LABEL$ OUT FOUND,
 ENDIF
 IF VM_CURFUNC&&!F THEN
  RETURN FOUND
 ENDIF
 IF !FOUND THEN
  SPLAY_GET% VM_GLBLTBL,LABEL$ OUT FOUND,
 ENDIF
 RETURN FOUND
END
'"0:FUNC"  :1
'"00:FUNC" :1
'" 00:FUNC":0
'"&H0:FUNC":0
'"0 :FUNC" :0
DEF VM_PARSE_SLOT L$,LABEL OUT ILL_FMT,HAS_SLOT,SLOT,N$
 N$=L$
 VAR POS=INSTR(L$,":")
 IF POS==-1 THEN
  HAS_SLOT=#FALSE
  ILL_FMT=#FALSE
  IF LABEL&&MID$(L$,0,1)!="@"THEN
   ILL_FMT=#TRUE
   RETURN
  ENDIF
  RETURN
 ENDIF
 N$=MID$(L$,POS+1,&H7FFFFFFF)
 VAR S$=MID$(L$,0,POS)
 VAR I
 FOR I=0TO LAST(S$)
  IF S$[I]<"0"||S$[I]>"9"THEN
   ILL_FMT=#TRUE
   RETURN
  ENDIF
 NEXT
 SLOT=VAL(S$)
 IF LABEL&&MID$(N$,0,1)!="@"THEN
  ILL_FMT=#TRUE
  RETURN
 ENDIF
 IF SLOT<0||SLOT>=4 THEN
  ILL_FMT=#TRUE
  RETURN
 ENDIF
 ILL_FMT=#FALSE
 HAS_SLOT=#TRUE
END

DEF VM_CHKCALL(FUNC$)
 VAR ILL_FMT,HAS_SLOT,SLOT
 VM_PARSE_SLOT FUNC$,#FALSE OUT ILL_FMT,HAS_SLOT,SLOT,FUNC$
 IF ILL_FMT THEN
  RETURN #FALSE
 ENDIF
 VAR FOUND
 SPLAY_GET% VM_FUNCTBL,FUNC$ OUT FOUND,
 IF !FOUND&&!HAS_SLOT THEN
  SPLAY_GET% VM_CFUNCTBL,FUNC$ OUT FOUND,
 ENDIF
 'HAS SLOT && BUILTIN FUNCTION->#TRUE
 RETURN FOUND||CHKCALL("3:"+FUNC$)||CHKCALL("SBSB_"+FUNC$)
END
DEF VM_GET_LABEL LABEL$,SEARCH_GLOBAL OUT SLOT,LABEL,FOUND
 VAR TBL
 VAR ILL_FMT,HAS_SLOT
 FOUND=#FALSE
 VM_PARSE_SLOT LABEL$,#TRUE OUT ILL_FMT,HAS_SLOT,SLOT,LABEL$
 IF ILL_FMT THEN
  ILLEGAL_LABEL_STRING LABEL$
  SLOT=-1
  LABEL=-1
  RETURN
 ENDIF
 IF VM_CURFUNC&&HAS_SLOT THEN
  UNDEFINED_LABEL LABEL$
  SLOT=-1
  LABEL=-1
  RETURN
 ENDIF
 IF !HAS_SLOT THEN
  SLOT=VM_CURSLOT
 ENDIF
 IF VM_CURFUNC THEN
  TBL=FUNC_LBLTBL[VM_CURFUNC]
 ELSE
  TBL=VM_SLOT_GLBLTBL[SLOT]
 ENDIF
 SPLAY_GET% TBL,LABEL$ OUT FOUND,LABEL
 IF SEARCH_GLOBAL&&!FOUND&&VM_CURFUNC THEN
  TBL=VM_SLOT_GLBLTBL[SLOT]
  SPLAY_GET% TBL,LABEL$ OUT FOUND,LABEL
 ENDIF
 IF !FOUND THEN
  UNDEFINED_LABEL LABEL$
  SLOT=-1
  LABEL=-1
  RETURN
 ENDIF
END

DEF VM_GET_LABEL_DATA_ADDR LABEL$ OUT SLOT,ADDR,FOUND
 VAR LABEL
 VM_GET_LABEL LABEL$,#TRUE OUT SLOT,LABEL,FOUND
 IF !FOUND THEN RETURN
 ADDR=LABEL_DATA_ADDR[LABEL]
END
DEF VM_GET_LABEL_ADDR LABEL$ OUT SLOT,ADDR,FOUND
 VAR LABEL
 VM_GET_LABEL LABEL$,#FALSE OUT SLOT,LABEL,FOUND
 IF !FOUND THEN RETURN
 ADDR=LABEL_ADDR[LABEL]
END
DEF VMINSTR_GOTO_PLACEHOLDER
 VAR ADDR,SLOT,FOUND
 VM_GET_LABEL_ADDR VM_IMM$[VM_OPS[VM_PC]] OUT SLOT,ADDR,FOUND
 IF !FOUND THEN RETURN
 VM_ASSERT VM_CURSLOT==SLOT
 VM_OPS[VM_PC-1]=#VM_BR
 VM_OPS[VM_PC]=ADDR
 VM_PC=ADDR
END
DEF VMINSTR_GOSUB_PLACEHOLDER
 VAR ADDR,SLOT,FOUND
 VM_GET_LABEL_ADDR VM_IMM$[VM_OPS[VM_PC]] OUT SLOT,ADDR,FOUND
 IF !FOUND THEN RETURN
 VM_ASSERT VM_CURSLOT==SLOT
 VM_OPS[VM_PC-1]=#VM_GOSUB
 VM_OPS[VM_PC]=ADDR
 DEC VM_PC
END
DEF VMINSTR_GOSUB SLOT,ADDR
 VAR RETADDR=VM_PC
 VM_PUSHTYP VM_CURSLOT,#VMT_SUBROUTINE
 VM_PUSHTYP RETADDR,#VMT_SUBROUTINE
 VM_PC=ADDR
 IF VM_CURSLOT!=SLOT THEN
  VM_CURSLOT=SLOT
  VM_SWITCH_SLOT VM_CURSLOT
 ENDIF
END
DEF VMINSTR_RETURN
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_SUBROUTINE THEN
  RETURN_WITHOUT_GOSUB
  RETURN
 ENDIF
 VAR TS,VS
 VM_POP OUT TS,VS
 IF TS!=#VMT_SUBROUTINE THEN
  VM_INTERNAL_ERROR
  RETURN
 ENDIF
 IF VS!=VM_CURSLOT THEN
  VM_CURSLOT=VS
  VM_SWITCH_SLOT VM_CURSLOT
 ENDIF
 VM_PC=V
END
DEF VMINSTR_PUSHEMPTY N
 FILL VM_STK_TYP,#VMT_DEFAULT,VM_SP,N
 INC VM_SP,N
END
DEF VM_GETFUNC NAME$,INCNT1,OUTCNT1 OUT FOUND,FUNC
 SPLAY_GET% VM_FUNCTBL,NAME$ OUT FOUND,FUNC
 IF FOUND THEN RETURN
 SPLAY_GET% VM_CFUNCTBL,NAME$ OUT FOUND,FUNC
 RETURN
END
DEF GENERATE_NATIVE_RELAY
 VAR I,O
 VAR R$=""
 VAR IM=9,OM=9
 PUSH R$,"DEF RELAY_NATIVE_FUNC N$,I,O"
 PUSH R$,CHR$(10)
 PUSH R$," DEC VM_SP,I"
 PUSH R$,CHR$(10)
 PUSH R$," VAR "
 FOR O=1TO OM
  PUSH R$,"O"
  PUSH R$,STR$(O)
  PUSH R$,","
 NEXT
 PUSH R$,CHR$(10)
 PUSH R$," ON I*"+STR$(OM+1)+"+O GOTO "
 FOR I=0TO IM
  FOR O=0TO OM
   PUSH R$,"@I"
   PUSH R$,STR$(I)
   PUSH R$,"O"
   PUSH R$,STR$(O)
   'TAILING COMMA NOT ALLOWED
   IF I!=IM||O!=OM THEN
    PUSH R$,","
   ENDIF
  NEXT
 NEXT
 PUSH R$,CHR$(10)
 FOR I=0TO IM
  FOR O=0TO OM
   PUSH R$," @I"
   PUSH R$,STR$(I)
   PUSH R$,"O"
   PUSH R$,STR$(O)
   PUSH R$,":"
   PUSH R$,"CALL N$"
   VAR I2
   FOR I2=1TO I
    PUSH R$,",VM_GETSTK(
    PUSH R$,STR$(I-I2)
    PUSH R$,")"
   NEXT
   FOR I2=1TO O
    IF I2==1 THEN
     PUSH R$," OUT O1"
    ELSE
     PUSH R$,",O"
     PUSH R$,STR$(I2)
    ENDIF
   NEXT
   PUSH R$,":"
   FOR I2=1TO O
    PUSH R$,"VM_SETSTK -"
    PUSH R$,STR$(I2)
    PUSH R$,",O"
    PUSH R$,STR$(O+1-I2)
    PUSH R$,":"
   NEXT
   PUSH R$,"RETURN"
   PUSH R$,CHR$(10)
  NEXT
 NEXT
 PUSH R$,"END"
 PUSH R$,CHR$(10)
 CLIPBOARD R$
END












DEF RELAY_NATIVE_FUNC N$,I,O
 DEC VM_SP,I
 VAR O1,O2,O3,O4,O5,O6,O7,O8,O9,
 ON I*10+O GOTO @I0O0,@I0O1,@I0O2,@I0O3,@I0O4,@I0O5,@I0O6,@I0O7,@I0O8,@I0O9,@I1O0,@I1O1,@I1O2,@I1O3,@I1O4,@I1O5,@I1O6,@I1O7,@I1O8,@I1O9,@I2O0,@I2O1,@I2O2,@I2O3,@I2O4,@I2O5,@I2O6,@I2O7,@I2O8,@I2O9,@I3O0,@I3O1,@I3O2,@I3O3,@I3O4,@I3O5,@I3O6,@I3O7,@I3O8,@I3O9,@I4O0,@I4O1,@I4O2,@I4O3,@I4O4,@I4O5,@I4O6,@I4O7,@I4O8,@I4O9,@I5O0,@I5O1,@I5O2,@I5O3,@I5O4,@I5O5,@I5O6,@I5O7,@I5O8,@I5O9,@I6O0,@I6O1,@I6O2,@I6O3,@I6O4,@I6O5,@I6O6,@I6O7,@I6O8,@I6O9,@I7O0,@I7O1,@I7O2,@I7O3,@I7O4,@I7O5,@I7O6,@I7O7,@I7O8,@I7O9,@I8O0,@I8O1,@I8O2,@I8O3,@I8O4,@I8O5,@I8O6,@I8O7,@I8O8,@I8O9,@I9O0,@I9O1,@I9O2,@I9O3,@I9O4,@I9O5,@I9O6,@I9O7,@I9O8,@I9O9
 @I0O0:CALL N$:RETURN
 @I0O1:CALL N$ OUT O1:VM_SETSTK -1,O1:RETURN
 @I0O2:CALL N$ OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I0O3:CALL N$ OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I0O4:CALL N$ OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I0O5:CALL N$ OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I0O6:CALL N$ OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I0O7:CALL N$ OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I0O8:CALL N$ OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I0O9:CALL N$ OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I1O0:CALL N$,VM_GETSTK(0):RETURN
 @I1O1:CALL N$,VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I1O2:CALL N$,VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I1O3:CALL N$,VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I1O4:CALL N$,VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I1O5:CALL N$,VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I1O6:CALL N$,VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I1O7:CALL N$,VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I1O8:CALL N$,VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I1O9:CALL N$,VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I2O0:CALL N$,VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I2O1:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I2O2:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I2O3:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I2O4:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I2O5:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I2O6:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I2O7:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I2O8:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I2O9:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I3O0:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I3O1:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I3O2:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I3O3:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I3O4:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I3O5:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I3O6:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I3O7:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I3O8:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I3O9:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I4O0:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I4O1:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I4O2:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I4O3:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I4O4:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I4O5:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I4O6:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I4O7:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I4O8:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I4O9:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I5O0:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I5O1:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I5O2:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I5O3:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I5O4:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I5O5:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I5O6:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I5O7:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I5O8:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I5O9:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I6O0:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I6O1:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I6O2:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I6O3:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I6O4:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I6O5:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I6O6:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I6O7:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I6O8:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I6O9:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I7O0:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I7O1:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I7O2:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I7O3:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I7O4:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I7O5:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I7O6:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I7O7:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I7O8:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I7O9:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I8O0:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I8O1:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I8O2:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I8O3:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I8O4:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I8O5:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I8O6:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I8O7:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I8O8:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I8O9:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I9O0:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I9O1:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I9O2:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I9O3:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I9O4:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I9O5:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I9O6:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I9O7:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I9O8:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I9O9:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
END









DEF CALL_NATIVE_FUNC NAME$,INCNT,OUTCNT
 CASE NAME$
 WHEN "CHKLABEL"
  IF OUTCNT!=1||(INCNT!=1&&INCNT!=2) THEN
   MISSING_PARAMETER "CHKLABEL"
   RETURN
  ENDIF
  DEC VM_SP,INCNT
  VAR I1,I2,O1
  IF INCNT==2 THEN
   I1=VM_GETSTK(1)
   I2=VM_GETSTK(0)
   O1=VM_CHKLABEL(I1,I2)
  ELSE
   I1=VM_GETSTK(0)
   O1=VM_CHKLABEL(I1,#FALSE)
  ENDIF
  VM_SETSTK -1,O1
  RETURN
 WHEN "CHKCALL"
  IF OUTCNT!=1||INCNT!=1 THEN
   MISSING_PARAMETER "CHKCALL"
   RETURN
  ENDIF
  DEC VM_SP,INCNT
  I1=VM_GETSTK(0)
  O1=VM_CHKCALL(I1)
  VM_SETSTK -1,O1
  RETURN
 WHEN "DEFARGC"
  IF OUTCNT!=1||INCNT!=0 THEN
   MISSING_PARAMETER "DEFARGC"
   RETURN
  ENDIF
  DEC VM_SP,INCNT
  IF!VM_CURFUNC THEN
   VM_SETSTK -1,0
  ENDIF
  VAR T,V
  VM_GETLVAR #VMSTK_INCNT OUT T,V
  IF T!=#VMT_INT THEN
   VM_INTERNAL_ERROR "TYPE OF #VMSTK_INCNT SHOULD BE #VMT_INT"
  ENDIF
  VM_SETSTK -1,V
 WHEN "DEFARG"
  IF OUTCNT!=1||INCNT!=1 THEN
   MISSING_PARAMETER "DEFARG"
   RETURN
  ENDIF
  DEC VM_SP,INCNT
  IF!VM_CURFUNC THEN
   CANT_USE_OUTSIDE_DEF "DEFARG"
   RETURN
  ENDIF
  I1=VM_GETSTK(0)
  IF TYPEOF(I1)!=#T_INT&&TYPEOF(I1)!=#T_REAL THEN
   TYPE_MISMATCH "DEFARG"
   RETURN
  ENDIF
  VM_GETLVAR #VMSTK_STARTARGS-I1 OUT T,V
  IF !VM_ISPRITYP(T)THEN
   VM_INTERNAL_ERROR "DEFARG"
  ENDIF
  VM_SETSTK -1,V
 WHEN "DEFOUTC"
  IF OUTCNT!=1||INCNT!=0 THEN
   MISSING_PARAMETER "DEFOUTC"
   RETURN
  ENDIF
  DEC VM_SP,INCNT
  IF!VM_CURFUNC THEN
   VM_SETSTK -1,0
  ENDIF
  VM_GETLVAR #VMSTK_OUTCNT OUT T,V
  IF T!=#VMT_INT THEN
   VM_INTERNAL_ERROR "TYPE OF #VMSTK_OUTCNT SHOULD BE #VMT_INT"
  ENDIF
  VM_SETSTK -1,V
 OTHERWISE
  RELAY_NATIVE_FUNC NAME$,INCNT,OUTCNT
 ENDCASE
 'CLEANUP ARRAYS
 VAR I,L=VM_SP+INCNT-1
 FOR I=VM_SP TO L
  T=VM_STK_TYP[I]
  IF T==#VMT_INTARRAY||T==#VMT_REALARRAY||T==#VMT_STRARRAY THEN
   VM_FREE_ARRAY VM_STK%[I]
  ENDIF
 NEXT
END
DEF VMINSTR_CALLFUNC
 VAR NAME$=VM_IMM$[VM_OPS[VM_PC]]
 INC VM_PC
 VAR INCNT=VM_OPS[VM_PC]
 INC VM_PC
 VAR OUTCNT=VM_OPS[VM_PC]
 INC VM_PC
 VAR ADDR
 VAR FUNC,INCNTF,OUTCNTF,FOUND
 IF NAME$=="CALL" THEN
  DEC INCNT
  VAR NAMET,NAMEV
  VM_POP OUT NAMET,NAMEV
  IF NAMET!=#VMT_STR THEN
   TYPE_MISMATCH "CALL"
   RETURN
  ENDIF
  NAME$=TO_UPPER$(NAMEV)
 ENDIF
 VM_GETFUNC NAME$,INCNT,OUTCNT OUT FOUND,FUNC
 IF !FOUND THEN
  IF CHKCALL("SBSB_"+NAME$) THEN
   CALL_NATIVE_FUNC "SBSB_"+NAME$,INCNT,OUTCNT
   RETURN
  ENDIF
  IF CHKCALL("3:"+NAME$)THEN
   CALL_NATIVE_FUNC NAME$,INCNT,OUTCNT
   RETURN
  ENDIF
  SYNTAX_ERROR "UNDEFINED FUNCTION "+NAME$
  RETURN
 ENDIF
 IF (FUNC_INCNT[FUNC]!=-1&&FUNC_INCNT[FUNC]!=INCNT)||\
    (FUNC_OUTCNT[FUNC]!=-1&&FUNC_OUTCNT[FUNC]!=OUTCNT)THEN
  MISSING_PARAMETER NAME$
  RETURN
 ENDIF
 VM_PUSHINT OUTCNT
 VM_PUSHINT INCNT
 VM_PUSHINT VM_CURFUNC
 VM_PUSHINT VM_BP
 VM_PUSHINT VM_CURSLOT
 VM_PUSHINT VM_PC
 IF VM_CURSLOT!=FUNC_SLOT[FUNC]THEN
  VM_CURSLOT=FUNC_SLOT[FUNC]
  VM_SWITCH_SLOT VM_CURSLOT
 ENDIF
 VM_BP=VM_SP
 VM_PC=FUNC_ADDR[FUNC]
 INC VM_SP,FUNC_VARNUM[FUNC]+1
 VM_INITLVARSTK GET_SPLAY_ROOT(FUNC_VARTBL[FUNC])
 VM_CURFUNC=FUNC
END
DEF VM_INITLVARSTK NODE
 IF !NODE THEN RETURN
 VM_INITLVARSTK GET_SPLAYN_LEFT(NODE)
 VAR V=GET_SPLAYN_VAL%(NODE)
 VAR IDX=VAR_IDX[V]
 VAR TYP=VAR_TYP[V]
 IF IDX>=0 THEN
  VM_STK_TYP[VM_BP+IDX]=TYP
  VM_STK%[VM_BP+IDX]=0
  VM_STK#[VM_BP+IDX]=0
  VAR N$
  VM_STK$[VM_BP+IDX]=N$
 ENDIF
 VM_INITLVARSTK GET_SPLAYN_RIGHT(NODE)
END
DEF VM_ASSERT *
 IF DEFARG(0)THEN
  RETURN
 ELSE
  IF DEFARGC()==1 THEN
   ?"Assertion failed(VM)"
  ELSEIF DEFARGC()==2 THEN
   ?"Assertion failed(VM) ";DEFARG(1)
  ELSE
   ?"Assertion failed(VM) MISSING PARAMETER(ASSERT)"
  ENDIF
  STOP
 ENDIF
END
DEF VMINSTR_RETURNFUNC
 VAR I,L=VM_BP+FUNC_VARNUM[VM_CURFUNC]-1
 FOR I=VM_BP TO L
  VAR T=VM_STK_TYP[I]
  IF T==#VMT_INTARRAY||T==#VMT_REALARRAY||T==#VMT_STRARRAY THEN
   VM_FREE_ARRAY VM_STK%[I]
  ENDIF
 NEXT
 VM_SP=VM_BP
 VAR RETADDR_T,RETADDR_V
 VM_POP OUT RETADDR_T,RETADDR_V
 VM_ASSERT RETADDR_T==#VMT_INT
 VAR RETSLOT_T,RETSLOT_V
 VM_POP OUT RETSLOT_T,RETSLOT_V
 VM_ASSERT RETADDR_T==#VMT_INT
 VAR OLDBP_T,OLDBP_V
 VM_POP OUT OLDBP_T,OLDBP_V
 VM_ASSERT OLDBP_T==#VMT_INT
 VAR OLDFUNC_T,OLDFUNC_V
 VM_POP OUT OLDFUNC_T,OLDFUNC_V
 VM_ASSERT OLDFUNC_T==#VMT_INT
 VM_CURFUNC=OLDFUNC_V
 VAR INCNT_T,OUTCNT_T
 VAR INCNT_V,OUTCNT_V
 VM_POP OUT INCNT_T,INCNT_V
 VM_ASSERT INCNT_T==#VMT_INT
 VM_POP OUT OUTCNT_T,OUTCNT_V
 VM_ASSERT OUTCNT_T==#VMT_INT
 L=VM_SP-1
 FOR I=VM_SP-INCNT_V TO L
  T=VM_STK_TYP[I]
  IF T==#VMT_INTARRAY||T==#VMT_REALARRAY||T==#VMT_STRARRAY THEN
   VM_FREE_ARRAY VM_STK%[I]
  ENDIF
 NEXT
 VM_BP=OLDBP_V
 IF RETSLOT_V!=VM_CURSLOT THEN
  VM_CURSLOT=RETSLOT_V
  VM_SWITCH_SLOT VM_CURSLOT
 ENDIF
 VM_PC=RETADDR_V
 DEC VM_SP,INCNT_V
END
DEF VMINSTR_PUSHEMPTYREF
 VM_PUSHTYP 0,#VMT_EMPTYREF
END
DEF VM_POP_DIMS DM OUT DM1,DM2,DM3,DM4,ERR
 VAR T
 ERR=#FALSE
 IF DM>=1 THEN
  VM_POP OUT T,DM1
  IF!VM_ISNUMTYPE(T) THEN
   ERR=#TRUE
   TYPE_MISMATCH "ARRAY DIM"
   RETURN
  ENDIF
 ENDIF
 IF DM>=2 THEN
  VM_POP OUT T,DM2
  IF!VM_ISNUMTYPE(T) THEN
   ERR=#TRUE
   TYPE_MISMATCH "ARRAY DIM"
   RETURN
  ENDIF
 ENDIF
 IF DM>=3 THEN
  VM_POP OUT T,DM3
  IF!VM_ISNUMTYPE(T) THEN
   ERR=#TRUE
   TYPE_MISMATCH "ARRAY DIM"
   RETURN
  ENDIF
 ENDIF
 IF DM>=4 THEN
  VM_POP OUT T,DM4
  IF!VM_ISNUMTYPE(T) THEN
   ERR=#TRUE
   TYPE_MISMATCH "ARRAY DIM"
   RETURN
  ENDIF
 ENDIF
END
DEF VMINSTR_NEWARRAY
 VAR DM=VM_OPS[VM_PC]
 INC VM_PC
 VAR TYP=VM_OPS[VM_PC]
 INC VM_PC
 VAR V
 VAR DM1,DM2,DM3,DM4,ERR
 VAR T
 VM_POP_DIMS DM OUT DM1,DM2,DM3,DM4,ERR
 IF ERR THEN RETURN
 CASE TYP
 WHEN #VMT_INTARRAY
  CASE DM
  WHEN 1
   V=ARRAY%(DM1)
  WHEN 2
   V=ARRAY%(DM1,DM2)
  WHEN 3
   V=ARRAY%(DM1,DM2,DM3)
  WHEN 4
   V=ARRAY%(DM1,DM2,DM3,DM4)
  ENDCASE
 WHEN #VMT_REALARRAY
  CASE DM
  WHEN 1
   V=ARRAY#(DM1)
  WHEN 2
   V=ARRAY#(DM1,DM2)
  WHEN 3
   V=ARRAY#(DM1,DM2,DM3)
  WHEN 4
   V=ARRAY#(DM1,DM2,DM3,DM4)
  ENDCASE
 WHEN #VMT_STRARRAY
  CASE DM
  WHEN 1
   V=ARRAY$(DM1)
  WHEN 2
   V=ARRAY$(DM1,DM2)
  WHEN 3
   V=ARRAY$(DM1,DM2,DM3)
  WHEN 4
   V=ARRAY$(DM1,DM2,DM3,DM4)
  ENDCASE
 OTHERWISE
  VM_ERROR
 ENDCASE
 VM_PUSHTYP V,TYP
END
DEF VM_ISARYTYP(T)
 RETURN T==#VMT_INTARRAY||T==#VMT_REALARRAY||T==#VMT_STRARRAY||T==#VMT_STR
END
DEF VM_ISSCALARTYP(T)
 RETURN T==#VMT_INT||T==#VMT_REAL||T==#VMT_STR
END
DEF VM_ISPRITYP(T)
 RETURN T==#VMT_INT||T==#VMT_REAL||T==#VMT_STR||T==#VMT_INTARRAY||T==#VMT_REALARRAY||T==#VMT_STRARRAY||T==#VMT_DEFAULT
END
DEF VMINSTR_PUSHARYREF
 VAR DM=VM_OPS[VM_PC]
 INC VM_PC
 VM_PUSHTYP DM,#VMT_ARYREF
 RETURN
END
DEF VMINSTR_INITARRAY
 VAR CNT=VM_OPS[VM_PC]
 INC VM_PC
 VAR REFT,REFV
 VM_POP OUT REFT,REFV
 VAR I
 FOR I=0TO CNT-1
  VAR T,V
  VM_POP OUT T,V
  IF !VM_ISSCALARTYP(T) THEN
   TYPE_MISMATCH "INITARRAY"
   RETURN
  ENDIF
  REFV[I]=V
 NEXT
END
DEF VMINSTR_READ
 IF VM_DATA_IDX>=LEN(VM_DATA_TYP)THEN
  OUT_OF_DATA "READ"
  RETURN
 ENDIF
 VAR TYP=VM_DATA_TYP[VM_DATA_IDX]
 VAR V
 VAR REFT,REFV
 VM_POP OUT REFT,REFV
 CASE TYP
 WHEN #VMT_INT
  V=VM_DATA%[VM_DATA_IDX]
 WHEN #VMT_REAL
  V=VM_DATA#[VM_DATA_IDX]
 WHEN #VMT_STR
  V=VM_DATA$[VM_DATA_IDX]
 OTHERWISE
  INTERNAL_VM_ERROR
 ENDCASE
 VAR ERR
 VM_ASSIGN REFT,REFV,#FALSE,TYP,V,ERR
 IF ERR THEN RETURN
 INC VM_DATA_IDX
END
DEF VMINSTR_RESTORE
 VM_CURDATASLOT=VM_OPS[VM_PC]
 INC VM_PC
 VM_DATA_IDX=VM_OPS[VM_PC]
 INC VM_PC
 VM_SWITCH_SLOT_DATA VM_CURDATASLOT
END
DEF VMINSTR_RESTORE_PLACEHOLDER
 VAR ADDR,SLOT,FOUND
 VM_GET_LABEL_DATA_ADDR VM_IMM$[VM_OPS[VM_PC]] OUT SLOT,ADDR,FOUND
 IF!FOUND THEN
  RETURN
 ENDIF
 VM_OPS[VM_PC-2]=#VM_RESTORE
 VM_OPS[VM_PC-1]=SLOT
 VM_OPS[VM_PC]=ADDR
 DEC VM_PC,2
END
DEF VMINSTR_RESTOREEXPR
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_STR THEN
  TYPE_MISMATCH "RESTORE"
 ENDIF
 VAR SLOT,ADDR,FOUND
 VM_GET_LABEL_DATA_ADDR V OUT SLOT,ADDR,FOUND
 IF!FOUND THEN
  RETURN
 ENDIF
 IF SLOT!=VM_CURDATASLOT THEN
  VM_CURDATASLOT=SLOT
  VM_SWITCH_SLOT_DATA VM_CURDATASLOT
 ENDIF
 VM_DATA_IDX=ADDR
END
DEF VMINSTR_GOTOEXPR
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_STR THEN
  TYPE_MISMATCH "RESTORE"
  RETURN
 ENDIF
 VAR SLOT,ADDR,FOUND
 VM_GET_LABEL_ADDR V OUT SLOT,ADDR,FOUND
 IF !FOUND THEN
  RETURN
 ENDIF
 ADDR=VM_PC
 IF SLOT!=VM_CURSLOT THEN
  VM_CURSLOT=SLOT
  VM_SWITCH_SLOT VM_CURSLOT
 ENDIF
END
DEF VMINSTR_GOSUBEXPR
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_STR THEN
  TYPE_MISMATCH "RESTORE"
  RETURN
 ENDIF
 VAR SLOT,ADDR,FOUND
 VM_GET_LABEL_ADDR V OUT SLOT,ADDR,FOUND
 IF !FOUND THEN
  RETURN
 ENDIF
 VMINSTR_GOSUB SLOT,ADDR
END
DEF VMINSTR_INC MINUS
 VAR T,V
 VAR OSP=VM_SP
 VAR RT,RV
 VAR ERR
 VM_REF OUT RT,RV,T,V,ERR
 IF ERR THEN RETURN
 VAR DT,DV
 VM_POP OUT DT,DV
 VM_SP=OSP-1
 IF (T==#VMT_STR&&DT==#VMT_STR)||(VM_ISNUMTYPE(T)&&VM_ISNUMTYPE(DT))THEN
 ELSE
  TYPE_MISMATCH "INC"
  RETURN
 ENDIF
 IF MINUS THEN
  DEC V,DV
 ELSE
  INC V,DV
 ENDIF
 VM_ASSIGN RT,RV,#FALSE,T,V,ERR
 IF ERR THEN RETURN
END
DEF VMINSTR_ONGOTO GSB
 VAR T,V
 VM_POP OUT T,V
 IF!VM_ISNUMTYPE(T)THEN
  TYPE_MISMATCH "ON GOTO"
  RETURN
 ENDIF
 VAR CNT=VM_OPS[VM_PC]
 INC VM_PC
 IF V<0||V>=CNT THEN
  INC VM_PC,CNT
  RETURN
 ENDIF
 VAR ADDR=VM_OPS[VM_PC+V]
 IF ADDR>0 THEN
  VAR SLOT,FOUND
  VM_GET_LABEL_ADDR VM_IMM$[ADDR] OUT SLOT,ADDR,FOUND
  IF !FOUND THEN
   RETURN
  ENDIF
  VM_ASSERT SLOT==VM_CURSLOT
  VM_OPS[VM_PC+V]=-ADDR
 ELSE
  ADDR=-ADDR
 ENDIF
 INC VM_PC,CNT
 IF GSB THEN
  VMINSTR_GOSUB VM_CURSLOT,ADDR
 ELSE
  VM_PC=ADDR
 ENDIF
END
DEF VMINSTR_WHEN
 VAR ADDR=VM_OPS[VM_PC]
 INC VM_PC
 VAR T,V
 VAR T2,V2
 VM_POP OUT T,V
 VAR OSP=VM_SP
 VM_POP OUT T2,V2
 VM_SP=OSP
 IF (VM_ISNUMTYPE(T)&&VM_ISNUMTYPE(T2))||(T==#VMT_STR&&T2==#VMT_STR)THEN
 ELSE
  STOP
  TYPE_MISMATCH "WHEN"
  RETURN
 ENDIF
 IF V==V2 THEN
  VM_PC=ADDR
  DEC VM_SP
 ENDIF
END
DEF VMINSTR_SWAP
 VAR T1,V1,RT1,RV1
 VAR T2,V2,RT2,RV2
 VAR OSP1=VM_SP
 VAR ERR
 VM_REF OUT RT1,RV1,T1,V1,ERR
 IF ERR THEN RETURN
 VAR OSP2=VM_SP
 VM_REF OUT RT2,RV2,T2,V2,ERR
 IF ERR THEN RETURN
 VAR OSP3=VM_SP
 VM_SP=OSP1-1
 VM_ASSIGN RT1,RV1,#FALSE,T2,V2,ERR
 IF ERR THEN RETURN
 VM_SP=OSP2-1
 VM_ASSIGN RT2,RV2,#FALSE,T1,V1,ERR
 IF ERR THEN RETURN
 VM_SP=OSP3
END
DEF VMINSTR_INPUT
 VAR GUIDE=VM_OPS[VM_PC]
 INC VM_PC
 VAR SEMI=VM_OPS[VM_PC]
 INC VM_PC
 VAR CNT=VM_OPS[VM_PC]
 INC VM_PC
 VAR GUIDET,GUIDEV=""
 VAR RT1,RV1,T1,V1,SP1
 VAR RT2,RV2,T2,V2,SP2
 VAR RT3,RV3,T3,V3,SP3
 VAR RT4,RV4,T4,V4,SP4
 IF GUIDE THEN
  VM_POP OUT GUIDET,GUIDEV
  IF GUIDET!=#VMT_STR THEN
'   TYPE_MISMATCH "INPUT(GUIDE)"
   SYNTAX_ERROR "INPUT(GUIDE)"'FIXME:(INPUT:1)
   RETURN
  ENDIF
  ?GUIDEV;
 ENDIF
 IF !SEMI&&!GUIDE THEN
  ?"? ";
 ENDIF
 VAR ERR
 IF CNT>=1 THEN
  SP1=VM_SP-1
  VM_REF OUT RT1,RV1,T1,V1,ERR
  IF ERR THEN RETURN
  IF CNT==1 THEN
   IF SEMI THEN
    INPUT "";V1
   ELSE
    INPUT "",V1
   ENDIF
  ENDIF
 ENDIF
 IF CNT>=2 THEN
  SP2=VM_SP-1
  VM_REF OUT RT2,RV2,T2,V2,ERR
  IF ERR THEN RETURN
  IF CNT==2 THEN
   IF SEMI THEN
    INPUT "";V1,V2
   ELSE
    INPUT "",V1,V2
   ENDIF
  ENDIF
 ENDIF
 IF CNT>=3 THEN
  SP3=VM_SP-1
  VM_REF OUT RT3,RV3,T3,V3,ERR
  IF ERR THEN RETURN
  IF CNT==3 THEN
   IF SEMI THEN
    INPUT "";V1,V2,V3
   ELSE
    INPUT "",V1,V2,V3
   ENDIF
  ENDIF
 ENDIF
 IF CNT>=4 THEN
  SP4=VM_SP-1
  VM_REF OUT RT4,RV4,T4,V4,ERR
  IF ERR THEN RETURN
  IF CNT==4 THEN
   IF SEMI THEN
    INPUT "";V1,V2,V3,V4
   ELSE
    INPUT "",V1,V2,V3,V4
   ENDIF
  ELSE
   VM_ERROR
  ENDIF
 ENDIF
 IF CNT>=1 THEN
  VM_SP=SP1
  VM_ASSIGN RT1,RV1,#FALSE,T1,V1,ERR
  IF ERR THEN RETURN
 ENDIF
 IF CNT>=2 THEN
  VM_SP=SP2
  VM_ASSIGN RT2,RV2,#FALSE,T2,V2,ERR
  IF ERR THEN RETURN
 ENDIF
 IF CNT>=3 THEN
  VM_SP=SP3
  VM_ASSIGN RT3,RV3,#FALSE,T3,V3,ERR
  IF ERR THEN RETURN
 ENDIF
 IF CNT>=4 THEN
  VM_SP=SP4
  VM_ASSIGN RT4,RV4,#FALSE,T4,V4,ERR
  IF ERR THEN RETURN
 ENDIF
END
DEF VMINSTR_LINPUT
 VAR GUIDE=VM_OPS[VM_PC]
 INC VM_PC
 VAR V
 VAR GUIDET,GUIDEV
 IF GUIDE THEN
  VM_POP OUT GUIDET,GUIDEV
  IF GUIDET!=#VMT_STR THEN
   TYPE_MISMATCH "INPUT(GUIDE)"
   RETURN
  ENDIF
  ?GUIDEV;
 ENDIF
 LINPUT V
 VM_PUSHSTR V
END
DEF VMINSTR_DEFOUT
 VAR T1,V1
 VAR T2,V2
 VM_POP OUT T1,V1
 VM_POP OUT T2,V2
 IF!VM_ISNUMTYPE(T1)THEN
  TYPE_MISMATCH "DEFOUT"
  RETURN
 ENDIF
 VAR IT,IV
 VM_GETLVAR #VMSTK_INCNT OUT IT,IV
 IF IT!=#VMT_INT THEN
  VM_INTERNAL_ERROR "TYPE OF #VMSTK_INCNT SHOULD BE #VMT_INT(DEFOUT)"
 ENDIF
 VAR OT,OV
 VM_GETLVAR #VMSTK_OUTCNT OUT OT,OV
 IF IT!=#VMT_INT THEN
  VM_INTERNAL_ERROR "TYPE OF #VMSTK_INCNT SHOULD BE #VMT_INT(DEFOUT)"
 ENDIF
 IF V1>=OV THEN
  OUT_OF_RANGE "DEFOUT"
  RETURN
 ENDIF
 VM_SETLVAR #VMSTK_STARTARGS-IV-OV+V1+1,T2,V2
END

DEF VM_FREE_GLBLTBL NODE
 IF !NODE THEN RETURN
 VM_FREE_GLBLTBL GET_SPLAYN_LEFT(NODE)
 DELETE_LABEL GET_SPLAYN_VAL%(NODE)
 VM_FREE_GLBLTBL GET_SPLAYN_RIGHT(NODE)
END
DEF VM_FREE_FUNCTBL NODE
 IF !NODE THEN RETURN
 VM_FREE_FUNCTBL GET_SPLAYN_LEFT(NODE)
 DELTE_FUNC GET_SPLAYN_VAL%(NODE)
 VM_FREE_FUNCTBL GET_SPLAYN_RIGHT(NODE)
END
DEF VM_FREE_GVARTBL NODE
 IF !NODE THEN RETURN
 VM_FREE_GVARTBL GET_SPLAYN_LEFT(NODE)
 DELETE_VAR GET_SPLAYN_VAL%(NODE)
 VM_FREE_GVARTBL GET_SPLAYN_RIGHT(NODE)
END
DEF VM_FREE_CONSTTBL NODE
 IF !NODE THEN RETURN
 VM_FREE_CONSTTBL GET_SPLAYN_LEFT(NODE)
 DELETE_CONST GET_SPLAYN_VAL%(NODE)
 VM_FREE_CONSTTBL GET_SPLAYN_RIGHT(NODE)
END
DEF VM_FREE_SLOT SLOT
 VM_FREE_ARRAY VM_SLOT_OPS[SLOT]:VM_SLOT_OPS[SLOT]=0
 VM_FREE_ARRAY VMDBG_SLOT_LINE[SLOT]:VMDBG_SLOT_LINE[SLOT]=0
 VM_FREE_ARRAY VMDBG_SLOT_LINE_PC[SLOT]:VMDBG_SLOT_LINE_PC[SLOT]=0
 VM_FREE_ARRAY VMDBG_SLOT_LINE_POS[SLOT]:VMDBG_SLOT_LINE_POS[SLOT]=0
 VM_FREE_ARRAY VMDBG_SLOT_LINE_END[SLOT]:VMDBG_SLOT_LINE_END[SLOT]=0
 VM_FREE_ARRAY VMDBG_SLOT_LINE_POS_END[SLOT]:VMDBG_SLOT_LINE_POS_END[SLOT]=0
 VM_FREE_ARRAY VM_SLOT_IMM#[SLOT]:VM_SLOT_IMM#[SLOT]=0
 VM_FREE_ARRAY VM_SLOT_IMM$[SLOT]:VM_SLOT_IMM$[SLOT]=0
 VAR TYP=VM_GET_ARRAY(VM_SLOT_GVAR_TYP[SLOT])
 VAR GV=VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT])
 VAR I
 FOR I=0TO LAST(TYP)
  IF VM_ISARYTYP(TYP[I])THEN
   VM_FREE_ARRAY GV[I]
  ENDIF
 NEXT
 VM_FREE_ARRAY VM_SLOT_GVAR_TYP[SLOT]:VM_SLOT_GVAR_TYP[SLOT]=0
 VM_FREE_ARRAY VM_SLOT_GVAR%[SLOT]:VM_SLOT_GVAR%[SLOT]=0
 VM_FREE_ARRAY VM_SLOT_GVAR#[SLOT]:VM_SLOT_GVAR#[SLOT]=0
 VM_FREE_ARRAY VM_SLOT_GVAR$[SLOT]:VM_SLOT_GVAR$[SLOT]=0
 VM_FREE_GLBLTBL GET_SPLAY_ROOT(VM_SLOT_GLBLTBL[SLOT])
 DELETE_SPLAY_TREE VM_SLOT_GLBLTBL[SLOT]
 VM_SLOT_GLBLTBL[SLOT]=0
 VM_FREE_FUNCTBL GET_SPLAY_ROOT(VM_SLOT_FUNCTBL[SLOT])
 DELETE_SPLAY_TREE VM_SLOT_FUNCTBL[SLOT]
 VM_SLOT_FUNCTBL[SLOT]=0
 VM_FREE_GVARTBL GET_SPLAY_ROOT(VM_SLOT_GVARTBL[SLOT])
 DELETE_SPLAY_TREE VM_SLOT_GVARTBL[SLOT]
 VM_SLOT_GVARTBL[SLOT]=0
 VM_FREE_CONSTTBL GET_SPLAY_ROOT(VM_SLOT_CONSTTBL[SLOT])
 DELETE_SPLAY_TREE VM_SLOT_CONSTTBL[SLOT]
 VM_SLOT_CONSTTBL[SLOT]=0
 VM_FREE_ARRAY VM_SLOT_DATA_TYP[SLOT]:VM_SLOT_DATA_TYP[SLOT]=0
 VM_FREE_ARRAY VM_SLOT_DATA%[SLOT]:VM_SLOT_DATA%[SLOT]=0
 VM_FREE_ARRAY VM_SLOT_DATA#[SLOT]:VM_SLOT_DATA#[SLOT]=0
 VM_FREE_ARRAY VM_SLOT_DATA$[SLOT]:VM_SLOT_DATA$[SLOT]=0
 VM_SLOT_EXEC_SLOT[SLOT]=-1
 VM_SLOT_EXEC_ADDR[SLOT]=-1
 VM_SLOT_EXEC_FUNC[SLOT]=-1
END
DEF VMINSTR_EXEC1
 VAR T,V
 VM_POP OUT T,V
 VAR SLOT=VM_CURSLOT
 IF VM_ISNUMTYPE(T)THEN
  V=INT(V)
  VAR IN$=GET_VSLOT$(V)
  SLOT=V
 ELSEIF T==#VMT_STR THEN
  SLOT=VM_CURSLOT
  STOP
 ELSE
  TYPE_MISMATCH "EXEC"
  RETURN
 ENDIF
 VAR RESET
 IF VM_SLOT_OPS[SLOT] THEN
'  DIM B_SLOT,B_LINE,B_POS
'  VM_BACKTRACE #TRUE OUT B_SLOT,B_LINE,B_POS
  VAR I
'  FOR I=0TO LAST(B_SLOT)
'   IF SLOT==B_SLOT[I] THEN
'    RESET=#TRUE
'    BREAK
'   ENDIF
'  NEXT
  RESET=VM_SLOT_EXEC_ADDR[SLOT]!=-1
  IF RESET THEN
   VAR L=VM_SP
   FOR I=1TO L
    VM_POP OUT ,
   NEXT
   VM_BP=0
   VM_CURFUNC=0
   VM_SP=0
  ENDIF
  VM_FREE_SLOT SLOT
 ENDIF
 INIT_LEXER IN$
 INIT_AST
 INIT_PARSER SLOT
 VAR AST=PARSE()
 INIT_COMPILER SLOT
 COMPILE AST
 LOAD_VM_SLOT SLOT
 IF!RESET THEN
  VM_SLOT_EXEC_ADDR[SLOT]=VM_PC
  VM_SLOT_EXEC_FUNC[SLOT]=VM_CURFUNC
  VM_SLOT_EXEC_SLOT[SLOT]=VM_CURSLOT
 ENDIF
 VM_CURSLOT=SLOT
 VM_SWITCH_SLOT VM_CURSLOT
 VM_PC=0
 VM_CURFUNC=0
 VM_PREV_PC=0
END
DEF VMINSTR_EXEC2
 STOP
END
ENUM #VM_LASTERR_NONE,#VM_LASTERR_EN,#VM_LASTERR_ENJA
VAR VM_LASTERR
VAR VM_CONTINUABLE
VAR VM_LASTERR_EN$
VAR VM_LASTERR_JA$
VAR VM_STOP
VAR VM_STOP_MSG$
DEF VMINSTR_STOP1
 VM_STOP=#TRUE
 VM_RAISE_ERR1 "Break on "+VM_GET_CURLOC$()
 VM_CONTINUABLE=#TRUE
END
DEF VMINSTR_STOP2
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_STR THEN
  TYPE_MISMATCH "STOP"
  RETURN
 ENDIF
 VM_STOP=#TRUE
 VM_STOP_MSG$=V
 VM_RAISE_ERR1 "Break on "+VM_GET_CURLOC$()+CHR$(10)+V
 VM_CONTINUABLE=#TRUE
END
DEF VMINSTR_PUSHVAREXPR
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_STR THEN
  UNDEFINED_VARIABLE "Type mismatch(VAR())"
  RETURN
 ENDIF
 VAR SLOT,LOCAL,IDX,FOUND
 VM_CHKVAR V OUT SLOT,LOCAL,IDX,FOUND
 IF!FOUND THEN
  UNDEFINED_VARIABLE "Type mismatch(VAR())"
  RETURN
 ENDIF
 IF LOCAL THEN
  VM_GETLVAR IDX OUT T,V
  VM_PUSHTYP V,T
 ELSE
  VM_GETVAR2_SLOT SLOT,IDX OUT T,V
  VM_PUSHTYP V,T
 ENDIF
END
DEF VM_CHKVAR NAME$ OUT SLOT,LOCAL,IDX,FOUND
 VAR ILL_FMT,HAS_SLOT,N$
 VM_PARSE_SLOT NAME$,#FALSE OUT ILL_FMT,HAS_SLOT,SLOT,N$
 IF ILL_FMT THEN
  FOUND=#FALSE
  RETURN
 ENDIF
 VAR TBL
 IF HAS_SLOT THEN
 ELSEIF VM_CURFUNC THEN
  SPLAY_GET% FUNC_VARTBL[VM_CURFUNC],N$ OUT FOUND,IDX
  IF FOUND THEN
   IDX=VAR_IDX[IDX]
   LOCAL=#TRUE
   RETURN
  ENDIF
  SLOT=VM_CURSLOT
 ELSE
  SLOT=VM_CURSLOT
 ENDIF
 SPLAY_GET% VM_SLOT_GVARTBL[SLOT],N$ OUT FOUND,IDX
 LOCAL=#FALSE
 IF FOUND THEN
  IDX=VAR_IDX[IDX]
 ENDIF
END
DEF VMINSTR_PUSHVAREXPRREF
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_STR THEN
  UNDEFINED_VARIABLE "Type mismatch(VAR())"
  RETURN
 ENDIF
 VAR SLOT,LOCAL,IDX,FOUND
 VM_CHKVAR V OUT SLOT,LOCAL,IDX,FOUND
 IF!FOUND THEN
  UNDEFINED_VARIABLE "Type mismatch(VAR())"
  RETURN
 ENDIF
 IF LOCAL THEN
  VM_PUSHTYP IDX,#VMT_LVARREF
 ELSE
  IF SLOT==VM_CURSLOT THEN
   VM_PUSHTYP IDX,#VMT_VARREF
  ELSE
   VM_PUSHTYP SLOT,#VMT_VARREFSLOT
   VM_PUSHTYP IDX,#VMT_VARREFSLOT
  ENDIF
 ENDIF
END
DEF VMINSTR_RETURNFUNCEXPR
 ?"FIXME:NOTIMPL"
 STOP
 VAR T,V,OT,OV
 VM_POP OUT T,V
 VM_GETLVAR #VMSTK_OUTCNT OUT T,V

 VMINSTR_RETURUFUNC
END
DEF VM_BACKTRACE INCLUDE_SUB OUT SLOT,LINE,INFO$
 VAR I,BP=VM_BP
 SLOT=ARRAY%(0)
 LINE=ARRAY%(0)
 INFO$=ARRAY$(0)
 VAR FUNC=VM_CURFUNC
 VAR A,S,L
 IF !INCLUDE_SUB THEN
  FUNC=0
  IF VM_CURFUNC THEN
   VMDBG_GET OUT S,L,
   PUSH LINE,L
   PUSH SLOT,S
   PUSH INFO$,FUNC_NAME$[VM_CURFUNC]
  ENDIF
 ENDIF
 FOR I=VM_SP-1 TO 0 STEP -1
  IF INCLUDE_SUB&&VM_STK_TYP[I]==#VMT_SUBROUTINE THEN
   A=VM_STK%[I]
   DEC I
   S=VM_STK%[I]
   VMDBG_GET_LINE S,A OUT L,
   PUSH LINE,L
   PUSH SLOT,S
   PUSH INFO$,""
  ELSEIF I==BP&&I THEN
   IF !INCLUDE_SUB THEN
    FUNC=VM_STK%[I+#VMSTK_FUNC]
   ENDIF
   A=VM_STK%[I+#VMSTK_PC]
   S=VM_STK%[I+#VMSTK_SLOT]
   BP=VM_STK%[I+#VMSTK_BP]
   VMDBG_GET_LINE S,A OUT L,
   PUSH LINE,L
   PUSH SLOT,S
   PUSH INFO$,FUNC_NAME$[FUNC]
   IF INCLUDE_SUB THEN
    FUNC=VM_STK%[I+#VMSTK_FUNC]
   ENDIF
  ENDIF
 NEXT
 IF !VM_BP THEN
  VMDBG_GET_LINE VM_CURSLOT,VM_PC OUT L,
  PUSH LINE,L
  PUSH SLOT,VM_CURSLOT
  PUSH INFO$,""
 ENDIF
END
DEF VM_IS_STOPPED()
 RETURN VM_STOP
END
DEF VM_IS_CONTINUABLE()
 RETURN VM_CONTINUABLE
END
DEF VM_CONT
 IF !VM_STOP||!VM_CONTINUABLE THEN
  VM_RAISE_ERR2 "Can't continue","CONTできません"
  RETURN
 ENDIF
 VM_RUN
END
DEF VMDBG_BINSEARCH(ARY,KEY)
 VAR MIN=0
 VAR L=LEN(ARY)
 VAR MAX=L
 LOOP
  IF MAX<MIN THEN
   RETURN MAX
  ENDIF
  VAR MID=MIN+(MAX-MIN) DIV 2
  IF L<=MID THEN
   RETURN L-1
  ENDIF
  IF MID<0 THEN
   RETURN 0
  ENDIF
  IF ARY[MID]>KEY THEN
   MAX=MID-1
  ELSEIF ARY[MID]<KEY THEN
   MIN=MID+1
  ELSE
   RETURN MID
  ENDIF
 ENDLOOP
END
DEF VMDBG_LINEARSEARCH(ARY,KEY)
 VAR I,L=LAST(ARY)
 FOR I=0TO L
  IF ARY[I]==KEY THEN RETURN MAX(0,I)
 NEXT
 RETURN -1
END
DEF VMDBG_GET_VAR_LIST FUNC,BP OUT VNAME$[],VIDX[]
 VNAME$=ARRAY$(0)
 VIDX=ARRAY%(0)
 IF FUNC THEN
  VMDBG_ENUM_VAR_LIST VNAME$,VIDX,GET_SPLAY_ROOT(FUNC_VARTBL[FUNC])
 ELSE
  VMDBG_ENUM_VAR_LIST VNAME$,VIDX,GET_SPLAY_ROOT(VM_SLOT_GVARTBL[VM_CURSLOT])
 ENDIF
END
DEF VMDBG_ENUM_VAR_LIST VNAME$,VIDX,NODE
 IF !NODE THEN RETURN
 VMDBG_ENUM_VAR_LIST VNAME$,VIDX,GET_SPLAYN_LEFT(NODE)
 VAR V=GET_SPLAYN_VAL%(NODE)
 VAR IDX=VAR_IDX[V]
 PUSH VNAME$,GET_SPLAYN_KEY$(NODE)
 PUSH VIDX,IDX
 VMDBG_ENUM_VAR_LIST VNAME$,VIDX,GET_SPLAYN_RIGHT(NODE)
END
DEF VMDBG_ENUM_CONST_LIST VNAME$,VIDX,NODE
 IF !NODE THEN RETURN
 VMDBG_ENUM_CONST_LIST VNAME$,VIDX,GET_SPLAYN_LEFT(NODE)
 VAR V=GET_SPLAYN_VAL%(NODE)
 PUSH VNAME$,GET_SPLAYN_KEY$(NODE)
 PUSH VIDX,V
 VMDBG_ENUM_CONST_LIST VNAME$,VIDX,GET_SPLAYN_RIGHT(NODE)
END
DEF VMDBG_GET_SLOT_VAR_LIST SLOT OUT VNAME$[],VIDX[]
 VNAME$=ARRAY$(0)
 VIDX=ARRAY%(0)
 IF VM_SLOT_GVARTBL[SLOT] THEN
  VMDBG_ENUM_VAR_LIST VNAME$,VIDX,GET_SPLAY_ROOT(VM_SLOT_GVARTBL[SLOT])
 ENDIF
END
DEF VMDBG_GET_SLOT_CONST_LIST SLOT OUT VNAME$[],VIDX[]
 VNAME$=ARRAY$(0)
 VIDX=ARRAY%(0)
 IF VM_SLOT_CONSTTBL[SLOT] THEN
  VMDBG_ENUM_CONST_LIST VNAME$,VIDX,GET_SPLAY_ROOT(VM_SLOT_CONSTTBL[SLOT])
 ENDIF
END
DEF VMDBG_GET_VAR FUNC,BP,VIDX OUT V
 IF FUNC THEN
  VAR T=VM_STK_TYP[BP+VIDX]
  V=VM_GETV(T,VM_GETSTKARY(T)[BP+VIDX])
 ELSE
  CASE VM_GVAR_TYP[VIDX]
  WHEN #VMT_INT
   V=VM_GVAR%[VIDX]
  WHEN #VMT_REAL
   V=VM_GVAR#[VIDX]
  WHEN #VMT_STR
   V=VM_GVAR$[VIDX]
  WHEN #VMT_INTARRAY
  WHEN #VMT_REALARRAY
  WHEN #VMT_STRARRAY
   V=VM_GET_ARRAY(VM_GVAR%[VIDX])
  WHEN #VMT_DEFAULT
  ENDCASE
 ENDIF
END
DEF VMDBG_GET_SLOT_VAR SLOT,VIDX OUT V
 CASE VM_GET_ARRAY(VM_SLOT_GVAR_TYP[SLOT])[VIDX]
 WHEN #VMT_INT
  V=VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT])[VIDX]
 WHEN #VMT_REAL
  V=VM_GET_ARRAY(VM_SLOT_GVAR#[SLOT])[VIDX]
 WHEN #VMT_STR
  V=VM_GET_ARRAY(VM_SLOT_GVAR$[SLOT])[VIDX]
 WHEN #VMT_INTARRAY
 WHEN #VMT_REALARRAY
 WHEN #VMT_STRARRAY
  V=VM_GET_ARRAY(VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT])[VIDX])
 WHEN #VMT_DEFAULT
 ENDCASE
END
DEF VMDBG_GET_SLOT_CONST SLOT,VIDX OUT V
 CASE CMP_CONST_TYP[VIDX]
 WHEN #VMT_INT
  V=CMP_CONST%[VIDX]
 WHEN #VMT_REAL
  V=CMP_CONST#[VIDX]
 WHEN #VMT_STR
  V=CMP_CONST$[VIDX]
 ENDCASE
END
DEF VMDBG_FIND_FRAME FRAME_NO OUT FUNC,BP,SLOT,PC
 VAR I
 FUNC=VM_CURFUNC
 BP=VM_BP
 PC=VM_PC
 SLOT=VM_CURSLOT
 VAR FRAME_NO_CUR
 FOR I=VM_SP-1 TO 0 STEP -1
  IF FRAME_NO_CUR==FRAME_NO THEN RETURN
  IF I==BP&&I THEN
   FUNC=VM_STK%[I+#VMSTK_FUNC]
   BP=VM_STK%[I+#VMSTK_BP]
   SLOT=VM_STK%[I+#VMSTK_SLOT]
   PC=VM_STK%[I+#VMSTK_PC]
   INC FRAME_NO_CUR
  ENDIF
 NEXT
END
DEF VMDBG_SET_BP SLOT,PC
 IF PC==-1 THEN RETURN
 VAR OPS=VM_GET_ARRAY(VM_SLOT_OPS[SLOT])
 OPS[PC]=&H80000000 OR OPS[PC]
END
DEF VMDBG_TOGGLE_BP SLOT,PC
 IF PC==-1 THEN RETURN
 VAR OPS=VM_GET_ARRAY(VM_SLOT_OPS[SLOT])
 OPS[PC]=&H80000000 XOR OPS[PC]
END
DEF VMDBG_TOGGLE_BP_LIST SLOT,PC_LIST
 VAR I
 FOR I=0TO LAST(PC_LIST)
  VAR OPS=VM_GET_ARRAY(VM_SLOT_OPS[SLOT])
  OPS[PC_LIST[I]]=&H80000000 XOR OPS[PC_LIST[I]]
 NEXT
END
DEF VMDBG_HAS_BP(SLOT,PC)
 IF PC==-1 THEN RETURN #FALSE
 VAR OPS=VM_GET_ARRAY(VM_SLOT_OPS[SLOT])
 RETURN &H80000000 AND OPS[PC]
END
DEF VMDBG_GET_PC SLOT,LINE OUT PC
 VAR L=VM_GET_ARRAY(VMDBG_SLOT_LINE[SLOT])
 IF TYPEOF(L)==#T_DEFAULT THEN
  PC=-1
  RETURN
 ENDIF
 VAR LPC=VM_GET_ARRAY(VMDBG_SLOT_LINE_PC[SLOT])
 VAR LPOS=VM_GET_ARRAY(VMDBG_SLOT_LINE_POS[SLOT])
 VAR IND=VMDBG_LINEARSEARCH(L,LINE)
 IF IND<0||IND>=LEN(LPC)THEN
  PC=-1
  RETURN
 ENDIF
 PC=LPC[IND]
END
DEF VMDBG_GET_PC_LIST SLOT,LINE OUT PC_LIST
 VAR L=VM_GET_ARRAY(VMDBG_SLOT_LINE[SLOT])
 VAR LPC=VM_GET_ARRAY(VMDBG_SLOT_LINE_PC[SLOT])
 VAR LPOS=VM_GET_ARRAY(VMDBG_SLOT_LINE_POS[SLOT])
 PC_LIST=ARRAY%(0)
 IF TYPEOF(L)==#T_DEFAULT THEN
  RETURN
 ENDIF
 VAR I,LAST=LAST(L)
 FOR I=0TO LAST
  IF L[I]==LINE THEN
   PUSH PC_LIST,LPC[I]
  ENDIF
 NEXT
END
DEF VMDBG_GET OUT SLOT,LINE,LINE_POS
 SLOT=VM_CURSLOT
 VMDBG_GET_LINE SLOT,VM_PC OUT LINE,LINE_POS
END
DEF VMDBG_GET_LINE SLOT,PC OUT LINE,LINE_POS
 VMDBG_GET_LINE2 SLOT,PC OUT LINE,LINE_POS,,
END
DEF VMDBG_GET_LINE2 SLOT,PC OUT LINE,LINE_POS,LINE_END,LINE_POS_END
 VAR L=VM_GET_ARRAY(VMDBG_SLOT_LINE[VM_CURSLOT])
 VAR LPC=VM_GET_ARRAY(VMDBG_SLOT_LINE_PC[VM_CURSLOT])
 VAR LPOS=VM_GET_ARRAY(VMDBG_SLOT_LINE_POS[VM_CURSLOT])
 VAR L_END=VM_GET_ARRAY(VMDBG_SLOT_LINE_END[VM_CURSLOT])
 VAR LPOS_END=VM_GET_ARRAY(VMDBG_SLOT_LINE_POS_END[VM_CURSLOT])
 VAR IND=VMDBG_BINSEARCH(LPC,PC)
 IF IND<0||IND>=LEN(LPC)THEN
  LINE=0
  LINE_POS=0
  LINE_END=0
  LINE_POS_END=0
  RETURN
 ENDIF
 LINE=L[IND]
 LINE_POS=LPOS[IND]
 LINE_END=L_END[IND]
 LINE_POS_END=LPOS_END[IND]
END
DEF VM_GET_CURLOC$()
 VAR SLOT=VM_CURSLOT,LINE,LINE_POS
 VMDBG_GET_LINE SLOT,VM_PREV_PC OUT LINE,LINE_POS
 RETURN STR$(SLOT)+":"+STR$(LINE)+":"+STR$(LINE_POS)
END
DEF SYNTAX_ERROR MSG$
 VM_RAISE_ERR2 "Syntax error","文法まちがい"
END
'A$[0]=1<=UNDEFINED VAR
DEF TYPE_MISMATCH MSG$
 VM_RAISE_ERR2 "Type mismatch","指定できない型の値です"
END
DEF SUBSCRIPT_OUT_OF_RANGE MSG$
 VM_RAISE_ERR2 "Subscript out of range","配列サイズを越えたアクセスです"
END
DEF OUT_OF_DATA MSG$
 VM_RAISE_ERR2 "Out of DATA","読み込めるDATA文がありません"
END
DEF UNDEFINED_LABEL MSG$
 VM_RAISE_ERR2 "Undefined label","未定義ラベル"
END
DEF ILLEGAL_LABEL_STRING MSG$
 VM_RAISE_ERR2 "Illegal label string","ラベル名として使えない文字列です"
END
DEF VM_RAISE_ERR1 E1$
 VM_LASTERR=#VM_LASTERR_EN
 VM_LASTERR=#TRUE
 VM_LASTERR_EN$=E1$
 VM_LASTERR_JA$=""
 VM_STOP=#TRUE
 VM_CONTINUABLE=#FALSE
 VM_RUNNING=#FALSE
END
DEF VM_RAISE_ERR2 E1$,E2$
 VM_LASTERR=#VM_LASTERR_ENJA
 'NOT DIRMODE
 VM_LASTERR_EN$=E1$+" in "+VM_GET_CURLOC$()
 VM_LASTERR_JA$=E2$
 VM_STOP=#TRUE
 VM_CONTINUABLE=#FALSE
END
DEF VM_LASTERR$()
 CASE VM_LASTERR
 WHEN #VM_LASTERR_EN
  RETURN VM_LASTERR_EN$
 WHEN #VM_LASTERR_ENJA
  RETURN VM_LASTERR_EN$+CHR$(10)+VM_LASTERR_JA$
 ENDCASE
END
VAR VMDBG_BREAK
VAR VMDBG_TRACE
VAR VMDBG_TRACE_BREAK
VAR VMDBG_TRACE_BP
VAR VMDBG_TRACE_STEPIN
VAR VMDBG_ENABLE_BREAK_KEY
DEF VM_TRACE_RUN STEPIN
 VMDBG_TRACE=#TRUE
 VMDBG_TRACE_BP=VM_BP
 VMDBG_TRACE_STEPIN=STEPIN
 VMDBG_ENABLE_BREAK_KEY=#TRUE
 VM_RUN
 VMDBG_TRACE=#FALSE
END
DEF VM_DEBUG_RUN
 VMDBG_ENABLE_BREAK_KEY=#TRUE
 VM_RUN
END
CONST #VMMSK_INSTR=&HFFFF
CONST #VMMSK_MASK=&HFFFF0000
ENUM #VMMSK_BREAK_POINT=&H80000000
DEF VM_RUN
 VM_RUNNING=#TRUE
 VMDBG_TRACE_BREAK=#FALSE
 VM_STOP=#FALSE
 VAR T,V
 VAR C
 VM_PREV_PC=VM_PC
 VAR TRACE=VMDBG_TRACE
 IF VMDBG_BREAK&&(VM_OPS[VM_PC]AND #VMMSK_MASK)==#VMMSK_BREAK_POINT THEN
  C=VM_OPS[VM_PC] AND #VMMSK_INSTR
  VMDBG_BREAK=#FALSE
  INC VM_PC
  GOTO@LOOP
 ENDIF
 VMDBG_BREAK=#FALSE
 LOOP
'  VAR K
'  VM_DUMPINSTR VM_PC OUT K
  IF VMDBG_ENABLE_BREAK_KEY THEN
   IF KEYBOARD(7) THEN
    VAR MODI
    KEYBOARD 7 OUT ,MODI
    IF MODI AND 4 THEN
     VM_STOP_MSG$="Break(Debugger)"
     VM_RAISE_ERR1 "Break on "+VM_GET_CURLOC$()+CHR$(10)+VM_STOP_MSG$
     VM_CONTINUABLE=#TRUE
     VM_STOP=#TRUE
     BREAK
    ENDIF
   ENDIF
  ENDIF
  VM_PREV_PC=VM_PC
  C=VM_OPS[VM_PC]
  INC VM_PC
  @LOOP
  ON C GOTO @VM_NOP,@VM_PUSHINT,@VM_PUSHDBL,@VM_PUSHSTR,@VM_BINOP,@VM_PRINT,@VM_TPRINT,@VM_ASSIGN,@VM_PUSHVARREF,@VM_PUSHLVARREF,@VM_REF,@VM_BR,@VM_BRTRUE,@VM_BRFALSE,@VM_FOR,@VM_FORINIT,@VM_BRAND,@VM_BROR,@VM_GOTO_PLACEHOLDER,@VM_GOSUB_PLACEHOLDER,@VM_GOSUB,@VM_GOTOEXPR,@VM_GOSUBEXPR,@VM_ONGOTO,@VM_ONGOSUB,@VM_RETURN,@VM_CALLFUNC,@VM_PUSHEMPTY,@VM_RETURNFUNC,@VM_PUSHEMPTYREF,@VM_PUSHARYREF,@VM_END,@VM_NEWARRAY,@VM_INITARRAY,@VM_READ,@VM_RESTORE,@VM_RESTORE_PLACEHOLDER,@VM_RESTOREEXPR,@VM_UNAOP,@VM_CALLSPRITE,@VM_CALLTEXT,@VM_INC,@VM_DEC,@VM_POP,@VM_WHEN,@VM_SWAP,@VM_INPUT,@VM_LINPUT,@VM_DEFOUT,@VM_EXEC1,@VM_EXEC2,@VM_STOP1,@VM_STOP2,@VM_PUSHVAREXPR,@VM_PUSHVAREXPRREF,@VM_RETURNFUNCEXPR
  @VM_NOP
  GOTO @VM_INVAL
  CASE C
  WHEN #VM_PUSHINT:@VM_PUSHINT
   VM_PUSHINT VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_PUSHDBL:@VM_PUSHDBL
   VM_PUSHDBL VM_IMM#[VM_OPS[VM_PC]]
   INC VM_PC
  WHEN #VM_PUSHSTR:@VM_PUSHSTR
   VM_PUSHSTR (VM_IMM$[VM_OPS[VM_PC]])+""
   INC VM_PC
  WHEN #VM_BINOP:@VM_BINOP
   T=VM_OPS[VM_PC]
   INC VM_PC
   VMINSTR_BINOP T
  WHEN #VM_PRINT:@VM_PRINT
   INC VM_PC
   VM_PRINT #FALSE,VM_OPS[VM_PC-1]
  WHEN #VM_TPRINT:@VM_TPRINT
   INC VM_PC
   VM_PRINT #TRUE,VM_OPS[VM_PC-1]
  WHEN #VM_PUSHVARREF:@VM_PUSHVARREF
   VMINSTR_PUSHVARREF VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_PUSHLVARREF:@VM_PUSHLVARREF
   VMINSTR_PUSHLVARREF VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_REF:@VM_REF
   VMINSTR_REF
  WHEN #VM_ASSIGN:@VM_ASSIGN
   VMINSTR_ASSIGN
  WHEN #VM_BR:@VM_BR
   VM_PC=VM_OPS[VM_PC]-1
   INC VM_PC
  WHEN #VM_BRFALSE:@VM_BRFALSE
   VM_POP OUT T,V
   CASE T
   WHEN #VMT_INT
   WHEN #VMT_REAL
    IF !V THEN VM_PC=VM_OPS[VM_PC]-1
   OTHERWISE
    TYPEMISMATCH
   ENDCASE
   INC VM_PC
  WHEN #VM_BRTRUE:@VM_BRTRUE
   VM_POP OUT T,V
   CASE T
   WHEN #VMT_INT
   WHEN #VMT_REAL
    IF V THEN VM_PC=VM_OPS[VM_PC]-1
   OTHERWISE
    TYPEMISMATCH
   ENDCASE
   INC VM_PC
  WHEN #VM_FOR:@VM_FOR
   VMINSTR_FOR #FALSE
  WHEN #VM_FORINIT:@VM_FORINIT
   VMINSTR_FOR #TRUE
  WHEN #VM_BROR:@VM_BROR
   INC VM_PC
   VMINSTR_BROR VM_OPS[VM_PC-1]
  WHEN #VM_BRAND:@VM_BRAND
   INC VM_PC
   VMINSTR_BRAND VM_OPS[VM_PC-1]
  WHEN #VM_GOTO_PLACEHOLDER:@VM_GOTO_PLACEHOLDER
   VMINSTR_GOTO_PLACEHOLDER
  WHEN #VM_GOSUB_PLACEHOLDER:@VM_GOSUB_PLACEHOLDER
   VMINSTR_GOSUB_PLACEHOLDER
  WHEN #VM_GOSUB:@VM_GOSUB
   INC VM_PC
   VMINSTR_GOSUB VM_CURSLOT,VM_OPS[VM_PC-1]
  WHEN #VM_RETURN:@VM_RETURN
   VMINSTR_RETURN
  WHEN #VM_CALLFUNC:@VM_CALLFUNC
   VMINSTR_CALLFUNC
  WHEN #VM_PUSHEMPTY:@VM_PUSHEMPTY
   INC VM_PC
   VMINSTR_PUSHEMPTY VM_OPS[VM_PC-1]
  WHEN #VM_RETURNFUNC:@VM_RETURNFUNC
   VMINSTR_RETURNFUNC
  WHEN #VM_PUSHEMPTYREF:@VM_PUSHEMPTYREF
   VMINSTR_PUSHEMPTYREF
  WHEN #VM_END:@VM_END
   IF VM_SLOT_EXEC_SLOT[VM_CURSLOT]!=-1THEN
    VAR OS=VM_CURSLOT
    VM_PC=VM_SLOT_EXEC_ADDR[OS]
    VM_CURSLOT=VM_SLOT_EXEC_SLOT[OS]
    VM_CURFUNC=VM_SLOT_EXEC_FUNC[OS]
    VM_SWITCH_SLOT VM_CURSLOT
    VM_SLOT_EXEC_FUNC[OS]=-1
    VM_SLOT_EXEC_ADDR[OS]=-1
    VM_SLOT_EXEC_SLOT[OS]=-1
   ELSE
    BREAK
   ENDIF
  WHEN #VM_NEWARRAY:@VM_NEWARRAY
   VMINSTR_NEWARRAY
  WHEN #VM_PUSHARYREF:@VM_PUSHARYREF
   VMINSTR_PUSHARYREF
  WHEN #VM_INITARRAY:@VM_INITARRAY
   VMINSTR_INITARRAY
  WHEN #VM_READ:@VM_READ
   VMINSTR_READ
  WHEN #VM_RESTORE:@VM_RESTORE
   VMINSTR_RESTORE
  WHEN #VM_RESTORE_PLACEHOLDER:@VM_RESTORE_PLACEHOLDER
   VMINSTR_RESTORE_PLACEHOLDER
  WHEN #VM_UNAOP:@VM_UNAOP
   INC VM_PC
   VMINSTR_UNAOP VM_OPS[VM_PC-1]
  WHEN #VM_CALLSPRITE:@VM_CALLSPRITE
   CALL SPRITE
  WHEN #VM_CALLTEXT:@VM_CALLTEXT
   CALL TEXT
  WHEN #VM_RESTOREEXPR:@VM_RESTOREEXPR
   VMINSTR_RESTOREEXPR
  WHEN #VM_GOTOEXPR:@VM_GOTOEXPR
   VMINSTR_GOTOEXPR
  WHEN #VM_GOSUBEXPR:@VM_GOSUBEXPR
   VMINSTR_GOSUBEXPR
  WHEN #VM_INC:@VM_INC
   VMINSTR_INC #FALSE
  WHEN #VM_DEC:@VM_DEC
   VMINSTR_INC #TRUE
  WHEN #VM_POP:@VM_POP
   DEC VM_SP,VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_ONGOTO:@VM_ONGOTO
   VMINSTR_ONGOTO #FALSE
  WHEN #VM_ONGOSUB:@VM_ONGOSUB
   VMINSTR_ONGOTO #TRUE
  WHEN #VM_WHEN:@VM_WHEN
   VMINSTR_WHEN
  WHEN #VM_SWAP:@VM_SWAP
   VMINSTR_SWAP
  WHEN #VM_INPUT:@VM_INPUT
   VMINSTR_INPUT
  WHEN #VM_LINPUT:@VM_LINPUT
   VMINSTR_LINPUT
  WHEN #VM_DEFOUT:@VM_DEFOUT
   VMINSTR_DEFOUT
  WHEN #VM_EXEC1:@VM_EXEC1
   VMINSTR_EXEC1
  WHEN #VM_EXEC2:@VM_EXEC2
   VMINSTR_EXEC2
  WHEN #VM_STOP1:@VM_STOP1
   VMINSTR_STOP1
   BREAK
  WHEN #VM_STOP2:@VM_STOP2
   VMINSTR_STOP2
   BREAK
  WHEN #VM_PUSHVAREXPR:@VM_PUSHVAREXPR
   VMINSTR_PUSHVAREXPR
  WHEN #VM_PUSHVAREXPRREF:@VM_PUSHVAREXPRREF
   VMINSTR_PUSHVAREXPRREF
  WHEN #VM_RETURNFUNCEXPR:@VM_RETURNFUNCEXPR
   VMINSTR_RETURNFUNCEXPR
  WHEN #VM_
   VMINSTR_
  OTHERWISE:@VM_INVAL
   VAR MSK=C AND #VMMSK_MASK
   VAR OP=C AND #VMMSK_INSTR
   IF MSK==#VMMSK_BREAK_POINT THEN
    DEC VM_PC
    'BREAK!
    VMDBG_BREAK=#TRUE
    RETURN
   ENDIF
   VM_ERROR
  ENDCASE
  IF TRACE THEN
   IF VMDBG_TRACE_STEPIN||VM_BP<=VMDBG_TRACE_BP THEN
    VMDBG_TRACE_BREAK=#TRUE
    RETURN
   ENDIF
  ENDIF
 ENDLOOP
 VM_RUNNING=#FALSE
END
DEF VM_IS_RUNNING()
 IF LEN(VM_OPS)<=VM_PC THEN VM_RUNNING=#FALSE
 RETURN VM_RUNNING
END

DEF VMDBG_IS_STOPPED_AT_BP()
 RETURN VMDBG_BREAK
END

DEF VM_DUMP_STR$(A$)
 RETURN CHR$(34)+A$+CHR$(34)
END
DEF VM_DUMP
 VAR VM_PC=0
 LOOP
  IF LEN(VM_OPS)<=VM_PC THEN BREAK
  VM_DUMPINSTR VM_PC OUT VM_PC
 ENDLOOP
END
DEF VM_DUMP_CURRENT
 VAR O
 VM_DUMPINSTR VM_PC OUT O
END
DEF VM_DUMP_ADDR$(ADDR)
 RETURN HEX$(ADDR,4)
END
DEF VM_DUMPINSTR VM_PC OUT VM_PC2
 ?HEX$(VM_PC,4);" ";
 VAR C=VM_OPS[VM_PC] AND &HFFFF
 VAR MSK=VM_OPS[VM_PC] AND &HFFFF0000
 IF MSK==&H80000000 THEN
  ?"BREAKPOINT ";
 ENDIF
 INC VM_PC
 ON C GOTO @VM_NOP,@VM_PUSHINT,@VM_PUSHDBL,@VM_PUSHSTR,@VM_BINOP,@VM_PRINT,@VM_TPRINT,@VM_ASSIGN,@VM_PUSHVARREF,@VM_PUSHLVARREF,@VM_REF,@VM_BR,@VM_BRTRUE,@VM_BRFALSE,@VM_FOR,@VM_FORINIT,@VM_BRAND,@VM_BROR,@VM_GOTO_PLACEHOLDER,@VM_GOSUB_PLACEHOLDER,@VM_GOSUB,@VM_GOTOEXPR,@VM_GOSUBEXPR,@VM_ONGOTO,@VM_ONGOSUB,@VM_RETURN,@VM_CALLFUNC,@VM_PUSHEMPTY,@VM_RETURNFUNC,@VM_PUSHEMPTYREF,@VM_PUSHARYREF,@VM_END,@VM_NEWARRAY,@VM_INITARRAY,@VM_READ,@VM_RESTORE,@VM_RESTORE_PLACEHOLDER,@VM_RESTOREEXPR,@VM_UNAOP,@VM_CALLSPRITE,@VM_CALLTEXT,@VM_INC,@VM_DEC,@VM_POP,@VM_WHEN,@VM_SWAP,@VM_INPUT,@VM_LINPUT,@VM_DEFOUT,@VM_EXEC1,@VM_EXEC2,@VM_STOP1,@VM_STOP2,@VM_PUSHVAREXPR,@VM_PUSHVAREXPRREF,@VM_RETURNFUNCEXPR
 @VM_NOP
 GOTO @VM_INVAL
 CASE C
 WHEN #VM_PUSHINT:@VM_PUSHINT
  ?"PUSHINT",VM_OPS[VM_PC]
  INC VM_PC
 WHEN #VM_PUSHDBL:@VM_PUSHDBL
  ?"PUSHDBL",VM_IMM#[VM_OPS[VM_PC]]
  INC VM_PC
 WHEN #VM_PUSHSTR:@VM_PUSHSTR
  ?"PUSHSTR",VM_DUMP_STR$(VM_IMM$[VM_OPS[VM_PC]])
  INC VM_PC
 WHEN #VM_BINOP:@VM_BINOP
  VAR T=VM_OPS[VM_PC]
  INC VM_PC
  ?"BINOP",TKN_STR$(T)
 WHEN #VM_PRINT:@VM_PRINT
  INC VM_PC
  ?"PRINT",VM_OPS[VM_PC-1]
 WHEN #VM_TPRINT:@VM_TPRINT
  INC VM_PC
  ?"TPRINT",VM_OPS[VM_PC-1]
 WHEN #VM_PUSHVARREF:@VM_PUSHVARREF
  ?"PUSHVARREF",VM_OPS[VM_PC]
  INC VM_PC
 WHEN #VM_PUSHLVARREF:@VM_PUSHLVARREF
  ?"PUSHLVARREF",VM_OPS[VM_PC]
  INC VM_PC
 WHEN #VM_REF:@VM_REF
  ?"REF"
 WHEN #VM_ASSIGN:@VM_ASSIGN
  ?"ASSIGN"
 WHEN #VM_BR:@VM_BR
  ?"BR",VM_DUMP_ADDR$(VM_OPS[VM_PC])
  INC VM_PC
 WHEN #VM_BRFALSE:@VM_BRFALSE
  ?"BRFALSE",VM_DUMP_ADDR$(VM_OPS[VM_PC])
  INC VM_PC
 WHEN #VM_BRTRUE:@VM_BRTRUE
  ?"BRTRUE",VM_DUMP_ADDR$(VM_OPS[VM_PC])
  INC VM_PC
 WHEN #VM_FOR:@VM_FOR
  ?"FOR",VM_DUMP_ADDR$(VM_OPS[VM_PC])
  INC VM_PC
 WHEN #VM_FORINIT:@VM_FORINIT
  ?"FORINIT",VM_DUMP_ADDR$(VM_OPS[VM_PC])
  INC VM_PC
 WHEN #VM_BROR:@VM_BROR
  ?"BROR",VM_DUMP_ADDR$(VM_OPS[VM_PC])
  INC VM_PC
 WHEN #VM_BRAND:@VM_BRAND
  ?"BRAND",VM_DUMP_ADDR$(VM_OPS[VM_PC])
  INC VM_PC
 WHEN #VM_GOTO_PLACEHOLDER:@VM_GOTO_PLACEHOLDER
  ?"GOTO",VM_IMM$[VM_OPS[VM_PC]]
  INC VM_PC
 WHEN #VM_GOSUB_PLACEHOLDER:@VM_GOSUB_PLACEHOLDER
  ?"GOSUB",VM_IMM$[VM_OPS[VM_PC]]
  INC VM_PC
 WHEN #VM_GOSUB:@VM_GOSUB
  ?"GOSUB",VM_DUMP_ADDR$(VM_OPS[VM_PC])
  INC VM_PC
 WHEN #VM_RETURN:@VM_RETURN
  ?"RETURN"
 WHEN #VM_CALLFUNC:@VM_CALLFUNC
  ?"CALLFUNC",VM_IMM$[VM_OPS[VM_PC]],VM_OPS[VM_PC+1],VM_OPS[VM_PC+2]
  INC VM_PC,3
 WHEN #VM_PUSHEMPTY:@VM_PUSHEMPTY
  INC VM_PC
  ?"PUSHEMPTY",VM_OPS[VM_PC-1]
 WHEN #VM_RETURNFUNC:@VM_RETURNFUNC
  ?"RETURNFUNC"
 WHEN #VM_PUSHEMPTYREF:@VM_PUSHEMPTYREF
  ?"PUSHEMPTYREF"
 WHEN #VM_END:@VM_END
  ?"END"
 WHEN #VM_NEWARRAY:@VM_NEWARRAY
  ?"NEWARRAY",VM_OPS[VM_PC],VM_OPS[VM_PC+1]
  INC VM_PC,2
 WHEN #VM_PUSHARYREF:@VM_PUSHARYREF
  ?"PUSHARYREF",VM_OPS[VM_PC]
  INC VM_PC,1
 WHEN #VM_INITARRAY:@VM_INITARRAY
  ?"INITARRAY",VM_OPS[VM_PC]
  INC VM_PC,1
 WHEN #VM_READ:@VM_READ
  ?"READ"
 WHEN #VM_RESTORE:@VM_RESTORE
  ?"RESTORE",VM_OPS[VM_PC]
  INC VM_PC,1
 WHEN #VM_RESTORE_PLACEHOLDER:@VM_RESTORE_PLACEHOLDER
  ?"RESTORE",VM_IMM$[VM_OPS[VM_PC]]
  INC VM_PC,1
 WHEN #VM_UNAOP:@VM_UNAOP
  ?"UNAOP",VM_OPS[VM_PC]
  INC VM_PC,1
 WHEN #VM_CALLSPRITE:@VM_CALLSPRITE
  ?"CALLSPRITE"
 WHEN #VM_CALLTEXT:@VM_CALLTEXT
  ?"CALLTEXT"
 WHEN #VM_RESTOREEXPR:@VM_RESTOREEXPR
  ?"RESTOREEXPR"
 WHEN #VM_GOTOEXPR:@VM_GOTOEXPR
  ?"GOTOEXPR"
 WHEN #VM_GOSUBEXPR:@VM_GOSUBEXPR
  ?"GOSUBEXPR"
 WHEN #VM_INC:@VM_INC
  ?"INC"
 WHEN #VM_DEC:@VM_DEC
  ?"DEC"
 WHEN #VM_POP:@VM_POP
  ?"POP",VM_OPS[VM_PC]
  INC VM_PC
 WHEN #VM_ONGOTO:@VM_ONGOTO
  VAR LEN=VM_OPS[VM_PC]
  INC VM_PC
  ?"ONGOTO",LEN
  INC VM_PC,LEN
 WHEN #VM_ONGOSUB:@VM_ONGOSUB
  LEN=VM_OPS[VM_PC]
  INC VM_PC
  ?"ONGOSUB",LEN
  INC VM_PC,LEN
 WHEN #VM_WHEN:@VM_WHEN
  ?"WHEN",VM_DUMP_ADDR$(VM_OPS[VM_PC])
  INC VM_PC
 WHEN #VM_SWAP:@VM_SWAP
  ?"SWAP"
 WHEN #VM_INPUT:@VM_INPUT
  ?"INPUT",VM_OPS[VM_PC],VM_OPS[VM_PC+1],VM_OPS[VM_PC+2]
  INC VM_PC,3
 WHEN #VM_LINPUT:@VM_LINPUT
  ?"LINPUT",VM_OPS[VM_PC]
  INC VM_PC,1
 WHEN #VM_DEFOUT:@VM_DEFOUT
  ?"DEFOUT"
 WHEN #VM_EXEC1:@VM_EXEC1
  ?"EXEC1"
 WHEN #VM_EXEC2:@VM_EXEC2
  ?"EXEC2"
 WHEN #VM_STOP1:@VM_STOP1
  ?"STOP1"
 WHEN #VM_STOP2:@VM_STOP2
  ?"STOP2"
 WHEN #VM_PUSHVAREXPR:@VM_PUSHVAREXPR
  ?"PUSHVAREXPR"
 WHEN #VM_PUSHVAREXPRREF:@VM_PUSHVAREXPRREF
  ?"PUSHVAREXPRREF"
 WHEN #VM_RETURNFUNCEXPR:@VM_RETURNFUNCEXPR
  ?"RETURNFUNCEXPR"
 OTHERWISE:@VM_INVAL
  VM_ERROR
 ENDCASE
 VM_PC2=VM_PC
END

'VM END




'VIRTUAL SLOT
DIM VSLOTL_LINE$[]
DIM VSLOTL_NEXT[]
DIM VSLOTL_PREV[]
VAR VSLOTL_FREE'FREELIST
DIM VSLOT[]
DIM VSLOT_CURLINE[]
DIM VSLOT_CURLINE_NO[]
DIM VSLOT_LINECNT[]
DIM VSLOT_CHRCNT[]
DIM VSLOT_EOF[]
VAR VSLOT_MAX
CONST #VSLOT_INVALSLOT=-1
VAR VSLOT_CURSLOT
DEF VSLOT_INIT
 VSLOT_CURSLOT=#VSLOT_INVALSLOT
 VSLOT_MAX=4
 VSLOT=ARRAY%(VSLOT_MAX)
 VSLOT_CURLINE=ARRAY%(VSLOT_MAX)
 VSLOT_CURLINE_NO=ARRAY%(VSLOT_MAX)
 VSLOT_LINECNT=ARRAY%(VSLOT_MAX)
 VSLOT_CHRCNT=ARRAY%(VSLOT_MAX)
 VSLOT_EOF=ARRAY%(VSLOT_MAX)
 VAR VSLOT_INIT_CAP=1024
 VSLOTL_LINE$=ARRAY$(VSLOT_INIT_CAP)
 VSLOTL_NEXT=ARRAY%(VSLOT_INIT_CAP)
 VSLOTL_PREV=ARRAY%(VSLOT_INIT_CAP)
 VAR I
 FOR I=1TO VSLOT_INIT_CAP-2
  VSLOTL_NEXT[I]=I+1
 NEXT
 VSLOTL_FREE=1
 FOR I=0TO VSLOT_MAX-1
  VSLOT_LOAD I,CHR$(10)
 NEXT
END

DEF NEW_VSLOTL()
 IF!VSLOTL_FREE THEN
  VAR LAST=LEN(VSLOTL_LINE$)
  RESIZE VSLOTL_LINE$,LEN(VSLOTL_LINE$)*2
  RESIZE VSLOTL_NEXT,LEN(VSLOTL_NEXT)*2
  RESIZE VSLOTL_PREV,LEN(VSLOTL_PREV)*2
  VAR I
  FOR I=LAST TO LEN(VSLOTL_NEXT)-2
   VSLOTL_NEXT[I]=I+1
  NEXT
  VSLOTL_FREE=LAST
 ENDIF
 VAR L=VSLOTL_FREE
 VSLOTL_FREE=VSLOTL_NEXT[VSLOTL_FREE]
 VSLOTL_NEXT[L]=0
 RETURN L
END

DEF DELETE_VSLOTL L
 VSLOTL_NEXT[L]=VSLOTL_FREE
 VSLOTL_FREE=L
 VSLOTL_PREV[L]=0
 VAR E$
 VSLOTL_LINE$[L]=E$
END

DEF VSLOT_DESTROY SLOT
 VAR S=VSLOT[SLOT]
 WHILE S
  VAR NXT=VSLOTL_NEXT[S]
  DELETE_VSLOTL S
  S=NXT
 WEND
 VSLOT[SLOT]=0
END

DEF VSLOT_DUMP SLOT
 VAR S=VSLOT[SLOT]
 VAR L
 WHILE S
  INC L
  IF S==VSLOT_CURLINE[SLOT]THEN
   ?VSLOT_CURLINE_NO[SLOT];"=>";
  ENDIF
  ?L;".";VSLOTL_LINE$[S];
  S=VSLOTL_NEXT[S]
 WEND
END

DEF VSLOT_DUMPR SLOT
 VAR S=VSLOT[SLOT]
 VAR L
 WHILE S
  INC L
  IF!VSLOTL_NEXT[S]THEN BREAK
  S=VSLOTL_NEXT[S]
 WEND
 WHILE S
  IF S==VSLOT_CURLINE[SLOT]THEN
   ?VSLOT_CURLINE_NO[SLOT];"=>";
  ENDIF
  ?L;".";VSLOTL_LINE$[S];
  S=VSLOTL_PREV[S]
  DEC L
 WEND
END


DEF VSLOT_LOAD SLOT,V$
 VAR I
 VAR LF$=CHR$(10)
 VSLOT_DESTROY SLOT
 VAR PREV=0
 VAR FRST
 VAR LINE
 VSLOT_CHRCNT[SLOT]=0
 LOOP
  IF I>=LEN(V$)THEN BREAK
  VAR NXTLF=INSTR(I,V$,LF$)
  IF NXTLF==-1 THEN
   NXTLF=LEN(V$)
  ENDIF
  VAR S$=MID$(V$,I,NXTLF-I+1)
  VAR L=NEW_VSLOTL()
  INC LINE
  INC VSLOT_CHRCNT[SLOT],LEN(S$)
  VSLOTL_LINE$[L]=S$
  IF!PREV THEN
   PREV=L
   FRST=L
  ELSE
   VSLOTL_NEXT[PREV]=L
   VSLOTL_PREV[L]=PREV
  ENDIF
  PREV=L
  I=NXTLF+1
 ENDLOOP
 VSLOT_LINECNT[SLOT]=LINE
 VSLOT[SLOT]=FRST
 VSLOT_CURLINE[SLOT]=PREV
 VSLOT_CURLINE_NO[SLOT]=LINE
 VSLOT_EOF[SLOT]=#TRUE
END

DEF VSLOT_SEEK(SLOT,DIFF)
 VSLOT_EOF[SLOT]=#FALSE
 IF DIFF==1 THEN
  IF VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]==0 THEN
   VSLOT_EOF[SLOT]=#TRUE
   RETURN 0
  ENDIF
  VSLOT_CURLINE[SLOT]=VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]
  INC VSLOT_CURLINE_NO[SLOT]
  RETURN 1
 ENDIF
 IF DIFF==-1 THEN
  IF VSLOTL_PREV[VSLOT_CURLINE[SLOT]]==0 THEN
   RETURN 0
  ENDIF
  VSLOT_CURLINE[SLOT]=VSLOTL_PREV[VSLOT_CURLINE[SLOT]]
  DEC VSLOT_CURLINE_NO[SLOT]
  RETURN 1
 ENDIF
 STOP
END
DEF VSLOT_SEEKEOF SLOT
 LOOP
  IF VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]==0 THEN
   VSLOT_EOF[SLOT]=#TRUE
   BREAK
  ENDIF
  VSLOT_CURLINE[SLOT]=VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]
  INC VSLOT_CURLINE_NO[SLOT]
 ENDLOOP
END
DEF VSLOT_GETLINE$(SLOT,LINE)
 VAR DIFF=LINE-VSLOT_CURLINE_NO[SLOT]
 VAR CL=VSLOT_CURLINE[SLOT]
 IF DIFF>0 THEN
  FOR DIFF=DIFF TO 1 STEP -1
   IF VSLOTL_NEXT[CL]==0 THEN
    BREAK
   ENDIF
   CL=VSLOTL_NEXT[CL]
  NEXT
 ELSE
  FOR DIFF=DIFF TO -1
   IF VSLOTL_PREV[CL]==0 THEN
    BREAK
   ENDIF
   CL=VSLOTL_PREV[CL]
  NEXT
 ENDIF
 RETURN VSLOTL_LINE$[CL]
END
DEF VSLOT_SEEKLINE SLOT,LINE
 VAR DIFF=LINE-VSLOT_CURLINE_NO[SLOT]
 VSLOT_EOF[SLOT]=#FALSE
 IF DIFF==0 THEN
  RETURN
 ENDIF
 IF DIFF>0 THEN
  FOR DIFF=DIFF TO 1 STEP -1
   IF VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]==0 THEN
    BREAK
   ENDIF
   VSLOT_CURLINE[SLOT]=VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]
   INC VSLOT_CURLINE_NO[SLOT]
  NEXT
 ELSE
  FOR DIFF=DIFF TO -1
   IF VSLOTL_PREV[VSLOT_CURLINE[SLOT]]==0 THEN
    BREAK
   ENDIF
   VSLOT_CURLINE[SLOT]=VSLOTL_PREV[VSLOT_CURLINE[SLOT]]
   DEC VSLOT_CURLINE_NO[SLOT]
  NEXT
 ENDIF
END

DEF VSLOT_SET SLOT,V$
 V$=V$+CHR$(10)
 VAR I
 VAR LF$=CHR$(10)
 VAR NL
 VAR MULTIPLE
 IF!VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]&&!VSLOT_EOF[SLOT]THEN
  NL=NEW_VSLOTL()
  VSLOTL_LINE$[NL]=LF$
  INC VSLOT_CHRCNT[SLOT]
  VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]=NL
  VSLOTL_PREV[NL]=VSLOT_CURLINE[SLOT]
  INC VSLOT_LINECNT[SLOT]
 ENDIF
 LOOP
  VAR NXTLF=INSTR(I,V$,LF$)
  IF NXTLF==-1 THEN
   NXTLF=LEN(V$)
  ENDIF
  VAR LINE$=MID$(V$,I,NXTLF-I+1)
  VAR L=VSLOT_CURLINE[SLOT]
  INC VSLOT_CHRCNT[SLOT],LEN(LINE$)-LEN(VSLOTL_LINE$[L])
  VSLOTL_LINE$[L]=LINE$
  I=NXTLF+1
  IF I>=LEN(V$)THEN BREAK
  INC VSLOT_CURLINE_NO[SLOT]
  INC VSLOT_LINECNT[SLOT]
  NL=NEW_VSLOTL()
  VSLOTL_PREV[NL]=L
  VSLOTL_NEXT[NL]=VSLOTL_NEXT[L]
  VSLOTL_PREV[VSLOTL_NEXT[L]]=NL
  VSLOTL_NEXT[L]=NL
  VSLOT_CURLINE[SLOT]=NL
  MULTIPLE=#TRUE
 ENDLOOP
 IF VSLOT_EOF[SLOT]THEN
  NL=NEW_VSLOTL()
  VSLOTL_PREV[NL]=L
  VSLOTL_NEXT[L]=NL
  VSLOTL_LINE$[NL]=LF$
  VSLOT_CURLINE[SLOT]=NL
  INC VSLOT_LINECNT[SLOT]
  INC VSLOT_CURLINE_NO[SLOT]
  INC VSLOT_CHRCNT[SLOT],LEN(LF$)
 ELSE
  INC VSLOT_CURLINE_NO[SLOT]
  IF VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]THEN
   VSLOT_CURLINE[SLOT]=VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]
  ENDIF
 ENDIF
END

DEF VSLOT_INS SLOT,V$,PS
 V$=V$+CHR$(10)
 VAR I
 VAR LF$=CHR$(10)
 VAR NL
 VAR INSTO=VSLOT_CURLINE[SLOT]
 IF PS THEN
  INSTO=INSTO
 ELSE
  INSTO=VSLOTL_PREV[INSTO]
 ENDIF
 IF !INSTO&&PS THEN
  INSTO=VSLOT_CURLINE[SLOT]
 ENDIF
 LOOP
  VAR NXTLF=INSTR(I,V$,LF$)
  IF NXTLF==-1 THEN
   NXTLF=LEN(V$)
  ENDIF
  VAR LINE$=MID$(V$,I,NXTLF-I+1)
  NL=NEW_VSLOTL()
  IF !INSTO THEN
   VSLOTL_PREV[NL]=INSTO
   VSLOTL_NEXT[NL]=VSLOTL_NEXT[INSTO]
   IF INSTO THEN
    VSLOTL_NEXT[INSTO]=NL
   ELSE
    VSLOTL_NEXT[NL]=VSLOT[SLOT]
    VSLOTL_PREV[VSLOT[SLOT]]=NL
    VSLOT[SLOT]=NL
   ENDIF
  ELSE
   VAR PRV=VSLOTL_PREV[INSTO]
   VAR NXT=VSLOTL_NEXT[INSTO]
   VSLOTL_NEXT[INSTO]=NL
   VSLOTL_NEXT[NL]=NXT
   VSLOTL_PREV[NL]=INSTO
   VSLOTL_PREV[NXT]=NL
  ENDIF
  INC VSLOT_CURLINE_NO[SLOT]
  IF PS THEN
   VSLOT_CURLINE[SLOT]=NL
  ELSE
   VSLOT_CURLINE[SLOT]=VSLOTL_NEXT[NL]
  ENDIF
  INSTO=NL
  INC VSLOT_LINECNT[SLOT]
  INC VSLOT_CHRCNT[SLOT],LEN(LINE$)
  VAR L=NL
  VSLOTL_LINE$[L]=LINE$
  I=NXTLF+1
  IF I>=LEN(V$)THEN BREAK
 ENDLOOP
END

DEF VSLOT_DEL SLOT,D
 IF D<0THEN
  VAR PRSV=VSLOT_EOF[SLOT]
  VSLOT_DESTROY SLOT
  VSLOT_LOAD SLOT,CHR$(10)
  VSLOT_EOF[SLOT]=PRSV
  RETURN
 ENDIF
 VAR CL=VSLOT_CURLINE[SLOT]
 VAR DELFRST
 WHILE D>0&&CL
  DEC D
  VAR NXT=VSLOTL_NEXT[CL]
  VAR PRV=VSLOTL_PREV[CL]
  DEC VSLOT_LINECNT[SLOT]
  DEC VSLOT_CHRCNT[SLOT],LEN(VSLOTL_LINE$[CL])
  VSLOTL_NEXT[PRV]=NXT
  IF NXT THEN
   VSLOTL_PREV[NXT]=PRV
  ELSE
   DEC VSLOT_CURLINE_NO[SLOT]
   NXT=PRV
  ENDIF
  VSLOT_CURLINE[SLOT]=NXT
  DELETE_VSLOTL CL
  IF CL==VSLOT[SLOT]THEN
   IF NXT THEN
    VSLOT[SLOT]=NXT
    VSLOT_CURLINE_NO[SLOT]=1
   ELSE
    DELFRST=#TRUE
   ENDIF
  ENDIF
  CL=NXT
 WEND
 IF DELFRST THEN
  PRSV=VSLOT_EOF[SLOT]
  VSLOT[SLOT]=0
  VSLOT_LOAD SLOT,CHR$(10)
  VSLOT_EOF[SLOT]=PRSV
 ENDIF
END

DEF VSLOT_PRGEDIT SLOT,LINE
 VSLOT_CURSLOT=SLOT
 IF LINE!=-1 THEN
  VSLOT_SEEKLINE SLOT,LINE
 ELSE
  VSLOT_SEEKEOF SLOT
 ENDIF
END

DEF VSLOT_PRGGET_SLOT$(SLOT,SEEKFLG)
 IF VSLOT_EOF[SLOT]THEN
  RETURN ""
 ENDIF
 VAR V$=VSLOTL_LINE$[VSLOT_CURLINE[SLOT]]
 IF SEEKFLG THEN
  VAR _=VSLOT_SEEK(SLOT,1)
 ENDIF
 RETURN V$
END
DEF VSLOT_PRGGET$(SEEKFLG)
 RETURN VSLOT_PRGGET_SLOT$(VSLOT_CURSLOT,SEEKFLG)
END

DEF VSLOT_PRGSEEK(D)
 RETURN VSLOT_SEEK(VSLOT_CURSLOT,D)
END

DEF VSLOT_PRGEDIT_OUT OUT SLOT,LINE
 SLOT=VSLOT_CURSLOT
 LINE=VSLOT_CURLINE_NO[SLOT]
END

DEF VSLOT_PRGSET L$
 VSLOT_SET VSLOT_CURSLOT,L$
END

DEF VSLOT_PRGINS L$,D
 VSLOT_INS VSLOT_CURSLOT,L$,D
END

DEF VSLOT_PRGDEL D
 VSLOT_DEL VSLOT_CURSLOT,D
END

DEF VSLOT_PRGSIZE(SLOT,TYP)
 IF TYP==0 THEN
  IF VSLOT_LINECNT[SLOT]==1&&VSLOTL_LINE$[VSLOT[SLOT]]==CHR$(10)THEN
   RETURN 0
  ENDIF
  RETURN VSLOT_LINECNT[SLOT]
 ELSEIF TYP==1THEN
  RETURN VSLOT_CHRCNT[SLOT]
 ENDIF
 RETURN 1048576-VSLOT_CHRCNT[SLOT]
END


VAR VSLOT_TEST_SLOT
DEF VSLOT_TEST_SET LINE,STR$
 VAR I
 FOR I=0TO LAST(STR$)
  IF STR$[I]=="/"THEN STR$[I]=CHR$(10)
 NEXT
 VSLOT_PRGEDIT VSLOT_TEST_SLOT,1
 VSLOT_PRGDEL -1
 VSLOT_PRGSET STR$
 VSLOT_PRGEDIT VSLOT_TEST_SLOT,LINE
 PRGEDIT VSLOT_TEST_SLOT
 PRGDEL -1
 PRGSET STR$
 PRGEDIT VSLOT_TEST_SLOT,LINE
END
VAR VSLOT_ASSERT_FAILED
DEF VSLOT_ASSERT *
 IF!DEFARG(0)THEN
  VSLOT_ASSERT_FAILED=#TRUE
  ?"Assertion failed",DEFARG(1),"SLOT ";DEFARG(2);" LINE ";DEFARG(3);" FILE ";CHR$(34);DEFARG(4);CHR$(34)
 ENDIF
END
DEF VSLOT_ASSERT_EQ L,L$,R,R$,SLOT,LINE,FILE
 IF L!=R THEN
  VSLOT_ASSERT_FAILED=#TRUE
  VAR LL$=VSLOT_TEST_ESCAPE$(L)
  VAR RR$=VSLOT_TEST_ESCAPE$(R)
  ?"Assertion failed",LL$;"!=";RR$,L$;"!=";R$,"SLOT ";SLOT;" LINE ";LINE;" FILE ";CHR$(34);FILE;CHR$(34)
 ENDIF
END
DEF VSLOT_TEST_ESCAPE$(S$)
 IF TYPEOF(S$)==#T_STR THEN
  VAR I
  VAR R$=""
  PUSH R$,CHR$(34)
  FOR I=0TO LAST(S$)
   IF ASC(S$[I])==10THEN
    PUSH R$,"\n"
   ELSEIF S$[I]=="\"THEN
    PUSH R$,"\\"
   ELSE
    PUSH R$,S$[I]
   ENDIF
  NEXT
  PUSH R$,CHR$(34)
  RETURN R$
 ELSE
  RETURN STR$(S$)
 ENDIF
END
VAR VSLOT_TEST_CNT
VAR VSLOT_TEST_SUCC_CNT
VAR VSLOT_TEST_FAILED_CNT
DEF VSLOT_CHECK
 INC VSLOT_TEST_CNT
 VSLOT_ASSERT_FAILED=#FALSE
 VAR SLOT=VSLOT_TEST_SLOT
 VAR S=VSLOT[SLOT]
 VAR L
 VAR LINES$[]
 VAR LINESR$[]
 VAR P_IS_EOF=PRGGET$(#FALSE)==""
 VAR V_IS_EOF=VSLOT_EOF[SLOT]
 VSLOT_ASSERT_EQ P_IS_EOF,"P_IS_EOF",V_IS_EOF,"V_IS_EOF",#_SLOT,#_LINE,#_FILENAME
 VAR P_LINE=PRGEDIT()
 VAR V_LINE=VSLOT_CURLINE_NO[SLOT]
 VSLOT_ASSERT_EQ P_LINE,"P_LINE",V_LINE,"V_LINE",#_SLOT,#_LINE,#_FILENAME
 VSLOT_ASSERT_EQ PRGGET$(#FALSE),"PRGGET$(#FALSE)",VSLOT_PRGGET$(#FALSE),"VSLOT_PRGGET$(#FALSE)",#_SLOT,#_LINE,#_FILENAME
 VAR HAS_CURLINE
 WHILE S
  INC L
  IF S==VSLOT_CURLINE[SLOT]THEN
   VSLOT_ASSERT_EQ VSLOT_CURLINE_NO[SLOT],"VSLOT_CURLINE_NO[SLOT]",L,"L",#_SLOT,#_LINE,#_FILENAME
   HAS_CURLINE=#TRUE
  ENDIF
  PUSH LINES$,VSLOTL_LINE$[S]
  IF!VSLOTL_NEXT[S] THEN
   BREAK
  ENDIF
  S=VSLOTL_NEXT[S]
 WEND
 VSLOT_ASSERT HAS_CURLINE,"HAS_CURLINE",#_SLOT,#_LINE,#_FILENAME
 HAS_CURLINE=#FALSE
 VAR V_LINE_CNT=L
 WHILE S
  IF S==VSLOT_CURLINE[SLOT]THEN
   VSLOT_ASSERT_EQ VSLOT_CURLINE_NO[SLOT],"VSLOT_CURLINE_NO[SLOT]",L,"L",#_SLOT,#_LINE,#_FILENAME
   HAS_CURLINE=#TRUE
  ENDIF
  UNSHIFT LINESR$,VSLOTL_LINE$[S]
  S=VSLOTL_PREV[S]
  DEC L
 WEND
 VSLOT_ASSERT HAS_CURLINE,"HAS_CURLINE",#_SLOT,#_LINE,#_FILENAME
 PRGEDIT SLOT,1
 DIM LINESP$[]
 LOOP
  VAR L$=PRGGET$()
  IF L$==""THEN BREAK
  PUSH LINESP$,L$
 ENDLOOP
 PRGEDIT SLOT,-1
 VAR P_LINE_CNT=PRGEDIT()
 VSLOT_ASSERT_EQ P_LINE_CNT,"P_LINE_CNT",V_LINE_CNT,"V_LINE_CNT",#_SLOT,#_LINE,#_FILENAME
 VSLOT_ASSERT_EQ LEN(LINES$),"LEN(LINES$)",LEN(LINESP$),"LEN(LINESP$)",#_SLOT,#_LINE,#_FILENAME
 VSLOT_ASSERT LEN(LINES$),"LEN(LINES$)",LEN(LINESR$),"LEN(LINESR$)",#_SLOT,#_LINE,#_FILENAME
 VAR I
 FOR I=0TO MIN(LAST(LINES$[I]),LAST(LINESP$),LAST(LINESR$))'P_LINE-1
  VSLOT_ASSERT_EQ LINES$[I],"LINES$[I]",LINESP$[I],"LINESP$[I]",#_SLOT,#_LINE,#_FILENAME
  VSLOT_ASSERT_EQ LINES$[I],"LINES$[I]",LINESR$[I],"LINESR$[I]",#_SLOT,#_LINE,#_FILENAME
 NEXT
 VSLOT_ASSERT_EQ PRGSIZE(VSLOT_TEST_SLOT,0),"PRGSIZE(VSLOT_TEST_SLOT,0)",VSLOT_PRGSIZE(VSLOT_TEST_SLOT,0),"VSLOT_PRGSIZE(VSLOT_TEST_SLOT,0)",#_SLOT,#_LINE,#_FILENAME
 VSLOT_ASSERT_EQ PRGSIZE(VSLOT_TEST_SLOT,1),"PRGSIZE(VSLOT_TEST_SLOT,1)",VSLOT_PRGSIZE(VSLOT_TEST_SLOT,1),"VSLOT_PRGSIZE(VSLOT_TEST_SLOT,1)",#_SLOT,#_LINE,#_FILENAME
 IF VSLOT_ASSERT_FAILED THEN
  ?FORMAT$("%15S%15S%15S","LINESP","LINES","LINESR")
  FOR I=0TO MAX(LAST(LINES$),LAST(LINESP$),LAST(LINESR$))
   IF LEN(LINESP$)>I THEN
    ?FORMAT$("%20S",VSLOT_TEST_ESCAPE$(LINESP$[I]));
   ELSE
    ?FORMAT$("%20S","XXX");
   ENDIF
   IF LEN(LINES$)>I THEN
    ?FORMAT$("%20S",VSLOT_TEST_ESCAPE$(LINES$[I]));
   ELSE
    ?FORMAT$("%20S","XXX");
   ENDIF
   IF LEN(LINESR$)>I THEN
    ?FORMAT$("%20S",VSLOT_TEST_ESCAPE$(LINESR$[I]))
   ELSE
    ?FORMAT$("%20S","XXX");
   ENDIF
  NEXT
 ENDIF
 IF VSLOT_ASSERT_FAILED THEN
  INC VSLOT_TEST_FAILED_CNT
  STOP
 ELSE
  INC VSLOT_TEST_SUCC_CNT
 ENDIF
END

DEF VSLOT_TEST_PRGINS A$,B
 PRGINS A$,B
 VSLOT_PRGINS A$,B
END
DEF VSLOT_TEST_PRGSET A$
 PRGSET A$
 VSLOT_PRGSET A$
END
DEF VSLOT_TEST_PRGDEL L
 PRGDEL L
 VSLOT_PRGDEL L
END
DEF VSLOT_TEST_PRGSEEK L
 VSLOT_ASSERT_EQ PRGSEEK(L),"PRGSEEK("+STR$(L)+")",VSLOT_PRGSEEK(L),"VSLOT_PRGSEEK("+STR$(L)+")",#_SLOT,#_LINE,#_FILENAME
END
DEF VSLOT_TEST_PRGGET L
 VSLOT_ASSERT_EQ PRGGET$(L),"PRGGET$("+STR$(L)+")",VSLOT_PRGGET$(L),"VSLOT_PRGGET$("+STR$(L)+")",#_SLOT,#_LINE,#_FILENAME
END

DEF VSLOT_TEST
 VSLOT_TEST_SLOT=3
 VAR I,J,K
 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 "+STR$(I)
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGINS "PRGINS0,"+STR$(I),0
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGINS "PRGINS1,"+STR$(I),1
  VSLOT_CHECK
 NEXT


 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGINS "PRGINS0,"+STR$(I)+CHR$(10)+"\n",0
  VSLOT_CHECK
 NEXT


 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGINS "PRGINS1,"+STR$(I)+CHR$(10)+"\n",1
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGSET "PRGSET"+STR$(I)
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGSET "PRGSET"+STR$(I)+CHR$(10)+"\n"
  VSLOT_CHECK
 NEXT


 FOR I=-1TO 2
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,""
  VSLOT_TEST_PRGSET "PRGSET"+STR$(I)+CHR$(10)+"\n"
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGSET "PRGSET"+STR$(I)+CHR$(10)+"\n1"
  VSLOT_TEST_PRGINS "PRGINS0,"+STR$(I)+CHR$(10)+"\n2",0
  VSLOT_TEST_PRGINS "PRGINS1,"+STR$(I)+CHR$(10)+"\n3",1
  VSLOT_TEST_PRGSET "PRGSET"+STR$(I)+CHR$(10)+"\n4"
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 DEL"+STR$(I)
  VSLOT_TEST_PRGDEL -1
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  FOR J=-1TO 5
   IF J==0THEN CONTINUE
   VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 DEL"+STR$(I)+","+STR$(J)
   VSLOT_TEST_PRGDEL J
   VSLOT_CHECK
  NEXT
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 SEEK"+STR$(I)
  VSLOT_TEST_PRGSEEK 1
  VSLOT_CHECK
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 SEEK"+STR$(I)
  VSLOT_TEST_PRGSEEK -1
  VSLOT_CHECK
  FOR J=0TO 5
   VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 GET0,"+STR$(I)
   FOR K=0TO J
    VSLOT_TEST_PRGGET 0
   NEXT
   VSLOT_CHECK
   VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 GET1,"+STR$(I)
   FOR K=0TO J
    VSLOT_TEST_PRGGET 1
   NEXT
   VSLOT_CHECK
  NEXT
 NEXT
 ?"(";VSLOT_TEST_SUCC_CNT;"/";VSLOT_TEST_CNT;") passed"
 STOP
END


'INTERFACES
DEF SBSB_LOAD * OUT *
 IF DEFOUTC()!=0 THEN
  MISSING_PARAMETER "LOAD"
  RETURN
 ENDIF
 IF DEFARGC()!=1&&DEFARGC()!=2 THEN
  MISSING_PARAMETER "LOAD"
  RETURN
 ENDIF
 VAR FN$=DEFARG(0)
 VAR SLOT=0
 IF TYPEOF(FN$)!=#T_STR THEN
  TYPE_MISMATCH "LOAD"
  RETURN
 ENDIF
 IF DEFARGC()==2THEN
  SLOT=DEFARG(1)
  IF TYPEOF(SLOT)!=#T_INT THEN
   TYPE_MISMATCH "LOAD"
   RETURN
  ENDIF
 ENDIF
 IF SLOT<0||SLOT>=VSLOT_MAX THEN
  OUT_OF_RANGE "LOAD"
  RETURN
 ENDIF
 IF INSTR(FN$,"TXT:")!=0 THEN
  FN$="TXT:"+FN$
 ENDIF
 'FIXME:VALIDATE FILENAME
 VAR V$=LOADV(FN$)
 VSLOT_LOAD SLOT,V$
END


DEF SBSB_PRGEDIT * OUT *
 IF DEFARGC()==0&&DEFOUTC()==1THEN
  VAR SLOT,LINE
  VSLOT_PRGEDIT_OUT OUT SLOT,LINE
  IF SLOT==#VSLOT_INVALSLOT THEN
   USE_PRGEDIT_BEFORE_ANY_PRG_FUNCTION "PRGEDIT"
  ELSE
   DEFOUT 0,LINE
  ENDIF
 ELSEIF DEFARGC()==0&&DEFOUTC()==2THEN
  VSLOT_PRGEDIT_OUT OUT SLOT,LINE
  IF SLOT==#VSLOT_INVALSLOT THEN
   USE_PRGEDIT_BEFORE_ANY_PRG_FUNCTION "PRGEDIT"
  ELSE
   DEFOUT 0,SLOT
   DEFOUT 0,LINE
  ENDIF
 ELSEIF DEFARGC()==1&&DEFOUTC()==0THEN
  VSLOT_PRGEDIT DEFARG(0),1'FIXME
 ELSEIF DEFARGC()==2&&DEFOUTC()==0THEN
  VSLOT_PRGEDIT DEFARG(0),DEFARG(1)
 ELSE
  MISSING_PARAMETER "PRGEDIT"
 ENDIF
END

DEF SBSB_PRGDEL * OUT *
 IF DEFARGC()==0&&DEFOUTC()==0THEN
  VSLOT_PRGDEL 1
 ELSEIF DEFARGC()==1&&DEFOUTC()==0THEN
  VSLOT_PRGDEL DEFARG(0)
 ELSE
  MISSING_PARAMETER "PRGDEL"
 ENDIF
END

DEF SBSB_PRGSET * OUT *
 IF DEFARGC()==1&&DEFOUTC()==0THEN
  VSLOT_PRGSET DEFARG(0)
 ELSE
  MISSING_PARAMETER "PRGSET"
 ENDIF
END
'REGISTER BASED
ENUM\
 #RIR_MOVINT,\
 #RIR_MOVREAL,\
 #RIR_MOVSTR,\
 #RIR_ADD,\
 #RIR_SUB,\
 #RIR_MUL,\
 #RIR_DIV,\
 #RIR_DIVINT,\
 #RIR_MOD,\
 #RIR_AND,\
 #RIR_OR,\
 #RIR_XOR,\
 #RIR_EQ,\
 #RIR_NEQ,\
 #RIR_LSHIFT,\
 #RIR_RSHIFT,\
 #RIR_GREAT,\
 #RIR_LESS,\
 #RIR_GEQ,\
 #RIR_LEQ,\
 #RIR_LNOT,\
 #RIR_NOT,\
 #RIR_NEG,\
 #RIR_SETGLOBAL,\
 #RIR_SETLOCAL,\
 #RIR_SETVAR,\
 #RIR_SETINARG,\
 #RIR_SETOUTARG,\
 #RIR_GETGLOBAL,\
 #RIR_GETLOCAL,\
 #RIR_GETVAR,\
 #RIR_GETINARG,\
 #RIR_GETOUTARG,\
 #RIR_BR,\
 #RIR_BRFALSE,\
 #RIR_BRTRUE,\
 #RIR_PRINT,\
 #RIR_CALL,\
 #RIR_LEAVE,\
 #RIR_END,\
 #RIR_DEFFUN,\
 #RIR_FORGLOBAL,\
 #RIR_FORLOCAL,\
 #RIR_FORINARG,\
 #RIR_FOROUTARG,\
 #RIR_NEWARRAY,\
 #RIR_SETARRAY,\
 #RIR_GETARRAY,\
 #RIR_DATAINT,\
 #RIR_DATAREAL,\
 #RIR_DATASTR,\
 #RIR_READ,\
 #RIR_GOTO,\
 #RIR_GOSUB,\
 #RIR_GOTOEXPR,\
 #RIR_GOSUBEXPR,\
 #RIR_LABEL,\
 #RIR_RESTORE,\
 #RIR_RESTOREEXPR,\
 #RIR_INCGLOBAL,\
 #RIR_INCLOCAL,\
 #RIR_INCINARG,\
 #RIR_INCOUTARG,\
 #RIR_INCARRAY,\
 #RIR_
'MOVEINT OP1(REG),OP2(INT)
'MOVEREAL OP1(REG),OP2(REAL TABLE)
'MOVESTR OP1(REG),OP2(STR TABLE)
'ADD MODRM REG,REG,REG
'SETGLOBAL OP1(INDEX),MODRM
'SETLOCAL OP1(INDEX),MODRM
ENUM\
 #RIR_MOD_REG,\
 #RIR_MOD_INT,\
 #RIR_MOD_REAL,\
 #RIR_MOD_STR

DIM RIR_OPS[]
DIM RIR_IMM#[]
DIM RIR_IMM$[]
DEF INIT_RIR_CODEGEN
 RIR_OPS=ARRAY%(0)
 RIR_IMM#=ARRAY#(0)
 RIR_IMM$=ARRAY$(0)
END
DEF REMIT OP
 PUSH RIR_OPS,OP
END
DEF REMIT_IMM# IMM#
 PUSH RIR_IMM#,IMM#
 PUSH RIR_OPS,LAST(RIR_IMM#)
END
DEF REMIT_IMM$ IMM$
 PUSH RIR_IMM$,IMM$
 PUSH RIR_OPS,LAST(RIR_IMM$)
END
DEF RIR_SET ADDR,V
 RIR_OPS[ADDR]=V
END
DEF RIR_GET_ADDR()
 RETURN LAST(RIR_OPS)
END
DEF RIR_NEXT_ADDR()
 RETURN LEN(RIR_OPS)
END

DEF RIR_DUMP
 VAR I
 LOOP
  IF I>=LEN(RIR_OPS) THEN
   BREAK
  ENDIF
  ?"@0"+HEX$(I);":";
  VAR C=RIR_OPS[I]
  INC I
  CASE C
  WHEN #RIR_MOVINT
   ?"R";RIR_OPS[I];"=";RIR_OPS[I+1]
   INC I,2
  WHEN #RIR_MOVREAL
   ?"R";RIR_OPS[I];"=";RIR_IMM#[RIR_OPS[I+1]]
   INC I,2
  WHEN #RIR_MOVSTR
   ?"R";RIR_OPS[I];"=";CHR$(34);RIR_IMM$[RIR_OPS[I+1]];CHR$(34)
   INC I,2
  WHEN #RIR_ADD
  WHEN #RIR_ADD
  WHEN #RIR_SUB
  WHEN #RIR_MUL
  WHEN #RIR_DIV
  WHEN #RIR_DIVINT
  WHEN #RIR_MOD
  WHEN #RIR_AND
  WHEN #RIR_OR
  WHEN #RIR_XOR
  WHEN #RIR_EQ
  WHEN #RIR_NEQ
  WHEN #RIR_LSHIFT
  WHEN #RIR_RSHIFT
  WHEN #RIR_GREAT
  WHEN #RIR_LESS
  WHEN #RIR_GEQ
  WHEN #RIR_LEQ
   ?"R";RIR_OPS[I];"=";"R";RIR_OPS[I+1];RIR_GET_OP$(C);"R";RIR_OPS[I+2]
   INC I,3
  WHEN #RIR_GETGLOBAL
   ?"R";RIR_OPS[I];"=G0";RIR_OPS[I+1]
   INC I,2
  WHEN #RIR_GETLOCAL
   ?"R";RIR_OPS[I];"=L";RIR_OPS[I+1]
   INC I,2
  WHEN #RIR_SETGLOBAL
   ?"G0";RIR_OPS[I];"=R";RIR_OPS[I+1]
   INC I,2
  WHEN #RIR_SETLOCAL
   ?"L";RIR_OPS[I];"=R";RIR_OPS[I+1]
   INC I,2
  WHEN #RIR_PRINT
   VAR CNT=RIR_OPS[I]*2+I-1
   ?"?";
   FOR I=I+1 TO CNT STEP 2
    ?"R";RIR_OPS[I+1];
    IF RIR_OPS[I]==0 THEN
     ?",";
    ELSEIF RIR_OPS[I]==1 THEN
    ELSEIF RIR_OPS[I]==2 THEN
     ?";";
    ENDIF
   NEXT
   ?
  WHEN #RIR_BRFALSE
   ?"IF R";RIR_OPS[I];" THEN ELSE GOTO@0";HEX$(RIR_OPS[I+1])
   INC I,2
  WHEN #RIR_BRTRUE
   ?"IF R";RIR_OPS[I];" GOTO@0";HEX$(RIR_OPS[I+1])
   INC I,2
  WHEN #RIR_BR
   ?"GOTO@0";HEX$(RIR_OPS[I])
   INC I
  OTHERWISE
   STOP
  ENDCASE
 ENDLOOP
END
VAR RCMP_REG
VAR RIR_SBCODE$
DEF RGEN_EMIT_SBCODE C$
 PUSH RIR_SBCODE$,C$
END
DIM RGEN_REG_TABLE[]
DIM RGEN_REG_TABLE_TYPE[]
DIM RGEN_REG_TABLE_CONST%[]
DIM RGEN_REG_TABLE_CONST#[]
DIM RGEN_REG_TABLE_CONST$[]
DIM RGEN_REG[]
DIM RGEN_REG_TYPE[]
DIM RGEN_REG_NEXT[]
DIM RGEN_REG_USED[]
VAR RGEN_REG_FREE
ENUM #RGEN_REG_NONE,#RGEN_REG_CONST

DEF RGEN_ALLOC_CONST% REG,V
 RGEN_REG_TABLE[REG]=-2
 RGEN_REG_TABLE_TYPE[REG]=#T_INT
 RGEN_REG_TABLE_CONST%[REG]=V
END
DEF RGEN_ALLOC_CONST# REG,V
 RGEN_REG_TABLE[REG]=-2
 RGEN_REG_TABLE_TYPE[REG]=#T_REAL
 RGEN_REG_TABLE_CONST#[REG]=V
END
DEF RGEN_ALLOC_CONST$ REG,V
 RGEN_REG_TABLE[REG]=-2
 RGEN_REG_TABLE_TYPE[REG]=#T_STR
 RGEN_REG_TABLE_CONST$[REG]=V
END
DEF RGEN_ALLOC_EXPR REG,V
 RGEN_REG_TABLE[REG]=-3
 RGEN_REG_TABLE_CONST$[REG]=V
END
DEF RGEN_ALLOC_REG(REG)
 IF RGEN_REG_FREE!=-1 THEN
  VAR L=RGEN_REG_FREE
  RGEN_REG_FREE=RGEN_REG_NEXT[RGEN_REG_FREE]
 ELSE
  PUSH RGEN_REG,0
  PUSH RGEN_REG_TYPE,0
  PUSH RGEN_REG_NEXT,-1
  PUSH RGEN_REG_USED,0
  L=LAST(RGEN_REG)
  RGEN_REG[L]=L
 ENDIF
 RGEN_REG[L]=REG
 RGEN_REG_TABLE[REG]=L
 RGEN_REG_USED[L]=#TRUE
 RETURN L
END
DEF RGEN_FREE_REG REG
 IF REG==-1THEN RETURN
 RGEN_REG_NEXT[REG]=RGEN_REG_FREE
 RGEN_REG_USED[REG]=#FALSE
 RGEN_REG_FREE=REG
 RGEN_REG_TABLE[RGEN_REG[REG]]=-99
END
DEF RGEN_GET_REG REG OUT R,R$
 IF RGEN_REG_TABLE[REG]==-1THEN
  STOP
 ELSEIF RGEN_REG_TABLE[REG]==-99THEN
  STOP "FRE
 ELSEIF RGEN_REG_TABLE[REG]==-2THEN
  IF RGEN_REG_TABLE_TYPE[REG]==#T_INT THEN
   R=-1
   R$=STR$(RGEN_REG_TABLE_CONST%[REG])
  ELSEIF RGEN_REG_TABLE_TYPE[REG]==#T_REAL THEN
   R=-1
   R$=STR$(RGEN_REG_TABLE_CONST#[REG])
  ELSEIF RGEN_REG_TABLE_TYPE[REG]==#T_STR THEN
   R=-1
   R$=CHR$(34)+RGEN_REG_TABLE_CONST$[REG]+CHR$(34)
  ENDIF
 ELSEIF RGEN_REG_TABLE[REG]==-3THEN
  R=-1
  R$=RGEN_REG_TABLE_CONST$[REG]
 ELSE
  R=RGEN_REG_TABLE[REG]
  R$=RGEN_REG_STR$(R)
 ENDIF
END
DEF RGEN_REG_STR$(R)
 RETURN "R"+STR$(R)
END
DEF RGEN_GLOBAL_STR$(R)
 RETURN "G0"+STR$(R)
END
DEF RGEN_LOCAL_STR$(R)
 RETURN "L"+STR$(R)
END
DEF RGEN_INARG_STR$(R)
 RETURN "I"+STR$(R)
END
DEF RGEN_OUTARG_STR$(R)
 RETURN "O"+STR$(R)
END
DIM RGEN_RJMP_TABLE[]
DIM RGEN_RJMP_TABLE$[]

DEF RGEN_LABEL$(CURRENT_PC,R)
 RETURN "@0"+HEX$(R)'+"@________"
 IF CURRENT_PC>=R THEN
  RETURN "@0"+HEX$(R)+"@0"+HEX$(RGEN_RJMP_TABLE[R])
 ENDIF
 RETURN "@0"+HEX$(R)+"@________"
END
DEF RGEN_FUNC$(FUNC$)
 RETURN "@F"+STR$(CMP_SLOT)+FUNC$
END
DEF RGEN_JMP_TABLE TBL
 VAR I,L=LAST(TBL)
 VAR PREFIX1$="@"+STR$(CMP_SLOT)
 VAR PREFIX$=",@"+STR$(CMP_SLOT)
 RGEN_EMIT_SBCODE "@JMP"+STR$(CMP_SLOT)
 RGEN_EMIT_SBCODE CHR$(10)
 RGEN_EMIT_SBCODE "ON RET GOTO"
 FOR I=0TO L
  IF I THEN
   RGEN_EMIT_SBCODE PREFIX$+HEX$(TBL[I])
  ELSE
   RGEN_EMIT_SBCODE PREFIX1$+HEX$(TBL[I])
  ENDIF
 NEXT
 RGEN_EMIT_SBCODE CHR$(10)
END
VAR RGEN_SAVE_REGS_UNIQ
VAR RGEN_FUNC=0
DEF RGEN_GEN_SAVE_REG R$
 RGEN_EMIT_SBCODE\
  "ON TYPEOF("+R$+")GOTO"+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ)+","+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+1)+","+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+2)+","+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+3)+","+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ)+","+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+4)+","+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+5)+","+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+6)+""+\
\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ)+":"+\
  "VM_STK_TYP[VM_SP]=0GOTO@S"+STR$(RGEN_SAVE_REGS_UNIQ+7)+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+1)+":"+\
  "VM_STK_TYP[VM_SP]=1VM_STK%[VM_SP]="+R$+":GOTO@S"+STR$(RGEN_SAVE_REGS_UNIQ+7)+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+2)+":"+\
  "VM_STK_TYP[VM_SP]=2VM_STK#[VM_SP]="+R$+":GOTO@S"+STR$(RGEN_SAVE_REGS_UNIQ+7)+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+3)+":"+\
  "VM_STK_TYP[VM_SP]=3VM_STK$[VM_SP]="+R$+":GOTO@S"+STR$(RGEN_SAVE_REGS_UNIQ+7)+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+4)+":FIXME:"+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+5)+":FIXME:"+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+6)+":FIXME:"+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+7)+":"+\
  "INC VM_SP"+\
  CHR$(10)
 INC RGEN_SAVE_REGS_UNIQ,8
END
DIM RGEN_SAVED_REGS[]
DEF RGEN_GEN_SAVE_ALL_REGS
 VAR I,L=LAST(RGEN_REG_USED)
 IF TYPEOF(RGEN_SAVED_REGS)THEN STOP
 RGEN_SAVED_REGS=ARRAY%(0)
 IF RGEN_FUNC THEN
  IF FUNC_INCNT[RGEN_FUNC]==-1 THEN
   RGEN_EMIT_SBCODE "VM_STK%[VM_SP]=ICNT:INC VM_SP"+CHR$(10)
  ELSE
   FOR I=0TO FUNC_INCNT[RGEN_FUNC]-1
    RGEN_GEN_SAVE_REG RGEN_INARG_STR$(I)
   NEXT
  ENDIF
  IF FUNC_OUTCNT[RGEN_FUNC]==-1 THEN
   RGEN_EMIT_SBCODE "VM_STK%[VM_SP]=OCNT:INC VM_SP"+CHR$(10)
  ELSE
   FOR I=0TO FUNC_OUTCNT[RGEN_FUNC]-1
    RGEN_GEN_SAVE_REG RGEN_OUTARG_STR$(I)
   NEXT
  ENDIF
  RGEN_EMIT_SBCODE "VM_STK%[VM_SP]=RET:INC VM_SP:VM_STK%[VM_SP]=RETS:INC VM_SP"+CHR$(10)
 ENDIF
 FOR I=0TO L
  IF !RGEN_REG_USED[I] THEN CONTINUE
  VAR R$=RGEN_REG_STR$(I)
  RGEN_GEN_SAVE_REG R$
  PUSH RGEN_SAVED_REGS,I
 NEXT
END
DEF RGEN_GEN_LOAD_REG R$
 RGEN_EMIT_SBCODE\
  "DEC VM_SP:ON VM_STK_TYP[VM_SP]GOTO"+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ)+","+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+1)+","+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+2)+","+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+3)+","+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ)+","+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+4)+","+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+5)+","+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+6)+""+\
\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ)+":"+\
  R$+"=EMPTY:GOTO@S"+STR$(RGEN_SAVE_REGS_UNIQ+7)+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+1)+":"+\
  R$+"=VM_STK%[VM_SP]GOTO@S"+STR$(RGEN_SAVE_REGS_UNIQ+7)+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+2)+":"+\
  R$+"=VM_STK#[VM_SP]GOTO@S"+STR$(RGEN_SAVE_REGS_UNIQ+7)+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+3)+":"+\
  R$+"=VM_STK$[VM_SP]GOTO@S"+STR$(RGEN_SAVE_REGS_UNIQ+7)+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+4)+":FIXME:"+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+5)+":FIXME:"+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+6)+":FIXME:"+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+7)+\
  CHR$(10)
 INC RGEN_SAVE_REGS_UNIQ,8
END
DEF RGEN_GEN_LOAD_ALL_REGS
 VAR I,L=LAST(RGEN_SAVED_REGS)
 FOR I=L TO 0 STEP -1
  VAR R$=RGEN_REG_STR$(RGEN_SAVED_REGS[I])
  RGEN_GEN_LOAD_REG R$
 NEXT
 IF RGEN_FUNC THEN
  RGEN_EMIT_SBCODE "DEC VM_SP:RETS=VM_STK%[VM_SP]:DEC VM_SP:RET=VM_STK%[VM_SP]"+CHR$(10)
  IF FUNC_OUTCNT[RGEN_FUNC]==-1 THEN
   RGEN_EMIT_SBCODE "DEC VM_SP:OCNT=VM_STK%[VM_SP]"+CHR$(10)
  ELSE
   FOR I=FUNC_OUTCNT[RGEN_FUNC]-1 TO 0 STEP -1
    RGEN_GEN_LOAD_REG RGEN_OUTARG_STR$(I)
   NEXT
  ENDIF
  IF FUNC_INCNT[RGEN_FUNC]==-1 THEN
   RGEN_EMIT_SBCODE "DEC VM_SP:ICNT=VM_STK%[VM_SP]"+CHR$(10)
  ELSE
   FOR I=FUNC_INCNT[RGEN_FUNC]-1 TO 0 STEP -1
    RGEN_GEN_LOAD_REG RGEN_INARG_STR$(I)
   NEXT
  ENDIF
 ENDIF
 RGEN_SAVED_REGS=EMPTY()
END
DEF RIR_DATA_ESCAPE$ D$ OUT R$
 R$=""
 PUSH R$,CHR$(34)
 VAR I,L=LAST(D$)
 FOR I=0TO L
  VAR C$=D$[I]
  IF ASC(C$)==34 THEN
   PUSH R$,CHR$(34)+"+CHR$(34)+"CHR$(34)
  ELSEIF ASC(C$)==10 THEN
   PUSH R$,CHR$(34)+"+CHR$(10)+"CHR$(34)
  ELSEIF ASC(C$)==13 THEN
   PUSH R$,CHR$(34)+"+CHR$(13)+"CHR$(34)
  ELSE
   PUSH R$,C$
  ENDIF
 NEXT
 PUSH R$,CHR$(34)
END
DEF RIR_GEN_SBCODE
 RGEN_SAVE_REGS_UNIQ=0
 RGEN_REG_TABLE=ARRAY%(RCMP_REG+1)
 FILL RGEN_REG_TABLE,-1
 RGEN_REG_TABLE_TYPE=ARRAY%(RCMP_REG+1)
 RGEN_REG_TABLE_CONST%=ARRAY%(RCMP_REG+1)
 RGEN_REG_TABLE_CONST#=ARRAY#(RCMP_REG+1)
 RGEN_REG_TABLE_CONST$=ARRAY$(RCMP_REG+1)
 RGEN_REG=ARRAY%(0)
 RGEN_REG_TYPE=ARRAY%(0)
 RGEN_REG_NEXT=ARRAY%(0)
 RGEN_REG_USED=ARRAY%(0)
 RGEN_REG_FREE=-1
 RIR_SBCODE$=""
 DIM RGEN_RJMP_TABLE=ARRAY%(0)
 RGEN_EMIT_SBCODE "DIM VM_STK_TYP[]"+CHR$(10)
 RGEN_EMIT_SBCODE "DIM VM_STK%[]"+CHR$(10)
 RGEN_EMIT_SBCODE "DIM VM_STK#[]"+CHR$(10)
 RGEN_EMIT_SBCODE "DIM VM_STK$[]"+CHR$(10)
 RGEN_EMIT_SBCODE "VAR VM_BP"+CHR$(10)
 RGEN_EMIT_SBCODE "VAR VM_SP"+CHR$(10)
 RGEN_EMIT_SBCODE "VAR EMPTY"+CHR$(10)
 RGEN_EMIT_SBCODE "DEF VM_INIT()"+CHR$(10)
 RGEN_EMIT_SBCODE " VM_STK_TYP=ARRAY%(65536)"+CHR$(10)
 RGEN_EMIT_SBCODE " VM_STK%=ARRAY%(65536)"+CHR$(10)
 RGEN_EMIT_SBCODE " VM_STK#=ARRAY#(65536)"+CHR$(10)
 RGEN_EMIT_SBCODE " VM_STK$=ARRAY$(65536)"+CHR$(10)
 RGEN_EMIT_SBCODE " VM_BP=0"+CHR$(10)
 RGEN_EMIT_SBCODE " VM_SP=0"+CHR$(10)
 RGEN_EMIT_SBCODE "END"+CHR$(10)
 RGEN_EMIT_SBCODE "EMPTY=VM_INIT()"+CHR$(10)
 RGEN_EMIT_SBCODE "VM_RUN"+CHR$(10)
 RGEN_EMIT_SBCODE "DEF VM_RUN"+CHR$(10)
 
' RGEN_RJMP_TABLE=ARRAY%(LEN(RIR_OPS))
' RGEN_RJMP_TABLE$=ARRAY$(LEN(RIR_OPS))
' FILL RGEN_RJMP_TABLE,-1
 VAR PC=0,OPC=-1
 VAR I
 VAR J
 VAR NEED_LOAD
 VAR R1,R1$
 VAR R2,R2$
 VAR R3,R3$
 LOOP
  IF I>=LEN(RIR_OPS) THEN
   BREAK
  ENDIF
  IF OPC!=PC THEN
   RGEN_EMIT_SBCODE CHR$(10)+"@0"+HEX$(I)+":"
'   RGEN_EMIT_SBCODE CHR$(10)'+"@0"+HEX$(PC)+":"
'   RGEN_RJMP_TABLE[I]=PC
   OPC=PC
   PUSH RGEN_RJMP_TABLE,I
  ENDIF
  VAR C=RIR_OPS[I]
  INC I
  CASE C
  WHEN #RIR_MOVINT
   RGEN_ALLOC_CONST% RIR_OPS[I],RIR_OPS[I+1]
   INC I,2
  WHEN #RIR_MOVREAL
   RGEN_ALLOC_CONST# RIR_OPS[I],RIR_IMM#[RIR_OPS[I+1]]
'   RGEN_EMIT_SBCODE RGEN_REG_STR$(R)+"="+STR$(RIR_IMM#[RIR_OPS[I+1]])'FIXME!!!!!!!ast
   INC I,2
  WHEN #RIR_MOVSTR
   RGEN_ALLOC_CONST$ RIR_OPS[I],RIR_IMM$[RIR_OPS[I+1]]
'   R=RGEN_ALLOC_REG(RIR_OPS[I])
'   RGEN_EMIT_SBCODE RGEN_REG_STR$(R)+"="+CHR$(34)+RIR_IMM$[RIR_OPS[I+1]]+CHR$(34)
   INC I,2
  WHEN #RIR_NEWARRAY
   VAR ARY_REG=RIR_OPS[I]:INC I
   VAR DM=RIR_OPS[I]:INC I
   VAR TYP=RIR_OPS[I]:INC I
   CASE TYP
   WHEN #T_INTARRAY
    VAR NEWARRAY$="ARRAY%("
   WHEN #T_REALARRAY
    NEWARRAY$="ARRAY#("
   WHEN #T_STRARRAY
    NEWARRAY$="ARRAY$("
   ENDCASE
   FOR J=0TO DM-1
    RGEN_GET_REG RIR_OPS[I] OUT R1,R1$
    PUSH NEWARRAY$,R1$
    IF J==DM-1 THEN
     PUSH NEWARRAY$,")"
    ELSE
     PUSH NEWARRAY$,","
    ENDIF
    RGEN_FREE_REG R1
    INC I
   NEXT
   RGEN_ALLOC_EXPR ARY_REG,NEWARRAY$
  WHEN #RIR_ADD
  WHEN #RIR_ADD
  WHEN #RIR_SUB
  WHEN #RIR_MUL
  WHEN #RIR_DIV
  WHEN #RIR_DIVINT
  WHEN #RIR_MOD
  WHEN #RIR_AND
  WHEN #RIR_OR
  WHEN #RIR_XOR
  WHEN #RIR_EQ
  WHEN #RIR_NEQ
  WHEN #RIR_LSHIFT
  WHEN #RIR_RSHIFT
  WHEN #RIR_GREAT
  WHEN #RIR_LESS
  WHEN #RIR_GEQ
  WHEN #RIR_LEQ
   RGEN_GET_REG RIR_OPS[I+1] OUT R2,R2$
   RGEN_GET_REG RIR_OPS[I+2] OUT R3,R3$
   RGEN_ALLOC_EXPR RIR_OPS[I],"("+R2$+RIR_GET_OP$(C)+R3$+")"
   RGEN_FREE_REG R2
   RGEN_FREE_REG R3
   INC I,3
  WHEN #RIR_GETGLOBAL
   RGEN_ALLOC_EXPR RIR_OPS[I],RGEN_GLOBAL_STR$(RIR_OPS[I+1])
   INC I,2
  WHEN #RIR_GETLOCAL
   RGEN_ALLOC_EXPR RIR_OPS[I],RGEN_LOCAL_STR$(RIR_OPS[I+1])
   INC I,2
  WHEN #RIR_GETINARG
   R1=RGEN_ALLOC_REG(RIR_OPS[I])
   RGEN_EMIT_SBCODE RGEN_REG_STR$(R1)+"="+RGEN_INARG_STR$(RIR_OPS[I+1])
   INC I,2
   INC PC
  WHEN #RIR_GETOUTARG
   R1=RGEN_ALLOC_REG(RIR_OPS[I])
   RGEN_EMIT_SBCODE RGEN_REG_STR$(R1)+"="+RGEN_OUTARG_STR$(RIR_OPS[I+1])
   INC I,2
   INC PC
  WHEN #RIR_SETGLOBAL
   RGEN_GET_REG RIR_OPS[I+1] OUT R1,R1$
   RGEN_EMIT_SBCODE RGEN_GLOBAL_STR$(RIR_OPS[I])+"="+R1$
   RGEN_FREE_REG R1
   INC I,2
   INC PC
  WHEN #RIR_SETLOCAL
   RGEN_GET_REG RIR_OPS[I+1] OUT R1,R1$
   RGEN_EMIT_SBCODE RGEN_LOCAL_STR$(RIR_OPS[I])+"="+R1$
   RGEN_FREE_REG R1
   INC I,2
   INC PC
  WHEN #RIR_SETINARG
   RGEN_GET_REG RIR_OPS[I+1] OUT R1,R1$
   RGEN_EMIT_SBCODE RGEN_INARG_STR$(RIR_OPS[I])+"="+R1$
   RGEN_FREE_REG R1
   INC I,2
   INC PC
  WHEN #RIR_SETOUTARG
   RGEN_GET_REG RIR_OPS[I+1] OUT R1,R1$
   RGEN_EMIT_SBCODE RGEN_OUTARG_STR$(RIR_OPS[I])+"="+R1$
   RGEN_FREE_REG R1
   INC I,2
   INC PC
  WHEN #RIR_PRINT
   VAR CNT=RIR_OPS[I]*2+I-1
   RGEN_EMIT_SBCODE "?"
   FOR I=I+1 TO CNT STEP 2
    RGEN_GET_REG RIR_OPS[I+1] OUT R1,R1$
    RGEN_EMIT_SBCODE R1$
    IF RIR_OPS[I]==0 THEN
     RGEN_EMIT_SBCODE ","
    ELSEIF RIR_OPS[I]==1 THEN
    ELSEIF RIR_OPS[I]==2 THEN
     RGEN_EMIT_SBCODE ";"
    ENDIF
   NEXT
   INC PC
  WHEN #RIR_BRFALSE
   RGEN_GET_REG RIR_OPS[I] OUT R1,R1$
   RGEN_EMIT_SBCODE "IF "+R1$+" THEN ELSE"+RGEN_LABEL$(I,RIR_OPS[I+1])
   INC I,2
   INC PC
  WHEN #RIR_BRTRUE
   RGEN_GET_REG RIR_OPS[I] OUT R1,R1$
   RGEN_EMIT_SBCODE "IF "+R1$+" GOTO"+RGEN_LABEL$(I,RIR_OPS[I+1])
   INC I,2
   INC PC
  WHEN #RIR_BR
   RGEN_EMIT_SBCODE "GOTO"+RGEN_LABEL$(I,RIR_OPS[I])
   INC I
   INC PC
  WHEN #RIR_CALL
   'FIXME:へんすうをいっかいれじすたにかく
   '?GLIL*A()
   'は
   'R0=O0
   '?(G00*R0)ではなく
   'R0=G00
   '...
   'R1=O0
   '?(R0*R1)がただしい(ごかんせいてきには)
   VAR FUNC$=RIR_IMM$[RIR_OPS[I]]
   VAR INCNT=RIR_OPS[I+1]
   VAR OUTCNT=RIR_OPS[I+2]
   IF CHKCALL("3:"+FUNC$)||CHKCALL("SBSB_"+FUNC$)THEN
    RGEN_EMIT_SBCODE FUNC$
    FOR J=INCNT-1 TO 0 STEP -1
     RGEN_GET_REG RIR_OPS[I+3+J] OUT R1,R1$
     RGEN_FREE_REG R1
     IF J!=INCNT-1 THEN
      RGEN_EMIT_SBCODE ","
     ELSE
      RGEN_EMIT_SBCODE " "
     ENDIF
     RGEN_EMIT_SBCODE R1$
    NEXT
    FOR J=OUTCNT-1TO 0 STEP -1
     IF J==OUTCNT-1 THEN
      RGEN_EMIT_SBCODE " OUT "
     ELSE
      RGEN_EMIT_SBCODE ","
     ENDIF
     R1=RGEN_ALLOC_REG(RIR_OPS[I+3+J+INCNT])
     RGEN_EMIT_SBCODE RGEN_REG_STR$(R1)
    NEXT
    INC I,3+INCNT+OUTCNT
    INC PC
    CONTINUE
   ENDIF
   FOR J=0TO INCNT-1
    RGEN_GET_REG RIR_OPS[I+3+J] OUT R1,R1$
    RGEN_FREE_REG R1
    RGEN_EMIT_SBCODE RGEN_INARG_STR$(J)+"="+R1$+":"
   NEXT
   RGEN_GEN_SAVE_ALL_REGS
   FOR J=0TO OUTCNT-1
    RGEN_EMIT_SBCODE RGEN_OUTARG_STR$(J)+"=EMPTY:"
   NEXT
   RGEN_EMIT_SBCODE "ICNT="+STR$(INCNT)+":"
   RGEN_EMIT_SBCODE "OCNT="+STR$(OUTCNT)+":"
   RGEN_EMIT_SBCODE "RETS="+STR$(CMP_SLOT)+":"
   RGEN_EMIT_SBCODE "RET="+STR$(PC+1)+":"
   RGEN_EMIT_SBCODE "GOTO"+RGEN_FUNC$(FUNC$)
   VAR K=I
   INC I,3+INCNT+OUTCNT
   INC PC
   RGEN_EMIT_SBCODE CHR$(10)+"@0"+HEX$(I)+":"
   FOR J=0TO OUTCNT-1
    R1=RGEN_ALLOC_REG(RIR_OPS[K+3+J+INCNT])
    RGEN_EMIT_SBCODE RGEN_REG_STR$(R1)+"="+RGEN_OUTARG_STR$(J)+":"
   NEXT
   RGEN_GEN_LOAD_ALL_REGS
   OPC=PC
   PUSH RGEN_RJMP_TABLE,I
  WHEN #RIR_DEFFUN
   VAR FUNC=RIR_OPS[I]
   INC I,1
    IF FUNC THEN
    VAR MAX_SLOT=3
    IF FUNC_COMMON[FUNC]THEN
     FOR J=0TO MAX_SLOT
      RGEN_EMIT_SBCODE "@F"+STR$(J)+FUNC_NAME$[FUNC]+":"
     NEXT
    ELSE
     RGEN_EMIT_SBCODE RGEN_FUNC$(FUNC_NAME$[FUNC])+":"
    ENDIF
   ENDIF
   RGEN_FUNC=FUNC
  WHEN #RIR_LEAVE
   RGEN_EMIT_SBCODE "ON RETS GOTO@JMP0,@JMP1,@JMP2,@JMP3
   INC PC
  WHEN #RIR_END
   RGEN_EMIT_SBCODE "GOTO@END"
  WHEN #RIR_FORGLOBAL
   VAR IDX=RIR_OPS[I]:INC I
   VAR TO_REG=RIR_OPS[I]:INC I
   VAR STEP_REG=RIR_OPS[I]:INC I
   VAR INIT=RIR_OPS[I]:INC I
   VAR BRKADDR=RIR_OPS[I]:INC I
   RGEN_GET_REG STEP_REG OUT R1,R1$
   RGEN_GET_REG TO_REG OUT R2,R2$
   IF !INIT THEN
    RGEN_EMIT_SBCODE "INC "+RGEN_GLOBAL_STR$(IDX)+","+R1$+CHR$(10)
    RGEN_EMIT_SBCODE "IF "+R1$+">0 THEN"+CHR$(10)
    RGEN_EMIT_SBCODE "IF "+RGEN_GLOBAL_STR$(IDX)+"<="+R2$+"THEN "+RGEN_LABEL$(PC,BRKADDR)+CHR$(10)
    RGEN_EMIT_SBCODE "ELSEIF "+R1$+"<0 THEN"+CHR$(10)
    RGEN_EMIT_SBCODE "IF "+RGEN_GLOBAL_STR$(IDX)+">="+R2$+"THEN "+RGEN_LABEL$(PC,BRKADDR)+CHR$(10)
    RGEN_EMIT_SBCODE "ELSE"+RGEN_LABEL$(PC,BRKADDR)+CHR$(10)
    RGEN_EMIT_SBCODE "ENDIF"+CHR$(10)
   ELSE
    RGEN_EMIT_SBCODE "IF "+R1$+">0 THEN"+CHR$(10)
    RGEN_EMIT_SBCODE "IF "+RGEN_GLOBAL_STR$(IDX)+">"+R2$+"THEN "+RGEN_LABEL$(PC,BRKADDR)+CHR$(10)
    RGEN_EMIT_SBCODE "ELSEIF "+R1$+"<0 THEN"+CHR$(10)
    RGEN_EMIT_SBCODE "IF "+RGEN_GLOBAL_STR$(IDX)+"<"+R2$+"THEN "+RGEN_LABEL$(PC,BRKADDR)+CHR$(10)
    RGEN_EMIT_SBCODE "ELSE"+RGEN_LABEL$(PC,BRKADDR)+CHR$(10)
    RGEN_EMIT_SBCODE "ENDIF"+CHR$(10)
   ENDIF
   RGEN_FREE_REG R1
   RGEN_FREE_REG R2
   INC PC
  WHEN #RIR_FORLOCAL
   STOP
  WHEN #RIR_FORINARG
   STOP
  WHEN #RIR_FOROUTARG
   STOP
  WHEN #RIR_SETARRAY
   RIR_GEN_ARRAY I OUT I
   RGEN_GET_REG RIR_OPS[I] OUT R1,R1$:INC I
   RGEN_EMIT_SBCODE "="+R1$
   RGEN_FREE_REG R1
   INC PC
  WHEN #RIR_GETARRAY
   VAR EXPR$=""
   R1=RIR_OPS[I]:INC I
   RGEN_GET_REG RIR_OPS[I] OUT R2,R2$:INC I
   RGEN_FREE_REG R2
   DM=RIR_OPS[I]:INC I
   PUSH EXPR$,R2$+"["
   FOR J=0TO DM-1
    RGEN_GET_REG RIR_OPS[I] OUT R3,R3$:INC I
    IF J THEN PUSH EXPR$,","
    PUSH EXPR$,R3$
    RGEN_FREE_REG R3
   NEXT
   PUSH EXPR$,"]"
   RGEN_ALLOC_EXPR R1,EXPR$
  WHEN #RIR_DATAINT
   RGEN_EMIT_SBCODE "DATA "+STR$(RIR_OPS[I])+":"
   INC I
  WHEN #RIR_DATASTR
   RGEN_EMIT_SBCODE "DATA "+RIR_DATA_ESCAPE$(RIR_IMM$[RIR_OPS[I]])+":"
   INC I
  WHEN #RIR_DATAREAL
   RGEN_EMIT_SBCODE "DATA "+MID$(FORMAT$("%.97F",RIR_IMM#[RIR_OPS[I]]),0,97)+":"
   INC I
  WHEN #RIR_READ
   R1=RGEN_ALLOC_REG(RIR_OPS[I])
   RGEN_EMIT_SBCODE "READ "+RGEN_REG_STR$(R1)
   INC I
   INC PC
  WHEN #RIR_LABEL
   VAR LABEL$=RIR_IMM$[RIR_OPS[I]]:INC I
   IF RGEN_FUNC THEN
    RGEN_EMIT_SBCODE "@K"+STR$(CMP_SLOT)+STR$(RGEN_FUNC)+"_"+MID$(LABEL$,1,&H7FFFFFFF)
   ELSE
    RGEN_EMIT_SBCODE "@L"+STR$(CMP_SLOT)+MID$(LABEL$,1,&H7FFFFFFF)
   ENDIF
   INC PC
  WHEN #RIR_RESTORE
   LABEL$=RIR_IMM$[RIR_OPS[I]]:INC I
   IF RGEN_FUNC THEN
    RGEN_EMIT_SBCODE "RESTORE@K"+STR$(CMP_SLOT)+STR$(RGEN_FUNC)+"_"+MID$(LABEL$,1,&H7FFFFFFF)
   ELSE
    RGEN_EMIT_SBCODE "RESTORE@L"+STR$(CMP_SLOT)+MID$(LABEL$,1,&H7FFFFFFF)
   ENDIF
   INC PC
  WHEN #RIR_GOTO
   LABEL$=RIR_IMM$[RIR_OPS[I]]:INC I
   IF RGEN_FUNC THEN
    RGEN_EMIT_SBCODE "GOTO@K"+STR$(CMP_SLOT)+STR$(RGEN_FUNC)+"_"+MID$(LABEL$,1,&H7FFFFFFF)
   ELSE
    RGEN_EMIT_SBCODE "GOTO@L"+STR$(CMP_SLOT)+MID$(LABEL$,1,&H7FFFFFFF)
   ENDIF
   INC PC
  WHEN #RIR_RESTOREEXPR
   RGEN_GET_REG RIR_OPS[I] OUT R1,R1$:INC I
   RGEN_FREE_REG R1
   RGEN_EMIT_SBCODE "LBL$=RVM_RESTORE("+R1$+"):RESTORE LBL$"
   INC PC
  WHEN #RIR_INCGLOBAL
  WHEN #RIR_INCARRAY
   VAR DECREMENT=RIR_OPS[I]:INC I
   VAR DIFF_REG=RIR_OPS[I]:INC I
   RGEN_GET_REG DIFF_REG OUT R1,R1$
   IF DECREMENT THEN
    RGEN_EMIT_SBCODE "DEC "
   ELSE
    RGEN_EMIT_SBCODE "INC "
   ENDIF
   IF C==#RIR_INCGLOBAL THEN
    RIR_GEN_GLOBAL I OUT I
   ELSEIF C==#RIR_INCARRAY THEN
    RIR_GEN_ARRAY I OUT I
   ENDIF
   RGEN_EMIT_SBCODE ","+R1$
   RGEN_FREE_REG R1
   INC PC
  WHEN #RIR_GOSUB
  OTHERWISE
   STOP
  ENDCASE
 ENDLOOP
 RGEN_EMIT_SBCODE CHR$(10)
 RGEN_JMP_TABLE RGEN_RJMP_TABLE
 RGEN_EMIT_SBCODE "@END:END"+CHR$(10)
 PRGEDIT 3
 PRGDEL -1
 PRGSET RIR_SBCODE$
END
DEF RIR_GEN_GLOBAL I OUT I2
 VAR IDX=RIR_OPS[I]:INC I
 RGEN_EMIT_SBCODE RGEN_GLOBAL_STR$(IDX)
 I2=I
END
DEF RIR_GEN_LOCAL I OUT I2
 VAR IDX=RIR_OPS[I]:INC I
 RGEN_EMIT_SBCODE RGEN_LOCAL_STR$(IDX)
 I2=I
END
DEF RIR_GEN_INARG I OUT I2
 VAR IDX=RIR_OPS[I]:INC I
 RGEN_EMIT_SBCODE RGEN_INARG_STR$(IDX)
 I2=I
END
DEF RIR_GEN_ARRAY I OUT I2
 VAR ARY_R,ARY_R$
 VAR IND_R,IND_R$
 RGEN_GET_REG RIR_OPS[I] OUT ARY_R,ARY_R$:INC I
 VAR DM=RIR_OPS[I]:INC I
 RGEN_EMIT_SBCODE ARY_R$+"["
 VAR J
 FOR J=0TO DM-1
  RGEN_GET_REG RIR_OPS[I] OUT IND_R,IND_R$:INC I
  IF J THEN
   RGEN_EMIT_SBCODE ","+IND_R$
  ELSE
   RGEN_EMIT_SBCODE IND_R$
  ENDIF
 NEXT
 RGEN_EMIT_SBCODE "]
 RGEN_FREE_REG ARY_R
 RGEN_FREE_REG IND_R
 I2=I
END
DEF RIR_GET_OP$(OP)
 CASE OP
 WHEN #RIR_ADD
  RETURN "+"
 WHEN #RIR_SUB
  RETURN "-"
 WHEN #RIR_MUL
  RETURN "*"
 WHEN #RIR_DIV
  RETURN "/"
 WHEN #RIR_DIVINT
  RETURN " DIV "
 WHEN #RIR_MOD
  RETURN " MOD "
 WHEN #RIR_AND
  RETURN " AND "
 WHEN #RIR_OR
  RETURN " OR "
 WHEN #RIR_XOR
  RETURN " XOR "
 WHEN #RIR_EQ
  RETURN "=="
 WHEN #RIR_NEQ
  RETURN "!="
 WHEN #RIR_LSHIFT
  RETURN "<<"
 WHEN #RIR_RSHIFT
  RETURN ">>"
 WHEN #RIR_GREAT
  RETURN "<"
 WHEN #RIR_LESS
  RETURN ">"
 WHEN #RIR_GEQ
  RETURN "<="
 WHEN #RIR_LEQ
  RETURN ">="
 ENDCASE
END
VAR RCMP_SLOT
VAR RCMP_STRICT
VAR RCMP_DEFINT
DEF INIT_RCOMPILER SLOT
 RCMP_SLOT=SLOT
 RCMP_STRICT=#FALSE
 RCMP_DEFINT=#FALSE
 RCMP_REG=0
 INIT_COMPILER SLOT
 INIT_RIR_CODEGEN
END
DEF RCOMPILE AST
 RCOMPILE_STATEMENTS AST
 REMIT #RIR_END
 RIR_GEN_SBCODE
' RIR_DUMP
END
DEF RCOMPILE_STATEMENTS A
 VAR I
 CASE AST_TYP[A]
 WHEN #AST_STATEMENTS
  I=AST_NEXT[AST_LEFT[A]]
  WHILE I
   IF!I THEN BREAK
   RCOMPILE_STATEMENT AST_LEFT[I]
   I=AST_NEXT[I]
  WEND
 OTHERWISE
  RCOMPILE_ERROR
 ENDCASE
END
DEF RCOMPILE_STATEMENT A
 IF AST_TYP[A]!=#AST_DEF THEN
'  VMDBG_ADD_SRC_INFO AST_LINE[A],AST_POS[A],AST_LINE_END[A],AST_POS_END[A]
 ENDIF
 CASE AST_TYP[A]
 WHEN #AST_PRINT
  RCOMPILE_PRINT A
 WHEN #AST_ASSIGN
  RCOMPILE_ASSIGN A
 WHEN #AST_IF
  RCOMPILE_IF A
 WHEN #AST_FOR
  RCOMPILE_FOR A
 WHEN #AST_BREAK
  RCOMPILE_BREAK
 WHEN #AST_CONTINUE
  RCOMPILE_CONTINUE
 WHEN #AST_WHILE
  RCOMPILE_WHILE A
 WHEN #AST_REPEAT
  RCOMPILE_REPEAT A
 WHEN #AST_LOOP
  RCOMPILE_LOOP A
 WHEN #AST_LABEL
  RCOMPILE_LABEL A
 WHEN #AST_GOTO
  RCOMPILE_GOTO A
 WHEN #AST_GOSUB
  RCOMPILE_GOSUB A
 WHEN #AST_GOTOEXPR
  RCOMPILE_GOTOEXPR A
 WHEN #AST_GOSUBEXPR
  RCOMPILE_GOSUBEXPR A
 WHEN #AST_ONGOTO
 WHEN #AST_ONGOSUB
  RCOMPILE_ONGOTO A
 WHEN #AST_ONBREAKGOTO
  RCOMPILE_ONBREAKGOTO A
 WHEN #AST_ONBREAKGOTOEXPR
  RCOMPILE_ONBREAKGOTOEXPR A
 WHEN #AST_RETURN
  RCOMPILE_RETURN A
 WHEN #AST_CALLFUNC
  VAR VOID
  RCOMPILE_CALLFUNC A OUT VOID
 WHEN #AST_DEF
  RCOMPILE_DEF A
 WHEN #AST_RETURNFUNC
  RCOMPILE_RETURNFUNC A
 WHEN #AST_DEFVAR
  RCOMPILE_DEFVAR A
 WHEN #AST_END
  RCOMPILE_END A
 WHEN #AST_OPTIONSTRICT
  RCMP_STRICT=#TRUE
 WHEN #AST_OPTIONDEFINT
  RCMP_DEFINT=#TRUE
 WHEN #AST_DATA
  RCOMPILE_DATA A
 WHEN #AST_CONST
  COMPILE_CONST A
 WHEN #AST_ENUM
  COMPILE_ENUM A
 WHEN #AST_READ
  RCOMPILE_READ A
 WHEN #AST_RESTORE
  RCOMPILE_RESTORE A
 WHEN #AST_RESTOREEXPR
  RCOMPILE_RESTOREEXPR A
 WHEN #AST_CALLSPRITE
  REMIT_CALLSPRITE
 WHEN #AST_CALLTEXT
  REMIT_CALLTEXT
 WHEN #AST_TPRINT
  RCOMPILE_TPRINT A
 WHEN #AST_INC
 WHEN #AST_DEC
  RCOMPILE_INC A
 WHEN #AST_CASE
  RCOMPILE_CASE A
 WHEN #AST_SWAP
  RCOMPILE_SWAP A
 WHEN #AST_INPUT
  RCOMPILE_INPUT A
 WHEN #AST_LINPUT
  RCOMPILE_LINPUT A
 WHEN #AST_DEFOUT
  RCOMPILE_DEFOUT A
 WHEN #AST_EXEC
  RCOMPILE_EXEC A
 WHEN #AST_STOP
  RCOMPILE_STOP A
 OTHERWISE
  ?AST_STR$(AST_TYP[A])
  RCOMPILE_ERROR
 ENDCASE
END

DEF RCOMPILE_RESTORE A
 IF LEN(AST$[A])THEN
  REMIT #RIR_RESTORE
  REMIT_IMM$ AST$[A]
 ELSE
  'CURRENT SLOT??FIXME
  TYPE_MISMATCH
 ENDIF
END
DEF RCOMPILE_RESTOREEXPR A
 VAR REG=RCOMPILE_EXPR(AST_LEFT[A])
 REMIT #RIR_RESTOREEXPR
 REMIT REG
END
DEF RCOMPILE_LABEL A
 DEFINE_LABEL AST$[A]
 REMIT #RIR_LABEL
 REMIT_IMM$ AST$[A]
END

DEF RCOMPILE_GOTO A
 REMIT #RIR_GOTO
 REMIT_IMM$ AST$[A]
END
DEF RCOMPILE_GOSUB A
 REMIT #RIR_GOSUB
 REMIT_IMM$ AST$[A]
END

DEF RCOMPILE_READ A
 VAR I=AST_NEXT[AST_A1[A]]
 WHILE I
  VAR REG=RCOMPILE_ADDREG()
  REMIT #RIR_READ
  REMIT REG
  RCOMPILE_ASSIGN_REG AST_A1[I],REG
  ' BAD:READ->EVAL REFEXPR->ASSIGN
  'GOOD:EVAL REFEXPR->READ->ASSIGN
  I=AST_NEXT[I]
 WEND
END
DEF RCOMPILE_DATA A
 VAR I=AST_NEXT[AST_A1[A]]
 WHILE I
  VAR EXPR=FOLD_CONSTEXPR(AST_A1[I])
  CASE AST_TYP[EXPR]
  WHEN #AST_IMM_INT
   REMIT #RIR_DATAINT
   REMIT AST%[EXPR]
  WHEN #AST_IMM_DBL
   REMIT #RIR_DATAREAL
   REMIT_IMM# AST#[EXPR]
  WHEN #AST_IMM_STR
   REMIT #RIR_DATASTR
   REMIT_IMM$ AST$[EXPR]
  OTHERWISE
   SYNTAX_ERROR "DATA"
  ENDCASE
  I=AST_NEXT[I]
 WEND
END
DEF RCOMPILE_ARRAY_INDEX_EXPR A OUT REGS
 VAR I=AST_PREV[A]
 REGS=ARRAY%(0)
 WHILE I!=A
  UNSHIFT REGS,RCOMPILE_EXPR(AST_A1[I])
  I=AST_PREV[I]
 WEND
END

DEF RCOMPILE_INITARRAY LOCAL,IDX,A
 VAR I=AST_PREV[A]
 VAR IND=AST_GET_ITEM_COUNT(A)
 WHILE I!=A
  DEC IND
  IF LOCAL THEN
   REMIT #RIR_GETLOCAL
  ELSE
   REMIT #RIR_GETGLOBAL
  ENDIF
  VAR ARY_REG=RCOMPILE_ADDREG()
  REMIT ARY_REG
  REMIT IDX
  VAR IND_REG=RCOMPILE_ADDREG()
  REMIT #RIR_MOVINT
  REMIT IND_REG
  REMIT IND
  VAR REG=RCOMPILE_EXPR(AST_A1[I])
  REMIT #RIR_SETARRAY
  REMIT ARY_REG
  REMIT 1
  REMIT IND_REG
  REMIT REG
  I=AST_PREV[I]
 WEND
END
DEF RCOMPILE_DEFVAR A
 'A1:LIST
  '$:NAME
  'A1:INIT EXPR
  'A2:ARRAY DIM
  'A3:ARRAY INIT LIST 
 'LEFT TO RIGHT
 VAR I=AST_NEXT[AST_A1[A]]
 WHILE I
  VAR NAME$=AST$[I]
  VAR IDX,LOCAL,ARY
  IF AST_A2[I] THEN
   ARY=#TRUE
  ENDIF
  DEFINE_VAR NAME$,ARY OUT IDX,LOCAL
  IF AST_A1[I] THEN
   VAR REG=RCOMPILE_EXPR(AST_A1[I])
   'FIXME:EXTRACT FUNCTION
   IF LOCAL THEN
    REMIT #RIR_SETLOCAL
   ELSE
    REMIT #RIR_SETGLOBAL
   ENDIF
   REMIT IDX
   REMIT REG
  ELSEIF ARY THEN
   'RIGHT TO LEFT
   VAR DM=RCOMPILE_ARRAY_INDEX_EXPR(AST_A2[I])
   IF LEN(DM)==0THEN
    REG=RCOMPILE_ADDREG()
    REMIT #RIR_MOVINT
    REMIT REG
    REMIT AST_GET_ITEM_COUNT(AST_A3[I])
    PUSH DM,REG
   ENDIF
   VAR ARY_REG=RCOMPILE_ADDREG()
   REMIT #RIR_NEWARRAY
   REMIT ARY_REG
   REMIT LEN(DM)
   REMIT DETER_VAR_TYPE(NAME$,#TRUE)
   VAR J
   FOR J=0TO LAST(DM)
    REMIT DM[J]
   NEXT
   IF LOCAL THEN
    REMIT #RIR_SETLOCAL
   ELSE
    REMIT #RIR_SETGLOBAL
   ENDIF
   REMIT IDX
   REMIT ARY_REG
   IF AST_A3[I]THEN
    'RIGHT TO LEFT
    RCOMPILE_INITARRAY LOCAL,IDX,AST_A3[I]
   ENDIF
  ENDIF
  I=AST_NEXT[I]
 WEND
END
DEF RCOMPILE_ASSIGN A
 VAR L=AST_LEFT[A]
 CASE AST_TYP[L]
 WHEN #AST_VAR
 WHEN #AST_BINOP
  VAR REG=RCOMPILE_EXPR(AST_RIGHT[A])
  RCOMPILE_ASSIGN_REG L,REG
 WHEN #AST_VAREXPR
  STOP
 OTHERWISE
  STOP
 ENDCASE
END
DEF RCOMPILE_ASSIGN_REG A,REG
 VAR L=A
 CASE AST_TYP[L]
 WHEN #AST_VAR
  VAR IDX,LC
  GET_VAR_INDEX AST$[L] OUT IDX,LC
  IF LC THEN
   IF IDX<0 THEN
    IF IDX>=-FUNC_INCNT[CMP_CURFUNC] THEN'FIXME VAARGS
     REMIT #RIR_SETINARG
     IDX=-IDX-1
    ELSE
     REMIT #RIR_SETOUTARG
     IDX=-IDX-FUNC_INCNT[CMP_CURFUNC]-1
    ENDIF
   ELSE
    REMIT #RIR_SETLOCAL
   ENDIF
  ELSE
   REMIT #RIR_SETGLOBAL
  ENDIF
  REMIT IDX
  REMIT REG
 WHEN #AST_BINOP
  VAR TYP=AST%[A]
  IF TYP!=#TKN_LB THEN
   SYNTAX_ERROR "EXPECTED '['"
   RETURN
  ENDIF
  VAR DM=RCOMPILE_ARRAY_INDEX_EXPR(AST_RIGHT[A])
  VAR ARY_REG=RCOMPILE_EXPR(AST_LEFT[A])
  REMIT #RIR_SETARRAY
  REMIT ARY_REG
  REMIT LEN(DM)
  VAR I
  FOR I=0TO LAST(DM)
   REMIT DM[I]
  NEXT
  REMIT REG
 WHEN #AST_VAREXPR
  STOP
 OTHERWISE
  STOP
 ENDCASE
END
DEF RCOMPILE_CALLFUNCEXPR A OUT REG
 RCOMPILE_CALLFUNC A OUT REG
END
DEF RCOMPILE_CALLFUNC A OUT OUT0_REG
 'A1:IN ARGS
 'A2:OUT ARGS
 'FIXME:SAVE REGS
 VAR FN$=AST$[A]
 VAR INCNT=0
 VAR I
 VAR OUTCNT
 IF AST_TYP[A]==#AST_CALLFUNC THEN
  OUTCNT=AST_GET_ITEM_COUNT(AST_A2[A])
 ELSE
  OUTCNT=1
 ENDIF
 I=AST_PREV[AST_A1[A]]
 DIM REGS%[0]
 WHILE I!=AST_A1[A]
  VAR REG=RCOMPILE_EXPR(AST_A1[I])
  PUSH REGS%,REG
  I=AST_PREV[I]
  INC INCNT
 WEND
 REMIT #RIR_CALL
 REMIT_IMM$ FN$
 REMIT INCNT
 REMIT OUTCNT
 FOR I=0TO LAST(REGS%)
  REMIT REGS%[I]
 NEXT
 DIM OUTREGS%[OUTCNT]
 FOR I=0TO OUTCNT-1
  OUTREGS%[I]=RCOMPILE_ADDREG()
  IF I==0 THEN OUT0_REG=OUTREGS%[I]
  REMIT OUTREGS%[I]
 NEXT

 IF AST_TYP[A]==#AST_CALLFUNC THEN
  I=AST_PREV[AST_A2[A]]
  VAR J
  WHILE I!=AST_A2[A]
   RCOMPILE_ASSIGN_REG AST_A1[I],OUTREGS%[J]
   INC J
   I=AST_PREV[I]
  WEND
 ENDIF
END
DEF RCOMPILE_IF A
 VAR COND_REG=RCOMPILE_EXPR(AST_A1[A])
 'チュウかんヒョウげん(キモちワルい)
 'IF COND THEN   #RIR_IF COND_REG
 '   
 'ELSE           #RIR_ELSE
 ' IF COND2 THEN #RIR_IF COND2_REG
 '  
 ' ENDIF         #RIR_ENDIF
 'ENDIF          #RIR_ENDIF
 'IF COND THEN 
 REMIT #RIR_BRFALSE
 REMIT COND_REG
 REMIT &H7FFFFFFF
 VAR ADDR_ELSE=RIR_GET_ADDR()
 RCOMPILE_STATEMENTS AST_A2[A]
 IF AST_A4[A]||AST_A3[A]THEN
  REMIT #RIR_BR
  REMIT &H7FFFFFFF
  VAR ADDR_ENDIF=RIR_GET_ADDR()
 ENDIF
 RIR_SET ADDR_ELSE,RIR_NEXT_ADDR()
 IF AST_A3[A]THEN'ELSEIF
  DIM BRLIST=ARRAY%(0)
  VAR I=AST_NEXT[AST_A3[A]]
  WHILE I
   VAR COND_ELSEIF=RCOMPILE_EXPR(AST_A1[I])
   REMIT #RIR_BRFALSE
   REMIT COND_ELSEIF
   REMIT &H7FFFFFFF
   VAR ADDR_AFTER_ELSEIF=RIR_GET_ADDR()
   RCOMPILE_STATEMENTS AST_A2[I]
   I=AST_NEXT[I]
   REMIT #RIR_BR
   REMIT &H7FFFFFFF
   PUSH BRLIST,RIR_GET_ADDR()
   RIR_SET ADDR_AFTER_ELSEIF,RIR_NEXT_ADDR()
  WEND
 ENDIF
 IF AST_A4[A]THEN'ELSE
  RCOMPILE_STATEMENTS AST_A4[A]
 ENDIF
 IF AST_A4[A]||AST_A3[A]THEN
  RIR_SET ADDR_ENDIF,RIR_NEXT_ADDR()
 ENDIF
 IF AST_A3[A]THEN'ELSEIF
  FOR I=0TO LAST(BRLIST)
   RIR_SET BRLIST[I],RIR_NEXT_ADDR()
  NEXT
 ENDIF
END
DEF RCOMPILE_ADDREG()
 INC RCMP_REG
 RETURN RCMP_REG
END
DEF RCOMPILE_EXPR A OUT REG
 CASE AST_TYP[A]
 WHEN #AST_BINOP
  VAR TYP=AST%[A]
  IF TYP==#TKN_LAND THEN
  ELSEIF TYP==#TKN_LOR THEN
  ELSEIF TYP==#TKN_LB THEN
   VAR IND_REGS=RCOMPILE_ARRAY_INDEX_EXPR(AST_RIGHT[A])
   VAR ARY_REG=RCOMPILE_EXPR(AST_LEFT[A])
   REMIT #RIR_GETARRAY
   REG=RCOMPILE_ADDREG()
   REMIT REG
   VAR I
   REMIT ARY_REG
   REMIT LEN(IND_REGS)
   FOR I=0TO LAST(IND_REGS)
    REMIT IND_REGS[I]
   NEXT
  ELSE
   VAR RIGHT_R=RCOMPILE_EXPR(AST_RIGHT[A])
   VAR LEFT_R=RCOMPILE_EXPR(AST_LEFT[A])
   VAR OP
   CASE TYP
   WHEN #TKN_PLUS
    OP=#RIR_ADD
   WHEN #TKN_MINUS
    OP=#RIR_SUB
   WHEN #TKN_MUL
    OP=#RIR_MUL
   WHEN #TKN_DIV
    OP=#RIR_DIV
   WHEN #TKN_DIVINT
    OP=#RIR_DIVINT
   WHEN #TKN_MOD
    OP=#RIR_MOD
   WHEN #TKN_AND
    OP=#RIR_AND
   WHEN #TKN_OR
    OP=#RIR_OR
   WHEN #TKN_XOR
    OP=#RIR_XOR
   WHEN #TKN_EQ
    OP=#RIR_EQ
   WHEN #TKN_NEQ
    OP=#RIR_NEQ
   WHEN #TKN_LSHIFT
    OP=#RIR_LSHIFT
   WHEN #TKN_RSHIFT
    OP=#RIR_RSHIFT
   WHEN #TKN_GREAT
    OP=#RIR_GREAT
   WHEN #TKN_LESS
    OP=#RIR_LESS
   WHEN #TKN_GEQ
    OP=#RIR_GEQ
   WHEN #TKN_LEQ
    OP=#RIR_LEQ
   OTHERWISE
    STOP
   ENDCASE
    REMIT OP
    REG=RCOMPILE_ADDREG()
    REMIT REG
    REMIT LEFT_R
    REMIT RIGHT_R
  ENDIF
 WHEN #AST_IMM_INT
  REMIT #RIR_MOVINT
  REG=RCOMPILE_ADDREG()
  REMIT REG
  REMIT AST%[A]
 WHEN #AST_IMM_DBL
  REMIT #RIR_MOVREAL
  REG=RCOMPILE_ADDREG()
  REMIT REG
  REMIT_IMM# AST#[A]
 WHEN #AST_IMM_STR
  REMIT #RIR_MOVSTR
  REG=RCOMPILE_ADDREG()
  REMIT REG
  REMIT_IMM$ AST$[A]
 WHEN #AST_VAR
  VAR IDX,LC
  GET_VAR_INDEX AST$[A] OUT IDX,LC
  IF LC THEN
   IF IDX<0 THEN
    IF IDX>=-FUNC_INCNT[CMP_CURFUNC] THEN'FIXME VAARGS
     REMIT #RIR_GETINARG
     IDX=-IDX-1
    ELSE
     REMIT #RIR_GETOUTARG
     IDX=-IDX-FUNC_INCNT[CMP_CURFUNC]-1
    ENDIF
   ELSE
    REMIT #RIR_GETLOCAL
   ENDIF
  ELSE
   REMIT #RIR_GETGLOBAL
  ENDIF
  REG=RCOMPILE_ADDREG()
  REMIT REG
  REMIT IDX
 WHEN #AST_CALLFUNCEXPR
  REG=RCOMPILE_CALLFUNCEXPR(A)
 WHEN #AST_CONSTVAR
  REG=RCOMPILE_EXPR(FOLD_CONSTEXPR(A))
 WHEN #AST_UNAOP
 WHEN #AST_EMPTYEXPR
 WHEN #AST_VAREXPR
 OTHERWISE
  ?AST_STR$(AST_TYP[A])
  COMPILE_ERROR
 ENDCASE
END
DEF RCOMPILE_PRINT A
 VAR I=AST_NEXT[AST_LEFT[A]]
 VAR CNT
 DIM ARGS=ARRAY%(0)
 WHILE I
  IF!I THEN BREAK
  VAR REG=RCOMPILE_EXPR(AST_LEFT[I])
  CASE AST_TYP[I]
  WHEN #AST_PRINT_EXPR_COMMA
   PUSH ARGS,0
  WHEN #AST_PRINT_EXPR_NEWLINE
   PUSH ARGS,1
  WHEN #AST_PRINT_EXPR_SEMI
   PUSH ARGS,2
  ENDCASE
   PUSH ARGS,REG
  I=AST_NEXT[I]
  INC CNT
 WEND
 REMIT #RIR_PRINT
 REMIT LEN(ARGS) DIV 2
 FOR I=0TO LAST(ARGS)
  REMIT ARGS[I]
 NEXT
END

DEF RCOMPILE_DEF A
 '$:NAME
 'A1:IN LIST
 'A2:OUT LIST
 'A3:STATEMENTS
 'A4:HAS RETURN VALUE
 REMIT #RIR_BR
 REMIT &H7FFFFFFF
 VAR SKIP=RIR_GET_ADDR()
 VAR FN$=AST$[A]
 VAR INCNT
 VAR I
 VAR OUTCNT
 VAR CMN
 INCNT=AST_GET_ITEM_COUNT(AST_A1[A])
 OUTCNT=AST_GET_ITEM_COUNT(AST_A2[A])
 IF AST_A4[A]AND #AST_DEF_A4_HAS_RET_VAL THEN
  INC OUTCNT
 ENDIF
 IF AST_A4[A]AND #AST_DEF_A4_OUT_VAARGS THEN
  OUTCNT=-1
 ENDIF
 IF AST_A4[A]AND #AST_DEF_A4_IN_VAARGS THEN
  INCNT=-1
 ENDIF
 IF AST_A4[A]AND #AST_DEF_A4_COMMON_DEF THEN
  CMN=#TRUE
 ENDIF
 CMP_CURFUNC=DEFINE_FUNC(FN$,RIR_NEXT_ADDR(),INCNT,OUTCNT,CMN)
 REMIT #RIR_DEFFUN
 REMIT CMP_CURFUNC
 I=AST_NEXT[AST_A1[A]]
 VAR IDX=-INCNT
 WHILE I
  DEFINE_LOCAL_VAR CMP_CURFUNC,AST$[I],IDX
  INC IDX
  I=AST_NEXT[I]
 WEND
 IDX=-INCNT-1
 I=AST_PREV[AST_A2[A]]
 WHILE I!=AST_A2[A]
  DEFINE_LOCAL_VAR CMP_CURFUNC,AST$[I],IDX
  I=AST_PREV[I]
  DEC IDX
 WEND
 RCOMPILE_STATEMENTS AST_A3[A]
 RIR_SET SKIP,RIR_NEXT_ADDR()
 CMP_CURFUNC=0
 REMIT #RIR_DEFFUN
 REMIT CMP_CURFUNC
END

DEF RCOMPILE_RETURNFUNC A
 VAR EXPR=AST_LEFT[A]
 IF EXPR THEN
  VAR REG=RCOMPILE_EXPR(EXPR)
  REMIT #RIR_SETOUTARG
  REMIT 0
  REMIT REG
 ENDIF
 REMIT #RIR_LEAVE
END

DEF RCOMPILE_FOR_VAR(INDEX,TOEXPR,STEPEXPR,INIT)

 IF STEPEXPR THEN
  VAR STEP_REG=RCOMPILE_EXPR(STEPEXPR)
 ELSE
  STEP_REG=RCOMPILE_ADDREG()
  REMIT #RIR_MOVINT
  REMIT STEP_REG
  REMIT 1
 ENDIF
 VAR TO_REG=RCOMPILE_EXPR(TOEXPR)
 CASE AST_TYP[INDEX]
 WHEN #AST_VAR
  VAR IDX,LC
  GET_VAR_INDEX AST$[INDEX] OUT IDX,LC
  IF LC THEN
   IF IDX<0 THEN
    IF IDX>=-FUNC_INCNT[CMP_CURFUNC] THEN'FIXME VAARGS
     REMIT #RIR_FORINARG
     IDX=-IDX-1
    ELSE
     REMIT #RIR_FOROUTARG
     IDX=-IDX-FUNC_INCNT[CMP_CURFUNC]-1
    ENDIF
   ELSE
    REMIT #RIR_FORLOCAL
   ENDIF
  ELSE
   REMIT #RIR_FORGLOBAL
  ENDIF
  REMIT IDX
  REMIT TO_REG
  REMIT STEP_REG
  REMIT INIT
  REMIT &H7FFFFFFF
  RETURN RIR_GET_ADDR()
 OTHERWISE
  STOP
 ENDCASE
END

DEF RCOMPILE_FOR A
 'A1:INDEXREFEXPR
 'A2:INITEXPR
 'A3:TOEXPR
 'A4:STEPEXPR
 'A5:STATEMENTS
 VAR INDEXREF=AST_A1[A]
 VAR INITEXPR=AST_A2[A]
 VAR TOEXPR=AST_A3[A]
 VAR STEPEXPR=AST_A4[A]
 VAR STATEMENTS=AST_A5[A]
 RCOMPILE_ASSIGN_REG INDEXREF,RCOMPILE_EXPR(INITEXPR)
 '0-GLOBAL 1-LOCAL 2IN 3OUT
 VAR BRKADDR=RCOMPILE_FOR_VAR(INDEXREF,TOEXPR,STEPEXPR,#TRUE)
 VAR LOOPADDR=RIR_NEXT_ADDR()
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  RCOMPILE_STATEMENTS STATEMENTS
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   RIR_SET CMP_CONTINUE[I],RIR_NEXT_ADDR()
  NEXT
'  VMDBG_ADD_SRC_INFO AST_LINE[A],AST_POS[A],AST_LINE_END[A],AST_POS_END[A]
  VAR BRKADDR2=RCOMPILE_FOR_VAR(INDEXREF,TOEXPR,STEPEXPR,#FALSE)
  RIR_SET BRKADDR,RIR_NEXT_ADDR()
  RIR_SET BRKADDR2,LOOPADDR
  FOR I=0TO LAST(CMP_BREAK)
   RIR_SET CMP_BREAK[I],RIR_NEXT_ADDR()
  NEXT
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF RCOMPILE_WHILE A
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  VAR CONTADDR=RIR_NEXT_ADDR()
  VAR REG=RCOMPILE_EXPR(AST_A1[A])
  REMIT #RIR_BRFALSE
  REMIT REG
  REMIT &H7FFFFFFF
  VAR BRL=RIR_GET_ADDR()
  RCOMPILE_STATEMENTS AST_A2[A]
  REMIT #RIR_BR
  REMIT CONTADDR
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   RIR_SET CMP_CONTINUE[I],CONTADDR
  NEXT
  FOR I=0TO LAST(CMP_BREAK)
   RIR_SET CMP_BREAK[I],RIR_NEXT_ADDR()
  NEXT
  RIR_SET BRL,RIR_NEXT_ADDR()
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF RCOMPILE_REPEAT A
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  VAR LOOPADDR=RIR_NEXT_ADDR()
  RCOMPILE_STATEMENTS AST_A2[A]
  VAR CONTADDR=RIR_NEXT_ADDR()
  VAR COND_REG=RCOMPILE_EXPR(AST_A1[A])
  REMIT #RIR_BRFALSE
  REMIT COND_REG
  REMIT LOOPADDR
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   RIR_SET CMP_CONTINUE[I],CONTADDR
  NEXT
  FOR I=0TO LAST(CMP_BREAK)
   RIR_SET CMP_BREAK[I],RIR_NEXT_ADDR()
  NEXT
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF RCOMPILE_LOOP A
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  VAR CONTADDR=RIR_NEXT_ADDR()
  RCOMPILE_STATEMENTS AST_A2[A]
  REMIT #RIR_BR
  REMIT CONTADDR
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   RIR_SET CMP_CONTINUE[I],CONTADDR
  NEXT
  FOR I=0TO LAST(CMP_BREAK)
   RIR_SET CMP_BREAK[I],RIR_NEXT_ADDR()
  NEXT
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END

DEF RCOMPILE_CONTINUE
 IF TYPEOF(CMP_CONTINUE)!=#T_INTARRAY THEN
  SYNTAX_ERROR
  RETURN
 ENDIF
 REMIT #RIR_BR
 REMIT &H7FFFFFFF
 PUSH CMP_CONTINUE,RIR_GET_ADDR()
END
DEF RCOMPILE_BREAK
 IF TYPEOF(CMP_CONTINUE)!=#T_INTARRAY THEN
  SYNTAX_ERROR
  RETURN
 ENDIF
 REMIT #RIR_BR
 REMIT &H7FFFFFFF
 PUSH CMP_BREAK,RIR_GET_ADDR()
END

DEF RCOMPILE_INC A
 'RIGHT TO LEFT
 IF AST_RIGHT[A] THEN
  VAR REG=RCOMPILE_EXPR(AST_RIGHT[A])
 ELSE
  REG=RCOMPILE_ADDREG()
  REMIT #RIR_MOVINT
  REMIT REG
  REMIT 1
 ENDIF
 IF AST_TYP[A]!=#AST_INC THEN
  RCOMPILE_INC_VAR AST_LEFT[A],REG,#TRUE
 ELSE
  RCOMPILE_INC_VAR AST_LEFT[A],REG,#FALSE
 ENDIF
END
DEF RCOMPILE_INC_VAR A,DIFF_REG,DECREMENT
 CASE AST_TYP[A]
 WHEN #AST_VAR
  VAR IDX,LC
  GET_VAR_INDEX AST$[A] OUT IDX,LC
  IF LC THEN
   IF IDX<0 THEN
    IF IDX>=-FUNC_INCNT[CMP_CURFUNC] THEN'FIXME VAARGS
     REMIT #RIR_INCINARG
     IDX=-IDX-1
    ELSE
     REMIT #RIR_INCOUTARG
     IDX=-IDX-FUNC_INCNT[CMP_CURFUNC]-1
    ENDIF
   ELSE
    REMIT #RIR_INCLOCAL
   ENDIF
  ELSE
   REMIT #RIR_INCGLOBAL
  ENDIF
  REMIT DECREMENT
  REMIT DIFF_REG

  REMIT IDX
 WHEN #AST_BINOP
  VAR TYP=AST%[A]
  IF TYP!=#TKN_LB THEN
   SYNTAX_ERROR "EXPECTED '['"
   RETURN
  ENDIF
  VAR DM=RCOMPILE_ARRAY_INDEX_EXPR(AST_RIGHT[A])
  VAR ARY_REG=RCOMPILE_EXPR(AST_LEFT[A])
  REMIT #RIR_INCARRAY
  REMIT DECREMENT
  REMIT DIFF_REG

  REMIT ARY_REG
  REMIT LEN(DM)
  VAR I
  FOR I=0TO LAST(DM)
   REMIT DM[I]
  NEXT
 OTHERWISE
  STOP
 ENDCASE
END
'UTIL

DIM SPLAYN_LEFT[]
DIM SPLAYN_RIGHT[]
DIM SPLAYN_PARENT[]
DIM SPLAYN_KEY$[]
DIM SPLAYN_VAL$[]
DIM SPLAYN_VAL%[]
DIM SPLAYN_VAL#[]
DIM SPLAY_ROOT[]
VAR SPLAY_INIT
VAR SPLAY_FREE
VAR SPLAYN_FREE

DEF INIT_SPLAY
 VAR S=1
 SPLAYN_LEFT=ARRAY%(S)
 SPLAYN_RIGHT=ARRAY%(S)
 SPLAYN_PARENT=ARRAY%(S)
 SPLAYN_KEY$=ARRAY$(S)
 SPLAYN_VAL$=ARRAY$(S)
 SPLAYN_VAL#=ARRAY%(S)
 SPLAYN_VAL%=ARRAY%(S)
 SPLAY_ROOT=ARRAY%(S)
 SPLAY_INIT=#TRUE
 SPLAY_FREE=0
 SPLAYN_FREE=0
END

DEF NEW_SPLAY_TREE()
 IF!SPLAY_INIT THEN
  INIT_SPLAY
 ENDIF
 IF SPLAY_FREE THEN
  VAR L=SPLAY_FREE
  SPLAY_FREE=SPLAY_ROOT[SPLAY_FREE]
  SPLAY_ROOT[L]=0
  RETURN L
 ENDIF
 PUSH SPLAY_ROOT,0
 RETURN LAST(SPLAY_ROOT)
END
DEF DELETE_SPLAY_NODE NODE
 IF!NODE THEN RETURN
 DELETE_SPLAY_NODE SPLAYN_LEFT[NODE]
 DELETE_SPLAY_NODE SPLAYN_RIGHT[NODE]
 SPLAYN_VAL%[NODE]=SPLAYN_FREE
 VAR N$
 SPLAYN_KEY$[NODE]=N$
 SPLAYN_VAL$[NODE]=N$
 SPLAYN_VAL#[NODE]=0
 SPLAYN_LEFT[NODE]=0
 SPLAYN_RIGHT[NODE]=0
 SPLAYN_PARENT[NODE]=0
 SPLAYN_FREE=NODE
END
DEF DELETE_SPLAY_TREE TREE
 IF !TREE THEN RETURN
 DELETE_SPLAY_NODE SPLAY_ROOT[TREE]
 SPLAY_ROOT[TREE]=SPLAY_FREE
 SPLAY_FREE=TREE
END
DEF NEW_SPLAYN(K$)
 VAR E$
 IF SPLAYN_FREE THEN
  VAR L=SPLAYN_FREE
  SPLAYN_FREE=SPLAYN_VAL%[SPLAYN_FREE]
  SPLAYN_KEY$[L]=K$
  SPLAYN_VAL%[L]=0
  RETURN L
 ENDIF
 PUSH SPLAYN_LEFT,0
 PUSH SPLAYN_RIGHT,0
 PUSH SPLAYN_PARENT,0
 PUSH SPLAYN_KEY$,K$
 PUSH SPLAYN_VAL$,E$
 PUSH SPLAYN_VAL%,0
 PUSH SPLAYN_VAL#,0
 RETURN LAST(SPLAYN_LEFT)
END
DEF NEW_SPLAYN%(K$,V%)
 VAR S=NEW_SPLAYN(K$)
 SPLAYN_VAL%[S]=V%
 RETURN S
END
DEF NEW_SPLAYN#(K$,V#)
 VAR S=NEW_SPLAYN(K$)
 SPLAYN_VAL#[S]=V#
 RETURN S
END
DEF NEW_SPLAYN$(K$,V$)
 VAR S=NEW_SPLAYN(K$)
 SPLAYN_VAL$[S]=V$
 RETURN S
END

DEF SPLAY_LEFT_ROTATE S,X
 VAR Y=SPLAYN_RIGHT[X]
 IF Y THEN
  SPLAYN_RIGHT[X]=SPLAYN_LEFT[Y]
  IF SPLAYN_LEFT[Y] THEN
   SPLAYN_PARENT[SPLAYN_LEFT[Y]]=X
  ENDIF
  SPLAYN_PARENT[Y]=SPLAYN_PARENT[X]
 ENDIF
 IF !SPLAYN_PARENT[X] THEN
  SPLAY_ROOT[S]=Y
 ELSEIF X==SPLAYN_LEFT[SPLAYN_PARENT[X]] THEN
  SPLAYN_LEFT[SPLAYN_PARENT[X]]=Y
 ELSE
  SPLAYN_RIGHT[SPLAYN_PARENT[X]]=Y
 ENDIF
 IF Y THEN
  SPLAYN_LEFT[Y]=X
 ENDIF
 SPLAYN_PARENT[X]=Y
END

DEF SPLAY_RIGHT_ROTATE S,X
 VAR Y=SPLAYN_LEFT[X]
 IF Y THEN
  SPLAYN_LEFT[X]=SPLAYN_RIGHT[Y]
  IF SPLAYN_RIGHT[Y]THEN
   SPLAYN_PARENT[SPLAYN_RIGHT[Y]]=X
  ENDIF
  SPLAYN_PARENT[Y]=SPLAYN_PARENT[X]
 ENDIF
 IF !SPLAYN_PARENT[X]THEN
  SPLAY_ROOT[S]=Y
 ELSEIF X==SPLAYN_LEFT[SPLAYN_PARENT[X]]THEN
  SPLAYN_LEFT[SPLAYN_PARENT[X]]=Y
 ELSE
  SPLAYN_RIGHT[SPLAYN_PARENT[X]]=Y
 ENDIF
 IF Y THEN
  SPLAYN_RIGHT[Y]=X
 ENDIF
 SPLAYN_PARENT[X]=Y
END

DEF SPLAY S,X
 WHILE SPLAYN_PARENT[X]
  VAR P=SPLAYN_PARENT[X]
  IF !SPLAYN_PARENT[P]THEN
   IF SPLAYN_LEFT[P]==X THEN
    SPLAY_RIGHT_ROTATE S,P
   ELSE
    SPLAY_LEFT_ROTATE S,P
   ENDIF
  ELSEIF SPLAYN_LEFT[P]==X&&SPLAYN_LEFT[SPLAYN_PARENT[P]]==P THEN
   SPLAY_RIGHT_ROTATE S,SPLAYN_PARENT[P]
   SPLAY_RIGHT_ROTATE S,SPLAYN_PARENT[X]
  ELSEIF SPLAYN_RIGHT[P]==X&&SPLAYN_RIGHT[SPLAYN_PARENT[P]]==P THEN
   SPLAY_LEFT_ROTATE S,SPLAYN_PARENT[P]
   SPLAY_LEFT_ROTATE S,SPLAYN_PARENT[X]
  ELSEIF SPLAYN_LEFT[P]==X&&SPLAYN_RIGHT[SPLAYN_PARENT[P]]==P THEN
   SPLAY_RIGHT_ROTATE S,P
   SPLAY_LEFT_ROTATE S,SPLAYN_PARENT[X]
  ELSE
   SPLAY_LEFT_ROTATE S,P
   SPLAY_RIGHT_ROTATE S,SPLAYN_PARENT[X]
  ENDIF
 WEND
END
DEF SPLAY_REPLACE S,U,V
 IF !SPLAYN_PARENT[U]THEN
  SPLAY_ROOT[S]=V
 ELSEIF U==SPLAYN_LEFT[SPLAYN_PARENT[U]]THEN
  SPLAYN_LEFT[SPLAYN_PARENT[U]]=V
 ELSE
  SPLAYN_RIGHT[SPLAYN_PARENT[U]]=V
 ENDIF
 IF V THEN
  SPLAYN_PARENT[V]=SPLAYN_PARENT[U]
 ENDIF
END

DEF SPLAY_SUBTREE_MIN(S,U)
 WHILE SPLAYN_LEFT[U]
  U=SPLAYN_LEFT[U]
 WEND
 RETURN U
END
DEF SPLAY_SUBTREE_MAX(S,U)
 WHILE SPLAYN_RIGHT[U]
  U=SPLAYN_RIGHT[U]
 WEND
 RETURN U
END

DEF SPLAY_INSERT% S,KEY$,VALUE%
 SPLAY_INSERT S,KEY$,VALUE%,#T_INT
END
DEF SPLAY_INSERT$ S,KEY$,VALUE$
 SPLAY_INSERT S,KEY$,VALUE$,#T_STR
END
DEF SPLAY_INSERT# S,KEY$,VALUE#
 SPLAY_INSERT S,KEY$,VALUE#,#T_REAL
END

DEF SPLAY_INSERT S,KEY$,VALUE,T
 VAR Z=SPLAY_ROOT[S]
 VAR P
 WHILE Z
  P=Z
  IF SPLAYN_KEY$[Z]<KEY$THEN
   Z=SPLAYN_RIGHT[Z]
  ELSE
   Z=SPLAYN_LEFT[Z]
  ENDIF
 WEND
 CASE T
 WHEN #T_INT
  Z=NEW_SPLAYN%(KEY$,VALUE)
 WHEN #T_STR
  Z=NEW_SPLAYN$(KEY$,VALUE)
 WHEN #T_REAL
  Z=NEW_SPLAYN#(KEY$,VALUE)
 ENDCASE
 SPLAYN_PARENT[Z]=P
 IF !P THEN
  SPLAY_ROOT[S]=Z
 ELSEIF SPLAYN_KEY$[P]<SPLAYN_KEY$[Z]THEN
  SPLAYN_RIGHT[P]=Z
 ELSE
  SPLAYN_LEFT[P]=Z
 ENDIF
 SPLAY S,Z
END

DEF SPLAY_FIND(S,KEY$)
 VAR Z=SPLAY_ROOT[S]
 WHILE Z
  IF SPLAYN_KEY$[Z]<KEY$THEN
   Z=SPLAYN_RIGHT[Z]
  ELSEIF SPLAYN_KEY$[Z]==KEY$THEN
   RETURN Z
  ELSE
   Z=SPLAYN_LEFT[Z]
  ENDIF
 WEND
 RETURN 0
END

DEF SPLAY_GET% S,KEY$ OUT FOUND,VALUE%
 VAR N=SPLAY_FIND(S,KEY$)
 IF !N THEN
  FOUND=#FALSE
  VALUE%=0
  RETURN
 ENDIF
 FOUND=#TRUE
 VALUE%=SPLAYN_VAL%[N]
END
DEF SPLAY_GET# S,KEY$ OUT FOUND,VALUE#
 VAR N=SPLAY_FIND(S,KEY$)
 IF !N THEN
  FOUND=#FALSE
  VALUE#=0E0
  RETURN
 ENDIF
 FOUND=#TRUE
 VALUE#=SPLAYN_VAL#[N]
END
DEF SPLAY_GET$ S,KEY$ OUT FOUND,VALUE$
 VAR N=SPLAY_FIND(S,KEY$)
 IF !N THEN
  FOUND=#FALSE
  VALUE$=""
  RETURN
 ENDIF
 FOUND=#TRUE
 VALUE$=SPLAYN_VAL$[N]
END

DEF SPLAY_ERASE S,KEY$
 VAR Z=SPLAY_FIND(S,KEY$)
 IF !Z THEN
  RETURN
 ENDIF
 SPLAY S,Z
 IF !SPLAYN_LEFT[Z]THEN
  SPLAY_REPLACE S,Z,SPLAYN_RIGHT[Z]
 ELSEIF !SPLAYN_RIGHT[Z]THEN
  SPLAY_REPLACE S,Z,SPLAYN_LEFT[Z]
 ELSE
  VAR Y=SPLAY_SUBTREE_MIN(S,SPLAYN_RIGHT[Z])
  IF SPLAYN_PARENT[Y]!=Z THEN
   SPLAY_REPLACE S,Y,SPLAYN_RIGHT[Y]
   SPLAYN_RIGHT[Y]=SPLAYN_RIGHT[Z]
   SPLAYN_PARENT[SPLAYN_RIGHT[Y]]=Y
  ENDIF
  SPLAY_REPLACE S,Z,Y
  SPLAYN_LEFT[Y]=SPLAYN_LEFT[Z]
  SPLAYN_PARENT[SPLAYN_LEFT[Y]]=Y
 ENDIF
 'DELETE Z
END

DEF SPLAY_TEST
 VAR T=NEW_SPLAY_TREE()
 SPLAY_INSERT T,"K","V1"
 SPLAY_INSERT T,"K2","V2"
 SPLAY_INSERT T,"K3","V3"
 VAR F
 SPLAY_GET T,"K" OUT ,F
 ?F
 SPLAY_GET T,"K2" OUT ,F
 ?F
 SPLAY_GET T,"K3" OUT ,F
 ?F
 SPLAY_ERASE T,"K2"
 SPLAY_GET T,"K" OUT ,F
 ?F
 SPLAY_GET T,"K2" OUT ,F
 ?F
 SPLAY_GET T,"K3" OUT ,F
 ?F
 SPLAY_ERASE T,"K3"
 SPLAY_ERASE T,"K"
 SPLAY_GET T,"K" OUT ,F
 ?F
 SPLAY_GET T,"K2" OUT ,F
 ?F
 SPLAY_GET T,"K3" OUT ,F
 ?F

 VAR I
 VAR O=50000
 DIM LST1=ARRAY$(0)
 DIM LST2=ARRAY$(0)
 FOR I=0TO O-1
  PUSH LST1,STR$(I)
  PUSH LST2,STR$(I)
 NEXT
 FOR I=0TO O*10
  SWAP LST1[RND(O)],LST1[RND(O)]
  SWAP LST2[RND(O)],LST2[RND(O)]
 NEXT
 PERFBEGIN 0
 FOR I=0TO O-1
  SPLAY_INSERT T,LST1[I],"a"
 NEXT
 ?PERFEND(0)/O
 PERFBEGIN 0
 FOR I=0TO O-1
  SPLAY_GET T,LST2[I] OUT ,
 NEXT
 ?PERFEND(0)/O
 PERFBEGIN 0
 FOR I=0TO O-1
  SPVAR #GSPRITE,LST1[I],"a"
 NEXT
 ?PERFEND(0)/O
 PERFBEGIN 0
 VAR A$
 FOR I=0TO O-1
  SPVAR #GSPRITE,LST2[I] OUT A$
 NEXT
 ?PERFEND(0)/O
END

DEF GET_SPLAY_ROOT(S)
 RETURN SPLAY_ROOT[S]
END
DEF GET_SPLAYN_LEFT(S)
 RETURN SPLAYN_LEFT[S]
END
DEF GET_SPLAYN_RIGHT(S)
 RETURN SPLAYN_RIGHT[S]
END
DEF GET_SPLAYN_VAL%(S)
 RETURN SPLAYN_VAL%[S]
END
DEF GET_SPLAYN_VAL#(S)
 RETURN SPLAYN_VAL#[S]
END
DEF GET_SPLAYN_VAL$(S)
 RETURN SPLAYN_VAL$[S]
END
DEF GET_SPLAYN_KEY$(S)
 RETURN SPLAYN_KEY$[S]
END

DIM NULLARRAY[0]
DIM SBARY[0]
VAR SBARYMAX
VAR SBARYFREE
DEF OTX_INIT_SBARRAY
 SBARYMAX=1024'256
 SBARY=ARRAY%(SBARYMAX)
 VAR I
 FOR I=0TO SBARYMAX-2
  SBARY[I]=I+1
 NEXT
 SBARY[SBARYMAX-1]=-1
 SBARYFREE=1
 NULLARRAY=ARRAY%(0)
END
COMMON DEF AllocSBArray()
 VAR A=SBARYFREE
 IF A==-1THEN RETURN -1
 SBARYFREE=SBARY[A]
 RETURN A
END
COMMON DEF FreeSBArray A
 IF!A THEN RETURN
 SBARY[A]=SBARYFREE
 SBARYFREE=A
 VAR("_"+HEX$(A))=EMPTY()
END
COMMON DEF GetSBArray(A)
 RETURN VAR("_"+HEX$(A))
END
COMMON DEF SetSBArray A,ARY
 VAR("_"+HEX$(A))=ARY
END
DIM _0[0],_1[0],_2[0],_3[0],_4[0],_5[0],_6[0],_7[0],_8[0],_9[0],_A[0],_B[0],_C[0],_D[0],_E[0],_F[0],_10[0],_11[0],_12[0],_13[0],_14[0],_15[0],_16[0],_17[0],_18[0],_19[0],_1A[0],_1B[0],_1C[0],_1D[0],_1E[0],_1F[0],_20[0],_21[0],_22[0],_23[0],_24[0],_25[0],_26[0],_27[0],_28[0],_29[0],_2A[0],_2B[0],_2C[0],_2D[0],_2E[0],_2F[0],_30[0],_31[0],_32[0],_33[0],_34[0],_35[0],_36[0],_37[0],_38[0],_39[0],_3A[0],_3B[0],_3C[0],_3D[0],_3E[0],_3F[0],_40[0],_41[0],_42[0],_43[0],_44[0],_45[0],_46[0],_47[0],_48[0],_49[0],_4A[0],_4B[0],_4C[0],_4D[0],_4E[0],_4F[0],_50[0],_51[0],_52[0],_53[0],_54[0],_55[0],_56[0],_57[0],_58[0],_59[0],_5A[0],_5B[0],_5C[0],_5D[0],_5E[0],_5F[0],_60[0],_61[0],_62[0],_63[0],_64[0],_65[0],_66[0],_67[0],_68[0],_69[0],_6A[0],_6B[0],_6C[0],_6D[0],_6E[0],_6F[0],_70[0],_71[0],_72[0],_73[0],_74[0],_75[0],_76[0],_77[0],_78[0],_79[0],_7A[0],_7B[0],_7C[0],_7D[0],_7E[0],_7F[0],_80[0],_81[0],_82[0],_83[0],_84[0],_85[0],_86[0],_87[0],_88[0],_89[0],_8A[0],_8B[0],_8C[0],_8D[0],_8E[0],_8F[0],_90[0],_91[0],_92[0],_93[0],_94[0],_95[0],_96[0],_97[0],_98[0],_99[0],_9A[0],_9B[0],_9C[0],_9D[0],_9E[0],_9F[0],_A0[0],_A1[0],_A2[0],_A3[0],_A4[0],_A5[0],_A6[0],_A7[0],_A8[0],_A9[0],_AA[0],_AB[0],_AC[0],_AD[0],_AE[0],_AF[0],_B0[0],_B1[0],_B2[0],_B3[0],_B4[0],_B5[0],_B6[0],_B7[0],_B8[0],_B9[0],_BA[0],_BB[0],_BC[0],_BD[0],_BE[0],_BF[0],_C0[0],_C1[0],_C2[0],_C3[0],_C4[0],_C5[0],_C6[0],_C7[0],_C8[0],_C9[0],_CA[0],_CB[0],_CC[0],_CD[0],_CE[0],_CF[0],_D0[0],_D1[0],_D2[0],_D3[0],_D4[0],_D5[0],_D6[0],_D7[0],_D8[0],_D9[0],_DA[0],_DB[0],_DC[0],_DD[0],_DE[0],_DF[0],_E0[0],_E1[0],_E2[0],_E3[0],_E4[0],_E5[0],_E6[0],_E7[0],_E8[0],_E9[0],_EA[0],_EB[0],_EC[0],_ED[0],_EE[0],_EF[0],_F0[0],_F1[0],_F2[0],_F3[0],_F4[0],_F5[0],_F6[0],_F7[0],_F8[0],_F9[0],_FA[0],_FB[0],_FC[0],_FD[0],_FE[0],_FF[0],_100[0],_101[0],_102[0],_103[0],_104[0],_105[0],_106[0],_107[0],_108[0],_109[0],_10A[0],_10B[0],_10C[0],_10D[0],_10E[0],_10F[0],_110[0],_111[0],_112[0],_113[0],_114[0],_115[0],_116[0],_117[0],_118[0],_119[0],_11A[0],_11B[0],_11C[0],_11D[0],_11E[0],_11F[0],_120[0],_121[0],_122[0],_123[0],_124[0],_125[0],_126[0],_127[0],_128[0],_129[0],_12A[0],_12B[0],_12C[0],_12D[0],_12E[0],_12F[0],_130[0],_131[0],_132[0],_133[0],_134[0],_135[0],_136[0],_137[0],_138[0],_139[0],_13A[0],_13B[0],_13C[0],_13D[0],_13E[0],_13F[0],_140[0],_141[0],_142[0],_143[0],_144[0],_145[0],_146[0],_147[0],_148[0],_149[0],_14A[0],_14B[0],_14C[0],_14D[0],_14E[0],_14F[0],_150[0],_151[0],_152[0],_153[0],_154[0],_155[0],_156[0],_157[0],_158[0],_159[0],_15A[0],_15B[0],_15C[0],_15D[0],_15E[0],_15F[0],_160[0],_161[0],_162[0],_163[0],_164[0],_165[0],_166[0],_167[0],_168[0],_169[0],_16A[0],_16B[0],_16C[0],_16D[0],_16E[0],_16F[0],_170[0],_171[0],_172[0],_173[0],_174[0],_175[0],_176[0],_177[0],_178[0],_179[0],_17A[0],_17B[0],_17C[0],_17D[0],_17E[0],_17F[0],_180[0],_181[0],_182[0],_183[0],_184[0],_185[0],_186[0],_187[0],_188[0],_189[0],_18A[0],_18B[0],_18C[0],_18D[0],_18E[0],_18F[0],_190[0],_191[0],_192[0],_193[0],_194[0],_195[0],_196[0],_197[0],_198[0],_199[0],_19A[0],_19B[0],_19C[0],_19D[0],_19E[0],_19F[0],_1A0[0],_1A1[0],_1A2[0],_1A3[0],_1A4[0],_1A5[0],_1A6[0],_1A7[0],_1A8[0],_1A9[0],_1AA[0],_1AB[0],_1AC[0],_1AD[0],_1AE[0],_1AF[0],_1B0[0],_1B1[0],_1B2[0],_1B3[0],_1B4[0],_1B5[0],_1B6[0],_1B7[0],_1B8[0],_1B9[0],_1BA[0],_1BB[0],_1BC[0],_1BD[0],_1BE[0],_1BF[0],_1C0[0],_1C1[0],_1C2[0],_1C3[0],_1C4[0],_1C5[0],_1C6[0],_1C7[0],_1C8[0],_1C9[0],_1CA[0],_1CB[0],_1CC[0],_1CD[0],_1CE[0],_1CF[0],_1D0[0],_1D1[0],_1D2[0],_1D3[0],_1D4[0],_1D5[0],_1D6[0],_1D7[0],_1D8[0],_1D9[0],_1DA[0],_1DB[0],_1DC[0],_1DD[0],_1DE[0],_1DF[0],_1E0[0],_1E1[0],_1E2[0],_1E3[0],_1E4[0],_1E5[0],_1E6[0],_1E7[0],_1E8[0],_1E9[0],_1EA[0],_1EB[0],_1EC[0],_1ED[0],_1EE[0],_1EF[0],_1F0[0],_1F1[0],_1F2[0],_1F3[0],_1F4[0],_1F5[0],_1F6[0],_1F7[0],_1F8[0],_1F9[0],_1FA[0],_1FB[0],_1FC[0],_1FD[0],_1FE[0],_1FF[0],_200[0],_201[0],_202[0],_203[0],_204[0],_205[0],_206[0],_207[0],_208[0],_209[0],_20A[0],_20B[0],_20C[0],_20D[0],_20E[0],_20F[0],_210[0],_211[0],_212[0],_213[0],_214[0],_215[0],_216[0],_217[0],_218[0],_219[0],_21A[0],_21B[0],_21C[0],_21D[0],_21E[0],_21F[0],_220[0],_221[0],_222[0],_223[0],_224[0],_225[0],_226[0],_227[0],_228[0],_229[0],_22A[0],_22B[0],_22C[0],_22D[0],_22E[0],_22F[0],_230[0],_231[0],_232[0],_233[0],_234[0],_235[0],_236[0],_237[0],_238[0],_239[0],_23A[0],_23B[0],_23C[0],_23D[0],_23E[0],_23F[0],_240[0],_241[0],_242[0],_243[0],_244[0],_245[0],_246[0],_247[0],_248[0],_249[0],_24A[0],_24B[0],_24C[0],_24D[0],_24E[0],_24F[0],_250[0],_251[0],_252[0],_253[0],_254[0],_255[0],_256[0],_257[0],_258[0],_259[0],_25A[0],_25B[0],_25C[0],_25D[0],_25E[0],_25F[0],_260[0],_261[0],_262[0],_263[0],_264[0],_265[0],_266[0],_267[0],_268[0],_269[0],_26A[0],_26B[0],_26C[0],_26D[0],_26E[0],_26F[0],_270[0],_271[0],_272[0],_273[0],_274[0],_275[0],_276[0],_277[0],_278[0],_279[0],_27A[0],_27B[0],_27C[0],_27D[0],_27E[0],_27F[0],_280[0],_281[0],_282[0],_283[0],_284[0],_285[0],_286[0],_287[0],_288[0],_289[0],_28A[0],_28B[0],_28C[0],_28D[0],_28E[0],_28F[0],_290[0],_291[0],_292[0],_293[0],_294[0],_295[0],_296[0],_297[0],_298[0],_299[0],_29A[0],_29B[0],_29C[0],_29D[0],_29E[0],_29F[0],_2A0[0],_2A1[0],_2A2[0],_2A3[0],_2A4[0],_2A5[0],_2A6[0],_2A7[0],_2A8[0],_2A9[0],_2AA[0],_2AB[0],_2AC[0],_2AD[0],_2AE[0],_2AF[0],_2B0[0],_2B1[0],_2B2[0],_2B3[0],_2B4[0],_2B5[0],_2B6[0],_2B7[0],_2B8[0],_2B9[0],_2BA[0],_2BB[0],_2BC[0],_2BD[0],_2BE[0],_2BF[0],_2C0[0],_2C1[0],_2C2[0],_2C3[0],_2C4[0],_2C5[0],_2C6[0],_2C7[0],_2C8[0],_2C9[0],_2CA[0],_2CB[0],_2CC[0],_2CD[0],_2CE[0],_2CF[0],_2D0[0],_2D1[0],_2D2[0],_2D3[0],_2D4[0],_2D5[0],_2D6[0],_2D7[0],_2D8[0],_2D9[0],_2DA[0],_2DB[0],_2DC[0],_2DD[0],_2DE[0],_2DF[0],_2E0[0],_2E1[0],_2E2[0],_2E3[0],_2E4[0],_2E5[0],_2E6[0],_2E7[0],_2E8[0],_2E9[0],_2EA[0],_2EB[0],_2EC[0],_2ED[0],_2EE[0],_2EF[0],_2F0[0],_2F1[0],_2F2[0],_2F3[0],_2F4[0],_2F5[0],_2F6[0],_2F7[0],_2F8[0],_2F9[0],_2FA[0],_2FB[0],_2FC[0],_2FD[0],_2FE[0],_2FF[0],_300[0],_301[0],_302[0],_303[0],_304[0],_305[0],_306[0],_307[0],_308[0],_309[0],_30A[0],_30B[0],_30C[0],_30D[0],_30E[0],_30F[0],_310[0],_311[0],_312[0],_313[0],_314[0],_315[0],_316[0],_317[0],_318[0],_319[0],_31A[0],_31B[0],_31C[0],_31D[0],_31E[0],_31F[0],_320[0],_321[0],_322[0],_323[0],_324[0],_325[0],_326[0],_327[0],_328[0],_329[0],_32A[0],_32B[0],_32C[0],_32D[0],_32E[0],_32F[0],_330[0],_331[0],_332[0],_333[0],_334[0],_335[0],_336[0],_337[0],_338[0],_339[0],_33A[0],_33B[0],_33C[0],_33D[0],_33E[0],_33F[0],_340[0],_341[0],_342[0],_343[0],_344[0],_345[0],_346[0],_347[0],_348[0],_349[0],_34A[0],_34B[0],_34C[0],_34D[0],_34E[0],_34F[0],_350[0],_351[0],_352[0],_353[0],_354[0],_355[0],_356[0],_357[0],_358[0],_359[0],_35A[0],_35B[0],_35C[0],_35D[0],_35E[0],_35F[0],_360[0],_361[0],_362[0],_363[0],_364[0],_365[0],_366[0],_367[0],_368[0],_369[0],_36A[0],_36B[0],_36C[0],_36D[0],_36E[0],_36F[0],_370[0],_371[0],_372[0],_373[0],_374[0],_375[0],_376[0],_377[0],_378[0],_379[0],_37A[0],_37B[0],_37C[0],_37D[0],_37E[0],_37F[0],_380[0],_381[0],_382[0],_383[0],_384[0],_385[0],_386[0],_387[0],_388[0],_389[0],_38A[0],_38B[0],_38C[0],_38D[0],_38E[0],_38F[0],_390[0],_391[0],_392[0],_393[0],_394[0],_395[0],_396[0],_397[0],_398[0],_399[0],_39A[0],_39B[0],_39C[0],_39D[0],_39E[0],_39F[0],_3A0[0],_3A1[0],_3A2[0],_3A3[0],_3A4[0],_3A5[0],_3A6[0],_3A7[0],_3A8[0],_3A9[0],_3AA[0],_3AB[0],_3AC[0],_3AD[0],_3AE[0],_3AF[0],_3B0[0],_3B1[0],_3B2[0],_3B3[0],_3B4[0],_3B5[0],_3B6[0],_3B7[0],_3B8[0],_3B9[0],_3BA[0],_3BB[0],_3BC[0],_3BD[0],_3BE[0],_3BF[0],_3C0[0],_3C1[0],_3C2[0],_3C3[0],_3C4[0],_3C5[0],_3C6[0],_3C7[0],_3C8[0],_3C9[0],_3CA[0],_3CB[0],_3CC[0],_3CD[0],_3CE[0],_3CF[0],_3D0[0],_3D1[0],_3D2[0],_3D3[0],_3D4[0],_3D5[0],_3D6[0],_3D7[0],_3D8[0],_3D9[0],_3DA[0],_3DB[0],_3DC[0],_3DD[0],_3DE[0],_3DF[0],_3E0[0],_3E1[0],_3E2[0],_3E3[0],_3E4[0],_3E5[0],_3E6[0],_3E7[0],_3E8[0],_3E9[0],_3EA[0],_3EB[0],_3EC[0],_3ED[0],_3EE[0],_3EF[0],_3F0[0],_3F1[0],_3F2[0],_3F3[0],_3F4[0],_3F5[0],_3F6[0],_3F7[0],_3F8[0],_3F9[0],_3FA[0],_3FB[0],_3FC[0],_3FD[0],_3FE[0],_3FF[0],_400[0]

'UTIL END
'OTYA FONT LIBRARY 1.00

'使い方
'
' VAR FONT
' INIT_FONT
' LOAD_FONT "NOTOSANS.FONT" OUT FONT
' GPUTCHR_FONT FONT,0,0,#FALSE,"Hello World",#C_WHITE
'


'INIT_FONT
'初期化する

'LOAD_FONT NAME% OUT FONT_DAT%
'ファイル名を指定してフォント読み込み
'IN
' NAME$:ファイル名
'OUT
' FONT_DAT%:フォントデータ

'GPUTCHR_FONT FONT_DAT%,X%,Y%,USE_BASE%,STR$,COL%
'フォントをつかって文字列を描画する
'プチコン4の制約によりCOL%の透明度は無視される
'IN
' FONT_DAT%:フォントデータ
' X%       :X
' Y%       :Y
' USE_BASE%:#TRUEの時ベースラインをY%の基準にする
' STR$     :描画する文字列
' COL%     :色

'GPUTCHR_FONT_NCLIP FONT_DAT%,X%,Y%,USE_BASE%,STR$,COL%
'フォントをつかって文字列を描画する
'プチコン4の制約によりCOL%の透明度とGCLIPは無視される
'IN
' FONT_DAT%:フォントデータ
' X%       :X
' Y%       :Y
' USE_BASE%:#TRUEの時ベースラインをY%の基準にする
' STR$     :描画する文字列
' COL%     :色

'FONT_GET_LINE_HEIGHT FONT_DAT% OUT HEIGHT%
'そのフォントの行の高さを取得する
'IN
' FONT_DAT%:フォントデータ
'OUT
' HEIGHT%  :行の高さ

'FONT_CALC_WIDTH FONT_DAT%,STR$ OUT WIDTH%
'文字列の幅を計算する
'IN
' FONT_DAT%:フォントデータ
' STR$     :幅をはかる文字列
'OUT
' WIDTH%   :計算された文字列の幅

'GENERATE_GRPF FONT_DAT%,YOFFSET%,FULL_WIDTH_CHAR%
'フォントからGRPFを生成する
' FONT_DAT%       :フォントデータ
' YOFFSET%        :フォントのY座標を微調整する
' FULL_WIDTH_CHAR%:#TRUEならば全角英数を使う



'OPTION STRICT
DEF BINREADN ARY%,OFS%,CNT% OUT V%,OFSO%
 VAR I%=0
 V%=0
 FOR I%=0TO CNT%-1
  VAR T%=ARY%[OFS% DIV 4]>>(OFS% MOD 4*8)AND 255
  INC V%,T%<<(I%*8)
  INC OFS%
 NEXT
 OFSO%=OFS%
END
DEF BINREAD ARY%,OFS%,FMT$ OUT *
 VAR I%,TMP%
 FOR I%=0TO LAST(FMT$)
  VAR F$=FMT$[I%]
  CASE F$
  '16-BIT SIGNED INTEGER
  WHEN "s"
   BINREADN ARY%,OFS%,2 OUT TMP%,OFS%
   DEFOUT I%+1,TMP%<<16>>16
  '16-BIT UNSIGNED INTEGER
  WHEN "S"
   BINREADN ARY%,OFS%,2 OUT TMP%,OFS%
   DEFOUT I%+1,TMP%
  '32-BIT SIGNED INTEGER
  WHEN "I"
   BINREADN ARY%,OFS%,4 OUT TMP%,OFS%
   DEFOUT I%+1,TMP%
  '8-BIT UNSIGNED INTEGER
  WHEN "B"
   BINREADN ARY%,OFS%,1 OUT TMP%,OFS%
   DEFOUT I%+1,TMP%
  '8-BIT SIGNED INTEGER
  WHEN "b"
   BINREADN ARY%,OFS%,1 OUT TMP%,OFS%
   DEFOUT I%+1,TMP%<<24>>24
  'NULL-TERMINATED ASCII STRING
  WHEN "N"
   VAR TMP$=""
   LOOP
    VAR C%
    BINREADN ARY%,OFS%,1 OUT C%,OFS%
    IF C%==0 THEN BREAK
    PUSH TMP$,CHR$(C%)
   ENDLOOP
   DEFOUT I%+1,TMP$
  ENDCASE
 NEXT
 DEFOUT 0,OFS%
END

ENUM\
     #FONTTBL_F,\
     #FONTTBL_X,\
     #FONTTBL_Y,\
     #FONTTBL_W,\
     #FONTTBL_H,\
     #FONTTBL_XOFF,\
     #FONTTBL_YOFF,\
     #FONTTBL_XADV,\
     #FONTTBL_PAGE,\
     #FONTTBL_CHNL,\
     #FONTTBL_SIZE
ENUM\
     #FONTTBL_INDEX_LAST=65536,\
     #FONTTBL_LEN
ENUM\
     #FONTTBL_L_LINE_H,\
     #FONTTBL_L_BASE,\
     #FONTTBL_L_SCALE_W,\
     #FONTTBL_L_SCALE_H,\
     #FONTTBL_L_PAGES,\
     #FONTTBL_L_BITFIELD_COMMON,\
     \
     #FONTTBL_L_TEXH
DIM FONT_ALPHA_PAL%[]
DIM FONT_PAL%[]
'INIT_FONT
'初期化する
COMMON DEF INIT_FONT
 VAR I%
 FONT_ALPHA_PAL%=ARRAY%(256)
 FOR I%=0TO 255
  FONT_ALPHA_PAL%[I%]=I%<<24
 NEXT
 FONT_PAL%=ARRAY%(256)
END


'GENERATE_GRPF FONT_DAT%,YOFFSET%,FULL_WIDTH_CHAR%
'フォントからGRPFをせいせいする
' FONT_DAT%       :フォントデータ
' YOFFSET%        :フォントのYざひょうをびちょうせいする
' FULL_WIDTH_CHAR%:#TRUEならばぜんかくえいすうをつかう
COMMON DEF GENERATE_GRPF FONT_DAT%,YOFFSET%,FULL_WIDTH_CHAR%
 FILL FONT_PAL%,&HFFFFFF
 ARYOP #AOPADD,FONT_PAL%,FONT_PAL%,FONT_ALPHA_PAL%
 VAR I%
 VAR TBL_I%=LEN(FONT_DAT%)-#FONTTBL_LEN*#FONTTBL_SIZE
 VAR GT%=GTARGET()
 VAR GCX1%,GCY1%,GCX2%,GCY2%
 GCLIP OUT GCX1%,GCY1%,GCX2%,GCY2%
 VAR LAST%=TBL_I%+#FONTTBL_INDEX_LAST*#FONTTBL_SIZE
 VAR BASE%=FONT_DAT%[LAST%+#FONTTBL_L_BASE]
 VAR LH%=FONT_DAT%[LAST%+#FONTTBL_L_LINE_H]
 VAR W%=FONT_DAT%[LAST%+#FONTTBL_L_SCALE_W]
 VAR H%=FONT_DAT%[LAST%+#FONTTBL_L_TEXH]
 VAR WORK_GP%=1
 DIM WORK%[]
 GSAVE WORK_GP%,0,0,16,16,WORK%
 VAR BY%=LH%-BASE%
 FOR I%=0TO 65535
  VAR X%,Y%
  IF !FULL_WIDTH_CHAR% THEN
   'Fullwidth
   IF I%>=&HFF01&&I%<=&HFF5ETHEN
    CONTINUE
   ENDIF
  ENDIF
  IF I%>=&HE800&&I%<=&HF7FF THEN CONTINUE
  VAR T%=TBL_I%+I%*#FONTTBL_SIZE
  FONTINFO I%,16 OUT X%,Y%
  IF X%==1008&&Y%==1184||!FONT_DAT%[T%+#FONTTBL_F] THEN
   CONTINUE
  ENDIF
  VAR P%=FONT_DAT%[T%+#FONTTBL_PAGE]
  VAR FX%=FONT_DAT%[T%+#FONTTBL_X]
  VAR FY%=FONT_DAT%[T%+#FONTTBL_Y]
  VAR FW%=FONT_DAT%[T%+#FONTTBL_W]
  VAR FH%=FONT_DAT%[T%+#FONTTBL_H]
  VAR XOFF%=FONT_DAT%[T%+#FONTTBL_XOFF]
  VAR YOFF%=FONT_DAT%[T%+#FONTTBL_YOFF]
  IF YOFF%+FH%>16THEN
   'YOFF%=-FH%+16
  ENDIF
  DEC YOFF%,BY%+YOFFSET%'-1
  VAR XADV%=FONT_DAT%[T%+#FONTTBL_XADV]
  GTARGET WORK_GP%
  GCLIP 0,0,FW%-1,FH%-1
  GLOAD -FX%,-FY%,W%,H%,FONT_DAT%,FONT_PAL%,#G_NORMAL
  GTARGET #GRPF
  GCLIP X%,Y%,X%+15,Y%+15
  GFILL X%,Y%,X%+15,Y%+15,0
  GCOPY WORK_GP%,0,0,FW%-1,FH%-1,X%+XOFF%+(16-XADV%)DIV 2,Y%+YOFF%,#G_NORMAL
 NEXT
 GTARGET WORK_GP%
 GLOAD 0,0,16,16,WORK%,#G_NORMAL
 GTARGET GT%
 GCLIP GCX1%,GCY1%,GCX2%,GCY2%
END

'LOAD_FONT NAME$ OUT FONT_DAT%[]
'ファイル名を指定してフォント読み込み
'IN
' NAME$:ファイル名
'OUT
' FONT_DAT%:フォントデータ
COMMON DEF LOAD_FONT NAME$ OUT FONT_DAT%[]
 FONT_DAT%=LOADV("DAT:"+NAME$)
END
'インチキをしてファイルのおおきさをさくげん(とうめいどを256/LEVEL%だんかいにしてあっしゅくりつをあげる)
COMMON DEF COMPRESS_FONT_DATA FONT_DAT%[],LEVEL%
 VAR TBL_I%=LEN(FONT_DAT%)-#FONTTBL_LEN*#FONTTBL_SIZE
 VAR LAST%=TBL_I%+#FONTTBL_INDEX_LAST*#FONTTBL_SIZE
 VAR W%=FONT_DAT%[LAST%+#FONTTBL_L_SCALE_W]
 VAR H%=FONT_DAT%[LAST%+#FONTTBL_L_TEXH]
 VAR I%
 FOR I%=0TO W%*H%-1
  IF FONT_DAT%[I%]==255 THEN CONTINUE
  FONT_DAT%[I%]=FONT_DAT%[I%] DIV LEVEL%*LEVEL%
 NEXT
END
'フォント画像の大きさを縮小してフォント情報をくっつけて一つの配列にまとめる
DEF REDUCE_FONT_DATA FONT_DAT%[],FONT_TBL%[]
 VAR I%
 VAR PAGES%=FONT_TBL%[#FONTTBL_INDEX_LAST,#FONTTBL_L_PAGES]
 VAR W%=FONT_TBL%[#FONTTBL_INDEX_LAST,#FONTTBL_L_SCALE_W]
 VAR H%=FONT_TBL%[#FONTTBL_INDEX_LAST,#FONTTBL_L_SCALE_H]
 VAR LAST_Y%=0
 FOR I%=0TO 65535
  VAR P%=FONT_TBL%[I%,#FONTTBL_PAGE]
  VAR FY%=FONT_TBL%[I%,#FONTTBL_Y]+P%*H%
  FONT_TBL%[I%,#FONTTBL_Y]=FY%
  IF P%!=PAGES%-1 THEN CONTINUE
  VAR FH%=FONT_TBL%[I%,#FONTTBL_H]
  LAST_Y%=MAX(LAST_Y%,FY%+FH%-1)
 NEXT
 ?LEN(FONT_DAT%) DIV W%;"->";LAST_Y%
 RESIZE FONT_DAT%,LAST_Y%*W%
 FONT_TBL%[#FONTTBL_INDEX_LAST,#FONTTBL_L_TEXH]=LAST_Y%
 COPY FONT_DAT%,LEN(FONT_DAT%),FONT_TBL%
END
'[&HAABBCCDD]->[AA,BB,CC,DD]
COMMON DEF GENERATE_FONT FNAME$ OUT FONT_DAT%[]
 VAR FONT_TBL%[]
 GEN_FONTTBL LOADV("DAT:"+FNAME$) OUT FONT_TBL%
 VAR I%
 VAR PAGES%=FONT_TBL%[#FONTTBL_INDEX_LAST,#FONTTBL_L_PAGES]
 VAR W%=FONT_TBL%[#FONTTBL_INDEX_LAST,#FONTTBL_L_SCALE_W]
 VAR H%=FONT_TBL%[#FONTTBL_INDEX_LAST,#FONTTBL_L_SCALE_H]
 FONT_TBL%[#FONTTBL_INDEX_LAST,#FONTTBL_L_TEXH]=H%*PAGES%
 FONT_DAT%=ARRAY%(W%*H%*PAGES%)
 VAR J%=0
 FOR I%=0TO PAGES%-1
  VAR G%=LOADV("DAT:"+FNAME$+"_"+STR$(I%))
  VAR X%,Y%
  VAR K%=0
  LOOP
   FOR Y%=I%*H% TO ((I%+1)*H%)-1
    FOR X%=0TO W% DIV 4-1
     VAR A1%,A2%,A3%,A4%
     RGB G%[K%] OUT A4%,A3%,A2%,A1%
     INC K%
     FONT_DAT%[J%]=A1%
     INC J%
     FONT_DAT%[J%]=A2%
     INC J%
     FONT_DAT%[J%]=A3%
     INC J%
     FONT_DAT%[J%]=A4%
     INC J%
    NEXT
   NEXT
   IF LEN(G%)==K% THEN BREAK
   INC I%
  ENDLOOP
 NEXT
 REDUCE_FONT_DATA FONT_DAT%,FONT_TBL%
END


'FONT_GET_LINE_HEIGHT FONT_DAT% OUT HEIGHT%
'そのフォントの行の高さを取得する
'IN
' FONT_DAT%:フォントデータ
'OUT
' HEIGHT%  :行の高さ
COMMON DEF FONT_GET_LINE_HEIGHT FONT_DAT% OUT HEIGHT%
 VAR TBL_I%=LEN(FONT_DAT%)-#FONTTBL_LEN*#FONTTBL_SIZE
 HEIGHT%=FONT_DAT%[TBL_I%+#FONTTBL_INDEX_LAST*#FONTTBL_SIZE+#FONTTBL_L_LINE_H]
END
'FONT_CALC_WIDTH FONT_DAT%,STR$ OUT WIDTH%
'文字列の幅を計算する
'IN
' FONT_DAT%:フォントデータ
' STR$     :幅をはかる文字列
'OUT
' WIDTH%   :計算された文字列の幅
COMMON DEF FONT_CALC_WIDTH FONT_DAT%,STR$ OUT WIDTH%
 VAR I%,L%=LAST(STR$)
 VAR TBL_I%=LEN(FONT_DAT%)-#FONTTBL_LEN*#FONTTBL_SIZE
 VAR LAST%=TBL_I%+#FONTTBL_INDEX_LAST*#FONTTBL_SIZE
 WIDTH%=0
 FOR I%=0TO L%
  VAR A%=ASC(STR$[I%])
  VAR T%=TBL_I%+A%*#FONTTBL_SIZE
  INC WIDTH%,FONT_DAT%[T%+#FONTTBL_XADV]
 NEXT
 RETURN WIDTH%
END
'GPUTCHR_FONT FONT_DAT%,X%,Y%,USE_BASE%,STR$,COL%
'フォントをつかって文字列を描画する
'プチコン4の制約によりCOL%の透明度は無視される
'IN
' FONT_DAT%:フォントデータ
' X%       :X
' Y%       :Y
' USE_BASE%:#TRUEの時ベースラインをY%の基準にする
' STR$     :描画する文字列
' COL%     :色
COMMON DEF GPUTCHR_FONT FONT_DAT%,X%,Y%,USE_BASE%,STR$,COL%
 VAR I%,L%=LAST(STR$),GCX1%,GCY1%,GCX2%,GCY2%
 DEC Y%,2
 FILL FONT_PAL%,COL% AND &HFFFFFF
 ARYOP #AOPADD,FONT_PAL%,FONT_PAL%,FONT_ALPHA_PAL%
 GCLIP OUT GCX1%,GCY1%,GCX2%,GCY2%
 VAR TBL_I%=LEN(FONT_DAT%)-#FONTTBL_LEN*#FONTTBL_SIZE
 VAR LAST%=TBL_I%+#FONTTBL_INDEX_LAST*#FONTTBL_SIZE
 VAR W%=FONT_DAT%[LAST%+#FONTTBL_L_SCALE_W]
 VAR H%=FONT_DAT%[LAST%+#FONTTBL_L_TEXH]
 IF USE_BASE% THEN
  DEC Y%,FONT_DAT%[LAST%+#FONTTBL_L_BASE]
 ENDIF
 FOR I%=0TO L%
  VAR A%=ASC(STR$[I%])
  VAR T%=TBL_I%+A%*#FONTTBL_SIZE
  VAR FX%=FONT_DAT%[T%+#FONTTBL_X]
  VAR FY%=FONT_DAT%[T%+#FONTTBL_Y]
  VAR FW%=FONT_DAT%[T%+#FONTTBL_W]
  VAR FH%=FONT_DAT%[T%+#FONTTBL_H]
  VAR XOFF%=FONT_DAT%[T%+#FONTTBL_XOFF]+X%
  VAR YOFF%=FONT_DAT%[T%+#FONTTBL_YOFF]+Y%
  X%=X%+FONT_DAT%[T%+#FONTTBL_XADV]
  'clipping
  IF GCX1%>=XOFF%+FW% ||\
     GCX2%<XOFF% ||\
     GCY1%>=YOFF%+FH% ||\
     GCY2%<YOFF% THEN CONTINUE
  GCLIP MAX(GCX1%,XOFF%),MAX(GCY1%,YOFF%),MIN(FW%+XOFF%-1,GCX2%),MIN(FH%+YOFF%-1,GCY2%)
  GLOAD XOFF%-FX%,YOFF%-FY%,W%,H%,FONT_DAT%,FONT_PAL%,#G_ALPHA2
 NEXT
 GCLIP GCX1%,GCY1%,GCX2%,GCY2%
END
COMMON DEF GPUTCHR_FONT_W FONT_DAT%,X%,Y%,USE_BASE%,STR$,COL% OUT TEXT_W%
 VAR I%,L%=LAST(STR$),GCX1%,GCY1%,GCX2%,GCY2%
 DEC Y%,2
 FILL FONT_PAL%,COL% AND &HFFFFFF
 ARYOP #AOPADD,FONT_PAL%,FONT_PAL%,FONT_ALPHA_PAL%
 GCLIP OUT GCX1%,GCY1%,GCX2%,GCY2%
 VAR TBL_I%=LEN(FONT_DAT%)-#FONTTBL_LEN*#FONTTBL_SIZE
 VAR LAST%=TBL_I%+#FONTTBL_INDEX_LAST*#FONTTBL_SIZE
 VAR W%=FONT_DAT%[LAST%+#FONTTBL_L_SCALE_W]
 VAR H%=FONT_DAT%[LAST%+#FONTTBL_L_TEXH]
 IF USE_BASE% THEN
  DEC Y%,FONT_DAT%[LAST%+#FONTTBL_L_BASE]
 ENDIF
 VAR SX%=X%
 FOR I%=0TO L%
  VAR A%=ASC(STR$[I%])
  VAR T%=TBL_I%+A%*#FONTTBL_SIZE
  VAR FX%=FONT_DAT%[T%+#FONTTBL_X]
  VAR FY%=FONT_DAT%[T%+#FONTTBL_Y]
  VAR FW%=FONT_DAT%[T%+#FONTTBL_W]
  VAR FH%=FONT_DAT%[T%+#FONTTBL_H]
  VAR XOFF%=FONT_DAT%[T%+#FONTTBL_XOFF]+X%
  VAR YOFF%=FONT_DAT%[T%+#FONTTBL_YOFF]+Y%
  X%=X%+FONT_DAT%[T%+#FONTTBL_XADV]
  'clipping
  IF GCX1%>=XOFF%+FW% ||\
     GCX2%<XOFF% ||\
     GCY1%>=YOFF%+FH% ||\
     GCY2%<YOFF% THEN CONTINUE
  GCLIP MAX(GCX1%,XOFF%),MAX(GCY1%,YOFF%),MIN(FW%+XOFF%-1,GCX2%),MIN(FH%+YOFF%-1,GCY2%)
  GLOAD XOFF%-FX%,YOFF%-FY%,W%,H%,FONT_DAT%,FONT_PAL%,#G_ALPHA2
 NEXT
 GCLIP GCX1%,GCY1%,GCX2%,GCY2%
 TEXT_W%=X%-SX%
END
'GPUTCHR_FONT_NCLIP FONT_DAT%,X%,Y%,USE_BASE%,STR$,COL%
'フォントをつかって文字列を描画する
'プチコン4の制約によりCOL%の透明度とGCLIPは無視される
'IN
' FONT_DAT%:フォントデータ
' X%       :X
' Y%       :Y
' USE_BASE%:#TRUEの時ベースラインをY%の基準にする
' STR$     :描画する文字列
' COL%     :色
COMMON DEF GPUTCHR_FONT_NCLIP FONT_DAT%,X%,Y%,USE_BASE%,STR$,COL%
 VAR I%,L%=LAST(STR$),GCX1%,GCY1%,GCX2%,GCY2%
 FILL FONT_PAL%,COL% AND &HFFFFFF
 ARYOP #AOPADD,FONT_PAL%,FONT_PAL%,FONT_ALPHA_PAL%
 GCLIP OUT GCX1%,GCY1%,GCX2%,GCY2%
 VAR TBL_I%=LEN(FONT_DAT%)-#FONTTBL_LEN*#FONTTBL_SIZE
 VAR LAST%=TBL_I%+#FONTTBL_INDEX_LAST*#FONTTBL_SIZE
 VAR W%=FONT_DAT%[LAST%+#FONTTBL_L_SCALE_W]
 VAR H%=FONT_DAT%[LAST%+#FONTTBL_L_TEXH]
 IF USE_BASE% THEN
  DEC Y%,FONT_DAT%[LAST%+#FONTTBL_L_BASE]
 ENDIF
 FOR I%=0TO L%
  VAR T%=TBL_I%+ASC(STR$[I%])*#FONTTBL_SIZE
  VAR XOFF%=FONT_DAT%[T%+#FONTTBL_XOFF]+X%
  VAR YOFF%=FONT_DAT%[T%+#FONTTBL_YOFF]+Y%
  GCLIP XOFF%,YOFF%,FONT_DAT%[T%+#FONTTBL_W]+XOFF%-1,FONT_DAT%[T%+#FONTTBL_H]+YOFF%-1
  GLOAD XOFF%-FONT_DAT%[T%+#FONTTBL_X],YOFF%-FONT_DAT%[T%+#FONTTBL_Y],W%,H%,FONT_DAT%,FONT_PAL%,#G_ALPHA2
  X%=X%+FONT_DAT%[T%+#FONTTBL_XADV]
 NEXT
 GCLIP GCX1%,GCY1%,GCX2%,GCY2%
END

'BMFファイルからフォント情報配列を生成
DEF GEN_FONTTBL FILE%[] OUT O_TBL%
 DIM TABLE%[#FONTTBL_LEN,#FONTTBL_SIZE]
 VAR OFS%=0
 VAR MAGIC_B%,MAGIC_M%,MAGIC_F%
 VAR VER%
 VAR BLOCK_TYPE_IDEN%
 VAR BLOCK_LEN%
 VAR FONTSIZE%,BITFIELD%,CHARSET%,STRETCHH%,AA%,PADDINGUP%,PADDINGRIGHT%,PADDINGDOWN%,PADDINGLEFT%,SPACINGHORIZ%,SPACINGVERT%,OUTLINE%,FONTNAME$
 BINREAD FILE%,OFS%,"BBBB" OUT OFS%,MAGIC_B%,MAGIC_M%,MAGIC_F%,VER%
 CONST\
       #BMF_BLOCK_INFO=1,\
       #BMF_BLOCK_COMMON=2,\
       #BMF_BLOCK_PAGES=3,\
       #BMF_BLOCK_CHARS=4,\
       #BMF_BLOCK_KERNING_PARTS=5
 LOOP
  IF OFS% DIV 4>=LEN(FILE%)-1THEN BREAK
  BINREAD FILE%,OFS%,"B" OUT OFS%,BLOCK_TYPE_IDEN%
  BINREAD FILE%,OFS%,"I" OUT OFS%,BLOCK_LEN%
  VAR OLD_OFS%=OFS%
  CASE BLOCK_TYPE_IDEN%
  WHEN #BMF_BLOCK_INFO
   BINREAD FILE%,OFS%,"sBBSBBBBBBBBN" OUT OFS%,FONTSIZE%,BITFIELD%,CHARSET%,STRETCHH%,AA%,PADDINGUP%,PADDINGRIGHT%,PADDINGDOWN%,PADDINGLEFT%,SPACINGHORIZ%,SPACINGVERT%,OUTLINE%,FONTNAME$
  WHEN #BMF_BLOCK_COMMON
   VAR lineHeight%
   VAR base%
   VAR scaleW%
   VAR scaleH%
   VAR pages%
   VAR bitFieldCommon%
   VAR alphaChnl%
   VAR redChnl%
   VAR greenChnl%
   VAR blueChnl%
   BINREAD FILE%,OFS%,"SSSSSBSSSS" OUT OFS%,lineHeight%,base%,scaleW%,\
                                       scaleH%,pages%,bitFieldCommon%,\
                                       alphaChnl%,redChnl%,greenChnl%,\
                                       blueChnl%
   TABLE%[#FONTTBL_INDEX_LAST,#FONTTBL_L_LINE_H]=lineHeight%
   TABLE%[#FONTTBL_INDEX_LAST,#FONTTBL_L_BASE]=base%
   TABLE%[#FONTTBL_INDEX_LAST,#FONTTBL_L_SCALE_W]=scaleW%
   TABLE%[#FONTTBL_INDEX_LAST,#FONTTBL_L_SCALE_H]=scaleH%
   TABLE%[#FONTTBL_INDEX_LAST,#FONTTBL_L_PAGES]=pages%
   TABLE%[#FONTTBL_INDEX_LAST,#FONTTBL_L_BITFIELD_COMMON]=bitFieldCommon%
  WHEN #BMF_BLOCK_PAGES
   LOOP
    VAR PAGE$
    BINREAD FILE%,OFS%,"N" OUT OFS%,PAGE$
    IF OFS%>=OLD_OFS%+BLOCK_LEN% THEN BREAK
   ENDLOOP
  WHEN #BMF_BLOCK_CHARS
   LOOP
    VAR ID%,X%,Y%,WIDTH%,HEIGHT%,X_OFF%,Y_OFF%,X_ADV%,PAGE%,CHNL%
    BINREAD FILE%,OFS%,"ISSSSsssBB" OUT\
            OFS%,ID%,X%,Y%,WIDTH%,HEIGHT%,X_OFF%,Y_OFF%,X_ADV%,PAGE%,CHNL%
    TABLE%[ID%,#FONTTBL_F]=1
    TABLE%[ID%,#FONTTBL_X]=X%
    TABLE%[ID%,#FONTTBL_Y]=Y%
    TABLE%[ID%,#FONTTBL_W]=WIDTH%
    TABLE%[ID%,#FONTTBL_H]=HEIGHT%
    TABLE%[ID%,#FONTTBL_XOFF]=X_OFF%
    TABLE%[ID%,#FONTTBL_YOFF]=Y_OFF%
    TABLE%[ID%,#FONTTBL_XADV]=X_ADV%
    TABLE%[ID%,#FONTTBL_PAGE]=PAGE%
    TABLE%[ID%,#FONTTBL_CHNL]=CHNL%
    IF OFS%>=OLD_OFS%+BLOCK_LEN% THEN BREAK
   ENDLOOP
  WHEN #BMF_BLOCK_KERNING_PARTS
   '''
  ENDCASE
  IF OFS%!=OLD_OFS%+BLOCK_LEN% THEN
   '?"INVALID FMT",BLOCK_TYPE_IDEN%,#_SLOT,#_LINE,#_FILENAME
  ENDIF
  OFS%=OLD_OFS%+BLOCK_LEN%
 ENDLOOP
 O_TBL%=TABLE%
END

