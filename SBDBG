CONST #VERSION$="1.0.0.153"
'VAR ARY=LOADV("GRP:BUG")
'VAR I=0
'DIM UNIQ[0]
'VAR R$="DIM ARY%["+STR$(DIM(ARY,0))+","+STR$(DIM(ARY,1))+"]=["
'FOR I=0TO LAST(ARY)
' FOR J=0TO LAST(UNIQ)
'  IF UNIQ[J]==ARY[I]THEN
'   IF I THEN PUSH R$,","
'   PUSH R$,CHR$(65+J)
'   BREAK
'  ENDIF
' NEXT
' IF J==LEN(UNIQ)THEN
'  PUSH UNIQ,ARY[I]
'  DEC I
'  CONTINUE
' ENDIF
'NEXT
'PUSH R$,"]"+CHR$(10)
'VAR R2$=""
' FOR J=0TO LAST(UNIQ)
'  PUSH R2$," VAR "+CHR$(65+J)+"=&H"+HEX$(UNIQ[J])+CHR$(10)
' NEXT
'CLIPBOARD R2$+R$
'
'STOP
OPTION STRICT
OPTION DEFINT
VAR NOT_USED_SLOT=2
VAR RVM_SLOT=3
VAR NOT_USED_SLOT$=STR$(NOT_USED_SLOT)+":"
VAR RVM_SLOT$=STR$(RVM_SLOT)+":"
'Debug Monitor
IF ENVTYPE()==1 THEN
 DEBUGMON
 RETURN
ENDIF
DEF DEBUGMON
 ENVFOCUS 0
 VAR OFS_X=0
 VAR OFS_Y=0
 VAR SCR_WIDTH=1280
 VAR SCR_HEIGHT=720
 VAR WIDTH=SCR_WIDTH
 VAR HEIGHT=SCR_HEIGHT
 VAR GRPF_OFS_X=512,GRPF_OFS_Y=0
 BACKCOLOR 0
 VAR GP=0
 XSCREEN WIDTH,HEIGHT
 SPPAGE #GSPRITE,GP
 SPCHR #GSPRITE,GRPF_OFS_X,GRPF_OFS_Y,WIDTH,HEIGHT
 SPCOLOR #GSPRITE,RGB(192,255,255,255)
 SPOFS #GSPRITE,0,0
 GTARGET #GRPF
 VAR R$=""
 VAR OLDP=GPGET(2047,2047)
 VAR OLD_PONG=MILLISEC()
 XSUBSCREEN 0
 PUSHKEY "CONT"+CHR$(13)
 VAR TIMEOUT=100'ms
 LOOP
  VAR UPDATED=#FALSE
  ENVLOAD 1,#GRPF,#GRPF
  VAR P=GPGET(2047,2047)
  IF P!=OLDP&&P THEN
   XSUBSCREEN OFS_X,OFS_Y,SCR_WIDTH-OFS_X,SCR_HEIGHT-OFS_Y
   OLD_PONG=MILLISEC()
   OLDP=P
   UPDATED=#TRUE
  ENDIF
  IF UPDATED THEN
   GTARGET GP
   GCOPY #GRPF,GRPF_OFS_X,GRPF_OFS_Y,GRPF_OFS_X+WIDTH-1,GRPF_OFS_Y+HEIGHT-1,GRPF_OFS_X,GRPF_OFS_Y,#G_NORMAL
   GTARGET #GRPF
  ENDIF
  IF MILLISEC()-OLD_PONG>=TIMEOUT THEN XSUBSCREEN 0
  LOOP
   VAR K$=INKEY$()
   IF K$=="" THEN BREAK
   PUSH R$,K$
   IF K$==CHR$(10)THEN
    IF R$=="PING"+CHR$(10)THEN
     ENVFOCUS 0
     VSYNC
     PUSHKEY "PONG"+CHR$(10)+"Debug Monitor ver 1.0"+CHR$(10)
    ENDIF
    R$=""
   ENDIF
  ENDLOOP
  VSYNC
 ENDLOOP
END

'SPLAY_TEST
'END
VAR TRACE=#FALSE

'VSLOT_INIT
'VSLOT_TEST
MAIN
END
DEF GET_SLOT$(N)
 PRGEDIT N
 VAR S$=""
 VAR I,L=PRGSIZE(N)
 FOR I=1TO L
  PUSH S$,PRGGET$()
 NEXT
 RETURN S$
END
DEF GET_VSLOT$(N)
 VSLOT_PRGEDIT N,0
 VAR S$=""
 VAR I,L=VSLOT_PRGSIZE(N,0)
 FOR I=1TO L
  PUSH S$,VSLOT_PRGGET$(#TRUE)
 NEXT
 RETURN S$
END
DEF SET_VSLOT N,V$
 VSLOT_PRGEDIT N,1
 VSLOT_PRGDEL -1
 VSLOT_PRGSET V$
 VSLOT_PRGDEL 1
 IF LEN(V$)>0&&ASC(V$[LAST(V$)])==10THEN
  VSLOT_PRGDEL 1
 ENDIF
END
DEF SET_SLOT N,V$
 PRGEDIT N,1
 PRGDEL -1
 PRGSET V$
 PRGDEL 1
 IF LEN(V$)>0&&ASC(V$[LAST(V$)])==10THEN
  PRGDEL 1
 ENDIF
END
DEF MAIN
 VAR SW,SH,TS,TS2
' ACLS
 XSCREEN OUT SW,SH
 IF SW!=1280||SH!=720THEN
  XSCREEN 1280,720
 ENDIF
 TSCREEN OUT TS,TS2,,
 IF TS!=16||TS2!=16THEN
  TSCREEN 16
 ENDIF
 CLS
 VSLOT_INIT
 VAR IN$=GET_SLOT$(1)
' SET_VSLOT 3,IN$
' IN$=GET_SLOT$(2)
' SET_VSLOT 2,IN$
' IN$=GET_SLOT$(1)
' SET_VSLOT 1,IN$
 IN$=GET_SLOT$(1)
 SET_VSLOT 0,IN$
 LOGO
 REPL_MAIN
END
DEF LOGO
 ?"PetitComputer フ゜チコン ver4.0.2
 ?"SMILEBASIC for SMILEBASIC ";FREEMEM();" bytes free"
 ?
 ?"READY"
END
VAR LEXER_IN$
VAR LEXER_I
VAR LEXER_PREV_I2
VAR LEXER_PREV_I
VAR LEXER_LINE
VAR LEXER_LINE_POS
VAR LEXER_PREV_LINE
VAR LEXER_PREV_LINE_POS
VAR LEXER_VAL
ENUM\
 #TKN_NONE,\
 #TKN_NUM,\
 #TKN_STR,\
 #TKN_PRINT,\
 #TKN_DEF,\
 #TKN_RETURN,\
 #TKN_IDEN,\
 #TKN_PLUS,\
 #TKN_MINUS,\
 #TKN_MUL,\
 #TKN_DIV,\
 #TKN_DIVINT,\
 #TKN_COMMA,\
 #TKN_LP,\
 #TKN_RP,\
 #TKN_LB,\
 #TKN_RB,\
 #TKN_SEMI,\
 #TKN_COL,\
 #TKN_NEWLINE,\
 #TKN_EOF,\
 #TKN_MOD,\
 #TKN_LSHIFT,\
 #TKN_RSHIFT,\
 #TKN_EQ,\
 #TKN_NEQ,\
 #TKN_LESS,\
 #TKN_LEQ,\
 #TKN_GREAT,\
 #TKN_GEQ,\
 #TKN_AND,\
 #TKN_OR,\
 #TKN_XOR,\
 #TKN_LAND,\
 #TKN_LOR,\
 #TKN_ASSIGN,\
 #TKN_NOT,\
 #TKN_LNOT,\
 #TKN_OUT,\
 #TKN_CALL,\
 #TKN_VAR,\
 #TKN_IF,\
 #TKN_THEN,\
 #TKN_ENDIF,\
 #TKN_ELSE,\
 #TKN_ELSEIF,\
 #TKN_FOR,\
 #TKN_NEXT,\
 #TKN_GOTO,\
 #TKN_GOSUB,\
 #TKN_BREAK,\
 #TKN_CONTINUE,\
 #TKN_WHILE,\
 #TKN_WEND,\
 #TKN_REPEAT,\
 #TKN_UNTIL,\
 #TKN_LOOP,\
 #TKN_ENDLOOP,\
 #TKN_LABEL,\
 #TKN_ON,\
 #TKN_DATA,\
 #TKN_RESTORE,\
 #TKN_CONST,\
 #TKN_ENUM,\
 #TKN_CONSTVAR,\
 #TKN_END,\
 #TKN_TPRINT,\
 #TKN_READ,\
 #TKN_INC,\
 #TKN_DEC,\
 #TKN_CASE,\
 #TKN_WHEN,\
 #TKN_OTHERWISE,\
 #TKN_ENDCASE,\
 #TKN_SWAP,\
 #TKN_COMMON,\
 #TKN_DEFOUT,\
 #TKN_INPUT,\
 #TKN_LINPUT,\
 #TKN_EXEC,\
 #TKN_INSPECT,\
 #TKN_DIM,\
 #TKN_,\
 #TKN_LAST
DEF TKN_STR$(T)
 CASE T
 WHEN #TKN_NONE:RETURN "#TKN_NONE"WHEN #TKN_NUM:RETURN "#TKN_NUM"WHEN #TKN_STR:RETURN "#TKN_STR"WHEN #TKN_PRINT:RETURN "#TKN_PRINT"WHEN #TKN_DEF:RETURN "#TKN_DEF"WHEN #TKN_RETURN:RETURN "#TKN_RETURN"WHEN #TKN_IDEN:RETURN "#TKN_IDEN"WHEN #TKN_PLUS:RETURN "#TKN_PLUS"WHEN #TKN_MINUS:RETURN "#TKN_MINUS"WHEN #TKN_MUL:RETURN "#TKN_MUL"WHEN #TKN_DIV:RETURN "#TKN_DIV"WHEN #TKN_DIVINT:RETURN "#TKN_DIVINT"WHEN #TKN_COMMA:RETURN "#TKN_COMMA"WHEN #TKN_LP:RETURN "#TKN_LP"WHEN #TKN_RP:RETURN "#TKN_RP"WHEN #TKN_LB:RETURN "#TKN_LB"WHEN #TKN_RB:RETURN "#TKN_RB"WHEN #TKN_SEMI:RETURN "#TKN_SEMI"WHEN #TKN_COL:RETURN "#TKN_COL"WHEN #TKN_NEWLINE:RETURN "#TKN_NEWLINE"WHEN #TKN_EOF:RETURN "#TKN_EOF"WHEN #TKN_MOD:RETURN "#TKN_MOD"WHEN #TKN_LSHIFT:RETURN "#TKN_LSHIFT"WHEN #TKN_RSHIFT:RETURN "#TKN_RSHIFT"WHEN #TKN_EQ:RETURN "#TKN_EQ"WHEN #TKN_NEQ:RETURN "#TKN_NEQ"WHEN #TKN_LESS:RETURN "#TKN_LESS"WHEN #TKN_LEQ:RETURN "#TKN_LEQ"WHEN #TKN_GREAT:RETURN "#TKN_GREAT"WHEN #TKN_GEQ:RETURN "#TKN_GEQ"WHEN #TKN_AND:RETURN "#TKN_AND"WHEN #TKN_OR:RETURN "#TKN_OR"WHEN #TKN_XOR:RETURN "#TKN_XOR"WHEN #TKN_LAND:RETURN "#TKN_LAND"WHEN #TKN_LOR:RETURN "#TKN_LOR"WHEN #TKN_ASSIGN:RETURN "#TKN_ASSIGN"WHEN #TKN_NOT:RETURN "#TKN_NOT"WHEN #TKN_LNOT:RETURN "#TKN_LNOT"WHEN #TKN_OUT:RETURN "#TKN_OUT"WHEN #TKN_CALL:RETURN "#TKN_CALL"WHEN #TKN_VAR:RETURN "#TKN_VAR"WHEN #TKN_IF:RETURN "#TKN_IF"WHEN #TKN_THEN:RETURN "#TKN_THEN"WHEN #TKN_ENDIF:RETURN "#TKN_ENDIF"WHEN #TKN_ELSE:RETURN "#TKN_ELSE"WHEN #TKN_ELSEIF:RETURN "#TKN_ELSEIF"WHEN #TKN_FOR:RETURN "#TKN_FOR"WHEN #TKN_NEXT:RETURN "#TKN_NEXT"WHEN #TKN_GOTO:RETURN "#TKN_GOTO"WHEN #TKN_GOSUB:RETURN "#TKN_GOSUB"WHEN #TKN_BREAK:RETURN "#TKN_BREAK"WHEN #TKN_CONTINUE:RETURN "#TKN_CONTINUE"WHEN #TKN_WHILE:RETURN "#TKN_WHILE"WHEN #TKN_WEND:RETURN "#TKN_WEND"WHEN #TKN_REPEAT:RETURN "#TKN_REPEAT"WHEN #TKN_UNTIL:RETURN "#TKN_UNTIL"WHEN #TKN_LOOP:RETURN "#TKN_LOOP"WHEN #TKN_ENDLOOP:RETURN "#TKN_ENDLOOP"WHEN #TKN_LABEL:RETURN "#TKN_LABEL"WHEN #TKN_ON:RETURN "#TKN_ON"WHEN #TKN_DATA:RETURN "#TKN_DATA"WHEN #TKN_RESTORE:RETURN "#TKN_RESTORE"WHEN #TKN_CONST:RETURN "#TKN_CONST"WHEN #TKN_ENUM:RETURN "#TKN_ENUM"WHEN #TKN_CONSTVAR:RETURN "#TKN_CONSTVAR"WHEN #TKN_END:RETURN "#TKN_END"WHEN #TKN_TPRINT:RETURN "#TKN_TPRINT"WHEN #TKN_READ:RETURN "#TKN_READ"WHEN #TKN_INC:RETURN "#TKN_INC"WHEN #TKN_DEC:RETURN "#TKN_DEC"WHEN #TKN_CASE:RETURN "#TKN_CASE"WHEN #TKN_WHEN:RETURN "#TKN_WHEN"WHEN #TKN_OTHERWISE:RETURN "#TKN_OTHERWISE"WHEN #TKN_ENDCASE:RETURN "#TKN_ENDCASE"WHEN #TKN_SWAP:RETURN "#TKN_SWAP"WHEN #TKN_COMMON:RETURN "#TKN_COMMON"WHEN #TKN_DEFOUT:RETURN "#TKN_DEFOUT"WHEN #TKN_INPUT:RETURN "#TKN_INPUT"WHEN #TKN_LINPUT:RETURN "#TKN_LINPUT"WHEN #TKN_EXEC:RETURN "#TKN_EXEC"WHEN #TKN_INSPECT:RETURN "#TKN_INSPECT"WHEN #TKN_DIM:RETURN "#TKN_DIM"WHEN #TKN_:RETURN "#TKN_"
 OTHERWISE
  RETURN "#TKN_"+STR$(T)
 ENDCASE
END
DEF REPL_RUN SLOT
 VM_RESET
' VAR IN$=LOADV("TXT:SOS64")'

' VAR IN$=GET_VSLOT$(SLOT)'LOADV("TXT:SOS64")'
 VAR IN$=GET_SLOT$(3)'LOADV("TXT:SOS64")'
 INIT_LEXER IN$
 INIT_AST
 INIT_PARSER SLOT
 VAR AST=PARSE()
' DUMP_AST AST,0
 INIT_COMPILER SLOT
 INIT_VM
 COMPILE AST
' LOAD_VM_SLOT SLOT
 VM_RUN_SLOT SLOT
 VM_RUN
 IF VM_IS_STOPPED()THEN
  ?VM_LASTERR$()
 ENDIF
 ?"OK"
END
DEF REPL_RRUN SLOT
 VM_RESET
' VAR IN$=LOADV("TXT:SOS64")'

' VAR IN$=GET_VSLOT$(SLOT)'LOADV("TXT:SOS64")'
'SLOT=1
'SLOT=0
' SET_VSLOT 0,LOADV("TXT:MAIN.PRG")
 VAR IN$=GET_VSLOT$(SLOT)'LOADV("TXT:SOS64")'
 INIT_LEXER IN$
 INIT_AST
 INIT_PARSER SLOT
 VAR AST=PARSE()
' DUMP_AST AST,0
 INIT_RCOMPILER SLOT
 INIT_VM
 RCOMPILE AST
' LOAD_VM_SLOT SLOT
 VM_RUN_SLOT SLOT
 RVM_RUN
' VM_RUN
 IF VM_IS_STOPPED()THEN
  ?VM_LASTERR$()
 ENDIF
 ?"OK"
 STOP
END
DEF REPL_MAIN
 INIT_VM
 VAR AST
' REPL_RRUN 0
 GDEBUG 0
 LOOP
  VAR D$
  LINPUT D$
  INIT_LEXER D$
  VAR T,V
  LEX_NEXT OUT T,V
  IF T==#TKN_IDEN&&V=="RUN"THEN
   LEX_NEXT OUT T,V
   VAR SLOT=0
   IF T==#TKN_EOF THEN
   ELSEIF T==#TKN_NUM THEN
    SLOT=V
   ELSE
    ILLEGAL_FUNCTION_CALL
    CONTINUE
   ENDIF
   VM_RESET
   VAR IN$=GET_VSLOT$(SLOT)
   INIT_LEXER IN$
   INIT_AST
   INIT_PARSER SLOT
   AST=PARSE()
   IF!PARSER_HAS_ERROR() THEN
    INIT_COMPILER SLOT
    INIT_VM
    COMPILE AST
    IF!COMPILER_HAS_ERROR() THEN
'     LOAD_VM_SLOT SLOT
     VM_RUN_SLOT SLOT
     VM_RUN
    ENDIF
   ENDIF
  ELSEIF T==#TKN_IDEN&&V=="CONT"THEN
   VM_CONT
  ELSEIF T==#TKN_IDEN&&V=="DEBUG"THEN
   LEX_NEXT OUT T,V
   SLOT=0
   IF T==#TKN_EOF THEN
   ELSEIF T==#TKN_NUM THEN
    SLOT=V
   ELSE
    ILLEGAL_FUNCTION_CALL
    CONTINUE
   ENDIF
   DEBUG SLOT
  ELSEIF T==#TKN_IDEN&&V=="GDEBUG"THEN
   LEX_NEXT OUT T,V
   SLOT=0
   IF T==#TKN_EOF THEN
   ELSEIF T==#TKN_NUM THEN
    SLOT=V
   ELSE
    ILLEGAL_FUNCTION_CALL
    CONTINUE
   ENDIF
   GDEBUG SLOT
  ELSE
   INIT_LEXER D$
   INIT_AST
   INIT_PARSER SLOT
   AST=PARSE()
   INIT_COMPILER_REPL
   COMPILE AST
'   LOAD_VM_SLOT_REPL
   VM_RUN
  ENDIF
  IF VM_IS_STOPPED()THEN
   ?VM_LASTERR$()
  ENDIF
  ?"OK"
 ENDLOOP
END
DEF PARSE_DBGCMD DBGC$ OUT PARSED$
 VAR I,R$=""
 PARSED$=ARRAY$(0)
 FOR I=0 TO LAST(DBGC$)
  VAR C$=DBGC$[I]
  IF C$==" "THEN
   IF LEN(R$)THEN
    PUSH PARSED$,R$
    R$=""
   ENDIF
   CONTINUE
  ELSE
   PUSH R$,C$
  ENDIF
 NEXT
 IF LEN(R$)THEN
  PUSH PARSED$,R$
  R$=""
 ENDIF
END
DEF DEBUG_INIT SLOT
 VM_RESET
 VAR IN$=GET_VSLOT$(SLOT)
 INIT_LEXER IN$
 INIT_AST
 INIT_PARSER SLOT
 ?"PARSE
 PERFBEGIN 0
 VAR AST=PARSE()
 ?PERFEND(0)/1000000
 ?"END PARSE
 INIT_RCOMPILER SLOT
 INIT_VM
 RCOMPILE AST
' LOAD_VM_SLOT SLOT
 VM_RUN_SLOT SLOT
END
DEF DEBUG SLOT
 ?"Debugger SLOT ";SLOT
 ?"COMMAND"
 ?"BREAK|B [SLOT:]LINE -- BREAKPOINT"
 ?"BREAK|B FUNCTION -- BREAKPOINT"
 ?"DELETE -- DELETE ALL BREAKPOINTS"
 ?"NEXT|N"
 ?"STEP|S"
 ?"BACKTRACE|BT -- BACKTRACE"
 ?"RUN|R"
 ?"FRAME|F N -- SELECT A STACK FRAME"
 ?"HELP -- SHOW HELP"
 LOOP
  VAR DBGC$
  LINPUT ") ";DBGC$
  VAR ARGS$=PARSE_DBGCMD(DBGC$)
  IF LEN(ARGS$)THEN
   CASE ARGS$[0]
   WHEN "R"
   WHEN "RUN"
    DEBUG_CMD_RUN ARGS$
   WHEN "B"
   WHEN "BREAK"
    DEBUG_CMD_BREAK ARGS$
   WHEN "N"
   WHEN "NEXT"
    DEBUG_CMD_NEXT ARGS$
   WHEN "S"
   WHEN "STEP"
    DEBUG_CMD_STEP ARGS$
   WHEN "BT"
   WHEN "BACKTRACE"
    DEBUG_CMD_BACKTRACE ARGS$
    CONTINUE
   ENDCASE
  ENDIF
  IF VM_IS_STOPPED()THEN
   ?VM_LASTERR$()
  ENDIF
 ENDLOOP
END
DEF DEBUG_CMD_RUN ARGS$
 VM_RUN
 IF VMDBG_IS_STOPPED_AT_BP()THEN
  ?"Breakpoint at ";VM_GET_CURLOC$()
  VAR SLOT,LINE
  VMDBG_GET OUT SLOT,LINE,
  ?VSLOT_GETLINE$(SLOT,LINE);
 ENDIF
END
DEF DEBUG_CMD_BREAK ARGS$
 VAR SLOT=0
 VAR LINE=VAL(ARGS$[1])
 VAR PC
 VMDBG_GET_PC SLOT,LINE OUT PC
 VMDBG_SET_BP SLOT,PC
END
DEF DEBUG_GETLINESTR$(LINE)
 VAR I
 VAR E$=""
 VAR C$=""
 FOR I=0TO 2
  VAR L=LINE MOD 100
  LINE=LINE DIV 100
  IF LINE&&L<10 THEN
   C$[2-I]=CHR$(ASC("")+L)
  ELSE
   C$[2-I]=CHR$(ASC("")+L)
  ENDIF
  IF!LINE THEN BREAK
 NEXT
 RETURN C$
END
DEF DEBUG_CMD_STEP ARGS$
 VAR SLOT,LINE
 VAR OSLOT,OLINE
 VMDBG_GET OUT OSLOT,OLINE,
 LOOP
  VM_TRACE_RUN #TRUE
  IF!VM_IS_RUNNING()THEN
   ?"END"
   BREAK
  ENDIF
  VMDBG_GET OUT SLOT,LINE,
  IF VMDBG_IS_STOPPED_AT_BP()THEN
   ?"Breakpoint at ";VM_GET_CURLOC$()
   VMDBG_GET OUT SLOT,LINE,
   ?DEBUG_GETLINESTR$(LINE);VSLOT_GETLINE$(SLOT,LINE);
   VM_DUMP_CURRENT
   BREAK
  ENDIF
  IF SLOT!=OSLOT||OLINE!=LINE THEN
   ?"Step ";VM_GET_CURLOC$()
   ?DEBUG_GETLINESTR$(LINE);VSLOT_GETLINE$(SLOT,LINE);
   VM_DUMP_CURRENT
   BREAK
  ENDIF
  IF VM_IS_STOPPED()THEN
   BREAK
  ENDIF
  OSLOT=SLOT
  OLINE=LINE
 ENDLOOP
END
DEF DEBUG_CMD_NEXT ARGS$
 VAR SLOT,LINE
 VAR OSLOT,OLINE
 VMDBG_GET OUT OSLOT,OLINE,
 LOOP
  VM_TRACE_RUN #FALSE
  IF!VM_IS_RUNNING()THEN
   ?"END"
   BREAK
  ENDIF
  VMDBG_GET OUT SLOT,LINE,
  IF VMDBG_IS_STOPPED_AT_BP()THEN
   ?"Breakpoint at ";VM_GET_CURLOC$()
   VMDBG_GET OUT SLOT,LINE,
   ?DEBUG_GETLINESTR$(LINE);VSLOT_GETLINE$(SLOT,LINE);
   VM_DUMP_CURRENT
   BREAK
  ENDIF
  IF SLOT!=OSLOT||OLINE!=LINE THEN
   ?"Next ";VM_GET_CURLOC$()
   ?DEBUG_GETLINESTR$(LINE);VSLOT_GETLINE$(SLOT,LINE);
   VM_DUMP_CURRENT
   BREAK
  ENDIF
  IF VM_IS_STOPPED()THEN
   BREAK
  ENDIF
  OSLOT=SLOT
  OLINE=LINE
 ENDLOOP
END
DEF DEBUG_CMD_BACKTRACE ARGS$
 VAR SLOT,LINE,INFO$
 VM_BACKTRACE #FALSE OUT SLOT,LINE,INFO$
 VAR I
 FOR I=0TO LAST(SLOT)
  ?"#";I,SLOT[I];":";STR$(LINE[I],6);
  IF LEN(INFO$[I])THEN
   ?"(";INFO$[I];")"
  ELSE
   ?
  ENDIF
 NEXT
END
'あくまでカンイうぃんどうカンリらいぶらり
'オモいのほかフクザツなGUIをコウチクしたせいでスゴいメンドウになったけどメをツブることにする
DIM GWIN_X[]
DIM GWIN_Y[]
DIM GWIN_REL_X[]
DIM GWIN_REL_Y[]
DIM GWIN_DRAW_X[]
DIM GWIN_DRAW_Y[]
DIM GWIN_W[]
DIM GWIN_H[]
DIM GWIN_FW1[]
DIM GWIN_FH1[]
DIM GWIN_FW2[]
DIM GWIN_FH2[]
DIM GWIN_PREV[]
DIM GWIN_NEXT[]
DIM GWIN_PARENT[]
DIM GWIN_CHILD[]
DIM GWIN_NAME$[]
DIM GWIN_EVENT$[]
DIM GWIN_VAR[,]
DIM GWIN_VAR$[,]
DIM GWIN_ID[]
DIM GWIN_MENU[]
DIM GWIN_FLG[]
DIM GWIN_NOTIF[]
DIM GWIN_CURSOR$[]
DIM GWIN_MIN_W[]
DIM GWIN_MIN_H[]
VAR GWIN_IDCNT
VAR GWIN_FREE
VAR GWIN_INPUT
VAR GWIN_ACTIVE
VAR GWIN_OVER_WIN
VAR GWIN_OVER_WIN_FRM
VAR GWIN_1[],GWIN_2[],GWIN_3[],GWIN_4[],GWIN_5[],GWIN_6[],GWIN_7[],GWIN_8[],GWIN_9[],GWIN_10[],GWIN_11[],GWIN_12[],GWIN_13[],GWIN_14[],GWIN_15[],GWIN_16[],GWIN_17[],GWIN_18[],GWIN_19[],GWIN_20[],GWIN_21[],GWIN_22[],GWIN_23[]
VAR GWIN_CAPTURE_GW
VAR GWIN_CAPTURE_FRAME
VAR GWIN_CAPTURE_X
VAR GWIN_CAPTURE_Y
VAR GWIN_UPDATED
CONST #GWIN_MAX_VAR=12
DIM GMENUI_NAME$[]
DIM GMENUI_NEXT[]
DIM GMENUI_PREV[]
DIM GMENUI_CHILD[]
DIM GMENUI_PARENT[]
DIM GMENUI_TYPE[]
DIM GMENUI_SUB[]
DIM GMENUI_ID[]
DIM GMENUI_FLG[]
VAR GMENUI_FREE

DIM GMENU_WIDTH[]
DIM GMENU_NEXT[]
DIM GMENU_CHILD[]
DIM GMENU_PARENT[]
DIM GMENU_TYPE[]
DIM GMENU_OLD_SEL[]
DIM GMENU_OLD_SEL_WIN[]
DIM GMENU_WIN[]
DIM GMENU_TAB_X[]
DIM GMENU_WIN2[]
VAR GMENU_FREE

'DBL CLK
CONST #GWIN_MAX_MBUTTON=5
DIM GWIN_DBL_CLK_X[]
DIM GWIN_DBL_CLK_Y[]
DIM GWIN_DBL_CLK_MS[]

VAR GWIN_DBL_CLK_HYSTERESIS_X
VAR GWIN_DBL_CLK_HYSTERESIS_Y
VAR GWIN_DBL_CLK_INTERVAL_MS
DEF GDEBUG_MENU_INIT
 VAR S=20
 GMENU_WIDTH=ARRAY%(S)
 GMENU_NEXT=ARRAY%(S)
 GMENU_CHILD=ARRAY%(S)
 GMENU_PARENT=ARRAY%(S)
 GMENU_TYPE=ARRAY%(S)
 GMENU_OLD_SEL=ARRAY%(S)
 GMENU_OLD_SEL_WIN=ARRAY%(S)
 GMENU_WIN=ARRAY%(S)
 GMENU_WIN2=ARRAY%(S)
 GMENU_TAB_X=ARRAY%(S)
 VAR I
 FOR I=1TO S-2
  GMENU_NEXT[I]=I+1
 NEXT
 GMENU_FREE=1
END
DEF GDEBUG_MENUI_INIT
 VAR S=400
 GMENUI_NAME$=ARRAY$(S)
 GMENUI_NEXT=ARRAY%(S)
 GMENUI_PREV=ARRAY%(S)
 GMENUI_CHILD=ARRAY%(S)
 GMENUI_PARENT=ARRAY%(S)
 GMENUI_TYPE=ARRAY%(S)
 GMENUI_SUB=ARRAY%(S)
 GMENUI_ID=ARRAY%(S)
 GMENUI_FLG=ARRAY%(S)
 VAR I
 FOR I=1TO S-2
  GMENUI_NEXT[I]=I+1
 NEXT
 GMENUI_FREE=1
END
DEF NEW_GMENUI()
 IF!GMENUI_FREE THEN STOP
 VAR L=GMENUI_FREE
 GMENUI_FREE=GMENUI_NEXT[GMENUI_FREE]
 GMENUI_NEXT[L]=0
 RETURN L
END
DEF NEW_GMENU()
 IF!GMENU_FREE THEN STOP
 VAR L=GMENU_FREE
 GMENU_FREE=GMENU_NEXT[GMENU_FREE]
 GMENU_NEXT[L]=0
 RETURN L
END
CONST #GMENU_FLG_GRAYED=1
CONST #GMENU_FLG_SEPARATOR=2
DEF GMENU_SEARCH_BY_ID GMENU,ID OUT GMENUI
 GMENUI=GMENU_CHILD[GMENU]
 WHILE GMENUI
  IF GMENUI_ID[GMENUI]==ID THEN RETURN
  GMENUI=GMENUI_NEXT[GMENUI]
 WEND
END
DEF GMENU_SET_FLG GMENU,ID,FLG
 VAR GMENUI
 GMENU_SEARCH_BY_ID GMENU,ID OUT GMENUI
 IF!GMENUI THEN
  RETURN
 ENDIF
 GMENUI_FLG[GMENUI]=FLG
END
DEF GMENU_GET_SUB(GMENU,ID)
 VAR GMENUI
 GMENU_SEARCH_BY_ID GMENU,ID OUT GMENUI
 IF!GMENUI THEN
  RETURN -1
 ENDIF
 RETURN GMENUI_CHILD[GMENUI]
END

DEF GMENU_ADD_ITEM GMENU,NAME$,ID,SUB,FLG
 VAR I=NEW_GMENUI()
 GMENUI_NAME$[I]=NAME$
 GMENUI_ID[I]=ID
 GMENUI_CHILD[I]=SUB
 GMENUI_FLG[I]=FLG
 IF SUB THEN
  GMENU_PARENT[SUB]=GMENU
 ENDIF
 IF!GMENU_CHILD[GMENU]THEN
  GMENU_CHILD[GMENU]=I
 ELSE
  VAR C=GMENU_CHILD[GMENU]
  WHILE C
   IF!GMENUI_NEXT[C]THEN BREAK
   C=GMENUI_NEXT[C]
  WEND
  GMENUI_NEXT[C]=I
  GMENUI_PREV[I]=C
 ENDIF
END
VAR GWIN_OPACITY
DEF GWIN_SET_OPACITY O
 GWIN_OPACITY=O
END
DEF GDEBUG_WIN_INIT
 GWIN_SET_OPACITY 204
 GDEBUG_MENU_INIT
 GDEBUG_MENUI_INIT
 VAR S=24
 GWIN_X=ARRAY%(S)
 GWIN_Y=ARRAY%(S)
 GWIN_W=ARRAY%(S)
 GWIN_H=ARRAY%(S)
 GWIN_FW1=ARRAY%(S)
 GWIN_FH1=ARRAY%(S)
 GWIN_FW2=ARRAY%(S)
 GWIN_FH2=ARRAY%(S)
 GWIN_NEXT=ARRAY%(S)
 GWIN_PREV=ARRAY%(S)
 GWIN_NAME$=ARRAY$(S)
 GWIN_EVENT$=ARRAY$(S)
 GWIN_PARENT=ARRAY%(S)
 GWIN_CHILD=ARRAY%(S)
 GWIN_REL_X=ARRAY%(S)
 GWIN_REL_Y=ARRAY%(S)
 GWIN_DRAW_X=ARRAY%(S)
 GWIN_DRAW_Y=ARRAY%(S)
 GWIN_VAR=ARRAY%(S,#GWIN_MAX_VAR)
 GWIN_VAR$=ARRAY$(S,#GWIN_MAX_VAR)
 GWIN_ID=ARRAY%(S)
 GWIN_MENU=ARRAY%(S)
 GWIN_FLG=ARRAY%(S)
 GWIN_NOTIF=ARRAY%(S)
 GWIN_CURSOR$=ARRAY$(S)
 GWIN_MIN_W=ARRAY%(S)
 GWIN_MIN_H=ARRAY%(S)
 VAR I
 FOR I=1TO S-2
  GWIN_NEXT[I]=I+1
 NEXT
 GWIN_FREE=1
 GWIN_INIT_CURSOR
 GWIN_DBL_CLK_X=ARRAY%(#GWIN_MAX_MBUTTON)
 GWIN_DBL_CLK_Y=ARRAY%(#GWIN_MAX_MBUTTON)
 GWIN_DBL_CLK_MS=ARRAY%(#GWIN_MAX_MBUTTON)
 GWIN_DBL_CLK_HYSTERESIS_X=10
 GWIN_DBL_CLK_HYSTERESIS_Y=10
 GWIN_DBL_CLK_INTERVAL_MS=500
END
DEF GWIN_SET_FRAME_BUF G,AR
 VAR("GWIN_"+STR$(G))=AR
END
DEF GWIN_GET_FRAME_BUF(G)
 RETURN VAR("GWIN_"+STR$(G))
END
ENUM\
 #GWIN_EVENT_PAINT,\
 #GWIN_EVENT_LDWN,\
 #GWIN_EVENT_RDWN,\
 #GWIN_EVENT_MDWN,\
 #GWIN_EVENT_B4DWN,\
 #GWIN_EVENT_B5DWN,\
 #GWIN_EVENT_LUP,\
 #GWIN_EVENT_RUP,\
 #GWIN_EVENT_MUP,\
 #GWIN_EVENT_B4UP,\
 #GWIN_EVENT_B5UP,\
 #GWIN_EVENT_LDBL,\
 #GWIN_EVENT_RDBL,\
 #GWIN_EVENT_MDBL,\
 #GWIN_EVENT_B4DBL,\
 #GWIN_EVENT_B5DBL,\
 #GWIN_EVENT_MMOVE,\
 #GWIN_EVENT_NEW,\
 #GWIN_EVENT_NOTIF,\
 #GWIN_EVENT_INKEY,\
 #GWIN_EVENT_CHFOCUS,\
 #GWIN_EVENT_CHFOCUS_CHILD,\
 #GWIN_EVENT_LEAVE,\
 #GWIN_EVENT_WHEEL,\
 #GWIN_EVENT_DELETE,\
 #GWIN_EVENT_ACTIVE,\
 #GWIN_EVENT_LAST

ENUM\
 #GWIN_NOTIF_NONE,\
 #GWIN_NOTIF_BUTTON_PUSHED,\
 #GWIN_NOTIF_ENTER,\
 #GWIN_NOTIF_LOST_FOCUS,\
 #GWIN_NOTIF_MENU,\
 #GWIN_NOTIF_LAST
VAR GWIN_ROOT
ENUM #GWIN_DRAW_BUTTON_RAIS,#GWIN_DRAW_BUTTON_ETCHED,#GWIN_DRAW_BUTTON_SUNK,#GWIN_DRAW_BUTTON_RAISED,#GWIN_DRAW_BUTTON_SUNKEN

DEF GWIN_SET_VAR GW,V,K
 GWIN_VAR[GW,V]=K
END
DEF GWIN_GET_VAR(GW,V)
 RETURN GWIN_VAR[GW,V]
END
DEF GWIN_SET_VAR$ GW,V,K
 GWIN_VAR$[GW,V]=K
END
DEF GWIN_GET_VAR$(GW,V)
 RETURN GWIN_VAR$[GW,V]
END
DEF GWIN_SET_ARY GW,V,INDEX,VALUE
 VAR V$=GWIN_VAR$[GW,V]
 IF LEN(V$)<INDEX*2+2 THEN
  COPY V$,INDEX*2+2,CHR$(0),0'HACK:RESIZE STRING
 ENDIF
 V$[INDEX*2]=CHR$(VALUE)
 V$[INDEX*2+1]=CHR$(VALUE>>16)
END
DEF GWIN_GET_ARY(GW,V,INDEX)
 VAR V$=GWIN_VAR$[GW,V]
 IF LEN(V$)<INDEX*2+2 THEN
  COPY V$,INDEX*2+2,CHR$(0),0'HACK:RESIZE STRING
 ENDIF
 RETURN (ASC(V$[INDEX*2+1])<<16) OR ASC(V$[INDEX*2])
END
DEF GWIN_DELETE_CHILD GW
 WHILE GW
  VAR NXT=GWIN_NEXT[GW]
  GWIN_DELETE GW
  GW=NXT
 WEND
END
VAR GWIN_SYS_MODAL
DEF GWIN_DELETE GW
 GWIN_UPDATED=#TRUE
 GWIN_CALL_EVENT GW,#GWIN_EVENT_DELETE,0,0,0,0
 GWIN_DELETE_CHILD GWIN_CHILD[GW]
 IF GW==GWIN_SYS_MODAL THEN GWIN_SYS_MODAL=0
 IF GW==GWIN_ACTIVE THEN GWIN_ACTIVE=GWIN_PARENT[GW]
 IF GW==GWIN_INPUT THEN GWIN_INPUT=GWIN_PARENT[GW]
 IF GW==GWIN_OVER_WIN THEN GWIN_OVER_WIN=GWIN_PARENT[GW]'FIXME CURSOR
 VAR NXT=GWIN_NEXT[GW]
 VAR PRV=GWIN_PREV[GW]
 IF !NXT&&!PRV THEN RETURN
 VAR GWIN_BACK=GWIN_CHILD[GWIN_PARENT[GW]]
 IF GWIN_BACK==GW THEN
  GWIN_CHILD[GWIN_PARENT[GW]]=NXT
 ENDIF
 IF PRV THEN
  GWIN_NEXT[PRV]=NXT
 ENDIF
 IF NXT THEN
  GWIN_PREV[NXT]=PRV
 ENDIF
 GWIN_NEXT[GW]=GWIN_FREE
 GWIN_FREE=GW
 GWIN_ID[GW]=0
 GWIN_MENU[GW]=0
 GWIN_PARENT[GW]=0
 GWIN_CHILD[GW]=0
 VAR I,N$
 GWIN_CURSOR$[GW]=N$
 GWIN_NAME$[GW]=N$
 GWIN_EVENT$[GW]=N$
 FOR I=0TO #GWIN_MAX_VAR-1
  GWIN_VAR[GW,I]=0
  GWIN_VAR$[GW,I]=N$
 NEXT
END
DEF GWIN_CLOSE GW
 GWIN_DELETE GW
END
CONST #GWIN_FLG_NOFRAME=1
CONST #GWIN_FLG_HIDE=2
CONST #GWIN_FLG_NCLOSEABLE=4
CONST #GWIN_FLG_MINMAX=8
CONST #GWIN_FLG_NACTV=16
CONST #GWIN_FLG_RESIZE=32
DEF GWIN_NEW(PARENT,RX,RY,W,H,NAME$,FUNC$)
 RETURN GWIN_NEW2(PARENT,RX,RY,W,H,NAME$,FUNC$,0)
END
DEF GWIN_NEW2(PARENT,RX,RY,W,H,NAME$,FUNC$,FLG)
 RETURN GWIN_NEW3(PARENT,RX,RY,W,H,NAME$,FUNC$,FLG,0,0,0,0)
END
DEF GWIN_NEW3(PARENT,RX,RY,W,H,NAME$,FUNC$,FLG,A1,A2,A3,A4)
 VAR G=GWIN_FREE
 IF !G THEN RETURN -1
 GWIN_FREE=GWIN_NEXT[G]
 GWIN_X[G]=RX+GWIN_X[PARENT]+GWIN_FW1[PARENT]
 GWIN_Y[G]=RY+GWIN_Y[PARENT]+GWIN_FH1[PARENT]
 IF PARENT!=GWIN_ROOT THEN
  GWIN_DRAW_X[G]=RX+GWIN_DRAW_X[PARENT]+GWIN_FW1[PARENT]
  GWIN_DRAW_Y[G]=RY+GWIN_DRAW_Y[PARENT]+GWIN_FH1[PARENT]
 ELSE
  GWIN_DRAW_X[G]=0
  GWIN_DRAW_Y[G]=0
 ENDIF
 GWIN_REL_X[G]=RX
 GWIN_REL_Y[G]=RY
 GWIN_W[G]=W
 GWIN_H[G]=H
 GWIN_FW1[G]=0
 GWIN_FH1[G]=0
 GWIN_FW2[G]=0
 GWIN_FH2[G]=0
 GWIN_FLG[G]=FLG
 GWIN_NAME$[G]=NAME$
 GWIN_EVENT$[G]=FUNC$
 GWIN_NOTIF[G]=PARENT
 GWIN_CURSOR$[G]="GWIN_CURSOR_ARROW"
 INC GWIN_IDCNT
 GWIN_ID[G]=GWIN_IDCNT
 IF PARENT THEN
  VAR GWIN_BACK=GWIN_CHILD[PARENT]
  GWIN_NEXT[G]=GWIN_BACK
  IF GWIN_BACK THEN
   GWIN_PREV[GWIN_BACK]=G
  ENDIF
  GWIN_CHILD[PARENT]=G
 ENDIF
 GWIN_PREV[G]=0
 GWIN_MIN_W[G]=0
 GWIN_MIN_H[G]=0
 GWIN_PARENT[G]=PARENT
 IF PARENT&&PARENT==GWIN_ROOT THEN
  GWIN_SET_FRAME_BUF G,ARRAY%(W*H)
  GWIN_CALL_EVENT_NC G,#GWIN_EVENT_NEW,0,0,0,0
 ELSE
  GWIN_FLG[G]=FLG OR #GWIN_FLG_NOFRAME
 ENDIF
 CALL GWIN_EVENT$[G],G,#GWIN_EVENT_NEW,A1,A2,A3,A4
 IF PARENT&&PARENT==GWIN_ROOT THEN
  GWIN_PAINT G,#TRUE
 ENDIF
 GWIN_FOCUS G
 RETURN G
END
DEF GWIN_SET_MENU GW,MENU
 GWIN_MENU[GW]=MENU
END
ENUM\
 #GDEBUG_KEY_F1=58,\
 #GDEBUG_KEY_F2,\
 #GDEBUG_KEY_F3,\
 #GDEBUG_KEY_F4,\
 #GDEBUG_KEY_F5,\
 #GDEBUG_KEY_F6,\
 #GDEBUG_KEY_F7,\
 #GDEBUG_KEY_F8,\
 #GDEBUG_KEY_F9,\
 #GDEBUG_KEY_F10,\
 #GDEBUG_KEY_F11,\
 #GDEBUG_KEY_F12

ENUM \
 #CK_UP = &h10000, #CK_DOWN, #CK_LEFT, #CK_RIGHT,\
 #CK_BS, #CK_DEL, #CK_PAGEUP, #CK_PAGEDOWN, #CK_TAB,\
 #CK_LINETOP, #CK_LINEEND, #CK_LINEJUMP,\
 #CK_FILETOP, #CK_FILEEND,\
 #CK_INSLINE, #CK_DELLINE, #CK_DELRIGHT, #CK_UNDO, #CK_REDO,\
 #CK_SELECTSTART, #CK_SELECTEND,\
 #CK_COPY, #CK_CUT, #CK_PASTE, #CK_SMARTDEL,\
 #CK_RUN, #CK_EDIT, #CK_EDIT0, #CK_EDIT1, #CK_EDIT2, #CK_EDIT3,\
 #CK_STOP, #CK_EXIT, #CK_TOOL, #CK_TOOL2, #CK_TOOL3, #CK_SYSREQ,\
 #CK_LOAD, #CK_SAVE, #CK_LISTERR, #CK_SOFTKEY, #CK_ESCAPE,\
 #CK_FONT, #CK_WRAP,\
 #CK_SPLIT, #CK_SPLIT_SINGLE, #CK_SPLIT_VERTICAL, #CK_SPLIT_HORIZONAL,\
 #CK_TAB_INC, #CK_TAB_DEC, #CK_COMMENTOUT, #CK_UNCOMMENTOUT,\
 #CK_SCROLL_UP, #CK_SCROLL_DOWN, #CK_SCROLL_LEFT,\
 #CK_SCROLL_RIGHT, #CK_SCROLL_PAGEUP, #CK_SCROLL_PAGEDOWN,\
 #CK_HELP, #CK_HELP_ON, #CK_HELP_OFF,\
 #_obsolete_CK_HELP_PREVHEADER, #_obsolete_CK_HELP_NEXTHEADER, #_obsolete_CK_HELP_COPY,\
 #_obsolete_CK_HELP_UP, #_obsolete_CK_HELP_DOWN, #_obsolete_CK_HELP_UPD,\
 #CK_FIND_REPL, #_obsolete_CK_FIND_REPLALL, #_obsolete_CK_FIND_REPLNEXT,\
 #CK_FIND_REPLSWITCH, #CK_FIND_PREV, #CK_FIND_NEXT, #CK_FINDMODE,\
 #CK_FOCUS_NEXT, #CK_FOCUS_PREV, #CK_FOCUS_MAIN, #CK_FOCUS_SUB,\
 #CK_FUNC1, #CK_FUNC2, #CK_FUNC3, #CK_FUNC4, #CK_FUNC5,\
 #CK_INSERT, #CK_RESET,\
 #CK_SOFTKEY_ON, #CK_SOFTKEY_OFF, #CK_TRACE, #CK_PERFGAUGE,\
 #CK_SPLIT_GUIDE, #CK_COMPLETION_OFF,\
 #CK_SOFTKEY_RIGHT,#CK_SOFTKEY_DOWN,#CK_SOFTKEY_LEFT,#CK_SOFTKEY_UP,\
 #CK_ENUMEND

VAR GDEBUG_TEMP_PAGE
VAR GDEBUG_OFFSCREEN_PAGE
DEF GDEBUG_GETLINE$()
 VAR R$=""
 LOOP
  VAR K$=INKEY$()
  IF !LEN(K$) THEN RETURN R$
  PUSH R$,K$
  IF K$==CHR$(10)THEN RETURN R$
 ENDLOOP
END
VAR GDEBUG_OFFX
VAR GDEBUG_OFFY
VAR GDEBUG_WIDTH
VAR GDEBUG_HEIGHT
DIM GDEBUG_SYS_FONT[]

DEF GDEBUG_DEBUGMON_PING()
 ?"->PING"
 PUSHKEY #CK_FOCUS_SUB
 VSYNC
 PUSHKEY CHR$(10)+"PING"+CHR$(10)
 VSYNC
 PUSHKEY #CK_FOCUS_MAIN
 VSYNC 10
 VAR OK
 LOOP
  VAR LINE$=GDEBUG_GETLINE$()
  IF LINE$=="PONG"+CHR$(10)THEN
   ?"<-PONG"
   ?"<-";GDEBUG_GETLINE$();
   OK=#TRUE
  ENDIF
  IF LINE$=="" THEN BREAK
 ENDLOOP
 IF!OK THEN RETURN OK
 PUSHKEY #CK_FOCUS_SUB
 VSYNC
 PUSHKEY CHR$(10)+"LOADDAT SOURCEHAN-CODE-JP-N12.FONT"+CHR$(10)
 VSYNC
 PUSHKEY #CK_FOCUS_MAIN
 VSYNC
 VAR BEG=MILLISEC()
 LOOP
  LINE$=GDEBUG_GETLINE$()
  IF INSTR(LINE$,"LOADED ")==0THEN
   VAR FN$=MID$(LINE$,LEN("LOADED "),&H7FFFFFFF)
   FN$=MID$(FN$,0,LAST(FN$))
   VAR ORIG_LEN=VAL(FN$)
   DIM D%[ORIG_LEN+2048-ORIG_LEN MOD 2048]
   GSAVE 2,0,0,2048,LEN(D%) DIV 2048,D%
   GDEBUG_SYS_FONT=D%
   RESIZE D%,ORIG_LEN
   BREAK
  ENDIF
  IF MILLISEC()-BEG>1000 THEN BREAK
 ENDLOOP
 RETURN OK
END
CONST\
 #GDEBUG_UPDATE_BACKTRACE=1,\
 #GDEBUG_UPDATE_VAR=2,\
 #GDEBUG_UPDATE_SRC=4,\
 #GDEBUG_UPDATE_ERROR=8
VAR GDEBUG_PRG_GWIN
VAR GDEBUG_VAR_GWIN
VAR GDEBUG_BACKTRACE_GWIN
ENUM #GDEBUG_PRG_V_REQ_SCROLL,#GDEBUG_PRG_V_REQ_SCROLL_LINE,#GDEBUG_PRG_V_SEL_MODE,#GDEBUG_PRG_V_SEL_WORD_SI,#GDEBUG_PRG_V_SEL_WORD_I
ENUM #GDEBUG_PRG_SEL_MODE_NONE,#GDEBUG_PRG_SEL_MODE_LINE,#GDEBUG_PRG_SEL_MODE_WORD
DEF GDEBUG_UPDATE_WINDOW MASK
 IF MASK AND #GDEBUG_UPDATE_BACKTRACE THEN
'  GWIN_SCR_RESET GWIN_FIND(GDEBUG_BACKTRACE_GWIN,"SCRBAR")
  GWIN_PAINT GDEBUG_BACKTRACE_GWIN,#FALSE
 ENDIF
 IF MASK AND #GDEBUG_UPDATE_VAR THEN
'  GWIN_SCR_RESET GWIN_FIND(GDEBUG_VAR_GWIN,"SCRBAR")
  GWIN_PAINT GDEBUG_VAR_GWIN,#FALSE
 ENDIF
 IF MASK AND #GDEBUG_UPDATE_SRC THEN
  GWIN_SET_VAR GDEBUG_PRG_GWIN,#GDEBUG_PRG_V_REQ_SCROLL,#TRUE
  GWIN_PAINT GDEBUG_PRG_GWIN,#FALSE
 ENDIF
 IF MASK AND #GDEBUG_UPDATE_ERROR THEN
  IF VM_IS_STOPPED()THEN
   ?VM_LASTERR$()
   IF !VM_IS_CONTINUABLE()THEN
    GWIN_MSG_BOX_ERR VM_LASTERR$()
   ENDIF
  ENDIF
 ENDIF
END
VAR GDEBUG_SYS_FONT_SIZE
VAR GDEBUG_CURRENT_FRAME
VAR GDEBUG_SLOT
DEF GDEBUG SLOT
 INIT_FONT
 GDEBUG_SLOT=SLOT
 GDEBUG_SYS_FONT_SIZE=12
' VAR AAAAA$=FONT_TO_STR(GDEBUG_SYS_FONT)
 VMDBG_SET_STOP_HANDLER STR$(#_SLOT)+":@GDEBUG_STOP_HANDLER"
 'GRAPHICAL DEBUGGER
 VAR WIDTH=1280
 VAR HEIGHT=720
 VAR OFFX=512
 VAR OFFY=0
 GDEBUG_OFFX=OFFX
 GDEBUG_OFFY=OFFY
 GDEBUG_WIDTH=WIDTH
 GDEBUG_HEIGHT=HEIGHT
 VAR GPAGE=#GRPF
 GDEBUG_TEMP_PAGE=2
 GDEBUG_OFFSCREEN_PAGE=3
 GTARGET GDEBUG_OFFSCREEN_PAGE
 SYSPARAM "MOUSECURSOR",#FALSE
 GDEBUG_WIN_INIT
 GDEBUG_SAVE_STATE
 GDEBUG_CONT
END
@GDEBUG_STOP_HANDLER
 GDEBUG_SHOW
 GDEBUG_UPDATE_WINDOW #GDEBUG_UPDATE_BACKTRACE OR #GDEBUG_UPDATE_VAR OR #GDEBUG_UPDATE_SRC OR #GDEBUG_UPDATE_ERROR
 GDEBUG_MAIN
END
COMMON DEF GDEBUG_CONT_DEBUGMON
 VAR X,Y
 LOCATE OUT X,Y
 VAR LC$=""
 VAR W,H
 TSCREEN OUT ,,W,H
 VAR Y1=Y-3
 VAR Y2=Y1+1
 FOR Y=Y1 TO Y2
  FOR X=0TO W-1
   IF CHKCHR(X,Y)||1 THEN
    PUSH LC$,CHR$(CHKCHR(X,Y))
   ENDIF
  NEXT
 NEXT
 VAR UBO$="User break on "+STR$(3)+":"
 VAR UBO=INSTR(LC$,UBO$)
 IF UBO!=-1 THEN
  VAR I
  VAR LINE$=""
  FOR I=UBO+LEN(UBO$) TO LAST(LC$)
   IF LC$[I]>="0"&&LC$[I]<="9"THEN
    PUSH LINE$,LC$[I]
   ELSE
    BREAK
   ENDIF
  NEXT
  IF LEN(LINE$)THEN
   VAR RL=VAL(LINE$)
   RVMDBG_CONT RL
  ENDIF
 ENDIF
END
COMMON DEF GDEBUG_CONT
 IF GDEBUG_DEBUGMON_PING() THEN
 ELSE
  ?"DEBUGMONが起動していません"
  ?"F5キーまたはCTRL+Cまたはボタンを押して下さい"
  VAR PRV$=KEY(1)
  KEY 1,"SUBRUN "+CHR$(34)+"SOS/DEBUGMON"+CHR$(34)+CHR$(13)
  LOOP
   VAR OM=MILLISEC()
   PUSHKEY #CK_FUNC1
   IF MILLISEC()-OM>=100 THEN
    BREAK
   ENDIF
  ENDLOOP
  IF PRV$=="SUBRUN "+CHR$(34)+"SOS/DEBUGMON"+CHR$(34)+CHR$(13) THEN PRV$="FILES"
  KEY 1,PRV$
  IF GDEBUG_DEBUGMON_PING() THEN
  ENDIF
 ENDIF
 ?"Graphical Debugger"
 GDEBUG_MAIN
END

CONST #GWIN_RES_END=-1
CONST #GWIN_RES_MENU_BEGIN=-2
CONST #GWIN_RES_MENU_END=-3
CONST #GWIN_RES_MENU_GRAYED=-4
CONST #GWIN_RES_MENU_SEPARATOR=-5
ENUM\
#GDBG_MENU_FILE=1,\
#GDBG_MENU_FILE_IMPORT_SLOT,\
#GDBG_MENU_FILE_IMPORT_SLOT_0,\
#GDBG_MENU_FILE_IMPORT_SLOT_1,\
#GDBG_MENU_FILE_IMPORT_SLOT_2,\
#GDBG_MENU_FILE_IMPORT_SLOT_3,\
#GDBG_MENU_FILE_LOAD,\
#GDBG_MENU_FILE_EXIT,\
#GDBG_MENU_DEBUG,\
#GDBG_MENU_DEBUG_COMPILE,\
#GDBG_MENU_DEBUG_RESUME,\
#GDBG_MENU_DEBUG_TERM,\
#GDBG_MENU_DEBUG_START,\
#GDBG_MENU_DEBUG_RESTART,\
#GDBG_MENU_DEBUG_STEPINTO,\
#GDBG_MENU_DEBUG_STEPOVER,\
#GDBG_MENU_DEBUG_STEPOUT,\
#GDBG_MENU_DEBUG_RUNTOCUR,\
#GDBG_MENU_DEBUG_JMPTOCUR,\
#GDBG_MENU_DEBUG_TOGGLE_BP,\
#GDBG_MENU_DEBUG_EVAL,\
#GDBG_MENU_WINDOW,\
#GDBG_MENU_WINDOW_RESET,\
#GDBG_MENU_WINDOW_OPACITY,\
#GDBG_MENU_WINDOW_OPACITY_100,\
#GDBG_MENU_WINDOW_OPACITY_90,\
#GDBG_MENU_WINDOW_OPACITY_80,\
#GDBG_MENU_WINDOW_OPACITY_70,\
#GDBG_MENU_WINDOW_OPACITY_60,\
#GDBG_MENU_WINDOW_OPACITY_50,\
#GDBG_MENU_WINDOW_OPACITY_40,\
#GDBG_MENU_WINDOW_OPACITY_30,\
#GDBG_MENU_HELP,\
#GDBG_MENU_HELP_ABOUT,\
#GDBG_ABOUT,\
#GDBG_ABOUT_NAME,\
#GDBG_ABOUT_AUTHOR,\
#GDBG_VARIABLE,\
#GDBG_VARIABLE_NAME,\
#GDBG_VARIABLE_VALUE,\
#GDBG_VARIABLE_TYPE,\
#GDBG_VARIABLE_GLOBALS,\
#GDBG_VARIABLE_LOCALS,\
#GDBG_VARIABLE_CONSTS,\
#GDBG_BACKTRACE,\
#GDBG_BACKTRACE_SLOT,\
#GDBG_BACKTRACE_LINE,\
#GDBG_BACKTRACE_NAME,\
\
#GDBG_CMENU_JUMPTODEF,\
#GDBG_CMENU_CUT,\
#GDBG_CMENU_COPY,\
#GDBG_CMENU_PASTE,\
\
\
#GDBG_EVAL,\
#GDBG_EVAL_EXPR,\
#GDBG_EVAL_VALUE,\
#GDBG_EVAL_REEVAL,\
\
#GDBG_VAR_CMENU_EDIT,\
#GDBG_VAR_CMENU_COPY,\
#GDBG_VAR_CMENU_OPEN_EVAL_WINDOW,\
\
#GDBG_EXIT_MSG,\
#GDBG_DISCARD_SLOT_MSG,\
#GDBG_ERR_SLOT_MSG,\
#GDBG_MSGBOX_ERROR,\
#GDBG_MSGBOX_OK,\
#GDBG_MSGBOX_YES,\
#GDBG_MSGBOX_NO,\
#GDBG_MSGBOX_CANCEL,\
\
#GDBG_TXTBOX_UNDO,\
#GDBG_TXTBOX_REDO,\
#GDBG_TXTBOX_CUT,\
#GDBG_TXTBOX_COPY,\
#GDBG_TXTBOX_PASTE,\
#GDBG_TXTBOX_DELETE,\
#GDBG_TXTBOX_SELALL,\
\
#GDBG_RES_LAST

@GDBG_MENU_EN
DATA #GDBG_MENU_FILE,"File"
DATA #GDBG_MENU_FILE_IMPORT_SLOT,"Import SLOT"
DATA #GDBG_MENU_FILE_IMPORT_SLOT_0,"SLOT 0"
DATA #GDBG_MENU_FILE_IMPORT_SLOT_1,"SLOT 1"
DATA #GDBG_MENU_FILE_IMPORT_SLOT_2,"SLOT 2"
DATA #GDBG_MENU_FILE_IMPORT_SLOT_3,"SLOT 3"
DATA #GDBG_MENU_FILE_LOAD,"Load File"
DATA #GDBG_MENU_FILE_EXIT,"Exit"
DATA #GDBG_MENU_DEBUG,"Debug"
DATA #GDBG_MENU_DEBUG_COMPILE,"Compile"
DATA #GDBG_MENU_DEBUG_RESUME,"Resume"
DATA #GDBG_MENU_DEBUG_START,"Start"
DATA #GDBG_MENU_DEBUG_TERM,"Terminate"
DATA #GDBG_MENU_DEBUG_RESTART,"Restart"
DATA #GDBG_MENU_DEBUG_STEPINTO,"Step Into"
DATA #GDBG_MENU_DEBUG_STEPOVER,"Step Over"
DATA #GDBG_MENU_DEBUG_STEPOUT,"Step Out"
DATA #GDBG_MENU_DEBUG_RUNTOCUR,"Run to Cursor"
DATA #GDBG_MENU_DEBUG_JMPTOCUR,"Jump to Cursor"
DATA #GDBG_MENU_DEBUG_TOGGLE_BP,"Toggle Breakpoint"
DATA #GDBG_MENU_DEBUG_EVAL,"Evaluate Expression"
DATA #GDBG_MENU_WINDOW,"Window"
DATA #GDBG_MENU_WINDOW_RESET,"Reset"
DATA #GDBG_MENU_WINDOW_OPACITY,"Opacity"
DATA #GDBG_MENU_WINDOW_OPACITY_100,"100%"
DATA #GDBG_MENU_WINDOW_OPACITY_90,"90%"
DATA #GDBG_MENU_WINDOW_OPACITY_80,"80%"
DATA #GDBG_MENU_WINDOW_OPACITY_70,"70%"
DATA #GDBG_MENU_WINDOW_OPACITY_60,"60%"
DATA #GDBG_MENU_WINDOW_OPACITY_50,"50%"
DATA #GDBG_MENU_WINDOW_OPACITY_40,"40%"
DATA #GDBG_MENU_WINDOW_OPACITY_30,"30%"
DATA #GDBG_MENU_HELP,"Help"
DATA #GDBG_MENU_HELP_ABOUT,"About SBDBG"
DATA #GDBG_ABOUT,"About SBDBG"

DATA #GDBG_VARIABLE,"Variable"
DATA #GDBG_VARIABLE_NAME,"Name"
DATA #GDBG_VARIABLE_VALUE,"Value"
DATA #GDBG_VARIABLE_TYPE,"Type"
DATA #GDBG_VARIABLE_GLOBALS,"Globals"
DATA #GDBG_VARIABLE_LOCALS,"Locals"
DATA #GDBG_VARIABLE_CONSTS,"Consts"
DATA #GDBG_BACKTRACE,"Backtrace"
DATA #GDBG_BACKTRACE_SLOT,"Slot"
DATA #GDBG_BACKTRACE_LINE,"Line"
DATA #GDBG_BACKTRACE_NAME,"Name"


DATA #GDBG_CMENU_JUMPTODEF,"Jump to Definition"
DATA #GDBG_CMENU_CUT,"Cut"
DATA #GDBG_CMENU_COPY,"Copy"
DATA #GDBG_CMENU_PASTE,"Paste"

DATA #GDBG_EVAL,"Evaluate"
DATA #GDBG_EVAL_EXPR,"Expression"
DATA #GDBG_EVAL_VALUE,"Value"
DATA #GDBG_EVAL_REEVAL,"Reevaluate"

DATA #GDBG_VAR_CMENU_EDIT,"Edit Value"
DATA #GDBG_VAR_CMENU_COPY,"Copy Value"
DATA #GDBG_VAR_CMENU_OPEN_EVAL_WINDOW,"Open Evaluate Window"

DATA #GDBG_EXIT_MSG,"Are you sure you want to exit SBDBG?"
DATA #GDBG_DISCARD_SLOT_MSG,"Are you sure you want to discard SLOT %D?"
DATA #GDBG_ERR_SLOT_MSG,"SLOT %D is already used."+CHR$(10)+"Are you sure you want to stop debugging?"
DATA #GDBG_MSGBOX_ERROR,"Error"
DATA #GDBG_MSGBOX_OK,"OK"
DATA #GDBG_MSGBOX_YES,"Yes"
DATA #GDBG_MSGBOX_NO,"No"
DATA #GDBG_MSGBOX_CANCEL,"Cancel"

DATA #GDBG_TXTBOX_UNDO,"Undo"
DATA #GDBG_TXTBOX_REDO,"Redo"
DATA #GDBG_TXTBOX_CUT,"Cut"
DATA #GDBG_TXTBOX_COPY,"Copy"
DATA #GDBG_TXTBOX_PASTE,"Paste"
DATA #GDBG_TXTBOX_DELETE,"Delete"
DATA #GDBG_TXTBOX_SELALL,"Select All"

DATA #GDBG_ABOUT_NAME,"SBDBG SmileBASIC Debugger"
DATA #GDBG_ABOUT_AUTHOR,"ver"+#VERSION$+" 2019.07 otya(@otya403)"
DATA #GWIN_RES_END
@GDBG_MENU_JA
DATA #GDBG_MENU_FILE,"ファイル"
DATA #GDBG_MENU_FILE_IMPORT_SLOT,"スロットから読み込み
DATA #GDBG_MENU_FILE_IMPORT_SLOT_0,"スロット0"
DATA #GDBG_MENU_FILE_IMPORT_SLOT_1,"スロット1"
DATA #GDBG_MENU_FILE_IMPORT_SLOT_2,"スロット2"
DATA #GDBG_MENU_FILE_IMPORT_SLOT_3,"スロット3"
DATA #GDBG_MENU_FILE_LOAD,"ファイル読み込み"
DATA #GDBG_MENU_FILE_EXIT,"終了"
DATA #GDBG_MENU_DEBUG,"デバッグ"
DATA #GDBG_MENU_DEBUG_COMPILE,"コンパイル"
DATA #GDBG_MENU_DEBUG_RESUME,"再開"
DATA #GDBG_MENU_DEBUG_START,"実行"
DATA #GDBG_MENU_DEBUG_TERM,"終了"
DATA #GDBG_MENU_DEBUG_RESTART,"再起動"
DATA #GDBG_MENU_DEBUG_STEPINTO,"ステップイン"
DATA #GDBG_MENU_DEBUG_STEPOVER,"ステップオーバー"
DATA #GDBG_MENU_DEBUG_STEPOUT,"ステップアウト"
DATA #GDBG_MENU_DEBUG_RUNTOCUR,"カーソルまで実行"
DATA #GDBG_MENU_DEBUG_JMPTOCUR,"カーソルへ移動"
DATA #GDBG_MENU_DEBUG_TOGGLE_BP,"ブレークポイント切り替え"
DATA #GDBG_MENU_DEBUG_EVAL,"式を評価"
DATA #GDBG_MENU_WINDOW,"ウィンドウ"
DATA #GDBG_MENU_WINDOW_RESET,"初期化"
DATA #GDBG_MENU_WINDOW_OPACITY,"透明度"
DATA #GDBG_MENU_WINDOW_OPACITY_100,"100%"
DATA #GDBG_MENU_WINDOW_OPACITY_90,"90%"
DATA #GDBG_MENU_WINDOW_OPACITY_80,"80%"
DATA #GDBG_MENU_WINDOW_OPACITY_70,"70%"
DATA #GDBG_MENU_WINDOW_OPACITY_60,"60%"
DATA #GDBG_MENU_WINDOW_OPACITY_50,"50%"
DATA #GDBG_MENU_WINDOW_OPACITY_40,"40%"
DATA #GDBG_MENU_WINDOW_OPACITY_30,"30%"
DATA #GDBG_MENU_HELP,"ヘルプ"
DATA #GDBG_MENU_HELP_ABOUT,"SBDBGについて"
DATA #GDBG_ABOUT,"SBDBGについて"

DATA #GDBG_VARIABLE,"変数"
DATA #GDBG_VARIABLE_NAME,"名前"
DATA #GDBG_VARIABLE_VALUE,"値"
DATA #GDBG_VARIABLE_TYPE,"型"
DATA #GDBG_VARIABLE_GLOBALS,"グローバル"
DATA #GDBG_VARIABLE_LOCALS,"ローカル"
DATA #GDBG_VARIABLE_CONSTS,"定数"
DATA #GDBG_BACKTRACE,"呼び出し履歴"
DATA #GDBG_BACKTRACE_SLOT,"スロット"
DATA #GDBG_BACKTRACE_LINE,"行"
DATA #GDBG_BACKTRACE_NAME,"名前"

DATA #GDBG_CMENU_JUMPTODEF,"定義へ移動"
DATA #GDBG_CMENU_CUT,"切り取り"
DATA #GDBG_CMENU_COPY,"コピー"
DATA #GDBG_CMENU_PASTE,"貼り付け"

DATA #GDBG_EVAL,"評価"
DATA #GDBG_EVAL_EXPR,"式"
DATA #GDBG_EVAL_VALUE,"値"
DATA #GDBG_EVAL_REEVAL,"再評価"

DATA #GDBG_VAR_CMENU_EDIT,"値を編集"
DATA #GDBG_VAR_CMENU_COPY,"値をコピー"
DATA #GDBG_VAR_CMENU_OPEN_EVAL_WINDOW,"評価ウィンドウを開く"

DATA #GDBG_EXIT_MSG,"SBDBGを終了しますか?"
DATA #GDBG_DISCARD_SLOT_MSG,"スロット%Dを破棄しますか?"
DATA #GDBG_ERR_SLOT_MSG,"スロット%Dは既に使われています。"+CHR$(10)+"デバッグを終了しますか?"
DATA #GDBG_MSGBOX_ERROR,"エラー"
DATA #GDBG_MSGBOX_OK,"OK"
DATA #GDBG_MSGBOX_YES,"はい"
DATA #GDBG_MSGBOX_NO,"いいえ"
DATA #GDBG_MSGBOX_CANCEL,"キャンセル"

DATA #GDBG_TXTBOX_UNDO,"元に戻す"
DATA #GDBG_TXTBOX_REDO,"やり直す"
DATA #GDBG_TXTBOX_CUT,"切り取り"
DATA #GDBG_TXTBOX_COPY,"コピー"
DATA #GDBG_TXTBOX_PASTE,"貼り付け"
DATA #GDBG_TXTBOX_DELETE,"削除"
DATA #GDBG_TXTBOX_SELALL,"すべて選択"

DATA #GDBG_ABOUT_NAME,"SBDBG SmileBASIC Debugger"
DATA #GDBG_ABOUT_AUTHOR,"ver"+#VERSION$+" 2019.07 otya(@otya403)"
'DATA #GDBG_ABOUT_AUTHOR,"http://wiki.hosiken.jp/petc4/Toukou%2FSBDBG"
DATA #GWIN_RES_END
@GDBG_MENU
 DATA #GWIN_RES_MENU_BEGIN,#GDBG_MENU_FILE
  DATA #GWIN_RES_MENU_BEGIN,#GDBG_MENU_FILE_IMPORT_SLOT
   DATA #GDBG_MENU_FILE_IMPORT_SLOT_0
   DATA #GDBG_MENU_FILE_IMPORT_SLOT_1
   DATA #GDBG_MENU_FILE_IMPORT_SLOT_2
   DATA #GDBG_MENU_FILE_IMPORT_SLOT_3
   DATA #GWIN_RES_MENU_END
  DATA #GDBG_MENU_FILE_LOAD
  DATA #GWIN_RES_MENU_SEPARATOR
  DATA #GDBG_MENU_FILE_EXIT
  DATA #GWIN_RES_MENU_END
 DATA #GWIN_RES_MENU_BEGIN,#GDBG_MENU_DEBUG
  DATA #GDBG_MENU_DEBUG_COMPILE
  DATA #GDBG_MENU_DEBUG_RESUME
  DATA #GDBG_MENU_DEBUG_TERM
  DATA #GDBG_MENU_DEBUG_RESTART
  DATA #GDBG_MENU_DEBUG_STEPINTO
  DATA #GDBG_MENU_DEBUG_STEPOVER
  DATA #GDBG_MENU_DEBUG_STEPOUT
  DATA #GDBG_MENU_DEBUG_RUNTOCUR
  DATA #GDBG_MENU_DEBUG_JMPTOCUR
  DATA #GWIN_RES_MENU_SEPARATOR
  DATA #GDBG_MENU_DEBUG_TOGGLE_BP
  DATA #GWIN_RES_MENU_SEPARATOR
  DATA #GDBG_MENU_DEBUG_EVAL
 DATA #GWIN_RES_MENU_END
 DATA #GWIN_RES_MENU_BEGIN,#GDBG_MENU_WINDOW
  DATA #GDBG_MENU_WINDOW_RESET
  DATA #GWIN_RES_MENU_SEPARATOR
  DATA #GWIN_RES_MENU_BEGIN,#GDBG_MENU_WINDOW_OPACITY
   DATA #GDBG_MENU_WINDOW_OPACITY_100
   DATA #GDBG_MENU_WINDOW_OPACITY_90
   DATA #GDBG_MENU_WINDOW_OPACITY_80
   DATA #GDBG_MENU_WINDOW_OPACITY_70
   DATA #GDBG_MENU_WINDOW_OPACITY_60
   DATA #GDBG_MENU_WINDOW_OPACITY_50
   DATA #GDBG_MENU_WINDOW_OPACITY_40
   DATA #GDBG_MENU_WINDOW_OPACITY_30
  DATA #GWIN_RES_MENU_END
 DATA #GWIN_RES_MENU_END
 DATA #GWIN_RES_MENU_BEGIN,#GDBG_MENU_HELP
  DATA #GDBG_MENU_HELP_ABOUT
 DATA #GWIN_RES_MENU_END
DATA #GWIN_RES_MENU_END

@GDBG_CMENU
DATA #GDBG_CMENU_JUMPTODEF
DATA #GWIN_RES_MENU_SEPARATOR
DATA #GDBG_MENU_DEBUG_EVAL
DATA #GWIN_RES_MENU_SEPARATOR
DATA #GDBG_MENU_DEBUG_TOGGLE_BP
DATA #GWIN_RES_MENU_SEPARATOR
DATA #GWIN_RES_MENU_GRAYED,#GDBG_CMENU_CUT
DATA #GDBG_CMENU_COPY
DATA #GWIN_RES_MENU_GRAYED,#GDBG_CMENU_PASTE
DATA #GWIN_RES_MENU_END

@GDBG_VAR_CMENU
DATA #GDBG_VAR_CMENU_EDIT
DATA #GDBG_VAR_CMENU_COPY
DATA #GWIN_RES_MENU_SEPARATOR
DATA #GDBG_VAR_CMENU_OPEN_EVAL_WINDOW
DATA #GWIN_RES_MENU_END

@GDBG_TXTBOX_CMENU
DATA #GDBG_TXTBOX_CUT
DATA #GDBG_TXTBOX_COPY
DATA #GDBG_TXTBOX_PASTE
DATA #GDBG_TXTBOX_DELETE
DATA #GWIN_RES_MENU_SEPARATOR
DATA #GDBG_TXTBOX_SELALL
DATA #GWIN_RES_MENU_END

VAR GDEBUG_INIT
DIM GDBG_RESOURCE_K[]
DIM GDBG_RESOURCE_V[]
DIM GDBG_RESOURCE_CMD$[]
DEF GDEBUG_RES$(KEY)
 RETURN GWIN_SEARCH_RES(GDBG_RESOURCE_K,GDBG_RESOURCE_V,KEY)
END
DEF GDEBUG_INIT
 IF TYPEOF(GDEBUG_SYS_FONT)==#T_DEFAULT THEN
  GDEBUG_SYS_FONT=LOAD_FONT("SOURCEHAN-CODE-JP-N12.FONT")
 ENDIF
 DEBUG_INIT GDEBUG_SLOT
 RESTORE @GDBG_MENU_JA
 GDBG_RESOURCE_K=ARRAY%(0)
 GDBG_RESOURCE_V=ARRAY$(0)
 GWIN_READ_RES GDBG_RESOURCE_K,GDBG_RESOURCE_V
 GDEBUG_INIT_CMD
 GDEBUG_INIT_KEY
 VAR PCX,PCY,PCW,PCH
 VAR PRG_HEIGHT=GDEBUG_HEIGHT DIV 2+GDEBUG_HEIGHT DIV 4
 VAR BASEX=GDEBUG_WIDTH DIV 2,BASEY
 GWIN_ROOT=GWIN_NEW(0,0,0,1280,720,"ROOT","GWIN_ROOT_EVENT")
 VAR PRG_GWIN=GWIN_NEW2(GWIN_ROOT,BASEX,BASEY,(GDEBUG_WIDTH-BASEX),PRG_HEIGHT,"Graphical Debugger(SLOT"+STR$(GDEBUG_SLOT)+")","GWIN_PRG_EVENT",#GWIN_FLG_NCLOSEABLE OR #GWIN_FLG_RESIZE)
 VAR VAR_GWIN=GWIN_NEW2(GWIN_ROOT,BASEX,BASEY+PRG_HEIGHT,(GDEBUG_WIDTH-BASEX)DIV 2,GDEBUG_HEIGHT-PRG_HEIGHT,GDEBUG_RES$(#GDBG_VARIABLE),"GWIN_VAR_EVENT",#GWIN_FLG_NCLOSEABLE OR #GWIN_FLG_RESIZE)
' VAR FVIEW_GWIN=GWIN_NEW(GWIN_ROOT,BASEX+(GDEBUG_WIDTH-BASEX) DIV 2,PRG_HEIGHT,(GDEBUG_WIDTH-BASEX) DIV 2,22+23+2,"Functions","GWIN_FVIEW_EVENT")
 VAR FVIEW_GWIN=GWIN_NEW(PRG_GWIN,GWIN_GET_CLIENT_W(PRG_GWIN)-200,0,200,20,"Functions","GWIN_FVIEW_EVENT")
 GWIN_PAINT FVIEW_GWIN,0
 VAR BACK_GWIN=GWIN_NEW2(GWIN_ROOT,BASEX+(GDEBUG_WIDTH-BASEX) DIV 2,PRG_HEIGHT,(GDEBUG_WIDTH-BASEX) DIV 2,GDEBUG_HEIGHT-PRG_HEIGHT,GDEBUG_RES$(#GDBG_BACKTRACE),"GWIN_BACK_EVENT",#GWIN_FLG_NCLOSEABLE OR #GWIN_FLG_RESIZE)
 GWIN_FOCUS PRG_GWIN
 GDEBUG_PRG_GWIN=PRG_GWIN
 GDEBUG_VAR_GWIN=VAR_GWIN
 GDEBUG_BACKTRACE_GWIN=BACK_GWIN
 GDEBUG_INIT=#TRUE
END
DEF GDEBUG_WINDOW_RESET
 VAR PRG_HEIGHT=GDEBUG_HEIGHT DIV 2+GDEBUG_HEIGHT DIV 4
 VAR BASEX=GDEBUG_WIDTH DIV 2,BASEY
 GWIN_MOVERESIZE GDEBUG_PRG_GWIN,BASEX,BASEY,(GDEBUG_WIDTH-BASEX),PRG_HEIGHT
 GWIN_MOVERESIZE GDEBUG_VAR_GWIN,BASEX,BASEY+PRG_HEIGHT,(GDEBUG_WIDTH-BASEX)DIV 2,GDEBUG_HEIGHT-PRG_HEIGHT
 GWIN_MOVERESIZE GDEBUG_BACKTRACE_GWIN,BASEX+(GDEBUG_WIDTH-BASEX) DIV 2,PRG_HEIGHT,(GDEBUG_WIDTH-BASEX) DIV 2,GDEBUG_HEIGHT-PRG_HEIGHT
END
CONST #GDEBUG_KEY_CFG_KEY=&HFFFF
CONST #GDEBUG_KEY_CFG_BTN=&HFFFE
DEF GDEBUG_KEY_CFG
END
DEF GDEBUG_CONSTRUCT_KEY$(*)
 VAR R$=CHR$(#GDEBUG_KEY_CFG_KEY)+CHR$(DEFARGC())+CHR$(0)*DEFARGC()
 VAR I
 FOR I=0TO DEFARGC()-1
  R$[2+I]=CHR$(DEFARG(I))
 NEXT
 RETURN R$
END
DEF GDEBUG_CONSTRUCT_BTN$(BTN)
 VAR R$=CHR$(#GDEBUG_KEY_CFG_BTN)+CHR$(BTN)
 RETURN R$
END
DIM GDEBUG_KEYS$[]
'TODO:KeyPadはベツのスキャンコードだけどどうアツカうべき?
DEF GDEBUG_INIT_KEY
 VAR N$
 'US KEY
 DIM KEYS$[256]=[N$,N$,N$,N$,"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","1","2","3","4","5","6","7","8","9","0","Enter","Esc","BS","Tab","Space","-","=","[","]","\",N$,";","'","`",",",".","/","Caps","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","PrtScr","Scroll Lock","Pause","Insert","Home","PageUp","Delete","End","PageDown","","","","","NumLock"]
 '...KeyPad...Keyboard F13-F24,Exe Help Key...KeyPad...International...Keypad...
 '...Reserved...(222-223)
 KEYS$[224]="Left Ctrl"
 KEYS$[225]="Left Shift"
 KEYS$[226]="Left Alt"
 KEYS$[227]="Left Win"
 KEYS$[228]="Right Ctrl"
 KEYS$[229]="Right Shift"
 KEYS$[230]="Right Alt"
 KEYS$[231]="Right Win"
 KEYS$[101]="Menu"
 'FIXME:キーはいれつ
 '109 KEY
 KEYS$[135]="\"
 KEYS$[137]="¥"
 KEYS$[46]="^"
 KEYS$[47]="@"
 KEYS$[48]="["
 KEYS$[49]="]"
 KEYS$[52]=":"
 KEYS$[53]="半角/全角"
 '...Reserved...(232-65535)
 GDEBUG_KEYS$=KEYS$
END
DEF GDEBUG_INIT_CMD
 DIM CMD$[MAX(GDBG_RESOURCE_K)+1]
 GDBG_RESOURCE_CMD$=CMD$
 CONST #GDEBUG_MOD_KEY_SHIFT=2,#GDEBUG_MOD_KEY_CTRL=4
 CMD$[#GDBG_MENU_DEBUG_COMPILE]=GDEBUG_CONSTRUCT_KEY$(#GDEBUG_MOD_KEY_CTRL OR #GDEBUG_MOD_KEY_SHIFT,4+ASC("B")-ASC("A"))
 CMD$[#GDBG_MENU_DEBUG_RESUME]=GDEBUG_CONSTRUCT_KEY$(0,#GDEBUG_KEY_F1)

 CMD$[#GDBG_MENU_DEBUG_TERM]=GDEBUG_CONSTRUCT_KEY$(#GDEBUG_MOD_KEY_SHIFT,#GDEBUG_KEY_F1)
 CMD$[#GDBG_MENU_DEBUG_RESTART]=GDEBUG_CONSTRUCT_KEY$(#GDEBUG_MOD_KEY_CTRL OR #GDEBUG_MOD_KEY_SHIFT,#GDEBUG_KEY_F1)
 CMD$[#GDBG_MENU_DEBUG_STEPINTO]=GDEBUG_CONSTRUCT_KEY$(0,#GDEBUG_KEY_F2)
 CMD$[#GDBG_MENU_DEBUG_STEPOVER]=GDEBUG_CONSTRUCT_KEY$(0,#GDEBUG_KEY_F3)
 CMD$[#GDBG_MENU_DEBUG_STEPOUT]=GDEBUG_CONSTRUCT_KEY$(#GDEBUG_MOD_KEY_SHIFT,#GDEBUG_KEY_F2)
 CMD$[#GDBG_MENU_DEBUG_TOGGLE_BP]=GDEBUG_CONSTRUCT_KEY$(0,#GDEBUG_KEY_F9)
 CMD$[#GDBG_CMENU_JUMPTODEF]=GDEBUG_CONSTRUCT_KEY$(0,#GDEBUG_KEY_F12)

' CMD$[#GDBG_TXTBOX_UNDO]=GDEBUG_CONSTRUCT_KEY$(#GDEBUG_MOD_KEY_CTRL,4+ASC("Z")-ASC("A"))
' CMD$[#GDBG_TXTBOX_REDO]=GDEBUG_CONSTRUCT_KEY$(#GDEBUG_MOD_KEY_CTRL,4+ASC("Y")-ASC("A"))
' CMD$[#GDBG_TXTBOX_CUT]=GDEBUG_CONSTRUCT_KEY$(#GDEBUG_MOD_KEY_CTRL,4+ASC("X")-ASC("A"))
' CMD$[#GDBG_TXTBOX_COPY]=GDEBUG_CONSTRUCT_KEY$(#GDEBUG_MOD_KEY_CTRL,4+ASC("C")-ASC("A"))
' CMD$[#GDBG_TXTBOX_PASTE]=GDEBUG_CONSTRUCT_KEY$(#GDEBUG_MOD_KEY_CTRL,4+ASC("V")-ASC("A"))
' CMD$[#GDBG_TXTBOX_SELALL]=GDEBUG_CONSTRUCT_KEY$(#GDEBUG_MOD_KEY_CTRL,4+ASC("A")-ASC("A"))
END
DEF GDEBUG_CMD_TO_STR$(CMD$)
 VAR I
 VAR R$=""
 WHILE I<LEN(CMD$)
  IF LEN(R$)THEN
   PUSH R$,","
  ENDIF
  VAR C=ASC(CMD$[I])
  IF C==#GDEBUG_KEY_CFG_KEY THEN
   INC I
   VAR LEN=I+ASC(CMD$[I])
   VAR KEY_MOD=ASC(CMD$[I+1])
   VAR R1$=""
   IF KEY_MOD AND 1 THEN
    IF LEN(R1$) THEN
     PUSH R1$,"+"
    ENDIF
    PUSH R1$,"Win"
   ENDIF
   IF KEY_MOD AND 2 THEN
    IF LEN(R1$) THEN
     PUSH R1$,"+"
    ENDIF
    PUSH R1$,"Shift"
   ENDIF
   IF KEY_MOD AND 4 THEN
    IF LEN(R1$) THEN
     PUSH R1$,"+"
    ENDIF
    PUSH R1$,"Ctrl"
   ENDIF
   IF KEY_MOD AND 8 THEN
    IF LEN(R1$) THEN
     PUSH R1$,"+"
    ENDIF
    PUSH R1$,"Alt"
   ENDIF
   FOR I=I+2 TO LEN
    IF LEN(R1$) THEN
     PUSH R1$,"+"
    ENDIF
    PUSH R1$,GDEBUG_KEYS$[ASC(CMD$[I])]
   NEXT
   PUSH R$,R1$
  ELSE
   BREAK
  ENDIF
 WEND
 RETURN R$
END
DEF GDEBUG_DO_DEBUG_CMD CMD
 IF CMD==#GDBG_MENU_DEBUG_COMPILE THEN
  VAR SLOT=GDEBUG_GET_PRG_SLOT()
  IF VM_IS_SLOT_COMPILED(SLOT)THEN RETURN
  VAR IN$=GET_VSLOT$(SLOT)
  INIT_LEXER IN$
  INIT_AST
  INIT_PARSER SLOT
  VAR AST=PARSE()
  INIT_RCOMPILER SLOT
  RCOMPILE AST
  GDEBUG_UPDATE_WINDOW #GDEBUG_UPDATE_BACKTRACE OR #GDEBUG_UPDATE_VAR OR #GDEBUG_UPDATE_ERROR
  GWIN_PAINT GDEBUG_PRG_GWIN,#FALSE
  RETURN
 ELSEIF CMD==#GDBG_MENU_DEBUG_TERM THEN
  GDEBUG_TERM
  GDEBUG_UPDATE_WINDOW #GDEBUG_UPDATE_BACKTRACE OR #GDEBUG_UPDATE_VAR OR #GDEBUG_UPDATE_ERROR
  GWIN_PAINT GDEBUG_PRG_GWIN,#FALSE
  RETURN
 ENDIF
 GDEBUG_CURRENT_FRAME=0
 GDEBUG_HIDE
 CASE CMD
 WHEN #GDBG_MENU_DEBUG_RESUME
  GDEBUG_RUN
 WHEN #GDBG_MENU_DEBUG_RESTART
  GDEBUG_RESTART
 WHEN #GDBG_MENU_DEBUG_STEPINTO
  GDEBUG_STEP #TRUE
 WHEN #GDBG_MENU_DEBUG_STEPOVER
  GDEBUG_STEP #FALSE
 WHEN #GDBG_MENU_DEBUG_STEPOUT
 WHEN #GDBG_MENU_DEBUG_RUNTOCUR
 WHEN #GDBG_MENU_DEBUG_JMPTOCUR
  STOP
 ENDCASE
 GDEBUG_SHOW
 GDEBUG_UPDATE_WINDOW #GDEBUG_UPDATE_BACKTRACE OR #GDEBUG_UPDATE_VAR OR #GDEBUG_UPDATE_SRC OR #GDEBUG_UPDATE_ERROR
END
DEF GDEBUG_RESTART
 VM_RESTART GDEBUG_SLOT
 GDEBUG_RUN
END
DEF GDEBUG_TERM
 VM_RESET
END
COMMON DEF GDEBUG_MAIN
 IF !GDEBUG_INIT THEN GDEBUG_INIT
 LOOP
  GWIN_UPDATE
  IF KEYBOARD(#GDEBUG_KEY_F1,2) THEN
   GDEBUG_CURRENT_FRAME=0
   GDEBUG_RUN
   GDEBUG_UPDATE_WINDOW #GDEBUG_UPDATE_BACKTRACE OR #GDEBUG_UPDATE_VAR OR #GDEBUG_UPDATE_SRC OR #GDEBUG_UPDATE_ERROR
  ENDIF
  IF KEYBOARD(#GDEBUG_KEY_F2,2) THEN
   GDEBUG_CURRENT_FRAME=0
   GDEBUG_HIDE
   GDEBUG_STEP #TRUE
   GDEBUG_SHOW
   GDEBUG_UPDATE_WINDOW #GDEBUG_UPDATE_BACKTRACE OR #GDEBUG_UPDATE_VAR OR #GDEBUG_UPDATE_SRC OR #GDEBUG_UPDATE_ERROR
  ENDIF
  IF KEYBOARD(#GDEBUG_KEY_F3,2) THEN
   GDEBUG_CURRENT_FRAME=0
   GDEBUG_HIDE
   GDEBUG_STEP #FALSE
   GDEBUG_SHOW
   GDEBUG_UPDATE_WINDOW #GDEBUG_UPDATE_BACKTRACE OR #GDEBUG_UPDATE_VAR OR #GDEBUG_UPDATE_SRC OR #GDEBUG_UPDATE_ERROR
  ENDIF
  GWIN_MAIN_LOOP
 ENDLOOP
END
DIM GDEBUG_OFFS_BUF[]
DIM GDEBUG_TMP_BUF[]
DIM GDEBUG_GRPF_BUF[]
DIM GDEBUG_GCLIP_X1
DIM GDEBUG_GCLIP_Y1
DIM GDEBUG_GCLIP_X2
DIM GDEBUG_GCLIP_Y2
VAR GDEBUG_OLD_GP
VAR GDEBUG_OLD_MC
VAR GWIN_OLD_MAINCNT
DIM GWIN_CURSOR[]
VAR GWIN_CURSOR_HX
VAR GWIN_CURSOR_HY
VAR GWIN_CURSOR_UPDATED

DEF GWIN_MAIN_LOOP
 VAR WIDTH=1280
 VAR HEIGHT=720
 VAR OFFX=512
 VAR OFFY=0
 GWIN_UPDATE
 GTARGET #GRPF
 GCLIP
 IF GWIN_CURSOR_UPDATED THEN
  GFILL 2046-128,2046-128,2046,2046,0
  GLOAD 2046-64-GWIN_CURSOR_HX,2046-64-GWIN_CURSOR_HY,DIM(GWIN_CURSOR,1),DIM(GWIN_CURSOR,0),GWIN_CURSOR,#G_NORMAL
  GWIN_CURSOR_UPDATED=#FALSE
 ENDIF
 GPSET 2047,2047,RGB(GWIN_OPACITY,RND(256),RND(256),RND(256))
 IF GWIN_UPDATED THEN
  GWIN_COMPOSE
  GTARGET #GRPF
  GCLIP OFFX,OFFY,OFFX+WIDTH-1,OFFY+HEIGHT-1
  GCOPY GDEBUG_OFFSCREEN_PAGE,0,0,WIDTH-1,HEIGHT-1,OFFX,OFFY,#G_NORMAL
  GCLIP
  GTARGET GDEBUG_TEMP_PAGE
  GLOAD 0,0,GDEBUG_WIDTH,GDEBUG_HEIGHT,GDEBUG_TMP_BUF,#G_NORMAL
  GTARGET GDEBUG_OFFSCREEN_PAGE
  GLOAD 0,0,GDEBUG_WIDTH,GDEBUG_HEIGHT,GDEBUG_OFFS_BUF,#G_NORMAL
 ENDIF
 IF GWIN_OLD_MAINCNT==MAINCNT() THEN
  VSYNC
 ENDIF
 GWIN_OLD_MAINCNT=MAINCNT()
END
DEF GDEBUG_STEP F
 VAR SLOT,LINE,LP,BP
 VAR OSLOT,OLINE,OLP,OBP
 VMDBG_GET OUT OSLOT,OLINE,OLP
 VM_GET_BP OUT OBP
 VAR OPC=VM_GET_PC()
 LOOP
  VM_TRACE_RUN F
  IF!VM_IS_RUNNING()THEN
   BREAK
  ENDIF
  VMDBG_GET OUT SLOT,LINE,LP
  VM_GET_BP OUT BP
  IF VMDBG_IS_STOPPED_AT_BP()THEN
   BREAK
  ENDIF
  VAR PC=VM_GET_PC()
  IF OPC==PC THEN BREAK
  OPC=PC
  IF BP!=OBP||SLOT!=OSLOT||OLINE!=LINE||OLP!=LP THEN
   BREAK
  ENDIF
  IF VM_IS_STOPPED()THEN
   BREAK
  ENDIF
  OSLOT=SLOT
  OLINE=LINE
  OLP=LP
  OBP=BP
 ENDLOOP
END
DEF GDEBUG_SAVE_STATE
 GDEBUG_OLD_GP=0
 IF TYPEOF(GDEBUG_TMP_BUF)==#T_DEFAULT THEN
  GDEBUG_OFFS_BUF=ARRAY%(GDEBUG_HEIGHT*GDEBUG_WIDTH)
  GDEBUG_TMP_BUF=ARRAY%(GDEBUG_HEIGHT*GDEBUG_WIDTH)
  GDEBUG_GRPF_BUF=ARRAY%(#GRPHEIGHT*#GRPHEIGHT)
 ENDIF
 ACLS
 GCLIP
 GTARGET #GRPF
 GPSET 2047,2047,0
 GTARGET 0
 SYSPARAM "MOUSECURSOR",#FALSE
 GDEBUG_SHOW
END
DEF GDEBUG_HIDE
 GTARGET GDEBUG_OFFSCREEN_PAGE
 GLOAD 0,0,GDEBUG_WIDTH,GDEBUG_HEIGHT,GDEBUG_OFFS_BUF,#G_NORMAL
 GTARGET GDEBUG_TEMP_PAGE
 GLOAD 0,0,GDEBUG_WIDTH,GDEBUG_HEIGHT,GDEBUG_TMP_BUF,#G_NORMAL
 GTARGET #GRPF
 SYSPARAM "MOUSECURSOR",GDEBUG_OLD_MC
' GLOAD 0,0,#GRPWIDTH,#GRPHEIGHT,GDEBUG_GRPF_BUF,#G_NORMAL
 GTARGET GDEBUG_OLD_GP
 GCLIP GDEBUG_GCLIP_X1,GDEBUG_GCLIP_Y1,GDEBUG_GCLIP_X2,GDEBUG_GCLIP_Y2
END
DEF GDEBUG_SHOW
 GSAVE GDEBUG_OFFSCREEN_PAGE,0,0,GDEBUG_WIDTH,GDEBUG_HEIGHT,GDEBUG_OFFS_BUF
 GSAVE GDEBUG_TEMP_PAGE,0,0,GDEBUG_WIDTH,GDEBUG_HEIGHT,GDEBUG_TMP_BUF
 GSAVE #GRPF,0,0,#GRPWIDTH,#GRPHEIGHT,GDEBUG_GRPF_BUF
 GDEBUG_OLD_GP=GTARGET()
 GDEBUG_OLD_MC=SYSPARAM("MOUSECURSOR")
 SYSPARAM "MOUSECURSOR",#FALSE
 GCLIP OUT GDEBUG_GCLIP_X1,GDEBUG_GCLIP_Y1,GDEBUG_GCLIP_X2,GDEBUG_GCLIP_Y2
 GTARGET GDEBUG_OFFSCREEN_PAGE
 GWIN_UPDATED=#TRUE
 GWIN_CURSOR_UPDATED=#TRUE
 GWIN_MAIN_LOOP
END
DEF GDEBUG_RUN
 GDEBUG_HIDE
 VM_DEBUG_RUN
 GDEBUG_SHOW
END
DEF GWIN_COMPOSE
 IF!GWIN_UPDATED THEN RETURN
 GWIN_UPDATED=#FALSE
' GFILL 0,0,1279,719,RGB(16,0,0,0),#G_ALPHA2
 VAR GWIN_BACK=GWIN_CHILD[GWIN_ROOT]
 VAR GW=GWIN_BACK
 GTARGET GDEBUG_OFFSCREEN_PAGE
 GCLIP 0,0,1280-1,720-1
 GCLS
 WHILE GW
  IF GWIN_FLG[GW] AND #GWIN_FLG_HIDE THEN
  ELSEIF 0 THEN
   GTARGET 2
   GLOAD GWIN_X[GW],GWIN_Y[GW],GWIN_W[GW],GWIN_H[GW],GWIN_GET_FRAME_BUF(GW),#G_NORMAL
   GTARGET GDEBUG_OFFSCREEN_PAGE
   GCOPY 2,GWIN_X[GW],GWIN_Y[GW],GWIN_X[GW]+GWIN_W[GW]-1,GWIN_Y[GW]+GWIN_H[GW]-1,GWIN_X[GW],GWIN_Y[GW],RGB(16,255,255,255),#G_ALPHA2
  ELSE
   GLOAD GWIN_X[GW],GWIN_Y[GW],GWIN_W[GW],GWIN_H[GW],GWIN_GET_FRAME_BUF(GW),#G_NORMAL
  ENDIF
  GW=GWIN_NEXT[GW]
 WEND
END
DEF GWIN_GET_WIN_FROM_POS ROOT,X,Y OUT GW,FRAME
 FRAME=#FALSE
 VAR GWIN_BACK=GWIN_CHILD[ROOT]
 GW=GWIN_BACK
 WHILE GW
  IF!GWIN_NEXT[GW] THEN BREAK
  GW=GWIN_NEXT[GW]
 WEND
 WHILE GW
  IF !(GWIN_FLG[GW]AND #GWIN_FLG_HIDE)&&GWIN_X[GW]<=X&&GWIN_Y[GW]<=Y&&X<GWIN_X[GW]+GWIN_W[GW]&&Y<GWIN_Y[GW]+GWIN_H[GW] THEN
   VAR CX=GWIN_X[GW]+GWIN_FW1[GW]
   VAR CY=GWIN_Y[GW]+GWIN_FH1[GW]
   IF CX<=X&&CY<=Y&&X<CX+GWIN_GET_CW(GW)&&Y<CY+GWIN_GET_CH(GW) THEN
    IF GWIN_CHILD[GW]THEN
     VAR GW2,FRAME2
     GWIN_GET_WIN_FROM_POS GW,X,Y OUT GW2,FRAME2
     IF GW2 THEN
      GW=GW2
      FRAME=FRAME2
     ENDIF
    ENDIF
   ELSE
    FRAME=#TRUE
   ENDIF
   RETURN
  ENDIF
  GW=GWIN_PREV[GW]
 WEND
END
VAR GWIN_OLD_MX
VAR GWIN_OLD_MY
VAR GWIN_WHEEL_INIT_FLG
VAR GWIN_OLD_MW
VAR GWIN_OLD_MBTN
DEF GWIN_GET_MOUSE_X(GW)
 RETURN GWIN_OLD_MX-GWIN_GET_CLIENT_X(GW)+GWIN_GET_CX(GW)
END
DEF GWIN_GET_MOUSE_Y(GW)
 RETURN GWIN_OLD_MY-GWIN_GET_CLIENT_Y(GW)+GWIN_GET_CY(GW)
END
DEF GWIN_GET_MOUSE_NCX(GW)
 RETURN GWIN_OLD_MX-GWIN_GET_X(GW)+GWIN_GET_DRAW_X(GW)
END
DEF GWIN_GET_MOUSE_NCY(GW)
 RETURN GWIN_OLD_MY-GWIN_GET_Y(GW)+GWIN_GET_DRAW_Y(GW)
END
DEF GWIN_MOUSE_L_CLK()
 RETURN GWIN_OLD_MBTN AND 1
END
DEF GWIN_ACTIVE GW
 IF GWIN_FLG[GW]AND #GWIN_FLG_NACTV THEN
  RETURN
 ENDIF
 IF GWIN_ACTIVE!=GW THEN
  VAR O=GWIN_ACTIVE
  GWIN_ACTIVE=GW
  IF GW THEN
   WHILE GW!=GWIN_ROOT&&GW
    IF !(GWIN_FLG[GW]AND #GWIN_FLG_NOFRAME) THEN
     GWIN_CALL_EVENT_NC GW,#GWIN_EVENT_ACTIVE,1,GWIN_ACTIVE,0,0
    ENDIF
    GWIN_CALL_EVENT GW,#GWIN_EVENT_ACTIVE,1,GWIN_ACTIVE,0,0
    GW=GWIN_PARENT[GW]
   WEND
  ENDIF
  IF O THEN
   WHILE O!=GWIN_ROOT&&O
    IF !(GWIN_FLG[O]AND #GWIN_FLG_NOFRAME) THEN
     GWIN_CALL_EVENT_NC O,#GWIN_EVENT_ACTIVE,0,GW,0,0
    ENDIF
    CALL GWIN_EVENT$[O],O,#GWIN_EVENT_ACTIVE,0,GW,0,0
    O=GWIN_PARENT[O]
   WEND
  ENDIF
 ENDIF
END
DEF GWIN_FOCUS GW
 GWIN_ACTIVE GW
 IF GWIN_INPUT!=GW THEN
  VAR O=GWIN_INPUT
  GWIN_INPUT=GW
  IF GW THEN
   VAR OGW=GW
   VAR ID=GWIN_ID[GW]
   GWIN_CALL_EVENT GW,#GWIN_EVENT_CHFOCUS,1,O,0,0
   'OTWやWINDOWSみたいにIDをウィンドウハンドルにつけたらさくじょされてむこうになったかどうかのはんていしなくてすむけどそこまではしない
   IF GWIN_ID[GW]==ID THEN
    WHILE GW!=GWIN_ROOT&&GW
     VAR P=GWIN_PARENT[GW]
     VAR PID=GWIN_ID[P]
     GWIN_CALL_EVENT GW,#GWIN_EVENT_CHFOCUS_CHILD,1,O,0,0
     GW=P
     IF PID!=GWIN_ID[P]THEN BREAK
    WEND
   ENDIF
   GW=OGW
  ENDIF
  IF O THEN
   VAR OO=O
   ID=GWIN_ID[O]
   CALL GWIN_EVENT$[O],O,#GWIN_EVENT_CHFOCUS,0,GW,0,0
   IF GWIN_ID[O]==ID THEN
    WHILE O!=GWIN_ROOT&&O
     P=GWIN_PARENT[O]
     PID=GWIN_ID[P]
     CALL GWIN_EVENT$[O],O,#GWIN_EVENT_CHFOCUS_CHILD,0,GW,0,0
     O=P
     IF PID!=GWIN_ID[P]THEN BREAK
    WEND
   ENDIF
   OO=O
  ENDIF
 ENDIF
END
DEF GWIN_GET_ANCESTOR(GW)
 WHILE GW&&GWIN_PARENT[GW]!=GWIN_ROOT
  GW=GWIN_PARENT[GW]
 WEND
 RETURN GW
END
DEF GWIN_SET_SYS_MODAL GW
 GWIN_SYS_MODAL=GW
END
DEF GWIN_SAME_PARENT(GW,PRNT)
 WHILE GW&&GW!=GWIN_ROOT
  IF GW==PRNT THEN RETURN #TRUE
  GW=GWIN_PARENT[GW]
 WEND
 RETURN #FALSE
END
DEF GWIN_CALL_EVENT GW,EVENT,A1,A2,A3,A4
 IF GWIN_SYS_MODAL&&!GWIN_SAME_PARENT(GW,GWIN_SYS_MODAL) THEN RETURN
 CALL GWIN_EVENT$[GW],GW,EVENT,A1,A2,A3,A4
END
DEF GWIN_CALL_EVENT_NC GW,EVENT,A1,A2,A3,A4
 IF GWIN_SYS_MODAL&&!GWIN_SAME_PARENT(GW,GWIN_SYS_MODAL) THEN RETURN
 GWIN_EVENT GW,EVENT,A1,A2,A3,A4
END
DEF GWIN_UPDATE
 VAR X,Y,W
 MOUSE 1 OUT X,Y,W
 VAR CBTN=MBUTTON()
 VAR DWN_BTN=(GWIN_OLD_MBTN XOR CBTN)AND NOT GWIN_OLD_MBTN
 VAR UP_BTN=(GWIN_OLD_MBTN XOR CBTN)AND GWIN_OLD_MBTN
 IF GWIN_OLD_MW!=W&&GWIN_WHEEL_INIT_FLG THEN
  VAR DELTA=W-GWIN_OLD_MW
  IF GWIN_OVER_WIN THEN
   GWIN_CALL_EVENT GWIN_OVER_WIN,#GWIN_EVENT_WHEEL,DELTA,0,0,0
  ENDIF
 ENDIF
 GWIN_WHEEL_INIT_FLG=#TRUE
 GWIN_OLD_MW=W
 GWIN_OLD_MBTN=CBTN
 IF DWN_BTN THEN
  VAR GW,FRAME
  GWIN_GET_WIN_FROM_POS GWIN_ROOT,X,Y OUT GW,FRAME
  IF !GWIN_SYS_MODAL||GWIN_SAME_PARENT(GW,GWIN_SYS_MODAL) THEN
   GWIN_FOCUS GW
   GWIN_FRONT GWIN_GET_ANCESTOR(GW)
  ENDIF
  VAR I,MS=MILLISEC()
  FOR I=0TO #GWIN_MAX_MBUTTON-1
   IF !(DWN_BTN AND (1<<I)) THEN CONTINUE
   IF FRAME&&GW THEN
    GWIN_CALL_EVENT_NC GW,#GWIN_EVENT_LDWN+I,X-GWIN_X[GW],Y-GWIN_Y[GW],0,0
   ELSEIF GW THEN
    GWIN_CALL_EVENT GW,#GWIN_EVENT_LDWN+I,X-GWIN_GET_CLIENT_X(GW),Y-GWIN_GET_CLIENT_Y(GW),0,0
   ENDIF
   
   IF MS-GWIN_DBL_CLK_MS[I]<GWIN_DBL_CLK_INTERVAL_MS&&\
      ABS(GWIN_DBL_CLK_X[I]-X)<GWIN_DBL_CLK_HYSTERESIS_X&&\
      ABS(GWIN_DBL_CLK_Y[I]-Y)<GWIN_DBL_CLK_HYSTERESIS_Y THEN
    IF FRAME&&GW THEN
     GWIN_CALL_EVENT_NC GW,#GWIN_EVENT_LDBL+I,X-GWIN_X[GW],Y-GWIN_Y[GW],0,0
    ELSEIF GW THEN
     GWIN_CALL_EVENT GW,#GWIN_EVENT_LDBL+I,X-GWIN_GET_CLIENT_X(GW),Y-GWIN_GET_CLIENT_Y(GW),0,0
    ENDIF
    GWIN_DBL_CLK_MS[I]=0
   ELSE
    GWIN_DBL_CLK_MS[I]=MS
    GWIN_DBL_CLK_X[I]=X
    GWIN_DBL_CLK_Y[I]=Y
   ENDIF
  NEXT
 ENDIF
 IF UP_BTN THEN
  IF GWIN_CAPTURE_GW THEN
   GW=GWIN_CAPTURE_GW
   FRAME=GWIN_CAPTURE_FRAME
  ELSE
   GWIN_GET_WIN_FROM_POS GWIN_ROOT,X,Y OUT GW,FRAME
  ENDIF
  FOR I=0TO #GWIN_MAX_MBUTTON-1
   IF !(UP_BTN AND (1<<I)) THEN CONTINUE
   IF GW&&FRAME THEN
    GWIN_CALL_EVENT_NC GW,#GWIN_EVENT_LUP+I,X-GWIN_X[GW],Y-GWIN_Y[GW],0,0
   ELSEIF GW THEN
    GWIN_CALL_EVENT GW,#GWIN_EVENT_LUP+I,X-GWIN_GET_CLIENT_X(GW),Y-GWIN_GET_CLIENT_Y(GW),0,0
   ENDIF
  NEXT
  IF GWIN_CAPTURE_GW THEN
   GWIN_CAPTURE_GW=0
   GWIN_OLD_MX=-1'MMOVE EVENT
  ENDIF
 ENDIF
 IF GWIN_OLD_MX!=X||GWIN_OLD_MY!=Y THEN
  GWIN_OLD_MX=X
  GWIN_OLD_MY=Y
  IF GWIN_CAPTURE_GW THEN
   GW=GWIN_CAPTURE_GW
   FRAME=GWIN_CAPTURE_FRAME
  ELSE
   GWIN_GET_WIN_FROM_POS GWIN_ROOT,X,Y OUT GW,FRAME
  ENDIF
  IF (GWIN_OVER_WIN!=GW||GWIN_OVER_WIN_FRM!=FRAME)&&GWIN_OVER_WIN THEN
   IF GWIN_OVER_WIN_FRM THEN
    GWIN_CALL_EVENT_NC GWIN_OVER_WIN,#GWIN_EVENT_LEAVE,X-GWIN_X[GWIN_OVER_WIN],Y-GWIN_Y[GWIN_OVER_WIN],0,0
   ELSE
    GWIN_CALL_EVENT GWIN_OVER_WIN,#GWIN_EVENT_LEAVE,X-GWIN_GET_CLIENT_X(GWIN_OVER_WIN),Y-GWIN_GET_CLIENT_Y(GWIN_OVER_WIN),0,0
   ENDIF
  ENDIF
  IF FRAME&&GW THEN
   GWIN_CALL_EVENT_NC GW,#GWIN_EVENT_MMOVE,X-GWIN_X[GW],Y-GWIN_Y[GW],0,0
  ELSEIF GW THEN
   GWIN_CALL_EVENT GW,#GWIN_EVENT_MMOVE,X-GWIN_GET_CLIENT_X(GW),Y-GWIN_GET_CLIENT_Y(GW),0,0
  ENDIF
  IF GWIN_OVER_WIN!=GW THEN
   VAR CUR$=GWIN_CURSOR$[GW]
   IF !LEN(CUR$) THEN CUR$="GWIN_CURSOR_ARROW"
   GWIN_CURSOR=VAR(CUR$)
   GWIN_CURSOR_HX=VAR(CUR$+"_HX")
   GWIN_CURSOR_HY=VAR(CUR$+"_HY")
   GWIN_CURSOR_UPDATED=#TRUE
  ENDIF
  GWIN_OVER_WIN=GW
  GWIN_OVER_WIN_FRM=FRAME
 ENDIF
 VAR IK$=INKEY$()
 IF LEN(IK$)&&GWIN_INPUT THEN
  GWIN_CALL_EVENT GWIN_INPUT,#GWIN_EVENT_INKEY,IK$,0,0,0
 ENDIF
END
VAR GWIN_PAINT_PERF_CNT
DEF GWIN_PAINT GW,FRAME
 GWIN_UPDATED=#TRUE
 IF !GWIN_PARENT[GW]THEN RETURN
 WHILE GW&&GWIN_PARENT[GW]!=GWIN_ROOT
  GW=GWIN_PARENT[GW]
 WEND
 INC GWIN_PAINT_PERF_CNT
 GTARGET GDEBUG_TEMP_PAGE
 IF FRAME||1 THEN
  GCLIP 0,0,GWIN_W[GW]-1,GWIN_H[GW]-1
  GWIN_CALL_EVENT_NC GW,#GWIN_EVENT_PAINT,0,0,0,0
 ENDIF
 GCLIP GWIN_FW1[GW],GWIN_FH1[GW],GWIN_W[GW]-GWIN_FW2[GW]-1,GWIN_H[GW]-GWIN_FH2[GW]-1
' IF GWIN_PAINT_PERF_CNT==1THEN
'  PERFBEGIN 1
' ENDIF
 GWIN_PAINT_CALL GW
' IF GWIN_PAINT_PERF_CNT==1 THEN
' ?"GP",PERFEND(1)/1000;"ms"
' ENDIF
 GSAVE 0,0,GWIN_W[GW],GWIN_H[GW],GWIN_GET_FRAME_BUF(GW)
 DEC GWIN_PAINT_PERF_CNT
END
DEF GWIN_PAINT_CALL GW
 VAR OID=GWIN_ID[GW]
 GWIN_CALL_EVENT GW,#GWIN_EVENT_PAINT,0,0,0,0
 IF OID!=GWIN_ID[GW] THEN
  RETURN
 ENDIF
 VAR C=GWIN_CHILD[GW]
 WHILE C
  IF GWIN_CHILD[C] THEN GWIN_PAINT_CALL GWIN_CHILD[C]
  GCLIP GWIN_GET_CX(C),GWIN_GET_CY(C),GWIN_GET_CX(C)+GWIN_GET_CW(C)-1,GWIN_GET_CY(C)+GWIN_GET_CH(C)-1
  OID=GWIN_ID[GW]
  GWIN_CALL_EVENT C,#GWIN_EVENT_PAINT,0,0,0,0
  IF OID!=GWIN_ID[GW] THEN
   RETURN
  ENDIF
  C=GWIN_NEXT[C]
 WEND
END
DEF GWIN_SET_CAPTURE GW,FRAME
 GWIN_CAPTURE_GW=GW
 GWIN_CAPTURE_FRAME=FRAME
 GWIN_CAPTURE_X=GWIN_OLD_MX-GWIN_X[GW]
 GWIN_CAPTURE_Y=GWIN_OLD_MY-GWIN_Y[GW]
 IF !FRAME THEN
  DEC GWIN_CAPTURE_X,GWIN_FW1[GW]
  DEC GWIN_CAPTURE_Y,GWIN_FH1[GW]
 ENDIF
END
DEF GWIN_GET_CAPTURE OUT GW,FRAME,X,Y
 GW=GWIN_CAPTURE_GW
 FRAME=GWIN_CAPTURE_FRAME
 X=GWIN_CAPTURE_X
 Y=GWIN_CAPTURE_Y
END
DEF GWIN_HIDE GW
 IF GWIN_FLG[GW] AND #GWIN_FLG_HIDE THEN
 ELSE
  GWIN_FLG[GW]=GWIN_FLG[GW] OR #GWIN_FLG_HIDE
  GWIN_UPDATED=#TRUE
 ENDIF
END
DEF GWIN_SHOW GW
 IF GWIN_FLG[GW] AND #GWIN_FLG_HIDE THEN
  GWIN_FLG[GW]=GWIN_FLG[GW] AND NOT #GWIN_FLG_HIDE
  GWIN_UPDATED=#TRUE
 ENDIF
END
DEF GWIN_FRONT GW
 GWIN_UPDATED=#TRUE
 VAR NXT=GWIN_NEXT[GW]
 VAR PRV=GWIN_PREV[GW]
 IF !NXT&&!PRV THEN RETURN
 VAR GWIN_BACK=GWIN_CHILD[GWIN_PARENT[GW]]
 IF GWIN_BACK==GW THEN
  GWIN_CHILD[GWIN_PARENT[GW]]=NXT
 ENDIF
 IF PRV THEN
  GWIN_NEXT[PRV]=NXT
 ENDIF
 IF NXT THEN
  GWIN_PREV[NXT]=PRV
 ENDIF
 VAR FGW=GWIN_BACK
 WHILE FGW
  IF!GWIN_NEXT[FGW] THEN BREAK
  FGW=GWIN_NEXT[FGW]
 WEND
 GWIN_NEXT[FGW]=GW
 GWIN_PREV[GW]=FGW
 GWIN_NEXT[GW]=0
END
DEF GWIN_FIND(GW,NAME$)
 GW=GWIN_CHILD[GW]
 WHILE GW
  IF GWIN_NAME$[GW]==NAME$ THEN BREAK
  GW=GWIN_NEXT[GW]
 WEND
 RETURN GW
END
DEF GWIN_FIND_BY_EVENT(GW,EVENT$)
 GW=GWIN_CHILD[GW]
 WHILE GW
  IF GWIN_EVENT$[GW]==EVENT$ THEN BREAK
  GW=GWIN_NEXT[GW]
 WEND
 RETURN GW
END
'FIXME:CHILD W
DEF GWIN_MOVE GW,X,Y
 GWIN_UPDATED=#TRUE
 GWIN_X[GW]=X+GWIN_X[GWIN_PARENT[GW]]+GWIN_FW1[GWIN_PARENT[GW]]
 GWIN_Y[GW]=Y+GWIN_Y[GWIN_PARENT[GW]]+GWIN_FH1[GWIN_PARENT[GW]]
 VAR PARENT=GWIN_PARENT[GW]
 IF PARENT!=GWIN_ROOT THEN
  GWIN_DRAW_X[GW]=X+GWIN_DRAW_X[PARENT]+GWIN_FW1[PARENT]
  GWIN_DRAW_Y[GW]=Y+GWIN_DRAW_Y[PARENT]+GWIN_FH1[PARENT]
 ENDIF
 GWIN_REL_X[GW]=X
 GWIN_REL_Y[GW]=Y
 GWIN_MOVE_CHILDREN GWIN_CHILD[GW]
END
DEF GWIN_MOVERESIZE GW,X,Y,W,H
 GWIN_UPDATED=#TRUE
 GWIN_X[GW]=X+GWIN_X[GWIN_PARENT[GW]]+GWIN_FW1[GWIN_PARENT[GW]]
 GWIN_Y[GW]=Y+GWIN_Y[GWIN_PARENT[GW]]+GWIN_FH1[GWIN_PARENT[GW]]
 VAR PARENT=GWIN_PARENT[GW]
 IF PARENT!=GWIN_ROOT THEN
  GWIN_DRAW_X[GW]=X+GWIN_DRAW_X[PARENT]+GWIN_FW1[PARENT]
  GWIN_DRAW_Y[GW]=Y+GWIN_DRAW_Y[PARENT]+GWIN_FH1[PARENT]
 ENDIF
 GWIN_REL_X[GW]=X
 GWIN_REL_Y[GW]=Y
 GWIN_W[GW]=W
 GWIN_H[GW]=H
 GWIN_MOVE_CHILDREN GWIN_CHILD[GW]
 IF PARENT==GWIN_ROOT THEN
  RESIZE GWIN_GET_FRAME_BUF(GW),W*H
  GWIN_PAINT GW,#TRUE
 ENDIF
END
DEF GWIN_MOVE_CHILDREN GW
 WHILE GW
  GWIN_X[GW]=GWIN_REL_X[GW]+GWIN_X[GWIN_PARENT[GW]]+GWIN_FW1[GWIN_PARENT[GW]]
  GWIN_Y[GW]=GWIN_REL_Y[GW]+GWIN_Y[GWIN_PARENT[GW]]+GWIN_FH1[GWIN_PARENT[GW]]
  VAR PARENT=GWIN_PARENT[GW]
  IF PARENT!=GWIN_ROOT THEN
   GWIN_DRAW_X[GW]=GWIN_REL_X[GW]+GWIN_DRAW_X[PARENT]+GWIN_FW1[PARENT]
   GWIN_DRAW_Y[GW]=GWIN_REL_Y[GW]+GWIN_DRAW_Y[PARENT]+GWIN_FH1[PARENT]
  ENDIF
  IF GWIN_CHILD[GW] THEN
   GWIN_MOVE_CHILDREN GWIN_CHILD[GW]
  ENDIF
  GW=GWIN_NEXT[GW]
 WEND
END
DEF GWIN_SET_FRAME GW,FW1,FH1,FW2,FH2
 IF GWIN_FW1[GW]!=FW1||GWIN_FH1[GW]!=FH1||GWIN_FW2[GW]!=FW2||GWIN_FH2[GW]!=FH2 THEN
  GWIN_FW1[GW]=FW1
  GWIN_FH1[GW]=FH1
  GWIN_FW2[GW]=FW2
  GWIN_FH2[GW]=FH2
  GWIN_MOVE_CHILDREN GWIN_CHILD[GW]
 ENDIF
END
'FIXME:GLOBAL
VAR GWIN_RESIZING
VAR GWIN_CLOSING
VAR GWIN_CLOSING_PUSH
VAR GWIN_RESIZING_DX
VAR GWIN_RESIZING_DY
VAR GWIN_RESIZING_REL_X
VAR GWIN_RESIZING_REL_Y

DEF GWIN_EVENT GW,EVENT,A1,A2,A3,A4
 IF (GWIN_FLG[GW]AND #GWIN_FLG_NOFRAME) THEN
  RETURN
 ENDIF
 CASE EVENT
 WHEN #GWIN_EVENT_LEAVE
  GWIN_DRAW_WINDOW GW,EVENT,GWIN_GET_DRAW_X(GW),GWIN_GET_DRAW_Y(GW),GWIN_W[GW],GWIN_H[GW],GWIN_NAME$[GW] OUT ,,,
 WHEN #GWIN_EVENT_NEW
 WHEN #GWIN_EVENT_PAINT
  VAR FCX,FCY,FCW,FCH
  GWIN_DRAW_WINDOW GW,EVENT,GWIN_GET_DRAW_X(GW),GWIN_GET_DRAW_Y(GW),GWIN_W[GW],GWIN_H[GW],GWIN_NAME$[GW] OUT FCX,FCY,FCW,FCH
  VAR FW1=FCX-GWIN_DRAW_X[GW]
  VAR FH1=FCY-GWIN_DRAW_Y[GW]
  VAR FW2=GWIN_W[GW]-FCW-FW1
  VAR FH2=GWIN_H[GW]-FCH-FH1
  GWIN_SET_FRAME GW,FW1,FH1,FW2,FH2
  IF EVENT==#GWIN_EVENT_NEW THEN
   GWIN_SET_MIN_SIZE GW,100,FH1+FH2
  ENDIF
 WHEN #GWIN_EVENT_LDWN
  GWIN_FRONT GW
  GWIN_DRAW_WINDOW GW,EVENT,GWIN_GET_DRAW_X(GW),GWIN_GET_DRAW_Y(GW),GWIN_W[GW],GWIN_H[GW],GWIN_NAME$[GW] OUT FCX,FCY,FCW,FCH
 WHEN #GWIN_EVENT_ACTIVE
  GWIN_PAINT GW,#TRUE
 WHEN #GWIN_EVENT_LUP
  VAR CGW,FRAME,CX,CY
  GWIN_GET_CAPTURE OUT CGW,FRAME,CX,CY
  IF FRAME&&CGW&&GW THEN
   IF GWIN_CLOSING&&GWIN_CLOSING_PUSH THEN
    GWIN_CLOSING=#FALSE
    GWIN_CLOSE GW
   ENDIF
  ENDIF
 WHEN #GWIN_EVENT_MMOVE
  GWIN_DRAW_WINDOW GW,EVENT,GWIN_GET_DRAW_X(GW),GWIN_GET_DRAW_Y(GW),GWIN_W[GW],GWIN_H[GW],GWIN_NAME$[GW] OUT FCX,FCY,FCW,FCH
  GWIN_GET_CAPTURE OUT CGW,FRAME,CX,CY
  IF FRAME&&CGW&&GW THEN
   VAR X=GWIN_GET_X(GW)
   VAR Y=GWIN_GET_Y(GW)
   VAR W=GWIN_GET_W(GW)
   VAR H=GWIN_GET_H(GW)
   VAR DF
   IF GWIN_RESIZING THEN
    IF GWIN_RESIZING_DX==1 THEN
     W=A1+GWIN_RESIZING_REL_X
     W=MAX(GWIN_MIN_W[GW],W)
    ELSEIF GWIN_RESIZING_DX==-1 THEN
     DF=CX-A1
     VAR OW=W
     INC W,DF
     W=MAX(GWIN_MIN_W[GW],W)
     X=GWIN_GET_X(GW)-(W-OW)
    ENDIF
    IF GWIN_RESIZING_DY==1 THEN
     H=A2+GWIN_RESIZING_REL_Y
     H=MAX(GWIN_MIN_H[GW],H)
    ELSEIF GWIN_RESIZING_DY==-1 THEN
     DF=CY-A2
     VAR OH=H
     INC H,DF
     H=MAX(GWIN_MIN_H[GW],H)
     Y=GWIN_GET_Y(GW)-(H-OH)
    ENDIF
    GWIN_MOVERESIZE GW,X,Y,W,H
   ELSEIF GWIN_CLOSING THEN
    GWIN_DRAW_WINDOW GW,EVENT,GWIN_GET_DRAW_X(GW),GWIN_GET_DRAW_Y(GW),GWIN_W[GW],GWIN_H[GW],GWIN_NAME$[GW] OUT ,,,
   ELSE
    GWIN_MOVE GW,GWIN_GET_X(GW)+A1-CX,GWIN_GET_Y(GW)+A2-CY
   ENDIF
  ENDIF
 ENDCASE
END
DEF GWIN_SET_MIN_SIZE GW,W,H
 GWIN_MIN_W[GW]=W
 GWIN_MIN_H[GW]=H
END
DEF GWIN_SET_NOTIF GW,NOTIF
 GWIN_NOTIF[GW]=NOTIF
END
DEF GWIN_SEND_NOTIF GW,NOTIF_TYP,A3,A4
 CALL GWIN_EVENT$[GWIN_NOTIF[GW]],GWIN_NOTIF[GW],#GWIN_EVENT_NOTIF,NOTIF_TYP,GW,A3,A4
END
DEF GWIN_GET_ID(GW)
 RETURN GWIN_ID[GW]
END
DEF GWIN_GET_DRAW_X(GW)
 RETURN GWIN_DRAW_X[GW]
END
DEF GWIN_GET_DRAW_Y(GW)
 RETURN GWIN_DRAW_Y[GW]
END
DEF GWIN_GET_CX(GW)
 RETURN GWIN_DRAW_X[GW]+GWIN_FW1[GW]
END
DEF GWIN_GET_CY(GW)
 RETURN GWIN_DRAW_Y[GW]+GWIN_FH1[GW]
END
DEF GWIN_GET_CLIENT_X(GW)
 RETURN GWIN_X[GW]+GWIN_FW1[GW]
END
DEF GWIN_GET_CLIENT_Y(GW)
 RETURN GWIN_Y[GW]+GWIN_FH1[GW]
END
DEF GWIN_GET_CW(GW)
 RETURN GWIN_W[GW]-GWIN_FW1[GW]-GWIN_FW2[GW]
END
DEF GWIN_GET_CH(GW)
 RETURN GWIN_H[GW]-GWIN_FH1[GW]-GWIN_FH2[GW]
END
DEF GWIN_GET_CLIENT_W(GW)
 RETURN GWIN_W[GW]-GWIN_FW1[GW]-GWIN_FW2[GW]
END
DEF GWIN_GET_CLIENT_H(GW)
 RETURN GWIN_H[GW]-GWIN_FH1[GW]-GWIN_FH2[GW]
END
DEF GWIN_GET_X(GW)
 RETURN GWIN_X[GW]
END
DEF GWIN_GET_Y(GW)
 RETURN GWIN_Y[GW]
END
DEF GWIN_GET_W(GW)
 RETURN GWIN_W[GW]
END
DEF GWIN_GET_H(GW)
 RETURN GWIN_H[GW]
END
DEF GWIN_GET_NAME$(GW)
 RETURN GWIN_NAME$[GW]
END
DEF GWIN_GET_EVENT$(GW)
 RETURN GWIN_EVENT$[GW]
END
DEF GWIN_SET_NAME GW,N$
 GWIN_NAME$[GW]=N$
END
DEF GWIN_ROOT_EVENT GW,EVENT,A1,A2,A3,A4
END
DEF GWIN_MSG_BOX_ERR ERR$
 VAR MSGBOX_WIDTH=300
 VAR MSGBOX_HEIGHT=114
 VAR SCRW=GDEBUG_WIDTH
 VAR SCRH=GDEBUG_HEIGHT
 VAR GWIN=GWIN_NEW(GWIN_ROOT,(SCRW-MSGBOX_WIDTH)DIV 2,(SCRH-MSGBOX_HEIGHT)DIV 2,MSGBOX_WIDTH,MSGBOX_HEIGHT,GDEBUG_RES$(#GDBG_MSGBOX_ERROR),"GWIN_MSGBOX_EVENT")
 GWIN_SET_NAME GWIN_FIND(GWIN,""),ERR$
 GWIN_PAINT GWIN,#FALSE
 GWIN_FRONT GWIN
 VAR ID=GWIN_GET_ID(GWIN)
 LOOP
  IF GWIN_GET_ID(GWIN)!=ID THEN BREAK
  GWIN_MAIN_LOOP
 ENDLOOP
END
CONST #GWIN_MSGBOX_RESULT_CLOSE_BUTTON=0
CONST #GWIN_MSGBOX_RESULT_OK=1
CONST #GWIN_MSGBOX_RESULT_YES=2
CONST #GWIN_MSGBOX_RESULT_NO=3
CONST #GWIN_MSGBOX_RESULT_CANCEL=4

CONST #GWIN_MSGBOX_OK=0
CONST #GWIN_MSGBOX_YES=1
CONST #GWIN_MSGBOX_YESNO=2
CONST #GWIN_MSGBOX_YESNOCANCEL=3
CONST #GWIN_MSGBOX_BTN_MASK=65535
CONST #GWIN_MSGBOX_ICON_MASK=268369920
CONST #GWIN_MSGBOX_ICON_INFO=0
CONST #GWIN_MSGBOX_ICON_ERR=65536
CONST #GWIN_MSGBOX_ICON_WARN=2<<16

ENUM #GWIN_MSGBOX_V_RESULT,#GWIN_MSGBOX_V_BTN_1,#GWIN_MSGBOX_V_BTN_2,#GWIN_MSGBOX_V_BTN_3,#GWIN_MSGBOX_V_FLG
DEF GWIN_MSGBOX TITLE$,MSG$,FLG OUT RESULT
 VAR MSGBOX_WIDTH=309
 VAR MSGBOX_HEIGHT=118
 VAR SCRW=GDEBUG_WIDTH
 VAR SCRH=GDEBUG_HEIGHT
 VAR OI=GWIN_INPUT
 VAR OA=GWIN_ACTIVE
 VAR GWIN=GWIN_NEW3(GWIN_ROOT,(SCRW-MSGBOX_WIDTH)DIV 2,(SCRH-MSGBOX_HEIGHT)DIV 2,MSGBOX_WIDTH,MSGBOX_HEIGHT,TITLE$,"GWIN_MSGBOX_EVENT",0,MSG$,FLG,0,0)
 GWIN_FOCUS GWIN_GET_VAR(GWIN,#GWIN_MSGBOX_V_BTN_1)
 GWIN_PAINT GWIN,#FALSE
 GWIN_FRONT GWIN
 VAR ID=GWIN_GET_ID(GWIN)
 GWIN_SET_SYS_MODAL GWIN
 LOOP
  RESULT=GWIN_GET_VAR(GWIN,#GWIN_MSGBOX_V_RESULT)
  IF RESULT THEN
   GWIN_DELETE GWIN
   BREAK
  ENDIF
  IF GWIN_GET_ID(GWIN)!=ID THEN BREAK
  GWIN_MAIN_LOOP
 ENDLOOP
 GWIN_FOCUS OA
' GWIN_FOCUS OI
END

DEF GWIN_MSGBOX_EVENT GW,EVENT,A1,A2,A3,A4
 VAR FLG=GWIN_GET_VAR(GW,#GWIN_MSGBOX_V_FLG)
 CASE EVENT
 WHEN #GWIN_EVENT_NEW
  IF TYPEOF(A1)!=#T_STR THEN
   A1=""
  ENDIF
  VAR BTNTYP=A2 AND #GWIN_MSGBOX_BTN_MASK
  VAR BCNT=0
  VAR B1$
  VAR B2$
  VAR B3$
  GWIN_SET_VAR GW,#GWIN_MSGBOX_V_FLG,A2
  IF BTNTYP==#GWIN_MSGBOX_OK THEN
   BCNT=1
   B1$=GDEBUG_RES$(#GDBG_MSGBOX_OK)
  ELSEIF BTNTYP==#GWIN_MSGBOX_YESNO THEN
   B1$=GDEBUG_RES$(#GDBG_MSGBOX_YES)
   B2$=GDEBUG_RES$(#GDBG_MSGBOX_NO)
   BCNT=2
  ENDIF
  VAR MARGIN=14
  VAR MARGIN_BTM=10
  VAR BTN1,BTN2,BTN3
  CASE BCNT
  WHEN 1
   BTN1=GWIN_NEW(GW,(GWIN_GET_CLIENT_W(GW)-88) DIV 2,GWIN_GET_CLIENT_H(GW)-21-MARGIN_BTM,88,21,B1$,"GWIN_BUTTON_EVENT")
'   BTN1=GWIN_NEW(GW,(GWIN_GET_CLIENT_W(GW)-88) DIV 2,GWIN_GET_CLIENT_H(GW)-30,88,GWIN_GET_CLIENT_H(GW)-21-MARGIN_BTM,B1$,"GWIN_BUTTON_EVENT")
  WHEN 2
   BTN1=GWIN_NEW(GW,GWIN_GET_CLIENT_W(GW)-14-88-14-88,GWIN_GET_CLIENT_H(GW)-21-MARGIN_BTM,88,21,B1$,"GWIN_BUTTON_EVENT")
   BTN2=GWIN_NEW(GW,GWIN_GET_CLIENT_W(GW)-14-88,GWIN_GET_CLIENT_H(GW)-21-MARGIN_BTM,88,21,B2$,"GWIN_BUTTON_EVENT")
  ENDCASE
  GWIN_SET_VAR GW,#GWIN_MSGBOX_V_BTN_1,BTN1
  GWIN_SET_VAR GW,#GWIN_MSGBOX_V_BTN_2,BTN2
  GWIN_SET_VAR GW,#GWIN_MSGBOX_V_BTN_3,BTN3
  VAR LABEL_GWIN=GWIN_NEW(GW,12+32+16,10,GWIN_GET_CLIENT_W(GW)-(12+32+16),GWIN_GET_CLIENT_H(GW)-40,A1,"GWIN_LABEL_EVENT")
  GWIN_LABEL_WRAP_TEXT LABEL_GWIN
 WHEN #GWIN_EVENT_PAINT
  VAR X=GWIN_GET_CX(GW),Y=GWIN_GET_CY(GW)
  GCLS RGB(192,192,192)
  
  VAR ICONTYP=FLG AND #GWIN_MSGBOX_ICON_MASK
  IF ICONTYP==#GWIN_MSGBOX_ICON_ERR THEN
   GWIN_DRAW_ERR_ICON GW,X+12,Y+12
  ELSEIF ICONTYP==#GWIN_MSGBOX_ICON_WARN THEN
   GWIN_DRAW_WARN_ICON GW,X+12,Y+12
  ENDIF
 WHEN #GWIN_EVENT_NOTIF
  BTNTYP=FLG AND #GWIN_MSGBOX_BTN_MASK
  CASE A1
  WHEN #GWIN_NOTIF_BUTTON_PUSHED
   VAR PUSHED=0
   IF A2==GWIN_GET_VAR(GW,#GWIN_MSGBOX_V_BTN_1)THEN
    PUSHED=1
   ELSEIF A2==GWIN_GET_VAR(GW,#GWIN_MSGBOX_V_BTN_2)THEN
    PUSHED=2
   ELSEIF A2==GWIN_GET_VAR(GW,#GWIN_MSGBOX_V_BTN_3)THEN
    PUSHED=3
   ENDIF
   IF BTNTYP==#GWIN_MSGBOX_OK THEN
    VAR RESULT=#GWIN_MSGBOX_RESULT_OK
   ELSEIF BTNTYP==#GWIN_MSGBOX_YESNO THEN
    IF PUSHED==1 THEN
     RESULT=#GWIN_MSGBOX_RESULT_YES
    ELSE
     RESULT=#GWIN_MSGBOX_RESULT_NO
    ENDIF
   ELSEIF BTNTYP==#GWIN_MSGBOX_YESNOCANCEL THEN
    IF PUSHED==1 THEN
     RESULT=#GWIN_MSGBOX_RESULT_YES
    ELSEIF PUSHED==2 THEN
     RESULT=#GWIN_MSGBOX_RESULT_NO
    ELSE
     RESULT=#GWIN_MSGBOX_RESULT_CANCEL
    ENDIF
   ENDIF
   GWIN_SET_VAR GW,#GWIN_MSGBOX_V_RESULT,RESULT
  ENDCASE
 ENDCASE
END
DIM GWIN_ERR_ICON[,]
DEF GWIN_DRAW_ERR_ICON GW,X,Y
 IF TYPEOF(GWIN_ERR_ICON)==#T_DEFAULT THEN
  VAR B=RGB(0,0,0)
  VAR C=RGB(192,192,192)
  VAR R=RGB(255,0,0)
  C=R
  VAR W=RGB(255,255,255)
  DIM A%[29,29]=[\
   0,0,0,0,0,0,0,0,0,0,0,B,B,B,B,B,B,B,0,0,0,0,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,0,0,B,B,B,C,C,C,C,C,C,C,B,B,B,0,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,B,B,C,C,C,R,R,R,R,R,R,R,C,C,C,B,B,0,0,0,0,0,0,\
   0,0,0,0,0,B,C,C,R,R,R,R,R,R,R,R,R,R,R,R,R,C,C,B,0,0,0,0,0,\
   0,0,0,0,B,C,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,C,B,0,0,0,0,\
   0,0,0,B,C,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,C,B,0,0,0,\
   0,0,B,C,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,C,B,0,0,\
   0,0,B,C,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,C,B,0,0,\
   0,B,C,R,R,R,R,R,R,R,W,R,R,R,R,R,R,R,W,R,R,R,R,R,R,R,C,B,0,\
   0,B,C,R,R,R,R,R,R,W,W,W,R,R,R,R,R,W,W,W,R,R,R,R,R,R,C,B,0,\
   0,B,C,R,R,R,R,R,W,W,W,W,W,R,R,R,W,W,W,W,W,R,R,R,R,R,C,B,0,\
   B,C,R,R,R,R,R,R,R,W,W,W,W,W,R,W,W,W,W,W,R,R,R,R,R,R,R,C,B,\
   B,C,R,R,R,R,R,R,R,R,W,W,W,W,W,W,W,W,W,R,R,R,R,R,R,R,R,C,B,\
   B,C,R,R,R,R,R,R,R,R,R,W,W,W,W,W,W,W,R,R,R,R,R,R,R,R,R,C,B,\
   B,C,R,R,R,R,R,R,R,R,R,R,W,W,W,W,W,R,R,R,R,R,R,R,R,R,R,C,B,\
   B,C,R,R,R,R,R,R,R,R,R,W,W,W,W,W,W,W,R,R,R,R,R,R,R,R,R,C,B,\
   B,C,R,R,R,R,R,R,R,R,W,W,W,W,W,W,W,W,W,R,R,R,R,R,R,R,R,C,B,\
   B,C,R,R,R,R,R,R,R,W,W,W,W,W,R,W,W,W,W,W,R,R,R,R,R,R,R,C,B,\
   0,B,C,R,R,R,R,R,W,W,W,W,W,R,R,R,W,W,W,W,W,R,R,R,R,R,C,B,0,\
   0,B,C,R,R,R,R,R,R,W,W,W,R,R,R,R,R,W,W,W,R,R,R,R,R,R,C,B,0,\
   0,B,C,R,R,R,R,R,R,R,W,R,R,R,R,R,R,R,W,R,R,R,R,R,R,R,C,B,0,\
   0,0,B,C,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,C,B,0,0,\
   0,0,B,C,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,C,B,0,0,\
   0,0,0,B,C,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,C,B,0,0,0,\
   0,0,0,0,B,C,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,C,B,0,0,0,0,\
   0,0,0,0,0,B,C,C,R,R,R,R,R,R,R,R,R,R,R,R,R,C,C,B,0,0,0,0,0,\
   0,0,0,0,0,0,B,B,C,C,C,R,R,R,R,R,R,R,C,C,C,B,B,0,0,0,0,0,0,\
   0,0,0,0,0,0,0,0,B,B,B,C,C,C,C,C,C,C,B,B,B,0,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,0,0,0,0,0,B,B,B,B,B,B,B,0,0,0,0,0,0,0,0,0,0,0\
  ]
  GWIN_ERR_ICON=A%
 ENDIF
 GLOAD X+1,Y+1,29,29,GWIN_ERR_ICON,#G_NORMAL2
END
DIM GWIN_WARN_ICON[,]
DEF GWIN_DRAW_WARN_ICON GW,X,Y_
 IF TYPEOF(GWIN_WARN_ICON)==#T_DEFAULT THEN
  VAR B=RGB(0,0,0)
  VAR G=RGB(128,128,128)
  VAR Y=RGB(255,255,0)
  VAR W=RGB(255,255,255)
  DIM A%[31,30]=[\
   0,0,0,0,0,0,0,0,0,0,0,0,0,B,B,B,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,0,0,0,0,0,0,B,Y,Y,Y,B,G,0,0,0,0,0,0,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,0,0,0,0,0,0,B,Y,Y,Y,B,G,G,0,0,0,0,0,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,0,0,0,0,0,B,Y,Y,Y,Y,Y,B,G,G,0,0,0,0,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,0,0,0,0,0,B,Y,Y,Y,Y,Y,B,G,G,0,0,0,0,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,0,0,0,0,B,Y,Y,Y,Y,Y,Y,Y,B,G,G,0,0,0,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,0,0,0,0,B,Y,Y,B,B,B,Y,Y,B,G,G,0,0,0,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,0,0,0,B,Y,Y,Y,B,B,B,Y,Y,Y,B,G,G,0,0,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,0,0,0,B,Y,Y,Y,B,B,B,Y,Y,Y,B,G,G,0,0,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,0,0,B,Y,Y,Y,Y,B,B,B,Y,Y,Y,Y,B,G,G,0,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,0,0,B,Y,Y,Y,Y,B,B,B,Y,Y,Y,Y,B,G,G,0,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,0,B,Y,Y,Y,Y,Y,B,B,B,Y,Y,Y,Y,Y,B,G,G,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,0,B,Y,Y,Y,Y,Y,B,B,B,Y,Y,Y,Y,Y,B,G,G,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,B,Y,Y,Y,Y,Y,Y,B,B,B,Y,Y,Y,Y,Y,Y,B,G,G,0,0,0,0,0,0,\
   0,0,0,0,0,0,B,Y,Y,Y,Y,Y,Y,B,B,B,Y,Y,Y,Y,Y,Y,B,G,G,0,0,0,0,0,0,\
   0,0,0,0,0,B,Y,Y,Y,Y,Y,Y,Y,B,B,B,Y,Y,Y,Y,Y,Y,Y,B,G,G,0,0,0,0,0,\
   0,0,0,0,0,B,Y,Y,Y,Y,Y,Y,Y,B,B,B,Y,Y,Y,Y,Y,Y,Y,B,G,G,0,0,0,0,0,\
   0,0,0,0,B,Y,Y,Y,Y,Y,Y,Y,Y,B,B,B,Y,Y,Y,Y,Y,Y,Y,Y,B,G,G,0,0,0,0,\
   0,0,0,0,B,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,B,G,G,0,0,0,0,\
   0,0,0,B,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,B,G,G,0,0,0,\
   0,0,0,B,Y,Y,Y,Y,Y,Y,Y,Y,Y,B,B,B,Y,Y,Y,Y,Y,Y,Y,Y,Y,B,G,G,0,0,0,\
   0,0,B,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,B,B,B,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,B,G,G,0,0,\
   0,0,B,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,B,B,B,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,B,G,G,0,0,\
   0,B,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,B,B,B,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,B,G,G,0,\
   0,B,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,B,G,G,0,\
   B,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,B,G,G,\
   B,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,B,G,G,\
   0,B,B,B,B,B,B,B,B,B,B,B,B,B,B,B,B,B,B,B,B,B,B,B,B,B,B,B,G,G,G,\
   0,0,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,\
   0,0,0,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,0\
  ]
  GWIN_WARN_ICON=A%
 ENDIF
 GLOAD X+1,Y_+1,DIM(GWIN_WARN_ICON,0),DIM(GWIN_WARN_ICON,1),GWIN_WARN_ICON,#G_NORMAL2
END
VAR GDEBUG_ABOUT_NAME$
VAR GDEBUG_ABOUT_AUTHOR$
DEF GDEBUG_ABOUT
 VAR GW=GWIN_NEW2(GWIN_ROOT,(GDEBUG_WIDTH-400)DIV 2,(GDEBUG_HEIGHT-91)DIV 2,400,91+25,GDEBUG_RES$(#GDBG_ABOUT),"GDEBUG_ABOUT_EVENT",0)
 GWIN_FRONT GW
 GWIN_SET_SYS_MODAL GW
END
DEF GDEBUG_ABOUT_EVENT GW,EVENT,A1,A2,A3,A4
 CASE EVENT
 WHEN #GWIN_EVENT_NEW
  GDEBUG_ABOUT_NAME$=GDEBUG_RES$(#GDBG_ABOUT_NAME)
  GDEBUG_ABOUT_AUTHOR$=GDEBUG_RES$(#GDBG_ABOUT_AUTHOR)
  VAR BTN=GWIN_NEW(GW,0,0,88,21,GDEBUG_RES$(#GDBG_MSGBOX_OK),"GWIN_BUTTON_EVENT")
 WHEN #GWIN_EVENT_DELETE
  GWIN_SET_SYS_MODAL 0
  GWIN_FOCUS GDEBUG_PRG_GWIN
 WHEN #GWIN_EVENT_NOTIF
  IF A1==#GWIN_NOTIF_BUTTON_PUSHED THEN
   GWIN_CLOSE GW
  ENDIF
 WHEN #GWIN_EVENT_PAINT
  GCLS RGB(192,192,192)
  VAR X=GWIN_GET_CX(GW),Y=GWIN_GET_CY(GW)
  VAR W=GWIN_GET_CW(GW),H=GWIN_GET_CH(GW)
  VAR ICON_MARG=8
  GWIN_DRAW_GDEBUG_ICON X+ICON_MARG,Y+ICON_MARG
  VAR FW=FONT_CALC_WIDTH(GDEBUG_SYS_FONT,GDEBUG_ABOUT_NAME$)
  VAR TEXT_MARG=ICON_MARG+48+8
  GPUTCHR_FONT GDEBUG_SYS_FONT,X+TEXT_MARG+(W-FW-TEXT_MARG) DIV 2,Y+ICON_MARG,#FALSE,GDEBUG_ABOUT_NAME$,RGB(0,0,0)
  FW=FONT_CALC_WIDTH(GDEBUG_SYS_FONT,GDEBUG_ABOUT_AUTHOR$)
  GPUTCHR_FONT GDEBUG_SYS_FONT,X+TEXT_MARG+(W-FW-TEXT_MARG) DIV 2,Y+ICON_MARG+FONT_GET_LINE_HEIGHT(GDEBUG_SYS_FONT),#FALSE,GDEBUG_ABOUT_AUTHOR$,RGB(0,0,0)
  BTN=GWIN_FIND_BY_EVENT(GW,"GWIN_BUTTON_EVENT")
  GWIN_MOVE BTN,TEXT_MARG+(W-GWIN_GET_W(BTN)-TEXT_MARG) DIV 2,ICON_MARG+FONT_GET_LINE_HEIGHT(GDEBUG_SYS_FONT)*3
 ENDCASE
END
DIM GDEBUG_ICON[,]
DEF GWIN_DRAW_GDEBUG_ICON X,Y
 IF!TYPEOF(GDEBUG_ICON)THEN
  VAR A=0
  VAR B=&HFF000000
  VAR C=&HFFFFFFFF
  VAR D=&HFF0A0000
  VAR E=&HFF800000
  VAR F=&HFFFF0000
  VAR G=&HFF00FFFF
  DIM ARY%[48,48]=[A,A,A,A,A,A,A,A,B,B,A,A,A,A,A,A,A,A,A,B,B,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,A,A,A,A,A,A,A,B,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,B,B,B,B,B,B,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,C,C,B,B,B,C,C,B,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,C,B,B,B,B,B,C,B,A,A,A,A,A,B,B,B,B,D,D,B,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,B,B,B,B,B,B,B,B,B,B,A,B,B,B,C,C,C,C,C,C,C,B,B,B,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,A,A,A,A,A,B,B,B,B,B,B,B,B,B,B,B,B,C,C,C,C,C,C,C,C,C,C,C,C,C,B,B,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,A,A,A,A,A,B,B,B,B,B,B,B,B,B,B,C,C,C,C,C,E,E,E,B,A,A,A,C,C,C,C,C,B,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,A,A,A,A,B,E,E,E,C,C,E,C,C,B,C,C,C,C,E,E,E,E,E,B,A,A,A,A,A,C,C,C,C,B,A,A,A,A,A,A,A,A,A,A,A,A,A,B,A,A,A,B,E,E,E,E,B,B,E,B,B,C,C,C,E,E,E,E,E,E,E,E,B,A,A,A,A,B,B,C,C,C,B,A,A,A,A,A,A,A,A,A,A,A,A,A,B,A,B,E,E,E,E,B,B,B,E,D,C,C,C,E,E,E,E,E,E,E,E,E,B,A,A,A,A,B,B,A,C,C,C,B,A,A,A,A,A,A,A,A,A,A,A,A,A,B,B,E,E,E,F,B,B,B,B,C,C,C,E,E,E,E,E,E,E,E,E,E,B,A,A,A,B,B,B,A,A,C,C,C,B,A,A,A,A,A,A,A,A,A,A,A,A,A,B,F,F,F,F,B,B,B,B,C,C,F,F,C,C,C,F,F,F,F,F,F,F,B,A,B,B,B,A,A,A,A,C,C,B,A,A,A,A,A,A,A,A,A,A,A,A,B,F,F,F,F,F,F,B,B,C,C,C,F,F,C,C,C,F,F,F,F,F,F,F,F,B,B,B,A,A,A,A,A,C,C,C,B,A,A,A,A,A,A,A,A,A,A,B,B,F,F,F,F,F,F,F,B,C,C,F,F,F,C,C,C,F,F,F,F,F,F,F,F,F,B,A,A,A,A,A,A,A,C,C,D,A,A,A,A,A,A,A,A,A,B,A,B,F,F,F,B,B,F,F,B,C,C,F,F,F,F,F,F,F,B,B,B,F,F,F,F,F,F,B,A,A,A,A,A,A,C,C,B,A,A,A,A,A,A,B,B,B,A,A,B,F,F,B,B,B,B,B,C,C,F,F,F,F,F,F,F,B,B,B,B,B,B,F,F,F,F,F,B,A,A,A,A,A,A,C,C,B,A,A,A,A,A,A,A,A,A,B,F,F,F,B,B,B,B,B,C,C,F,F,F,F,F,F,F,B,B,B,B,B,B,B,F,F,F,F,B,A,A,A,A,A,A,C,C,B,A,A,A,A,A,A,A,A,A,B,F,F,F,B,B,B,B,B,C,C,F,F,F,F,F,F,B,B,B,B,B,B,B,B,B,F,F,F,F,B,A,A,A,A,A,C,C,B,A,A,A,A,A,A,A,A,A,B,F,F,F,F,B,B,F,B,C,C,F,F,F,F,F,F,B,B,B,B,B,B,B,B,B,B,F,F,F,B,A,A,A,A,A,C,C,D,A,A,A,A,A,A,A,A,A,B,F,F,F,F,F,F,F,B,C,C,F,F,F,F,F,F,B,B,B,B,B,B,B,B,B,B,F,F,F,B,A,A,A,A,A,C,C,D,A,A,A,A,A,A,A,A,A,B,F,F,F,F,F,F,F,B,C,C,F,F,F,F,F,F,F,B,B,B,B,B,B,B,B,B,F,F,F,F,B,A,A,A,A,C,C,D,A,A,A,A,A,A,A,A,A,B,F,F,F,F,F,F,F,B,C,C,F,F,F,F,F,F,F,B,B,B,B,B,B,B,B,B,F,F,F,F,B,B,A,A,A,C,C,D,A,A,A,A,A,A,A,A,A,B,F,F,B,B,F,F,F,F,B,C,C,F,F,F,F,F,F,F,B,B,B,B,B,B,B,B,F,F,F,F,B,B,B,A,C,C,B,A,A,A,A,A,A,A,A,A,A,A,B,B,B,B,B,F,F,F,B,C,C,F,F,F,F,F,F,F,F,B,B,B,B,B,B,F,F,F,F,F,B,B,B,B,C,C,B,A,A,A,A,A,A,A,A,A,A,A,B,B,B,B,B,F,F,F,B,C,C,C,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,B,A,B,C,C,C,B,A,A,A,A,A,A,A,A,A,A,A,B,B,B,B,B,F,F,F,F,B,C,C,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,B,A,A,C,C,B,A,A,A,A,A,A,A,A,A,A,A,B,A,A,B,B,F,F,F,F,F,B,C,C,C,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,B,A,C,C,C,B,A,A,A,A,A,A,A,A,A,A,A,B,A,A,A,B,B,F,F,F,F,E,B,C,C,C,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,B,C,C,C,B,A,A,A,A,A,A,A,A,A,A,A,A,B,A,A,A,A,A,B,B,B,B,B,B,B,C,C,C,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,C,C,C,D,A,A,A,A,A,A,A,A,A,A,A,A,A,B,A,A,A,A,A,A,A,A,A,A,A,A,D,C,C,C,C,F,F,F,F,F,F,F,F,F,F,F,C,C,C,C,B,D,A,A,A,A,A,A,A,A,A,A,A,A,B,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,C,C,C,C,C,F,F,F,F,F,F,F,C,C,C,C,C,B,D,D,D,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,B,C,C,C,C,C,C,C,C,C,C,C,C,C,D,B,D,G,G,D,D,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,D,B,C,C,C,C,C,C,C,B,B,B,D,D,G,G,D,D,C,B,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,D,D,D,D,D,B,A,A,A,A,D,G,D,D,D,D,C,B,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,D,D,D,D,D,D,C,B,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,D,D,D,D,D,D,C,B,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,D,D,D,D,D,D,C,B,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,D,D,D,D,D,D,C,B,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,D,D,D,D,D,D,C,B,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,D,D,D,D,D,D,C,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,D,D,D,D,D,D,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,D,D,D,D,D,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,D,D,D,D,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,D,D,D,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,D,B,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,B,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A]
  GDEBUG_ICON=ARY%
 ENDIF
 GLOAD X,Y,DIM(GDEBUG_ICON,0),DIM(GDEBUG_ICON,1),GDEBUG_ICON,#G_NORMAL2
END
DEF GDEBUG_EXIT
 VAR RESULT
 GWIN_MSGBOX "SBDBG",GDEBUG_RES$(#GDBG_EXIT_MSG),#GWIN_MSGBOX_ICON_WARN OR #GWIN_MSGBOX_YESNO OUT RESULT
END
DEF GDEBUG_IMPORT_SLOT SLOT
 VAR RESULT
 VAR CURSLOT=GDEBUG_GET_PRG_SLOT()
 IF VM_IS_SLOT_COMPILED(CURSLOT)THEN
  GWIN_MSGBOX "SBDBG",FORMAT$(GDEBUG_RES$(#GDBG_ERR_SLOT_MSG),CURSLOT),#GWIN_MSGBOX_ICON_WARN OR #GWIN_MSGBOX_YESNO OUT RESULT
  IF RESULT==#GWIN_MSGBOX_RESULT_YES THEN
   GDEBUG_TERM
   GDEBUG_UPDATE_WINDOW #GDEBUG_UPDATE_BACKTRACE OR #GDEBUG_UPDATE_VAR OR #GDEBUG_UPDATE_SRC OR #GDEBUG_UPDATE_ERROR
  ELSE
   RETURN
  ENDIF
 ELSE
  GWIN_MSGBOX "SBDBG",FORMAT$(GDEBUG_RES$(#GDBG_DISCARD_SLOT_MSG),CURSLOT),#GWIN_MSGBOX_ICON_WARN OR #GWIN_MSGBOX_YESNO OUT RESULT
  IF RESULT!=#GWIN_MSGBOX_RESULT_YES THEN
   RETURN
  ENDIF
 ENDIF
 VAR IN$=GET_SLOT$(SLOT)
 SET_VSLOT CURSLOT,IN$
 GWIN_PAINT GDEBUG_PRG_GWIN,#FALSE
END
ENUM #GWIN_BUTTON_V_PUSH
DEF GWIN_BUTTON_EVENT GW,EVENT,A1,A2,A3,A4
 VAR X=GWIN_GET_CX(GW),Y=GWIN_GET_CY(GW)
 VAR W=GWIN_GET_CW(GW),H=GWIN_GET_CH(GW)
 VAR PUSH=GWIN_GET_VAR(GW,#GWIN_BUTTON_V_PUSH),ST
 CASE EVENT
 WHEN #GWIN_EVENT_LDWN
  GWIN_SET_VAR GW,#GWIN_BUTTON_V_PUSH,#TRUE
  GWIN_SET_CAPTURE GW,#FALSE
    GWIN_PAINT GW,#FALSE
 WHEN #GWIN_EVENT_MMOVE
  VAR C_GW
  GWIN_GET_CAPTURE OUT C_GW,,,
  IF C_GW!=GW THEN RETURN
  VAR MX=GWIN_GET_MOUSE_X(GW),MY=GWIN_GET_MOUSE_Y(GW)
  IF X<=MX&&X+W>MX&&Y<=MY&&Y+H>MY THEN
   IF !PUSH THEN
    GWIN_SET_VAR GW,#GWIN_BUTTON_V_PUSH,#TRUE
    GWIN_PAINT GW,#FALSE
   ENDIF
  ELSE
   IF PUSH THEN
    GWIN_SET_VAR GW,#GWIN_BUTTON_V_PUSH,#FALSE
    GWIN_PAINT GW,#FALSE
   ENDIF
  ENDIF
 WHEN #GWIN_EVENT_LUP
  GWIN_GET_CAPTURE OUT C_GW,,,
  GWIN_SET_VAR GW,#GWIN_BUTTON_V_PUSH,#FALSE
  GWIN_PAINT GW,#FALSE
  IF C_GW==GW THEN
   IF\
      A1>=0&&A1<GWIN_GET_W(GW)&&\
      A2>=0&&A2<GWIN_GET_H(GW) THEN
    GWIN_SEND_NOTIF GW,#GWIN_NOTIF_BUTTON_PUSHED,0,0
   ENDIF
  ENDIF
 WHEN #GWIN_EVENT_CHFOCUS
  GWIN_PAINT GW,#FALSE
 WHEN #GWIN_EVENT_PAINT
  VAR N$=GWIN_GET_NAME$(GW)
  IF PUSH THEN
   ST=#GWIN_DRAW_BUTTON_SUNKEN
  ELSE
   ST=#GWIN_DRAW_BUTTON_RAISED
  ENDIF
  GWIN_DRAW_BUTTON2 X,Y,W,H,ST
  VAR FW=FONT_CALC_WIDTH(GDEBUG_SYS_FONT,N$)
  GPUTCHR_FONT GDEBUG_SYS_FONT,PUSH+X+(W-FW) DIV 2,PUSH+Y+(H-GDEBUG_SYS_FONT_SIZE) DIV 2,#FALSE,N$,RGB(0,0,0)
  IF GWIN_IS_FOCUSED(GW) THEN
   GBOX X,Y,X+W-1,Y+H-1,RGB(0,0,0)
  ENDIF
 ENDCASE
END
DEF GWIN_LABEL_WRAP_TEXT GW
 VAR SI=0
 VAR I=0
 VAR N$=GWIN_GET_NAME$(GW)
 VAR SP$=CHR$(32)+CHR$(10)
 VAR X=0
 VAR W=GWIN_GET_W(GW)
 VAR R$=""
 WHILE I<LEN(N$)
  VAR C$=N$[I]
  IF INSTR(SP$,C$)!=-1||I==LAST(N$) THEN
   INC I
   VAR DT$=MID$(N$,SI,I-SI)
   VAR FW=FONT_CALC_WIDTH(GDEBUG_SYS_FONT,DT$)
   IF C$==CHR$(10)THEN
    PUSH R$,DT$
    X=0
   ELSE
    INC X,FW
    IF X>=W THEN
     PUSH R$,CHR$(10)
     X=FW
    ENDIF
    PUSH R$,DT$
   ENDIF
   SI=I
  ELSE
   INC I
  ENDIF
 WEND
 GWIN_SET_NAME GW,R$
END
DEF GWIN_LABEL_EVENT GW,EVENT,A1,A2,A3,A4
 CASE EVENT
 WHEN #GWIN_EVENT_PAINT
  GCLS RGB(192,192,192)
  VAR N$=GWIN_GET_NAME$(GW)
  VAR I
  VAR X=GWIN_GET_CX(GW),Y=GWIN_GET_CY(GW)
  VAR W=GWIN_GET_CW(GW)
  LOOP
   VAR NI=INSTR(I,N$,CHR$(10))
   IF NI==-1 THEN NI=LEN(N$)
   VAR T$=MID$(N$,I,NI-I)
   GPUTCHR_FONT GDEBUG_SYS_FONT,X,Y,#FALSE,T$,RGB(0,0,0)
   IF NI==LEN(N$)THEN BREAK
   I=NI+1
   INC Y,FONT_GET_LINE_HEIGHT(GDEBUG_SYS_FONT)
  ENDLOOP
 ENDCASE
END
ENUM #GWIN_TBOX_V_CUR,#GWIN_TBOX_V_SX,#GWIN_TBOX_V_EX

DEF GWIN_TEXTBOX_REMOVESEL GW
 VAR SX=GWIN_GET_VAR(GW,#GWIN_TBOX_V_SX)
 VAR EX=GWIN_GET_VAR(GW,#GWIN_TBOX_V_EX)
 IF SX>EX THEN
  SWAP SX,EX
 ENDIF
 VAR N$=GWIN_GET_NAME$(GW)
 IF SX!=-1 THEN
  N$=MID$(N$,0,SX)+MID$(N$,EX,&H7FFFFFFF)
  GWIN_SET_NAME GW,N$
  GWIN_SET_VAR GW,#GWIN_TBOX_V_CUR,MIN(GWIN_GET_VAR(GW,#GWIN_TBOX_V_CUR),LEN(N$))
  GWIN_SET_VAR GW,#GWIN_TBOX_V_SX,-1
  GWIN_SET_VAR GW,#GWIN_TBOX_V_EX,-1
 ENDIF
END
DEF GWIN_TEXTBOX_INS GW,T$
 VAR I
 VAR N$=GWIN_GET_NAME$(GW)
 GWIN_SET_VAR GW,#GWIN_TBOX_V_CUR,MIN(GWIN_GET_VAR(GW,#GWIN_TBOX_V_CUR),LEN(N$))
 VAR MODIED
 VAR CUR=GWIN_GET_VAR(GW,#GWIN_TBOX_V_CUR)
 FOR I=0TO LAST(T$)
  VAR C$=T$[I]
  IF C$==CHR$(29) THEN
   CUR=MAX(CUR-1,0)
   GWIN_TEXTBOX_UNSEL GW
   CONTINUE
  ENDIF
  IF C$==CHR$(28) THEN
   CUR=MIN(CUR+1,LEN(N$))
   GWIN_TEXTBOX_UNSEL GW
   CONTINUE
  ENDIF
  IF C$==CHR$(30) THEN
   CUR=0
   GWIN_TEXTBOX_UNSEL GW
   CONTINUE
  ENDIF
  IF C$==CHR$(31) THEN
   GWIN_TEXTBOX_UNSEL GW
   CUR=LEN(N$)
   CONTINUE
  ENDIF
  IF C$==CHR$(8) THEN
   IF GWIN_GET_VAR(GW,#GWIN_TBOX_V_EX)!=-1&&GWIN_GET_VAR(GW,#GWIN_TBOX_V_SX)!=-1&&GWIN_GET_VAR(GW,#GWIN_TBOX_V_SX)!=GWIN_GET_VAR(GW,#GWIN_TBOX_V_EX) THEN
    GWIN_SET_NAME GW,N$
    GWIN_SET_VAR GW,#GWIN_TBOX_V_CUR,CUR
    GWIN_TEXTBOX_REMOVESEL GW
    CUR=GWIN_GET_VAR(GW,#GWIN_TBOX_V_CUR)
    N$=GWIN_GET_NAME$(GW)
    CONTINUE
   ENDIF
   N$=MID$(N$,0,MAX(0,CUR-1))+MID$(N$,CUR,&H7FFFFFFF)
   CUR=MAX(CUR-1,0)
   CONTINUE
  ENDIF
  IF C$==CHR$(13)THEN
   CONTINUE
  ENDIF
  IF !MODIED THEN
   GWIN_SET_VAR GW,#GWIN_TBOX_V_CUR,CUR
   GWIN_TEXTBOX_REMOVESEL GW
   N$=GWIN_GET_NAME$(GW)
   MODIED=#TRUE
   CUR=GWIN_GET_VAR(GW,#GWIN_TBOX_V_CUR)
  ENDIF
  N$=MID$(N$,0,CUR)+C$+MID$(N$,CUR,&H7FFFFFFF)
  INC CUR
 NEXT
 GWIN_SET_NAME GW,N$
 GWIN_SET_VAR GW,#GWIN_TBOX_V_CUR,CUR
END
DEF GWIN_TEXTBOX_SELALL GW
  GWIN_SET_VAR GW,#GWIN_TBOX_V_SX,0
  GWIN_SET_VAR GW,#GWIN_TBOX_V_EX,LEN(GWIN_GET_NAME$(GW))
END
DEF GWIN_TEXTBOX_UNSEL GW
 GWIN_SET_VAR GW,#GWIN_TBOX_V_SX,-1
 GWIN_SET_VAR GW,#GWIN_TBOX_V_EX,-1
END
DEF GWIN_TEXTBOX_MOUSE(GW,EVENT,A1,A2)
 VAR N$=GWIN_GET_NAME$(GW)
 VAR X,Y,W,H
 INC X,2
 INC Y,2
 DEC W,4
 DEC H,4
 VAR I
 VAR R=0
 FOR I=0TO LAST(N$)
  VAR FW=FONT_CALC_WIDTH(GDEBUG_SYS_FONT,N$[I])
  IF X<=A1 THEN
   IF X+FW>A1 THEN
    R=I
    BREAK
   ELSE
    R=I+1
   ENDIF
  ENDIF
  INC X,FW
 NEXT
 RETURN R
END

VAR GWIN_TEXTBOX_CMENU
DEF GWIN_TEXTBOX_EVENT GW,EVENT,A1,A2,A3,A4
 VAR SX=GWIN_GET_VAR(GW,#GWIN_TBOX_V_SX)
 VAR EX=GWIN_GET_VAR(GW,#GWIN_TBOX_V_EX)
 IF SX>EX THEN
  SWAP SX,EX
 ENDIF
 VAR N$=GWIN_GET_NAME$(GW)
 CASE EVENT
 WHEN #GWIN_EVENT_NEW
  IF!GWIN_TEXTBOX_CMENU THEN
   RESTORE @GDBG_TXTBOX_CMENU
   GWIN_TEXTBOX_CMENU=GWIN_READ_MENU_RES(GDBG_RESOURCE_K,GDBG_RESOURCE_V,GDBG_RESOURCE_CMD$)
  ENDIF
  GWIN_SET_VAR GW,#GWIN_TBOX_V_SX,-1
  GWIN_SET_VAR GW,#GWIN_TBOX_V_EX,-1
  GWIN_SET_CURSOR GW,"GWIN_CURSOR_BEAM"
 WHEN #GWIN_EVENT_CHFOCUS
 WHEN #GWIN_EVENT_ACTIVE
  GWIN_PAINT GW,#FALSE
  IF !GWIN_IS_ACTIVE_WIN(GW)THEN
   GWIN_SEND_NOTIF GW,#GWIN_NOTIF_LOST_FOCUS,0,0
  ENDIF
 WHEN #GWIN_EVENT_MMOVE
  VAR C_GW,C_FRAME,C_X,C_Y
  GWIN_GET_CAPTURE OUT C_GW,C_FRAME,C_X,C_Y
  IF C_GW==GW THEN
   VAR M=GWIN_TEXTBOX_MOUSE(GW,EVENT,A1,A2)
   IF GWIN_GET_VAR(GW,#GWIN_TBOX_V_EX)!=M THEN
    GWIN_SET_VAR GW,#GWIN_TBOX_V_EX,M
    GWIN_PAINT GW,#FALSE
   ENDIF
  ENDIF
 WHEN #GWIN_EVENT_RUP
  IF SX!=-1&&SX!=EX THEN
   GMENU_SET_FLG GWIN_TEXTBOX_CMENU,#GDBG_TXTBOX_COPY,0
   GMENU_SET_FLG GWIN_TEXTBOX_CMENU,#GDBG_TXTBOX_CUT,0
   GMENU_SET_FLG GWIN_TEXTBOX_CMENU,#GDBG_TXTBOX_DELETE,0
  ELSE
   GMENU_SET_FLG GWIN_TEXTBOX_CMENU,#GDBG_TXTBOX_COPY,#GMENU_FLG_GRAYED
   GMENU_SET_FLG GWIN_TEXTBOX_CMENU,#GDBG_TXTBOX_CUT,#GMENU_FLG_GRAYED
   GMENU_SET_FLG GWIN_TEXTBOX_CMENU,#GDBG_TXTBOX_DELETE,#GMENU_FLG_GRAYED
  ENDIF
  GWIN_SHOW_CTX_MENU GW,GWIN_TEXTBOX_CMENU
 WHEN #GWIN_EVENT_LDWN
  GWIN_TEXTBOX_UNSEL GW
  GWIN_SET_VAR GW,#GWIN_TBOX_V_CUR,GWIN_TEXTBOX_MOUSE(GW,EVENT,A1,A2)
  GWIN_SET_VAR GW,#GWIN_TBOX_V_SX,GWIN_TEXTBOX_MOUSE(GW,EVENT,A1,A2)
  GWIN_SET_CAPTURE GW,#FALSE
  GWIN_PAINT GW,#FALSE
 WHEN #GWIN_EVENT_INKEY
  GWIN_TEXTBOX_INS GW,A1
  GWIN_PAINT GW,#FALSE
  IF INSTR(A1,CHR$(13))!=-1 THEN
   GWIN_SEND_NOTIF GW,#GWIN_NOTIF_ENTER,0,0
  ENDIF
 WHEN #GWIN_EVENT_PAINT
  GCLS RGB(255,255,255)
  VAR I
  VAR X=GWIN_GET_CX(GW),Y=GWIN_GET_CY(GW)
  VAR W=GWIN_GET_CW(GW),H=GWIN_GET_CH(GW)
  IF H>16 THEN
   GDEBUG_DRAW_SUNKEN_EDGE EVENT,X,Y,W,H OUT X,Y,W,H
'   GCLS RGB(255,255,255)
  ELSE
   GBOX X,Y,X+W-1,Y+H-1,RGB(0,0,0)
  ENDIF
  INC X,2
  INC Y,2
  DEC W,4
  DEC H,4
  GCLIP X,Y,X+W-1,Y+H-1
  VAR TH=GDEBUG_SYS_FONT_SIZE
  IF SX!=-1&&SX!=EX THEN
   VAR TX=X
   INC TX,GPUTCHR_FONT_W(GDEBUG_SYS_FONT,TX,Y,#FALSE,MID$(N$,0,SX),RGB(0,0,0))
   VAR BTX=TX+FONT_CALC_WIDTH(GDEBUG_SYS_FONT,MID$(N$,SX,EX-SX))-1
   GFILL TX,Y,BTX,Y+TH-1,RGB(0,0,128)
   INC TX,GPUTCHR_FONT_W(GDEBUG_SYS_FONT,TX,Y,#FALSE,MID$(N$,SX,EX-SX),RGB(255,255,255))
   INC TX,GPUTCHR_FONT_W(GDEBUG_SYS_FONT,TX,Y,#FALSE,MID$(N$,EX,&H7FFFFFFF),RGB(0,0,0))
  ELSE
   GPUTCHR_FONT GDEBUG_SYS_FONT,X,Y,#FALSE,N$,RGB(0,0,0)
   IF GWIN_IS_ACTIVE_WIN(GW)THEN
    VAR CUR=GWIN_GET_VAR(GW,#GWIN_TBOX_V_CUR)
    VAR CX=FONT_CALC_WIDTH(GDEBUG_SYS_FONT,MID$(N$,0,CUR))
    GLINE X+CX,Y,X+CX,Y+TH-1,RGB(0,0,0)
   ENDIF
  ENDIF
 WHEN #GWIN_EVENT_LDBL
  GWIN_TEXTBOX_SELALL GW
  GWIN_PAINT GW,#FALSE
 WHEN #GWIN_EVENT_NOTIF
  IF A1==#GWIN_NOTIF_MENU THEN
   IF A3==#GDBG_TXTBOX_COPY THEN
    GWIN_COPY MID$(N$,SX,EX-SX)
   ELSEIF A3==#GDBG_TXTBOX_DELETE THEN
    GWIN_TEXTBOX_REMOVESEL GW
    GWIN_PAINT GW,#FALSE
   ELSEIF A3==#GDBG_TXTBOX_CUT THEN
    GWIN_COPY MID$(N$,SX,EX-SX)
    GWIN_TEXTBOX_REMOVESEL GW
    GWIN_PAINT GW,#FALSE
   ELSEIF A3==#GDBG_TXTBOX_PASTE THEN
    GWIN_TEXTBOX_INS GW,GWIN_GET_CLIPBOARD$()
    GWIN_PAINT GW,#FALSE
   ELSEIF A3==#GDBG_TXTBOX_SELALL THEN
    GWIN_TEXTBOX_SELALL GW
    GWIN_PAINT GW,#FALSE
   ENDIF
  ENDIF
 ENDCASE
END
DEF GWIN_READ_MENU_RES(K[],V[],CMD$[])
 VAR MENU=NEW_GMENU()
 VAR FLG
 LOOP
  VAR D
  VAR CMENU=0
  READ D
  IF D==#GWIN_RES_MENU_BEGIN THEN
   READ D
   CMENU=GWIN_READ_MENU_RES(K,V,CMD$)
  ENDIF
  IF D==#GWIN_RES_MENU_END THEN
   RETURN MENU
  ENDIF
  IF D==#GWIN_RES_MENU_GRAYED THEN
   FLG=FLG OR #GMENU_FLG_GRAYED
   CONTINUE
  ENDIF
  IF D==#GWIN_RES_MENU_SEPARATOR THEN
   FLG=FLG OR #GMENU_FLG_SEPARATOR
   GMENU_ADD_ITEM MENU,"",D,CMENU,FLG
  ELSE
   VAR VAL=GWIN_SEARCH_RES(K,V,D)
   IF LEN(CMD$[D])THEN VAL=VAL+CHR$(9)+GDEBUG_CMD_TO_STR$(CMD$[D])
   GMENU_ADD_ITEM MENU,VAL,D,CMENU,FLG
  ENDIF
  FLG=0
 ENDLOOP
END
DEF GWIN_SEARCH_RES(K[],V[],KEY)
 VAR I,L=LAST(K)
 FOR I=0TO L
  IF K[I]==KEY THEN RETURN V[I]
 NEXT
 RETURN ""
END
DEF GWIN_READ_RES K[],V[]
 LOOP
  VAR D
  READ D
  IF D==#GWIN_RES_END THEN
   RETURN
  ENDIF
  PUSH K,D
  READ D
  PUSH V,D
 ENDLOOP
END
DIM GDEBUG_PRG_CURLINE[]
DIM GDEBUG_PRG_CURPOS[]
DIM GDEBUG_PRG_SELPOS[]
DIM GDEBUG_PRG_SELLINE[]
DIM GDEBUG_PRG_SCRPOS[]
VAR GDEBUG_CMENU
'FIXME:GLOBAL
VAR GDEBUG_PRG_SLOT
VAR GDEBUG_PRG_SLOT_MAX_W
DEF GDEBUG_GET_PRG_SLOT()
 RETURN GDEBUG_PRG_SLOT
END
DEF GWIN_PRG_EVENT GW,EVENT,A1,A2,A3,A4
 CASE EVENT
 WHEN #GWIN_EVENT_WHEEL
  VAR POS
  VAR DELTA=A1
  GWIN_SCR_GET GWIN_FIND(GW,"SCRBAR") OUT ,,POS
  GWIN_SCR_SET GWIN_FIND(GW,"SCRBAR"),,,POS+(32*-DELTA DIV 120)
  GWIN_PAINT GW,#FALSE
 WHEN #GWIN_EVENT_NEW
  GWIN_SET_MIN_SIZE GW,400,140
  '4=MAX SLOT
  GDEBUG_PRG_CURLINE=ARRAY%(4)
  FILL GDEBUG_PRG_CURLINE,1
  GDEBUG_PRG_CURPOS=ARRAY%(4)
  GDEBUG_PRG_SELPOS=ARRAY%(4)
  GDEBUG_PRG_SELLINE=ARRAY%(4)
  FILL GDEBUG_PRG_SELLINE,1
  GDEBUG_PRG_SCRPOS=ARRAY%(4)
  RESTORE @GDBG_MENU
  VAR MENU=GWIN_READ_MENU_RES(GDBG_RESOURCE_K,GDBG_RESOURCE_V,GDBG_RESOURCE_CMD$)
  VAR FILE_MENU=GMENU_GET_SUB(MENU,#GDBG_MENU_FILE)
  IF FILE_MENU>0 THEN
   VAR FILE_IMPORT_SLOT_MENU=GMENU_GET_SUB(FILE_MENU,#GDBG_MENU_FILE_IMPORT_SLOT)
   IF FILE_IMPORT_SLOT_MENU>0 THEN
    GMENU_SET_FLG FILE_IMPORT_SLOT_MENU,#GDBG_MENU_FILE_IMPORT_SLOT_0,#GMENU_FLG_GRAYED*(#_SLOT==0)
    GMENU_SET_FLG FILE_IMPORT_SLOT_MENU,#GDBG_MENU_FILE_IMPORT_SLOT_1,#GMENU_FLG_GRAYED*(#_SLOT==1)
    GMENU_SET_FLG FILE_IMPORT_SLOT_MENU,#GDBG_MENU_FILE_IMPORT_SLOT_2,#GMENU_FLG_GRAYED*(#_SLOT==2)
    GMENU_SET_FLG FILE_IMPORT_SLOT_MENU,#GDBG_MENU_FILE_IMPORT_SLOT_3,#GMENU_FLG_GRAYED*(#_SLOT==3)
   ENDIF
  ENDIF
  GWIN_SET_MENU GW,MENU
  IF !GDEBUG_CMENU THEN
   RESTORE @GDBG_CMENU
   GDEBUG_CMENU=GWIN_READ_MENU_RES(GDBG_RESOURCE_K,GDBG_RESOURCE_V,GDBG_RESOURCE_CMD$)
  ENDIF
  VAR SCR_GWIN=GWIN_NEW(GW,0,0,0,0,"SCRBAR","GWIN_SCR_EVENT")
  VAR SCR_GWIN2=GWIN_NEW(GW,0,0,0,0,"SCRBAR_H","GWIN_SCR_EVENT")
 WHEN #GWIN_EVENT_PAINT
  GWIN_MOVE GWIN_FIND_BY_EVENT(GW,"GWIN_FVIEW_EVENT"),GWIN_GET_CLIENT_W(GW)-200,0
  GDEBUG_DRAW_PRG GW,EVENT,GWIN_GET_CX(GW),GWIN_GET_CY(GW),GWIN_GET_CW(GW),GWIN_GET_CH(GW)
 WHEN #GWIN_EVENT_LDWN
 WHEN #GWIN_EVENT_LDBL
 WHEN #GWIN_EVENT_LUP
 WHEN #GWIN_EVENT_RDWN
 WHEN #GWIN_EVENT_MMOVE
  GDEBUG_DRAW_PRG GW,EVENT,GWIN_GET_CX(GW),GWIN_GET_CY(GW),GWIN_GET_CW(GW),GWIN_GET_CH(GW)
 WHEN #GWIN_EVENT_RUP
'  GMENU_SET_FLG GDEBUG_CMENU,#GDBG_CMENU_COPY,#GMENU_FLG_GRAYED*!GWIN_PRG_IS_SEL(GW)
  GWIN_SHOW_CTX_MENU GW,GDEBUG_CMENU
 WHEN #GWIN_EVENT_NOTIF
  IF A1==#GWIN_NOTIF_MENU THEN
   GWIN_PRG_NOTIF_MENU GW,A3
  ENDIF
 ENDCASE
END

DEF GWIN_PRG_IS_SEL(GW)
 VAR CURLINE,CURPOS,SELLINE,SELPOS,SELENDLINE,SELENDPOS
 GWIN_GET_SEL GW OUT CURLINE,CURPOS,SELLINE,SELPOS,SELENDLINE,SELENDPOS
 VAR SELECTED=SELLINE!=SELENDLINE||SELPOS!=SELENDPOS
 RETURN SELECTED
END
DEF GWIN_PRG_GET_LINE$(GW)
 VAR SLOT=GDEBUG_PRG_SLOT
 VAR CURLINE,CURPOS,SELLINE,SELPOS,SELENDLINE,SELENDPOS
 GWIN_GET_SEL GW OUT CURLINE,CURPOS,SELLINE,SELPOS,SELENDLINE,SELENDPOS
 VSLOT_SEEKLINE SLOT,CURLINE
 RETURN VSLOT_PRGGET_SLOT$(SLOT,#FALSE)
END
DEF GWIN_PRG_GET_SELECTED_TEXT$(GW)
 VAR CURLINE,CURPOS,SELLINE,SELPOS,SELENDLINE,SELENDPOS
 GWIN_GET_SEL GW OUT CURLINE,CURPOS,SELLINE,SELPOS,SELENDLINE,SELENDPOS
 VAR SELECTED=SELLINE!=SELENDLINE||SELPOS!=SELENDPOS
 IF!SELECTED THEN
  VAR W$
  GWIN_PRG_GET_CUR_WORD GW,CURLINE,CURPOS,#TRUE OUT W$,,
  RETURN W$
 ELSE
  VAR SLOT=GDEBUG_PRG_SLOT
  VSLOT_SEEKLINE SLOT,SELLINE
  VAR L$=VSLOT_PRGGET_SLOT$(SLOT,#TRUE)
  IF SELLINE==SELENDLINE THEN
   RETURN MID$(L$,SELPOS,SELENDPOS-SELPOS)
  ELSE
   VAR I
   VAR R$=MID$(L$,SELPOS,&H7FFFFFFF)
   FOR I=SELLINE+1 TO SELENDLINE-1
    PUSH R$,VSLOT_PRGGET_SLOT$(SLOT,#TRUE)
   NEXT
   PUSH R$,MID$(VSLOT_PRGGET_SLOT$(SLOT,#TRUE),0,SELENDPOS)
   RETURN R$
  ENDIF
 ENDIF
END
DEF GWIN_PRG_GET_CUR_WORD GW,LINE,POS,MODE OUT W$,SI,I
 VAR SLOT=GDEBUG_PRG_SLOT
 VSLOT_SEEKLINE SLOT,LINE
 VAR L$=VSLOT_PRGGET_SLOT$(SLOT,#FALSE)
 IF L$=="" THEN W$="":SI=0I=0:RETURN
 L$=MID$(L$,0,LAST(L$))'REMOVE LF
 I=0
 WHILE I<=LAST(L$)
  VAR C$=L$[I]
  VAR C=ASC(C$)
  IF !MODE&&I==POS THEN
   BREAK
  ENDIF
  IF IS_ALPHA(C)||C$=="_"||C$=="#"THEN
   SI=I
   INC I
   WHILE I<=LAST(L$)
    C$=L$[I]
    C=ASC(C$)
    IF IS_ALPHA(C)||C$=="_"||IS_NUM(C)THEN
     INC I
     CONTINUE
    ENDIF
    BREAK
   WEND
   IF C$=="$"||C$=="#"||C$=="%"THEN INC I
   IF SI<=POS&&(POS<I||(MODE&&POS==I)) THEN
    W$=MID$(L$,SI,I-SI)
    RETURN
   ENDIF
   CONTINUE
  ELSEIF IS_NUM(C)||C$=="."||C$=="-" THEN
   SI=I
   INC I
   VAR HAS_E=#FALSE
   VAR HAS_DOT=#FALSE
   WHILE I<=LAST(L$)
    C$=L$[I]
    C=ASC(C$)
    IF IS_NUM(C)||(!HAS_E&&C$=="E")||(!HAS_DOT&&C$==".")THEN
     INC I
     IF C$=="E"THEN HAS_E=#TRUE
     IF C$=="."THEN HAS_DOT=#TRUE
     CONTINUE
    ENDIF
    BREAK
   WEND
   IF C$=="#"THEN INC I
   IF SI<=POS&&(POS<I||(MODE&&POS==I)) THEN
    W$=MID$(L$,SI,I-SI)
    RETURN
   ENDIF
   CONTINUE
  ELSEIF C$=="&"&&MID$(L$,I+1,1)=="H"THEN
   SI=I
   INC I,2
   WHILE I<=LAST(L$)
    C$=L$[I]
    C=ASC(C$)
    IF IS_NUM(C)||(C$>="A"&&C$<="F")||(C$>="a"&&C$<="f")THEN
     INC I
     CONTINUE
    ENDIF
    BREAK
   WEND
   IF SI<=POS&&(POS<I||(MODE&&POS==I)) THEN
    W$=MID$(L$,SI,I-SI)
    RETURN
   ENDIF
   CONTINUE
  ELSEIF C$=="&"&&MID$(L$,I+1,1)=="B"THEN
   SI=I
   INC I,2
   WHILE I<=LAST(L$)
    C$=L$[I]
    C=ASC(C$)
    IF C$=="1"||C$=="0"THEN
     INC I
     CONTINUE
    ENDIF
    BREAK
   WEND
   IF SI<=POS&&(POS<I||(MODE&&POS==I)) THEN
    W$=MID$(L$,SI,I-SI)
    RETURN
   ENDIF
   CONTINUE
  ELSEIF C==34 THEN
   SI=I
   I=INSTR(I+1,L$,CHR$(34))+1
   IF I==0 THEN I=LEN(L$)
   IF SI<=POS&&(POS<I||(MODE&&POS==I)) THEN
    W$=MID$(L$,SI,I-SI)
    RETURN
   ENDIF
   CONTINUE
  ENDIF
  INC I
 WEND
 W$=""
 I=POS
 SI=POS
END
DEF GWIN_COPY T$
 CLIPBOARD T$
END
DEF GWIN_GET_CLIPBOARD$()
 RETURN CLIPBOARD()
END
DEF GWIN_PRG_NOTIF_MENU GW,ID
 CASE ID
 WHEN #GDBG_MENU_HELP_ABOUT
  GDEBUG_ABOUT
 WHEN #GDBG_MENU_FILE_IMPORT_SLOT_0
  GDEBUG_IMPORT_SLOT 0
 WHEN #GDBG_MENU_FILE_IMPORT_SLOT_1
  GDEBUG_IMPORT_SLOT 1
 WHEN #GDBG_MENU_FILE_IMPORT_SLOT_2
  GDEBUG_IMPORT_SLOT 2
 WHEN #GDBG_MENU_FILE_IMPORT_SLOT_3
  GDEBUG_IMPORT_SLOT 3
 WHEN #GDBG_MENU_FILE_EXIT
  GDEBUG_EXIT
 WHEN #GDBG_MENU_WINDOW_RESET
  GDEBUG_WINDOW_RESET
 WHEN #GDBG_MENU_WINDOW_OPACITY_100
  GWIN_SET_OPACITY INT(1*255)
 WHEN #GDBG_MENU_WINDOW_OPACITY_90
  GWIN_SET_OPACITY INT(0.9*255)
 WHEN #GDBG_MENU_WINDOW_OPACITY_80
  GWIN_SET_OPACITY INT(0.8*255)
 WHEN #GDBG_MENU_WINDOW_OPACITY_70
  GWIN_SET_OPACITY INT(0.7*255)
 WHEN #GDBG_MENU_WINDOW_OPACITY_60
  GWIN_SET_OPACITY INT(0.6*255)
 WHEN #GDBG_MENU_WINDOW_OPACITY_50
  GWIN_SET_OPACITY INT(0.5*255)
 WHEN #GDBG_MENU_WINDOW_OPACITY_40
  GWIN_SET_OPACITY INT(0.4*255)
 WHEN #GDBG_MENU_WINDOW_OPACITY_30
  GWIN_SET_OPACITY INT(0.3*255)
 WHEN #GDBG_CMENU_JUMPTODEF
  RETURN
 WHEN #GDBG_MENU_DEBUG_EVAL
  VAR EW=GDEBUG_NEW_EVAL_WINDOW(GWIN_PRG_GET_SELECTED_TEXT$(GW))
  RETURN
 WHEN #GDBG_MENU_DEBUG_TOGGLE_BP
  VAR PC
  VMDBG_GET_PC_LIST GDEBUG_PRG_SLOT,GDEBUG_PRG_CURLINE[GDEBUG_PRG_SLOT] OUT PC
  VMDBG_TOGGLE_BP_LIST GDEBUG_PRG_SLOT,PC
  GWIN_PAINT GW,#FALSE
  RETURN
 WHEN #GDBG_MENU_DEBUG_COMPILE
 WHEN #GDBG_MENU_DEBUG_RESUME
 WHEN #GDBG_MENU_DEBUG_TERM
 WHEN #GDBG_MENU_DEBUG_RESTART
 WHEN #GDBG_MENU_DEBUG_STEPINTO
 WHEN #GDBG_MENU_DEBUG_STEPOVER
 WHEN #GDBG_MENU_DEBUG_STEPOUT
 WHEN #GDBG_MENU_DEBUG_RUNTOCUR
 WHEN #GDBG_MENU_DEBUG_JMPTOCUR
  GDEBUG_DO_DEBUG_CMD ID
 WHEN #GDBG_CMENU_CUT
  RETURN
 WHEN #GDBG_CMENU_COPY
  IF GWIN_PRG_IS_SEL(GW)THEN
   GWIN_COPY GWIN_PRG_GET_SELECTED_TEXT$(GW)
  ELSE
   GWIN_COPY GWIN_PRG_GET_LINE$(GW)
  ENDIF
  RETURN
 WHEN #GDBG_CMENU_PASTE
  RETURN
 ENDCASE
END
ENUM #GWIN_SCR_V_PAGE,#GWIN_SCR_V_SIZE,#GWIN_SCR_V_POS,#GWIN_SCR_V_STATE
ENUM #GWIN_SCR_STATE_NONE,#GWIN_SCR_STATE_UP,#GWIN_SCR_STATE_DOWN,#GWIN_SCR_STATE_THUMB,#GWIN_SCR_STATE_THUMB_OLD
DEF GWIN_SCR_RESET GW
 GWIN_SCR_SET GW,0,0,0
END
DEF GWIN_SCR_SET GW,PAGE,SIZE,POS
 IF TYPEOF(PAGE)THEN
  GWIN_SET_VAR GW,#GWIN_SCR_V_PAGE,PAGE
 ENDIF
 IF TYPEOF(SIZE)THEN
  GWIN_SET_VAR GW,#GWIN_SCR_V_SIZE,SIZE
 ENDIF
 IF TYPEOF(POS)THEN
  GWIN_SET_VAR GW,#GWIN_SCR_V_POS,POS
 ENDIF
 GWIN_SCR_GET GW OUT PAGE,SIZE,POS
 IF SIZE THEN
  POS=MAX(0,MIN(POS,SIZE-PAGE+1))
  GWIN_SET_VAR GW,#GWIN_SCR_V_POS,POS
 ENDIF
END
DEF GWIN_SCR_GET GW OUT PAGE,SIZE,POS
 GWIN_GET_VAR GW,#GWIN_SCR_V_PAGE OUT PAGE
 GWIN_GET_VAR GW,#GWIN_SCR_V_SIZE OUT SIZE
 GWIN_GET_VAR GW,#GWIN_SCR_V_POS OUT POS
END
DEF GWIN_SCR_EVENT GW,EVENT,A1,A2,A3,A4
 CASE EVENT
 WHEN #GWIN_EVENT_PAINT
 WHEN #GWIN_EVENT_LDWN
 WHEN #GWIN_EVENT_MMOVE
  GDEBUG_DRAW_SCRBAR GW,EVENT,GWIN_GET_CX(GW),GWIN_GET_CY(GW),GWIN_GET_CW(GW),GWIN_GET_CH(GW)
 ENDCASE
END
ENUM #GWIN_VAR_V_TXTBOX,#GWIN_VAR_V_IDX,#GWIN_VAR_V_TAB,#GWIN_VAR_V_FUNC,#GWIN_VAR_V_BP
VAR GDEBUG_VAR_CMENU
DEF GWIN_VAR_EVENT GW,TYP,A1,A2,A3,A4
 CASE TYP
 WHEN #GWIN_EVENT_WHEEL
  VAR POS
  VAR DELTA=A1
  GWIN_SCR_GET GWIN_FIND(GW,"SCRBAR") OUT ,,POS
  GWIN_SCR_SET GWIN_FIND(GW,"SCRBAR"),,,POS+(32*-DELTA DIV 120)
  GWIN_PAINT GW,#FALSE
 WHEN #GWIN_EVENT_NEW
  GWIN_SET_MIN_SIZE GW,190,90
  IF !GDEBUG_VAR_CMENU THEN
   RESTORE @GDBG_VAR_CMENU
   GDEBUG_VAR_CMENU=GWIN_READ_MENU_RES(GDBG_RESOURCE_K,GDBG_RESOURCE_V,GDBG_RESOURCE_CMD$)
  ENDIF
  VAR SCR_GWIN=GWIN_NEW(GW,0,0,0,0,"SCRBAR","GWIN_SCR_EVENT")
 WHEN #GWIN_EVENT_RUP
  GWIN_SHOW_CTX_MENU GW,GDEBUG_VAR_CMENU
 WHEN #GWIN_EVENT_PAINT
  GDEBUG_DRAW_VAR GW,TYP,GWIN_GET_CX(GW),GWIN_GET_CY(GW),GWIN_GET_CW(GW),GWIN_GET_CH(GW),A1,A2,A3,A4
 WHEN #GWIN_EVENT_NOTIF
 WHEN #GWIN_EVENT_LDBL
 WHEN #GWIN_EVENT_LDWN
 WHEN #GWIN_EVENT_RDWN
 WHEN #GWIN_EVENT_RUP
  GDEBUG_DRAW_VAR GW,TYP,GWIN_GET_CX(GW),GWIN_GET_CY(GW),GWIN_GET_CW(GW),GWIN_GET_CH(GW),A1,A2,A3,A4
 ENDCASE
END
ENUM #GWIN_LBOX_V_ITEM,#GWIN_LBOX_V_ITEM_LAST,#GWIN_LBOX_V_SEL,#GWIN_LBOX_V_SELING
DIM GLBOX$[]
DIM GLBOX_NEXT[]
DIM GLBOX_PREV[]
VAR GLBOX_FREE
DEF GWIN_LBOX_INIT
 IF!TYPEOF(GLBOX$)THEN
  VAR S=1
  GLBOX$=ARRAY$(S)
  GLBOX_NEXT=ARRAY%(S)
  GLBOX_PREV=ARRAY%(S)
 ENDIF
END
DEF GWIN_LBOX_NEW(I$)
 IF GLBOX_FREE THEN
  VAR L=GLBOX_FREE
  GLBOX_FREE=GLBOX_NEXT[L]
  GLBOX_NEXT[L]=0
  GLBOX$[L]=I$
 ELSE
  PUSH GLBOX$,I$
  PUSH GLBOX_NEXT,0
  PUSH GLBOX_PREV,0
  L=LAST(GLBOX$)
 ENDIF
 RETURN L
END
DEF GWIN_LBOX_ADD GW,I$
 VAR I=GWIN_LBOX_NEW(I$)
 IF!GWIN_GET_VAR(GW,#GWIN_LBOX_V_ITEM) THEN
  GWIN_SET_VAR GW,#GWIN_LBOX_V_ITEM,I
 ELSE
  GLBOX_PREV[I]=GWIN_GET_VAR(GW,#GWIN_LBOX_V_ITEM_LAST)
  GLBOX_NEXT[GWIN_GET_VAR(GW,#GWIN_LBOX_V_ITEM_LAST)]=I
 ENDIF
 GWIN_SET_VAR GW,#GWIN_LBOX_V_ITEM_LAST,I
END
DEF GWIN_LBOX_GET$(GW)
 RETURN GLBOX$[GWIN_GET_VAR(GW,#GWIN_LBOX_V_SEL)]
END

DEF GWIN_LBOX_MOUSE(GW,MX,MY)
 VAR SGW=GWIN_FIND(GW,"SCRBAR")
 VAR ITEMH=GDEBUG_SYS_FONT_SIZE+2
 VAR SCRBAR_POS,SCRBAR_H_POS
 GWIN_SCR_GET SGW OUT ,,SCRBAR_POS
 VAR LINE=SCRBAR_POS DIV ITEMH
 VAR OFF_Y=SCRBAR_POS MOD ITEMH
 VAR I=GWIN_GET_VAR(GW,#GWIN_LBOX_V_ITEM)
 VAR X=0,Y=-OFF_Y
 INC X
 INC Y
 VAR IC=0
 WHILE I
  INC IC
   IF LINE>=IC THEN I=GLBOX_NEXT[I]CONTINUE
  IF Y<=MY&&Y+ITEMH>MY THEN
   RETURN I
  ENDIF
  INC Y,ITEMH
  I=GLBOX_NEXT[I]
 WEND
 RETURN 0
END

DEF GWIN_LBOX_EVENT GW,EVENT,A1,A2,A3,A4
 VAR SGW=GWIN_FIND(GW,"SCRBAR")
 VAR SCRBAR_POS
 GWIN_SCR_GET SGW OUT ,,SCRBAR_POS
 VAR ITEMH=GDEBUG_SYS_FONT_SIZE+2
 VAR X=GWIN_GET_CX(GW),Y=GWIN_GET_CY(GW)
 VAR W=GWIN_GET_CW(GW),H=GWIN_GET_CH(GW)
 VAR LINE=SCRBAR_POS DIV ITEMH
 VAR OFF_Y=SCRBAR_POS MOD ITEMH
 VAR I=GWIN_GET_VAR(GW,#GWIN_LBOX_V_ITEM)
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GBOX X,Y,X+W-1,Y+H-1,RGB(0,0,0)
 ENDIF
 INC X
 INC Y
 DEC W,2
 DEC H,2
 VAR SEL=GWIN_GET_VAR(GW,#GWIN_LBOX_V_SELING)
' GDEBUG_DRAW_SUNKEN_EDGE EVENT,X,Y,W,H OUT X,Y,W,H
 CASE EVENT
 WHEN #GWIN_EVENT_NEW
  GWIN_LBOX_INIT
  VAR SCR_GWIN=GWIN_NEW2(GW,X+W-16-GWIN_GET_CX(GW),Y-GWIN_GET_CY(GW),16,H,"SCRBAR","GWIN_SCR_EVENT",#GWIN_FLG_NACTV)
  RETURN
 WHEN #GWIN_EVENT_CHFOCUS_CHILD
  IF !GWIN_IS_FOCUSED(GW)THEN
   GWIN_SEND_NOTIF GW,#GWIN_NOTIF_LOST_FOCUS,0,0
  ENDIF
 WHEN #GWIN_EVENT_LDWN
  SEL=GWIN_LBOX_MOUSE(GW,A1,A2)
  IF GWIN_GET_VAR(GW,#GWIN_LBOX_V_SEL)!=SEL THEN
   GWIN_SET_VAR GW,#GWIN_LBOX_V_SEL,SEL
   GWIN_SEND_NOTIF GW,#GWIN_NOTIF_ENTER,0,0
  ENDIF
 WHEN #GWIN_EVENT_MMOVE
  VAR S2=GWIN_LBOX_MOUSE(GW,A1,A2)
  IF S2!=SEL THEN
   SEL=S2
   GWIN_SET_VAR GW,#GWIN_LBOX_V_SELING,SEL
   GWIN_PAINT GW,#FALSE
  ENDIF
 WHEN #GWIN_EVENT_PAINT
  GCLIP X,Y,X+W-1,Y+H-1
  GCLS RGB(255,255,255)
  VAR IC=0
  Y=Y-OFF_Y
  WHILE I
   INC IC
   IF LINE>=IC THEN
    I=GLBOX_NEXT[I]
    CONTINUE
   ENDIF
   VAR C=RGB(0,0,0)
   IF SEL==I THEN
    C=RGB(255,255,255)
    GFILL X,Y,X+W-1,Y+ITEMH-1,RGB(0,0,128)
   ENDIF
   GPUTCHR_FONT GDEBUG_SYS_FONT,X,Y,#FALSE,GLBOX$[I],C
   INC Y,ITEMH
   I=GLBOX_NEXT[I]
  WEND
  GWIN_SCR_SET SGW,H,ITEMH*IC,
 ENDCASE
END
DEF GWIN_FVIEW_EVENT GW,EVENT,A1,A2,A3,A4
 VAR CB=GWIN_FIND(GW,"CB")
 CASE EVENT
 WHEN #GWIN_EVENT_NEW
  CB=GWIN_NEW(GW,0,0,GWIN_GET_CLIENT_W(GW),GWIN_GET_CLIENT_H(GW),"CB","GWIN_CBOX_EVENT")
  VAR LB=GWIN_CBOX_GET_LBOX(CB)
  VAR FS$
  VMDBG_GET_FUNC_LIST GDEBUG_GET_PRG_SLOT() OUT FS$
  VAR I
  FOR I=0TO LAST(FS$)
   GWIN_LBOX_ADD LB,FS$[I]
  NEXT
  VMDBG_GET_LABEL_LIST GDEBUG_GET_PRG_SLOT() OUT FS$
  FOR I=0TO LAST(FS$)
   GWIN_LBOX_ADD LB,FS$[I]
  NEXT
 WHEN #GWIN_EVENT_NOTIF
  IF A1==#GWIN_NOTIF_ENTER&&A2==CB THEN
   VAR LINE,ADDR
   VAR A$=GWIN_LBOX_GET$(GWIN_CBOX_GET_LBOX(CB))
   IF !LEN(A$)THEN RETURN
   IF A$[0]=="@"THEN
    VMDBG_GET_LABEL_ADDR VM_GET_SLOT(),A$ OUT ADDR
    VMDBG_GET_LINE VM_GET_SLOT(),ADDR OUT LINE,
   ELSE
    VMDBG_GET_FUNC_ADDR VM_GET_SLOT(),A$ OUT ADDR
    VMDBG_GET_LINE VM_GET_SLOT(),ADDR OUT LINE,
   ENDIF
   GWIN_SET_VAR GDEBUG_PRG_GWIN,#GDEBUG_PRG_V_REQ_SCROLL_LINE,LINE
   GWIN_SET_VAR GDEBUG_PRG_GWIN,#GDEBUG_PRG_V_REQ_SCROLL,#TRUE
   GWIN_PAINT GDEBUG_PRG_GWIN,#FALSE
  ENDIF
 ENDCASE
END
ENUM #GWIN_CBOX_PUSHED,#GWIN_CBOX_LBOX
DEF GWIN_CBOX_GET_LBOX(GW)
 RETURN GWIN_GET_VAR(GW,#GWIN_CBOX_LBOX)
END
DEF GWIN_CBOX_EVENT GW,EVENT,A1,A2,A3,A4
 VAR X=GWIN_GET_CX(GW),Y=GWIN_GET_CY(GW)
 VAR W=GWIN_GET_CW(GW),H=GWIN_GET_CH(GW)
 GDEBUG_DRAW_SUNKEN_EDGE EVENT,X,Y,W,H OUT X,Y,W,H
 CASE EVENT
 WHEN #GWIN_EVENT_NEW
  VAR LB=GWIN_NEW2(GWIN_ROOT,0,0,GWIN_GET_CLIENT_W(GW),200,"A","GWIN_LBOX_EVENT",#GWIN_FLG_NOFRAME OR #GWIN_FLG_NACTV)
  GWIN_HIDE LB
  GWIN_SET_VAR GW,#GWIN_CBOX_LBOX,LB
  GWIN_SET_NOTIF LB,GW
  RETURN
 WHEN #GWIN_EVENT_NOTIF
  LB=GWIN_GET_VAR(GW,#GWIN_CBOX_LBOX)
  IF A1==#GWIN_NOTIF_LOST_FOCUS&&A2==LB THEN
   GWIN_HIDE LB
   GWIN_SET_VAR GW,#GWIN_CBOX_PUSHED,#FALSE
   GWIN_PAINT GW,#FALSE
  ENDIF
  IF A1==#GWIN_NOTIF_ENTER&&A2==LB THEN
   GWIN_HIDE LB
   GWIN_SET_VAR GW,#GWIN_CBOX_PUSHED,#FALSE
   GWIN_PAINT GW,#FALSE
   GWIN_SEND_NOTIF GW,#GWIN_NOTIF_ENTER,0,0
  ENDIF
 WHEN #GWIN_EVENT_LDWN
  GWIN_SET_VAR GW,#GWIN_CBOX_PUSHED,#TRUE
  GWIN_MOVE GWIN_GET_VAR(GW,#GWIN_CBOX_LBOX),GWIN_GET_CLIENT_X(GW),GWIN_GET_CLIENT_Y(GW)+GWIN_GET_CLIENT_H(GW)
  GWIN_SHOW GWIN_GET_VAR(GW,#GWIN_CBOX_LBOX)
  GWIN_FRONT GWIN_GET_VAR(GW,#GWIN_CBOX_LBOX)
  GWIN_FOCUS GWIN_GET_VAR(GW,#GWIN_CBOX_LBOX)
  GWIN_PAINT GW,#FALSE
  GWIN_PAINT GWIN_GET_VAR(GW,#GWIN_CBOX_LBOX),#FALSE
 WHEN #GWIN_EVENT_PAINT
  GCLIP X,Y,X+W-1,Y+H-1
  GCLS RGB(255,255,255)
  VAR I
  VAR X1=X+W-16
  VAR BTN2Y=Y+H-16
  VAR S=#GWIN_DRAW_BUTTON_RAIS
  IF GWIN_GET_VAR(GW,#GWIN_CBOX_PUSHED) THEN
   S=#GWIN_DRAW_BUTTON_ETCHED
   INC X1
   INC BTN2Y
  ENDIF
  GPUTCHR_FONT GDEBUG_SYS_FONT,X,Y,#FALSE,GWIN_LBOX_GET$(GWIN_GET_VAR(GW,#GWIN_CBOX_LBOX)),RGB(0,0,0)
  GWIN_DRAW_BUTTON2 X+W-16,Y+H-16,16,16,S
   GPSET X1+7,BTN2Y+9,#C_BLACK
   GLINE X1+6,BTN2Y+8,X1+8,BTN2Y+8,#C_BLACK
   GLINE X1+5,BTN2Y+7,X1+9,BTN2Y+7,#C_BLACK
   GLINE X1+4,BTN2Y+6,X1+10,BTN2Y+6,#C_BLACK
 ENDCASE
END
DEF GWIN_BACK_EVENT GW,TYP,A1,A2,A3,A4
 CASE TYP
 WHEN #GWIN_EVENT_WHEEL
  VAR POS
  VAR DELTA=A1
  GWIN_SCR_GET GWIN_FIND(GW,"SCRBAR") OUT ,,POS
  GWIN_SCR_SET GWIN_FIND(GW,"SCRBAR"),,,POS+(32*-DELTA DIV 120)
  GWIN_PAINT GW,#FALSE
 WHEN #GWIN_EVENT_NEW
  GWIN_SET_MIN_SIZE GW,190,90
  VAR SCR_GWIN=GWIN_NEW(GW,0,0,0,0,"SCRBAR","GWIN_SCR_EVENT")
 WHEN #GWIN_EVENT_PAINT
  GDEBUG_DRAW_BACKTRACE GW,TYP,GWIN_GET_CX(GW),GWIN_GET_CY(GW),GWIN_GET_CW(GW),GWIN_GET_CH(GW)
 WHEN #GWIN_EVENT_LDWN
  GWIN_FRONT GW
  GDEBUG_DRAW_BACKTRACE GW,TYP,GWIN_GET_CX(GW),GWIN_GET_CY(GW),GWIN_GET_CW(GW),GWIN_GET_CH(GW)
 ENDCASE
END

'OTWヨリ
COMMON DEF NewImageArrayFromDATA D OUT ARY,W,H
 DIM C$[0]
 DIM C=ARRAY%(0)
 WHILE 1
  VAR D$,DAT
  READ D$
  IF!LEN(D$)THEN BREAK
  READ DAT
  PUSH C$,D$
  PUSH C,DAT
 WEND
 VAR X,Y,Z
 READ W,H
 
 IF D==2 THEN
  DIM IMG=ARRAY%(H,W)
 ELSE
  IMG=ARRAY%(W*H)
 ENDIF
 ARY=IMG
 FOR Y=0TO H-1
  READ D$
  FOR X=0TO W-1
   IF LEN(D$)<=X THEN BREAK
   VAR CHIP$=D$[X]
   FOR Z=0TO LEN(C$)-1
    IF CHIP$==C$[Z]THEN
     IMG[X+Y*W]=C[Z]
     BREAK
    ENDIF
   NEXT
  NEXT
 NEXT
 RETURN IMG
END
DIM GWIN_CURSOR_ARROW[]
VAR GWIN_CURSOR_ARROW_HX
VAR GWIN_CURSOR_ARROW_HY
DIM GWIN_CURSOR_ARROW2[]
VAR GWIN_CURSOR_ARROW2_HX
VAR GWIN_CURSOR_ARROW2_HY
DIM GWIN_CURSOR_SIZENS[]
VAR GWIN_CURSOR_SIZENS_HX
VAR GWIN_CURSOR_SIZENS_HY
DIM GWIN_CURSOR_SIZEWE[]
VAR GWIN_CURSOR_SIZEWE_HX
VAR GWIN_CURSOR_SIZEWE_HY
DIM GWIN_CURSOR_SIZENWSE[]
VAR GWIN_CURSOR_SIZENWSE_HX
VAR GWIN_CURSOR_SIZENWSE_HY
DIM GWIN_CURSOR_SIZENESW[]
VAR GWIN_CURSOR_SIZENESW_HX
VAR GWIN_CURSOR_SIZENESW_HY
DIM GWIN_CURSOR_WAIT[]
VAR GWIN_CURSOR_WAIT_HX
VAR GWIN_CURSOR_WAIT_HY
DIM GWIN_CURSOR_BEAM[]
VAR GWIN_CURSOR_BEAM_HX
VAR GWIN_CURSOR_BEAM_HY
VAR GWIN_CURRENT_CURSOR$
DEF GWIN_SET_CURSOR GW,CUR$
 IF GWIN_CURRENT_CURSOR$==CUR$ THEN RETURN
 IF GW THEN
  GWIN_CURSOR$[GW]=CUR$
 ENDIF
 IF GWIN_OVER_WIN==GW||!GW THEN
  GWIN_CURSOR=VAR(CUR$)
  GWIN_CURSOR_HX=VAR(CUR$+"_HX")
  GWIN_CURSOR_HY=VAR(CUR$+"_HY")
  GWIN_CURSOR_UPDATED=#TRUE
 ENDIF
END
DEF GWIN_INIT_CURSOR
 RESTORE @ARROW
 NewImageArrayFromDATA 2 OUT GWIN_CURSOR_ARROW,,
 GWIN_CURSOR_ARROW_HX=0
 GWIN_CURSOR_ARROW_HY=0
 NewImageArrayFromDATA 2 OUT GWIN_CURSOR_ARROW2,,
 GWIN_CURSOR_ARROW2_HX=14
 GWIN_CURSOR_ARROW2_HY=0
 NewImageArrayFromDATA 2 OUT GWIN_CURSOR_SIZENS,,
 GWIN_CURSOR_SIZENS_HX=4
 GWIN_CURSOR_SIZENS_HY=10
 NewImageArrayFromDATA 2 OUT GWIN_CURSOR_SIZEWE,,
 GWIN_CURSOR_SIZEWE_HX=10
 GWIN_CURSOR_SIZEWE_HY=4
 NewImageArrayFromDATA 2 OUT GWIN_CURSOR_SIZENWSE,,
 GWIN_CURSOR_SIZENWSE_HX=7
 GWIN_CURSOR_SIZENWSE_HY=7
 NewImageArrayFromDATA 2 OUT GWIN_CURSOR_SIZENESW,,
 GWIN_CURSOR_SIZENESW_HX=7
 GWIN_CURSOR_SIZENESW_HY=7
 NewImageArrayFromDATA 2 OUT GWIN_CURSOR_WAIT,,
 GWIN_CURSOR_WAIT_HX=0
 GWIN_CURSOR_WAIT_HY=0
 NewImageArrayFromDATA 2 OUT GWIN_CURSOR_BEAM,,
 GWIN_CURSOR_BEAM_HX=3
 GWIN_CURSOR_BEAM_HY=7
 GWIN_SET_CURSOR 0,"GWIN_CURSOR_ARROW"
 'OTWヨリ
 @ARROW_OLD
 DATA "1",&HFF000000
 DATA "F",&HFFFFFFFF
 DATA ""
 DATA 10,16
 DATA "1         
 DATA "11        
 DATA "1F1       
 DATA "1FF1      
 DATA "1FFF1     
 DATA "1FFFF1    
 DATA "1FFFFF1   
 DATA "1FFFFFF1  
 DATA "1FFFFFFF1 
 DATA "1FFFFF1111
 DATA "1FF1FF1   
 DATA "1F1 1FF1  
 DATA "11  1FF1  
 DATA "1    1FF1 
 DATA "     1FF1 
 DATA "      11  
 @ARROW_OLD2
 DATA "1",&HFF000000
 DATA "F",&HFFFFFFFF
 DATA ""
 DATA 10,20
 DATA "1         
 DATA "11        
 DATA "1F1       
 DATA "1FF1      
 DATA "1FFF1     
 DATA "1FFFF1    
 DATA "1FFFFF1   
 DATA "1FFFFFF1  
 DATA "1FFFFFFF1 
 DATA "1FFFFFFFF1
 DATA "1FFFFF1111
 DATA "1FF1FF1   
 DATA "1F1 FFF1  
 DATA "11  1FF1  
 DATA "1   1FFF1 
 DATA "     1FF1 
 DATA "     1FFF1
 DATA "      1FF1
 DATA "      1FF1
 DATA "       11 
 @ARROW
 DATA "1",&HFF000000
 DATA "F",&HFFFFFFFF
 DATA ""
 DATA 15,23
 DATA "1              
 DATA "11             
 DATA "1F1            
 DATA "1FF1           
 DATA "1FFF1          
 DATA "1FFFF1         
 DATA "1FFFFF1        
 DATA "1FFFFFF1       
 DATA "1FFFFFFF1      
 DATA "1FFFFFFFF1     
 DATA "1FFFFFFFFF1    
 DATA "1FFFFFFFFFF1   
 DATA "1FFFFFFFFFFF1  
 DATA "1FFFFFFFFFFFF1 
 DATA "1FFFFFFF1111111
 DATA "1FFF1FFF1      
 DATA "1FF1 1FFF1     
 DATA "1F1  1FFF1     
 DATA "11    1FFF1    
 DATA "1     1FFF1    
 DATA "       1FFF1   
 DATA "       1FFF1   
 DATA "        111    
 @ARROW2
 DATA "1",&HFF000000
 DATA "F",&HFFFFFFFF
 DATA ""
 DATA 15,23
 DATA "              1
 DATA "             11
 DATA "            1F1
 DATA "           1FF1
 DATA "          1FFF1
 DATA "         1FFFF1
 DATA "        1FFFFF1
 DATA "       1FFFFFF1
 DATA "      1FFFFFFF1
 DATA "     1FFFFFFFF1
 DATA "    1FFFFFFFFF1
 DATA "   1FFFFFFFFFF1
 DATA "  1FFFFFFFFFFF1
 DATA " 1FFFFFFFFFFFF1
 DATA "1111111FFFFFFF1
 DATA "      1FFF1FFF1
 DATA "     1FFF1 1FF1
 DATA "     1FFF1  1F1
 DATA "    1FFF1    11
 DATA "    1FFF1     1
 DATA "   1FFF1       
 DATA "   1FFF1       
 DATA "    111        
 @SIZENS
 DATA "1",&HFF000000
 DATA "F",&HFFFFFFFF
 DATA ""
 DATA 9,21
 DATA "    F    
 DATA "   F1F   
 DATA "  F111F  
 DATA " F11111F 
 DATA "F1111111F
 DATA "FFFF1FFFF
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "FFFF1FFFF
 DATA "F1111111F
 DATA " F11111F 
 DATA "  F111F  
 DATA "   F1F   
 DATA "    F    
 @SIZEWE
 DATA "1",&HFF000000
 DATA "F",&HFFFFFFFF
 DATA ""
 DATA 21,9
 DATA "    FF         FF    
 DATA "   F1F         F1F   
 DATA "  F11F         F11F  
 DATA " F111FFFFFFFFFFF111F 
 DATA "F1111111111111111111F
 DATA " F111FFFFFFFFFFF111F 
 DATA "  F11F         F11F  
 DATA "   F1F         F1F   
 DATA "    FF         FF    
 @SIZENWSE
 DATA "1",&HFF000000
 DATA "F",&HFFFFFFFF
 DATA ""
 DATA 15,15
 DATA "FFFFFFF        
 DATA "F11111F        
 DATA "F1111F         
 DATA "F111F          
 DATA "F11F1F         
 DATA "F1F F1F        
 DATA "FF   F1F       
 DATA "      F1F      
 DATA "       F1F   FF
 DATA "        F1F F1F
 DATA "         F1F11F
 DATA "          F111F
 DATA "         F1111F
 DATA "        F11111F
 DATA "        FFFFFFF
 @SIZENESW
 DATA "1",&HFF000000
 DATA "F",&HFFFFFFFF
 DATA ""
 DATA 15,15
 DATA "        FFFFFFF
 DATA "        F11111F
 DATA "         F1111F
 DATA "          F111F
 DATA "         F1F11F
 DATA "        F1F F1F
 DATA "       F1F   FF
 DATA "      F1F      
 DATA "FF   F1F       
 DATA "F1F F1F        
 DATA "F11F1F         
 DATA "F111F          
 DATA "F1111F         
 DATA "F11111F        
 DATA "FFFFFFF        
 @WAIT
 DATA "1",&HFF000000
 DATA "F",&HFFFFFFFF
 DATA ""
 DATA 11,20
 DATA "11111111111
 DATA "11FFFFFFF11
 DATA "11111111111
 DATA "1FFFFFFFFF1
 DATA "1FFFFFFFFF1
 DATA "1FFFFFFFFF1
 DATA "1FFFF1FFFF1
 DATA "11FF1F1FF11
 DATA " 11FF1FF11 
 DATA "  11FFF11  
 DATA "   11F11   
 DATA "  11FFF11  
 DATA " 11FFFFF11 
 DATA "11FFF1FFF11
 DATA "1FFF1F1FFF1
 DATA "1FF1F1F1FF1
 DATA "1F1F1F1F1F1
 DATA "11111111111
 DATA "11FFFFFFF11
 DATA "11111111111
 @BEAM
 DATA "1",&HFF000000
 DATA "F",&HFFFFFFFF
 DATA ""
 DATA 7,15
 DATA "FFFFFFF
 DATA "F11F11F
 DATA "FFF1FFF
 DATA "  F1F 
 DATA "  F1F 
 DATA "  F1F 
 DATA "  F1F 
 DATA "  F1F 
 DATA "  F1F 
 DATA "  F1F 
 DATA "  F1F 
 DATA "  F1F 
 DATA "FFF1FFF
 DATA "F11F11F
 DATA "FFFFFFF
END

'GSAVE 4,0,40,40,AHO
DIM GDEBUG_DISABLED_CLOSE_BUTTON[]
DIM GDEBUG_CLOSE_BUTTON[]
DEF GWIN_IS_ACTIVE_WIN(GW)
 VAR I=GWIN_ACTIVE
 WHILE I
  IF GW==I THEN RETURN #TRUE
  I=GWIN_PARENT[I]
 WEND
 RETURN #FALSE
END
DEF GWIN_IS_FOCUSED(GW)
 VAR I=GWIN_INPUT
 WHILE I
  IF GW==I THEN RETURN #TRUE
  I=GWIN_PARENT[I]
 WEND
 RETURN #FALSE
END

DEF GWIN_DRAW_WINDOW GW,EVENT,X,Y,W,H,TITLE$ OUT CX,CY,CW,CH
 VAR X2=X+W-1
 VAR Y2=Y+H-1
 GCLIP X,Y,X2,Y2
 VAR BACK_C=RGB(0,0,0)
 VAR BORDER_C2=RGB(255,255,255)
 VAR TITLE_BACK_C=RGB(0,0,128)
 VAR TITLE_FORE_C=RGB(255,255,255)
 IF !GWIN_IS_ACTIVE_WIN(GW) THEN
  TITLE_BACK_C=RGB(128,128,128)
  TITLE_FORE_C=RGB(192,192,192)
 ENDIF
 VAR TITLE_BORDER_C=RGB(255,255,255)
 VAR TITLE_H=19
 VAR TITLE_BORDER_H=1
 VAR B=!!(GWIN_FLG[GW]AND #GWIN_FLG_RESIZE)
 VAR BORDER_W1=3+B
 VAR BORDER_W2=3+B
 VAR BORDER_H1=3+B
 VAR BORDER_H2=3+B
 VAR MX=GWIN_GET_MOUSE_NCX(GW),MY=GWIN_GET_MOUSE_NCY(GW)
 VAR C_GW,C_FRM
 GWIN_GET_CAPTURE OUT C_GW,C_FRM,,
 VAR CAPTURED=C_GW==GW&&C_FRM
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GLINE X,Y,X,Y2-1,RGB(223,223,223)
  GLINE X,Y,X2-1,Y,RGB(223,223,223)
  GLINE X2,Y,X2,Y2,RGB(0,0,0)
  GLINE X,Y2,X2,Y2,RGB(0,0,0)
  GLINE X+1,Y+1,X2-2,Y+1,RGB(255,255,255)
  GLINE X+1,Y+1,X+1,Y2-2,RGB(255,255,255)
  GLINE X+1,Y2-1,X2-1,Y2-1,RGB(128,128,128)
  GLINE X2-1,Y+1,X2-1,Y2-1,RGB(128,128,128)
  GFILL X+2,Y+2,X+2+B,Y2-2,RGB(192,192,192)
  GFILL X+2,Y+2,X2-2,Y+2+B,RGB(192,192,192)
  GFILL X2-2-B,Y+2,X2-2,Y2-2,RGB(192,192,192)
  GFILL X+2,Y2-2-B,X2-2,Y2-2,RGB(192,192,192)
 ELSEIF (GWIN_FLG[GW]AND #GWIN_FLG_RESIZE)&&(EVENT==#GWIN_EVENT_MMOVE||EVENT==#GWIN_EVENT_LDWN)&&!CAPTURED THEN
  VAR SIZE=32
  VAR TOP=MY>=Y&&MY<Y+BORDER_H1
  VAR BTM=MY>Y2-BORDER_H2&&MY<=Y2
  VAR LFT=MX>=X&&MX<X+BORDER_W1
  VAR RGT=MX>X2-BORDER_H2&&MX<=X2
  VAR DX=0
  VAR DY=0
  IF (LFT&&MY<Y+SIZE)||(TOP&&MX<X+SIZE) THEN
   DX=-1
   DY=-1
   GWIN_SET_CURSOR GW,"GWIN_CURSOR_SIZENWSE"
  ELSEIF (RGT&&MY<Y+SIZE)||(TOP&&MX>X2-SIZE) THEN
   DX=1
   DY=-1
   GWIN_SET_CURSOR GW,"GWIN_CURSOR_SIZENESW"
  ELSEIF (LFT&&MY>Y2-SIZE)||(BTM&&MX<X+SIZE) THEN
   DX=-1
   DY=1
   GWIN_SET_CURSOR GW,"GWIN_CURSOR_SIZENESW"
  ELSEIF (RGT&&MY>Y2-SIZE)||(BTM&&MX>X2-SIZE) THEN
   DX=1
   DY=1
   GWIN_SET_CURSOR GW,"GWIN_CURSOR_SIZENWSE"
  ELSEIF LFT THEN
   DX=-1
   DY=0
   GWIN_SET_CURSOR GW,"GWIN_CURSOR_SIZEWE"
  ELSEIF RGT THEN
   DX=1
   DY=0
   GWIN_SET_CURSOR GW,"GWIN_CURSOR_SIZEWE"
  ELSEIF TOP THEN
   DX=0
   DY=-1
   GWIN_SET_CURSOR GW,"GWIN_CURSOR_SIZENS"
  ELSEIF BTM THEN
   DX=0
   DY=1
   GWIN_SET_CURSOR GW,"GWIN_CURSOR_SIZENS"
  ELSE
   GWIN_SET_CURSOR GW,"GWIN_CURSOR_ARROW"
  ENDIF
  IF EVENT==#GWIN_EVENT_LDWN&&(DX||DY) THEN
   GWIN_RESIZING=#TRUE
   GWIN_CLOSING=#FALSE
   GWIN_RESIZING_DX=DX
   GWIN_RESIZING_DY=DY
   GWIN_RESIZING_REL_X=W-1-MX
   GWIN_RESIZING_REL_Y=H-1-MY
   GWIN_SET_CAPTURE GW,#TRUE
  ENDIF
 ELSEIF !(GWIN_FLG[GW]AND #GWIN_FLG_RESIZE)&&EVENT==#GWIN_EVENT_MMOVE THEN
  GWIN_SET_CURSOR GW,"GWIN_CURSOR_ARROW"
 ELSEIF EVENT==#GWIN_EVENT_LEAVE&&!CAPTURED THEN
  GWIN_SET_CURSOR GW,"GWIN_CURSOR_ARROW"
 ENDIF
 TITLE_BORDER_C=RGB(192,192,192)

 INC X,BORDER_W1
 DEC X2,BORDER_W2
 INC Y,BORDER_H1
 DEC Y2,BORDER_H2
 VAR FONT_H=12
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GFILL X,Y,X2,Y+TITLE_H-1,TITLE_BACK_C
  VAR ST
  VAR PUSH=GWIN_CLOSING&&GWIN_CLOSING_PUSH
  IF PUSH THEN
   ST=#GWIN_DRAW_BUTTON_SUNKEN
  ELSE
   ST=#GWIN_DRAW_BUTTON_RAISED
  ENDIF
  GWIN_DRAW_BUTTON2 X2-17,Y+2,16,14,ST
  GPUTCHR_FONT GDEBUG_SYS_FONT,X+2,Y+((TITLE_H-TITLE_BORDER_H)-FONT_H) DIV 2-1,#FALSE,TITLE$,TITLE_FORE_C
  GLINE X,Y+TITLE_H-1,X2,Y+TITLE_H-1,TITLE_BORDER_C
  IF GWIN_FLG[GW]AND #GWIN_FLG_NCLOSEABLE THEN
   GDEBUG_DRAW_DISABLED_CLOSE_BUTTON X2-13+PUSH,Y+5+PUSH
  ELSE
   GDEBUG_DRAW_CLOSE_BUTTON X2-13+PUSH,Y+5+PUSH
  ENDIF
 ELSEIF EVENT==#GWIN_EVENT_MMOVE||EVENT==#GWIN_EVENT_LDWN THEN
  VAR O=GWIN_CLOSING_PUSH
  GWIN_CLOSING_PUSH=#FALSE
  IF MX>=X2-17&&MY>=Y+2&&MX<X2-17+16&&MY<Y+2+14THEN
   IF GWIN_FLG[GW]AND #GWIN_FLG_NCLOSEABLE THEN
   ELSE
    IF EVENT==#GWIN_EVENT_LDWN THEN
     GWIN_CLOSING=#TRUE
     GWIN_CLOSING_PUSH=#TRUE
     GWIN_SET_CAPTURE GW,#TRUE
     GWIN_PAINT GW,#TRUE
    ELSEIF CAPTURED&&GWIN_CLOSING THEN
     GWIN_CLOSING_PUSH=#TRUE
    ENDIF
   ENDIF
  ELSEIF EVENT==#GWIN_EVENT_LDWN&&MX>=X&&MX<=X2&&MY>=Y&&MY<=Y+TITLE_H-1 THEN
   GWIN_RESIZING=#FALSE
   GWIN_CLOSING=#FALSE
   GWIN_SET_CAPTURE GW,#TRUE
  ENDIF
  IF O!=GWIN_CLOSING_PUSH THEN
   GWIN_PAINT GW,#TRUE
  ENDIF
  IF GWIN_CLOSING THEN RETURN
 ENDIF
 INC Y,TITLE_H
 IF GWIN_MENU[GW] THEN
  VAR MENU_H=19
  GWIN_DRAW_MENU GW,EVENT,X,Y,X2-X+1,MENU_H,GWIN_MENU[GW]
  INC Y,MENU_H
 ENDIF
 CX=X
 CY=Y
 CW=X2-X+1
 CH=Y2-Y+1
END
VAR GMENU_EDGE_SIZE
VAR GMENU_MARGIN_LEFT
VAR GMENU_MARGIN_RIGHT
VAR GMENU_MARGIN_TOP
VAR GMENU_MARGIN_BOTTOM
VAR GMENU_ITEM_MARGIN_BOTTOM
VAR GMENU_TAB_WIDTH
VAR GMENU_SUBMENU_ICON_WIDTH
DEF GMENU_SPLIT_TAB M$ OUT M1$,M2$
 VAR I=INSTR(M$,CHR$(9))
 IF I==-1 THEN
  M1$=M$
  M2$=""
 ELSE
  M1$=MID$(M$,0,I)
  M2$=MID$(M$,I+1,&H7FFFFFFF)
 ENDIF
END
DEF GMENU_CALC_SIZE MENU OUT W,H
 VAR MENUI=GMENU_CHILD[MENU]
 GMENU_EDGE_SIZE=2
 GMENU_MARGIN_LEFT=16
 GMENU_MARGIN_RIGHT=16
 GMENU_MARGIN_TOP=1
 GMENU_MARGIN_BOTTOM=1
 W=GMENU_EDGE_SIZE*2+GMENU_MARGIN_LEFT+GMENU_MARGIN_RIGHT
 H=GMENU_EDGE_SIZE*2+GMENU_MARGIN_TOP+GMENU_MARGIN_BOTTOM
 GMENU_ITEM_MARGIN_BOTTOM=4
 GMENU_TAB_WIDTH=12
 GMENU_SUBMENU_ICON_WIDTH=5
 VAR MAX_FW=0
 VAR MAX_TAB_FW=0
 WHILE MENUI
  VAR M1$,M2$
  IF GMENUI_FLG[MENUI] AND #GMENU_FLG_SEPARATOR THEN
   INC H,4
  ELSE
   VAR FW=0
   IF GMENUI_CHILD[MENUI] THEN
    INC FW,GMENU_SUBMENU_ICON_WIDTH
   ENDIF
   GMENU_SPLIT_TAB GMENUI_NAME$[MENUI] OUT M1$,M2$
   FW=FONT_CALC_WIDTH(GDEBUG_SYS_FONT,M1$)+GMENU_TAB_WIDTH
   MAX_FW=MAX(FW,MAX_FW)
   IF LEN(M2$)THEN
    MAX_TAB_FW=MAX(FONT_CALC_WIDTH(GDEBUG_SYS_FONT,M2$),MAX_TAB_FW)
   ENDIF
   INC H,GDEBUG_SYS_FONT_SIZE+GMENU_ITEM_MARGIN_BOTTOM
  ENDIF
  MENUI=GMENUI_NEXT[MENUI]
 WEND
 GMENU_TAB_X[MENU]=MAX_FW
 INC W,MAX_FW+MAX_TAB_FW
END
DEF GMENU_DRAW_POPUP_MENU GW,EVENT,X,Y,W,H,MENU
 VAR MENUI=GMENU_CHILD[MENU]
 GMENU_EDGE_SIZE=2
 VAR ST=#GWIN_DRAW_BUTTON_RAIS
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GWIN_DRAW_BUTTON2 X,Y,W,H,ST
 ENDIF
 VAR MX=GWIN_GET_MOUSE_X(GW),MY=GWIN_GET_MOUSE_Y(GW)
 INC X,GMENU_EDGE_SIZE+1
 DEC W,GMENU_EDGE_SIZE*2+1*2
 VAR SX=X
 VAR SX2=X+W-1
 INC X,GMENU_MARGIN_LEFT
 INC Y,GMENU_EDGE_SIZE+GMENU_MARGIN_TOP
 IF EVENT==#GWIN_EVENT_LEAVE&&GMENU_OLD_SEL_WIN[MENU]THEN
  RETURN
 ENDIF
 IF EVENT==#GWIN_EVENT_LEAVE&&GMENU_OLD_SEL[MENU] THEN
  GMENU_OLD_SEL[MENU]=0
  GWIN_PAINT GW,#FALSE
  RETURN
 ENDIF
 WHILE MENUI
  VAR MENU_FORE_C=RGB(0,0,0)
  VAR IH=GDEBUG_SYS_FONT_SIZE+GMENU_ITEM_MARGIN_BOTTOM
  IF GMENUI_FLG[MENUI] AND #GMENU_FLG_SEPARATOR THEN
   IH=4
   GLINE SX+1,Y+1,SX2-1,Y+1,RGB(128,128,128)
   GLINE SX+1,Y+2,SX2-1,Y+2,RGB(255,255,255)
  ELSE
   VAR GRAYED=GMENUI_FLG[MENUI] AND #GMENU_FLG_GRAYED
   IF EVENT==#GWIN_EVENT_PAINT THEN
    VAR M1$,M2$
    IF GMENU_OLD_SEL[MENU]==MENUI THEN
     GFILL SX,Y,SX2,Y+IH-1,RGB(0,0,128)
     MENU_FORE_C=RGB(255,255,255)
    ENDIF
    GMENU_SPLIT_TAB GMENUI_NAME$[MENUI] OUT M1$,M2$
    IF GRAYED THEN
     MENU_FORE_C=RGB(128,128,128)
     IF GMENU_OLD_SEL[MENU]!=MENUI THEN
      GPUTCHR_FONT GDEBUG_SYS_FONT,X+1,Y+1,#FALSE,M1$,RGB(255,255,255)
      IF LEN(M2$)THEN
       GPUTCHR_FONT GDEBUG_SYS_FONT,X+GMENU_TAB_X[MENU]+1,Y+1,#FALSE,M2$,RGB(255,255,255)
      ENDIF
     ENDIF
    ENDIF
    IF GMENUI_CHILD[MENUI]THEN
     VAR BTN2X=SX2-12,Y1=Y
     GPSET BTN2X+9,Y1+7,MENU_FORE_C
     GLINE BTN2X+8,Y1+6,BTN2X+8,Y1+8,MENU_FORE_C
     GLINE BTN2X+7,Y1+5,BTN2X+7,Y1+9,MENU_FORE_C
     GLINE BTN2X+6,Y1+4,BTN2X+6,Y1+10,MENU_FORE_C
    ENDIF
    VAR FW=GPUTCHR_FONT_W(GDEBUG_SYS_FONT,X,Y,#FALSE,M1$,MENU_FORE_C)
    IF LEN(M2$)THEN
     FW=GPUTCHR_FONT_W(GDEBUG_SYS_FONT,X+GMENU_TAB_X[MENU],Y,#FALSE,M2$,MENU_FORE_C)
    ENDIF
   ENDIF
  ENDIF
  VAR OVER=Y<=MY&&Y+IH>MY
  IF EVENT==#GWIN_EVENT_MMOVE THEN
   IF OVER&&GMENU_OLD_SEL[MENU]!=MENUI THEN
    IF GMENU_OLD_SEL[MENU]&&GMENUI_CHILD[GMENU_OLD_SEL[MENU]]&&GMENU_WIN2[GMENUI_CHILD[GMENU_OLD_SEL[MENU]]]THEN
     GMENU_OLD_SEL_WIN[MENU]=#FALSE
     GMENU_DEL GMENUI_CHILD[GMENU_OLD_SEL[MENU]],GMENU_WIN2[GMENUI_CHILD[GMENU_OLD_SEL[MENU]]],#TRUE
     GWIN_FOCUS GW
    ENDIF
    GMENU_OLD_SEL[MENU]=MENUI
    GWIN_PAINT GW,#FALSE
    IF GMENUI_CHILD[MENUI]THEN
     GWIN_SHOW_MENU GW,GMENUI_CHILD[MENUI],SX2-2+GWIN_GET_X(GW),Y+GWIN_GET_Y(GW)
     GMENU_OLD_SEL_WIN[MENU]=#TRUE
    ENDIF
    RETURN
   ENDIF
  ELSEIF EVENT==#GWIN_EVENT_LUP THEN'ELSEIF EVENT==#GWIN_EVENT_MMOVE THEN
   IF GMENU_OLD_SEL[MENU]==MENUI THEN
    IF GRAYED||(GMENUI_FLG[MENUI] AND #GMENU_FLG_SEPARATOR)||GMENUI_CHILD[MENUI] THEN RETURN
     'FIXME
     VAR NW=GWIN_NOTIF[GW]
     GMENU_DEL MENU,GW,#TRUE
     CALL GWIN_EVENT$[NW],NW,#GWIN_EVENT_NOTIF,#GWIN_NOTIF_MENU,0,GMENUI_ID[MENUI],0
    RETURN
   ENDIF
  ENDIF'ELSEIF EVENT==#GWIN_EVENT_LDWN THEN
  INC Y,IH
  MENUI=GMENUI_NEXT[MENUI]
 WEND
END
DEF GMENU_DEL MENU,GW,DEL_THIS
 GMENU_WIN[MENU]=0
 IF DEL_THIS THEN
  GWIN_DELETE GW
 ENDIF
 IF GWIN_GET_EVENT$(GMENU_WIN[GMENU_PARENT[MENU]])!="GWIN_MENU_EVENT"THEN
  GMENU_OLD_SEL_WIN[GMENU_PARENT[MENU]]=#FALSE
  GMENU_OLD_SEL[GMENU_PARENT[MENU]]=0
'  GWIN_FOCUS GMENU_WIN[GMENU_PARENT[MENU]]
  GWIN_PAINT GMENU_WIN[GMENU_PARENT[MENU]],#TRUE
 ENDIF
END
DEF GWIN_SHOW_CTX_MENU GW,MENU
 IF GWIN_INPUT&&GWIN_EVENT$[GWIN_INPUT]=="GWIN_MENU_EVENT"THEN
  GWIN_DELETE GWIN_INPUT
 ENDIF
 VAR X=GWIN_GET_MOUSE_X(GWIN_ROOT)
 VAR Y=GWIN_GET_MOUSE_Y(GWIN_ROOT)
 GWIN_SHOW_MENU GW,MENU,X,Y
END
DEF GWIN_SHOW_CHILD_MENU GW,MENU,MENUI,X,Y
 GMENU_WIN[MENU]=GW
 VAR W,H
 IF GWIN_INPUT&&GWIN_EVENT$[GWIN_INPUT]=="GWIN_MENU_EVENT"THEN
  GWIN_DELETE GWIN_INPUT
 ENDIF
 X=X-GWIN_GET_DRAW_X(GW)+GWIN_GET_X(GW)
 Y=GWIN_GET_CLIENT_Y(GW)-1
 GMENU_CALC_SIZE GMENUI_CHILD[MENUI] OUT W,H
 IF X+W>GDEBUG_WIDTH THEN
  X=GDEBUG_WIDTH-W
 ENDIF
 IF Y+H>GDEBUG_HEIGHT THEN
  Y=GDEBUG_HEIGHT-H
 ENDIF
 X=MAX(0,X)
 Y=MAX(0,Y)
 VAR MW=GWIN_NEW2(GWIN_ROOT,X,Y,W,H,"","GWIN_MENU_EVENT",#GWIN_FLG_NOFRAME OR #GWIN_FLG_NACTV)
 GMENU_WIN[GMENUI_CHILD[MENUI]]=MW
 GWIN_SET_VAR MW,0,GMENUI_CHILD[MENUI]
 GWIN_FRONT MW
 GWIN_SET_NOTIF MW,GW
 GMENU_OLD_SEL_WIN[MENU]=#TRUE
 GWIN_PAINT GW,#TRUE
 GWIN_PAINT MW,#FALSE
END
DEF GWIN_SHOW_MENU GW,MENU,X,Y
 GMENU_WIN[MENU]=GW
 VAR W,H
 GMENU_CALC_SIZE MENU OUT W,H
 IF X+W>GDEBUG_WIDTH THEN
  X=GDEBUG_WIDTH-W
 ENDIF
 IF Y+H>GDEBUG_HEIGHT THEN
  Y=GDEBUG_HEIGHT-H
 ENDIF
 X=MAX(0,X)
 Y=MAX(0,Y)
 VAR MW=GWIN_NEW2(GWIN_ROOT,X,Y,W,H,"","GWIN_MENU_EVENT",#GWIN_FLG_NOFRAME OR #GWIN_FLG_NACTV)
 GMENU_WIN2[MENU]=MW
 GWIN_SET_NOTIF MW,GW
 GWIN_SET_VAR MW,0,MENU
 GWIN_FRONT MW
 GWIN_PAINT MW,#FALSE
END

DEF GWIN_DRAW_MENU GW,EVENT,X,Y,W,H,MENU
 VAR X2=X+W-1
 VAR Y2=Y+H-1
 VAR MENU_BACK_C=RGB(192,192,192)
 VAR MENU_FORE_C=RGB(0,0,0)
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GFILL X,Y,X2,Y2,MENU_BACK_C
 ENDIF
 VAR MX=GWIN_GET_MOUSE_NCX(GW),MY=GWIN_GET_MOUSE_NCY(GW)
 VAR MENUI=GMENU_CHILD[MENU]
 VAR SEL
 WHILE MENUI
  VAR FW
  VAR SX=X+5
  VAR SY=Y+1
  IF GMENU_OLD_SEL[MENU]==MENUI&&GMENU_OLD_SEL_WIN[MENU] THEN
   INC SX,1
   INC SY,1
  ENDIF
  IF EVENT==#GWIN_EVENT_PAINT THEN
   FW=GPUTCHR_FONT_W(GDEBUG_SYS_FONT,SX,SY,#FALSE,GMENUI_NAME$[MENUI],MENU_FORE_C)+12
  VAR OVER=X<=MX&&X+FW>MX&&Y<=MY&&Y+H>MY
   IF GMENU_OLD_SEL[MENU]==MENUI||OVER THEN
    VAR C1=RGB(128,128,128)
    VAR C2=RGB(255,255,255)
    IF GMENU_WIN[GMENUI_CHILD[MENUI]] THEN
     SWAP C1,C2
    ENDIF
    GLINE X,Y,X+FW-2,Y,C2
    GLINE X,Y,X,Y2-2,C2
    GLINE X,Y2-1,X+FW-1,Y2-1,C1
    GLINE X+FW-1,Y,X+FW-1,Y2-1,C1
   ENDIF
  ELSE
   FW=FONT_CALC_WIDTH(GDEBUG_SYS_FONT,GMENUI_NAME$[MENUI])+12
   OVER=X<=MX&&X+FW>MX&&Y<=MY&&Y+H>MY
  ENDIF
  IF OVER THEN
   SEL=#TRUE
   IF EVENT==#GWIN_EVENT_LDWN THEN
    IF GMENU_OLD_SEL_WIN[MENU]THEN
     GMENU_OLD_SEL_WIN[MENU]=#FALSE
     GWIN_PAINT GW,#TRUE
     RETURN
    ENDIF
    GWIN_SHOW_CHILD_MENU GW,MENU,MENUI,X,Y
    RETURN
   ENDIF
   IF EVENT!=#GWIN_EVENT_PAINT THEN
    IF GMENU_OLD_SEL[MENU]!=MENUI THEN
     IF GMENU_WIN[GMENUI_CHILD[GMENU_OLD_SEL[MENU]]]THEN
      GWIN_DELETE GMENU_WIN[GMENUI_CHILD[GMENU_OLD_SEL[MENU]]]
      GMENU_WIN[GMENUI_CHILD[GMENU_OLD_SEL[MENU]]]=0
      GWIN_SHOW_CHILD_MENU GW,MENU,MENUI,X,Y
     ENDIF
     GMENU_OLD_SEL[MENU]=MENUI
     GWIN_PAINT GW,#TRUE
     RETURN
    ENDIF
   ENDIF
  ENDIF
  INC X,FW
  MENUI=GMENUI_NEXT[MENUI]
 WEND
 IF GMENU_OLD_SEL_WIN[MENU]&&!SEL THEN
   GMENU_OLD_SEL_WIN[MENU]=0
 ENDIF
 IF EVENT!=#GWIN_EVENT_PAINT THEN
  IF !SEL&&GMENU_OLD_SEL[MENU]&&!GMENU_WIN[GMENUI_CHILD[GMENU_OLD_SEL[MENU]]] THEN
   GMENU_OLD_SEL[MENU]=0
   GWIN_PAINT GW,#TRUE
   RETURN
  ENDIF
 ENDIF
END
DEF GWIN_MENU_EVENT GW,EVENT,A1,A2,A3,A4
 VAR MENU=GWIN_GET_VAR(GW,0)
 CASE EVENT
 WHEN #GWIN_EVENT_CHFOCUS
  IF!A1 THEN
   IF GWIN_GET_EVENT$(A2)=="GWIN_MENU_EVENT"THEN RETURN
   GMENU_DEL MENU,GW,#TRUE
   GMENU_OLD_SEL[GMENU_PARENT[MENU]]=0
   VAR P=GMENU_PARENT[MENU]
   WHILE P
    IF GMENU_PARENT[P]&&!GMENU_PARENT[GMENU_PARENT[P]]THEN
     IF GWIN_GET_EVENT$(GMENU_WIN[P])=="GWIN_MENU_EVENT"THEN
      IF GWIN_GET_EVENT$(GMENU_WIN[GMENU_PARENT[P]])!="GWIN_MENU_EVENT"THEN
       GMENU_OLD_SEL[GMENU_PARENT[P]]=0
       GMENU_OLD_SEL_WIN[GMENU_PARENT[P]]=#FALSE
      ENDIF
      GWIN_DELETE GMENU_WIN[P]
      BREAK
     ENDIF
    ENDIF
    P=GMENU_PARENT[P]
   WEND
   GMENU_OLD_SEL_WIN[MENU]=#FALSE
   RETURN
  ENDIF
 WHEN #GWIN_EVENT_DELETE
  IF GMENU_OLD_SEL[MENU]&&GMENUI_CHILD[GMENU_OLD_SEL[MENU]]&&GMENU_WIN2[GMENUI_CHILD[GMENU_OLD_SEL[MENU]]]THEN
   GMENU_OLD_SEL_WIN[MENU]=#FALSE
   GMENU_DEL GMENUI_CHILD[GMENU_OLD_SEL[MENU]],GMENU_WIN2[GMENUI_CHILD[GMENU_OLD_SEL[MENU]]],#FALSE

'     GWIN_DELETE GMENU_WIN2[GMENUI_CHILD[GMENU_OLD_SEL[MENU]]]
  ENDIF
  GMENU_WIN[MENU]=0
  GMENU_OLD_SEL[MENU]=0
  IF GWIN_GET_EVENT$(GMENU_WIN[GMENU_PARENT[MENU]])!="GWIN_MENU_EVENT"THEN
   GWIN_PAINT GMENU_WIN[GMENU_PARENT[MENU]],#TRUE
  ENDIF
 RETURN
 WHEN #GWIN_EVENT_NOTIF
  IF A1==#GWIN_NOTIF_MENU THEN
   VAR NW=GWIN_NOTIF[GW]
   GMENU_DEL MENU,GW,#TRUE
   'FIXME
   CALL GWIN_EVENT$[NW],NW,#GWIN_EVENT_NOTIF,#GWIN_NOTIF_MENU,0,A3,0
  ENDIF
 WHEN #GWIN_EVENT_MMOVE
 WHEN #GWIN_EVENT_PAINT
 WHEN #GWIN_EVENT_LUP
 WHEN #GWIN_EVENT_LEAVE
  VAR X=GWIN_GET_CX(GW),Y=GWIN_GET_CY(GW)
  VAR W=GWIN_GET_CW(GW),H=GWIN_GET_CH(GW)
  GMENU_DRAW_POPUP_MENU GW,EVENT,X,Y,W,H,MENU
 ENDCASE
END
DEF GDEBUG_DRAW_DISABLED_CLOSE_BUTTON X,Y
 IF TYPEOF(GDEBUG_DISABLED_CLOSE_BUTTON)==#T_DEFAULT THEN
  VAR GRAY=RGB(128,128,128)
  VAR WHITE=RGB(255,255,255)
  DIM BMP%[]=[\
  GRAY, GRAY,    0,    0,    0,    0, GRAY, GRAY,    0,\
     0, GRAY, GRAY,    0,    0, GRAY, GRAY,WHITE,WHITE,\
     0,    0, GRAY, GRAY, GRAY, GRAY,WHITE,WHITE,    0,\
     0,    0,    0, GRAY, GRAY,WHITE,WHITE,    0,    0,\
     0,    0, GRAY, GRAY, GRAY, GRAY,    0,    0,    0,\
     0, GRAY, GRAY,WHITE,WHITE, GRAY, GRAY,    0,    0,\
  GRAY, GRAY,WHITE,WHITE,    0,    0, GRAY, GRAY,    0,\
     0,WHITE,WHITE,    0,    0,    0,    0,WHITE,WHITE]
  GDEBUG_DISABLED_CLOSE_BUTTON=BMP%
 ENDIF
 GLOAD X,Y,9,8,GDEBUG_DISABLED_CLOSE_BUTTON,#G_NORMAL2
END
DEF GDEBUG_DRAW_CLOSE_BUTTON X,Y
 IF TYPEOF(GDEBUG_CLOSE_BUTTON)==#T_DEFAULT THEN
  VAR GRAY=RGB(0,0,0)
  VAR WHITE=0
  DIM BMP%[]=[\
  GRAY, GRAY,    0,    0,    0,    0, GRAY, GRAY,    0,\
     0, GRAY, GRAY,    0,    0, GRAY, GRAY,WHITE,WHITE,\
     0,    0, GRAY, GRAY, GRAY, GRAY,WHITE,WHITE,    0,\
     0,    0,    0, GRAY, GRAY,WHITE,WHITE,    0,    0,\
     0,    0, GRAY, GRAY, GRAY, GRAY,    0,    0,    0,\
     0, GRAY, GRAY,WHITE,WHITE, GRAY, GRAY,    0,    0,\
  GRAY, GRAY,WHITE,WHITE,    0,    0, GRAY, GRAY,    0,\
     0,WHITE,WHITE,    0,    0,    0,    0,WHITE,WHITE]
  GDEBUG_CLOSE_BUTTON=BMP%
 ENDIF
 GLOAD X,Y,9,8,GDEBUG_CLOSE_BUTTON,#G_NORMAL2
END
DEF GDEBUG_DRAW_BUTTON_EDGE X,Y,W,H
 VAR X2=X+W-1
 VAR Y2=Y+H-1
 GFILL X+1,Y+1,X2-2,Y2-2,RGB(192,192,192)
 GLINE X,Y,X2-1,Y,RGB(255,255,255)
 GLINE X,Y,X,Y2-1,RGB(255,255,255)
 GLINE X2,Y,X2,Y2,RGB(0,0,0)
 GLINE X,Y2,X2,Y2,RGB(0,0,0)
 GLINE X+1,Y2-1,X2-1,Y2-1,RGB(128,128,128)
 GLINE X2-1,Y+1,X2-1,Y2-1,RGB(128,128,128)
END
DEF GDEBUG_DRAW_TAB X,Y,W,H,DRAW_LEFT,DRAW_RIGHT,REVERSED
 VAR X2=X+W-1
 VAR Y2=Y+H-1
 IF DRAW_LEFT THEN
  IF REVERSED THEN
   GPSET X+1,Y2-1,RGB(255,255,255)
   GLINE X,Y2-2,X,Y,RGB(255,255,255)
   GLINE X+1,Y2-2,X+1,Y,RGB(223,223,223)
  ELSE
   GPSET X+1,Y+1,RGB(255,255,255)
   GLINE X,Y+2,X,Y2,RGB(255,255,255)
   GLINE X+1,Y+2,X+1,Y2,RGB(223,223,223)
  ENDIF
 ENDIF
 IF REVERSED THEN
  GLINE X+2,Y2,X2-2,Y2,RGB(0,0,0)
  GLINE X+2,Y2-1,X2-2,Y2-1,RGB(128,128,128)
  GLINE X+2,Y2-1,X2-2,Y2-1,RGB(223,223,223)
 ELSE
  GLINE X+2,Y,X2-2,Y,RGB(255,255,255)
  GLINE X+2,Y+1,X2-2,Y+1,RGB(223,223,223)
 ENDIF
 IF DRAW_RIGHT THEN
  IF REVERSED THEN
   GPSET X2-1,Y2-1,RGB(0,0,0)
   GLINE X2,Y2-2,X2,Y,RGB(0,0,0)
   GLINE X2-1,Y2-2,X2-1,Y,RGB(128,128,128)
  ELSE
   GPSET X2-1,Y+1,RGB(0,0,0)
   GLINE X2,Y+2,X2,Y2,RGB(0,0,0)
   GLINE X2-1,Y+2,X2-1,Y2,RGB(128,128,128)
  ENDIF
 ENDIF
 VAR FX1=X+2,FX2=X2-2
 IF !DRAW_LEFT THEN
  FX1=X+2
 ENDIF
 IF !DRAW_RIGHT THEN
  FX2=X2-3
 ENDIF
 IF REVERSED THEN
  GFILL FX1,Y2-2,FX2,Y,RGB(192,192,192)
 ELSE
  GFILL FX1,Y+3,FX2,Y2,RGB(192,192,192)
 ENDIF
END
DEF GDEBUG_DRAW_TABS GW,EVENT,X,Y,W,H,TABS$[],SEL_TAB,REVERSED,TABS_COL[] OUT SEL_TAB_UPD
 VAR X2=X+W-1
 VAR Y2=Y+H-1
 VAR DRW_EDGE=0
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GFILL X,Y,X2,Y2,RGB(192,192,192)
  IF DRW_EDGE&&REVERSED THEN
   GLINE X,Y,X2,Y,RGB(128,128,128)
   GLINE X,Y+1,X2,Y+1,RGB(0,0,0)
  ELSEIF DRW_EDGE THEN
   GLINE X,Y2,X2,Y2,RGB(223,223,223)
   GLINE X,Y2-1,X2,Y2-1,RGB(255,255,255)
  ENDIF
 ENDIF
 VAR TABW
 VAR I
 VAR ADD_Y=2
 IF REVERSED THEN ADD_Y=0
 VAR MX=GWIN_GET_MOUSE_X(GW)
 VAR MY=GWIN_GET_MOUSE_Y(GW)
 FOR I=0 TO LAST(TABS$)
  VAR TABX=X
  TABW=FONT_CALC_WIDTH(GDEBUG_SYS_FONT,TABS$[I])+5
  VAR TABX2=X+TABW
  VAR TABY=Y
  VAR TABH=H
  VAR DRWL=#TRUE
  VAR DRWR=#TRUE
  IF SEL_TAB==I THEN
   IF REVERSED THEN
    TABY=Y-1
    TABH=TABH+1
   ENDIF
   TABW=TABW+2
  ELSEIF SEL_TAB==I-1 THEN
   TABY=Y+ADD_Y
   TABW=TABW+2
   TABH=H-1-2*DRW_EDGE
   DRWL=#FALSE
   IF REVERSED&&DRW_EDGE THEN TABY=TABY+2
  ELSEIF SEL_TAB==I+1 THEN
   TABX=X+2
   TABY=Y+ADD_Y
   TABH=H-1-2*DRW_EDGE
   DRWR=#FALSE
   IF REVERSED&&DRW_EDGE THEN TABY=TABY+2
  ELSE
   TABX=X+2
   TABY=Y+ADD_Y
   TABH=H-1-2*DRW_EDGE
   IF REVERSED&&DRW_EDGE THEN TABY=TABY+2
  ENDIF
  IF EVENT==#GWIN_EVENT_PAINT THEN
   GDEBUG_DRAW_TAB TABX,TABY,TABW,TABH,DRWL,DRWR,REVERSED
   IF SEL_TAB==I&&REVERSED THEN
    GLINE TABX+2,Y-1,TABX+TABW-3,Y-1,RGB(192,192,192)
   ENDIF
   IF TYPEOF(TABS_COL) THEN
    VAR C=TABS_COL[I]
   ELSE
    C=RGB(0,0,0)
   ENDIF
   VAR TX=X+4,TY
   IF SEL_TAB==I THEN
    IF REVERSED THEN
     TY=Y2-15
    ELSE
     TY=Y2-16
    ENDIF
   ELSE
    IF REVERSED THEN
     TY=Y2-16
    ELSE
     TY=Y2-14
    ENDIF
   ENDIF
   IF RGB(128,128,128)==C THEN
    'FIXME:ZATSU!!
    GPUTCHR_FONT GDEBUG_SYS_FONT,TX+1,TY+1,#FALSE,TABS$[I],RGB(255,255,255)
   ENDIF
   GPUTCHR_FONT GDEBUG_SYS_FONT,TX,TY,#FALSE,TABS$[I],C
  ELSEIF EVENT==#GWIN_EVENT_LDWN THEN
   IF MX>=TABX&&MX<TABX+TABW&&MY>=TABY&&MY<TABY+TABH THEN
    SEL_TAB_UPD=I
    BREAK
   ENDIF
  ENDIF
  X=TABX2
 NEXT
END
DEF GDEBUG_DRAW_SUNKEN_EDGE EVENT,X,Y,W,H OUT X_OUT,Y_OUT,W_OUT,H_OUT
 VAR X2=X+W-1
 VAR Y2=Y+H-1
 X_OUT=X+2
 Y_OUT=Y+2
 W_OUT=W-4
 H_OUT=H-4
 IF EVENT!=#GWIN_EVENT_PAINT THEN RETURN
 GLINE X,Y,X2-1,Y,RGB(128,128,128)
 GLINE X,Y,X,Y2-1,RGB(128,128,128)
 GLINE X+1,Y+1,X2-2,Y+1,RGB(0,0,0)
 GLINE X+1,Y+1,X+1,Y2-2,RGB(0,0,0)
 GLINE X+1,Y2-1,X2-1,Y2-1,RGB(192,192,192)
 GLINE X2-1,Y+1,X2-1,Y2-1,RGB(192,192,192)
 GLINE X,Y2,X2,Y2,RGB(255,255,255)
 GLINE X2,Y,X2,Y2,RGB(255,255,255)
END
DEF GCLIP_SAFE X1,Y1,X2,Y2
 GCLIP MAX(0,X1),MAX(0,Y1),MAX(0,X2),MAX(0,Y2)
END
DEF GWIN_GET_SEL GW OUT CURLINE,CURPOS,SELLINE,SELPOS,SELENDLINE,SELENDPOS
 CURLINE=GDEBUG_PRG_CURLINE[GDEBUG_PRG_SLOT]
 CURPOS=GDEBUG_PRG_CURPOS[GDEBUG_PRG_SLOT]
 SELLINE=CURLINE
 SELPOS=CURPOS
 SELENDLINE=GDEBUG_PRG_SELLINE[GDEBUG_PRG_SLOT]
 SELENDPOS=GDEBUG_PRG_SELPOS[GDEBUG_PRG_SLOT]
 IF SELENDLINE<SELLINE THEN
  SWAP SELLINE,SELENDLINE
  SWAP SELPOS,SELENDPOS
 ELSEIF SELENDLINE==SELLINE&&SELPOS>SELENDPOS THEN
  SWAP SELPOS,SELENDPOS
 ENDIF
END
DEF GDEBUG_DRAW_PRG GW,EVENT,X,Y,W,H
 VAR FONT_TYPE=16,FONT_SCALE_X=1,FONT_SCALE_Y=1
 VAR FONT_TYPE2=16,FONT_SCALE_X2=1,FONT_SCALE_Y2=1
 VAR FS=FONT_TYPE*FONT_SCALE_Y
 VAR FH=16
 VAR TABH=20
 DIM TABS$[]=["SLOT0","SLOT1","SLOT2","SLOT3"]
 DIM TABS_COL%[4]
 VAR I
 FOR I=0TO 3
  IF VM_IS_SLOT_COMPILED(I)THEN
   TABS_COL%[I]=RGB(0,0,0)
  ELSE
   TABS_COL%[I]=RGB(128,128,128)
  ENDIF
 NEXT
 VAR VSLOT,VLINE,VLINE_POS
 VAR VPC
 VAR RUNNING=VM_IS_COMPILED()
 IF RUNNING THEN
  VMDBG_FIND_FRAME GDEBUG_CURRENT_FRAME OUT ,,VSLOT,VPC
  VMDBG_GET_LINE VSLOT,VPC OUT VLINE,VLINE_POS
 ENDIF
 VLINE=MAX(VLINE,1)
 VAR SCRBAR_GW=GWIN_FIND(GW,"SCRBAR")
 VAR SCRBAR_H_GW=GWIN_FIND(GW,"SCRBAR_H")
 VAR GDEBUG_PRG_SLOT_SEL
 VAR SCROLL_REQUESTED=GWIN_GET_VAR(GW,#GDEBUG_PRG_V_REQ_SCROLL)
 IF SCROLL_REQUESTED THEN
  GDEBUG_PRG_SLOT=VSLOT
 ENDIF
 VAR SCRBAR_POS,SCRBAR_H_POS
 GWIN_SCR_GET SCRBAR_GW OUT ,,SCRBAR_POS
 GDEBUG_DRAW_TABS GW,EVENT,X,Y,W,TABH,TABS$,GDEBUG_PRG_SLOT,#FALSE,TABS_COL% OUT GDEBUG_PRG_SLOT_SEL
 'TABきりかえ
 IF TYPEOF(GDEBUG_PRG_SLOT_SEL) THEN
  GDEBUG_PRG_SCRPOS[GDEBUG_PRG_SLOT]=SCRBAR_POS
  GDEBUG_PRG_SLOT=GDEBUG_PRG_SLOT_SEL
  SCRBAR_POS=GDEBUG_PRG_SCRPOS[GDEBUG_PRG_SLOT]
  GWIN_SCR_SET SCRBAR_GW,,FS*MAX(1,VSLOT_PRGSIZE(GDEBUG_PRG_SLOT,0)),SCRBAR_POS
  GWIN_PAINT GW,#FALSE
  RETURN
 ENDIF
 VAR SLOT=GDEBUG_PRG_SLOT
 INC Y,TABH
 DEC H,TABH
 VAR MX=GWIN_GET_MOUSE_X(GW)
 VAR MY=GWIN_GET_MOUSE_Y(GW)
 GDEBUG_DRAW_SUNKEN_EDGE EVENT,X,Y,W,H OUT X,Y,W,H
 VAR C_GW,C_FRM
 GWIN_GET_CAPTURE OUT C_GW,C_FRM,,
 VAR SCRBAR_W=16
 IF EVENT==#GWIN_EVENT_MMOVE||EVENT==#GWIN_EVENT_LUP THEN
  IF EVENT==#GWIN_EVENT_LUP THEN
   GWIN_SET_VAR GW,#GDEBUG_PRG_V_SEL_MODE,#GDEBUG_PRG_SEL_MODE_NONE
  ENDIF
  IF MX>=X+LEN(DEBUG_GETLINESTR$(1))*FONT_TYPE2*FONT_SCALE_X2&&X+W-SCRBAR_W>MX&&MY>=Y&&Y+H-SCRBAR_W>MY||(C_GW&&!C_FRM)THEN
   IF GWIN_GET_VAR(GW,#GDEBUG_PRG_V_SEL_MODE)==#GDEBUG_PRG_SEL_MODE_LINE THEN
    GWIN_SET_CURSOR GW,"GWIN_CURSOR_ARROW2"
   ELSE
    GWIN_SET_CURSOR GW,"GWIN_CURSOR_BEAM"
   ENDIF
  ELSE
   IF MX>X+(LEN(DEBUG_GETLINESTR$(1))-1)*FONT_TYPE2*FONT_SCALE_X2&&MY>=Y&&Y+H-SCRBAR_W>MY THEN
    GWIN_SET_CURSOR GW,"GWIN_CURSOR_ARROW2"
   ELSE
    GWIN_SET_CURSOR GW,"GWIN_CURSOR_ARROW"
   ENDIF
  ENDIF
 ENDIF
 VAR X2=X+W-1-SCRBAR_W
 DEC H,SCRBAR_W
 VAR Y2=Y+H-1
 VAR BACK_COLOR=RGB(0,0,0)
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GCLIP X,Y,X2,Y2
  GFILL X,Y,X2,Y2,BACK_COLOR
 ENDIF
 VAR OFF_Y=0
 VAR SLOT_LINE_COUNT=MAX(1,VSLOT_PRGSIZE(SLOT,0))
 VAR CUR_RUN_LOC_COLOR=RGB(128,128,0)
 VAR CUR_RUN_LOC_COLOR2=RGB(64,64,0)
 VAR BP_COLOR=RGB(128,0,0)
 VAR LINES=H DIV (FONT_TYPE*FONT_SCALE_Y)
 VAR LINE=SCRBAR_POS DIV FS+1
 VAR END_LINE=LINE+LINES
 IF SCROLL_REQUESTED THEN
  VAR RLINE=GWIN_GET_VAR(GW,#GDEBUG_PRG_V_REQ_SCROLL_LINE)
  GWIN_SET_VAR GW,#GDEBUG_PRG_V_REQ_SCROLL,#FALSE
  GWIN_SET_VAR GW,#GDEBUG_PRG_V_REQ_SCROLL_LINE,0
  IF !RLINE THEN
   RLINE=VLINE
  ENDIF
  GDEBUG_PRG_CURLINE[SLOT]=RLINE
  GDEBUG_PRG_CURPOS[SLOT]=0
  GDEBUG_PRG_SELLINE[SLOT]=RLINE
  GDEBUG_PRG_SELPOS[SLOT]=0
  IF LINE>RLINE THEN
   LINE=RLINE-LINES DIV 2
  ELSEIF END_LINE<RLINE THEN
   LINE=RLINE-LINES DIV 2
  ENDIF
  GWIN_SCR_SET SCRBAR_GW,,SLOT_LINE_COUNT*FS,(LINE-1)*FS
  GWIN_SCR_GET SCRBAR_GW OUT ,,SCRBAR_POS
  LINE=SCRBAR_POS DIV FS+1
 ENDIF
 OFF_Y=SCRBAR_POS MOD FS
 GWIN_SCR_GET SCRBAR_H_GW OUT ,,SCRBAR_H_POS
 VSLOT_SEEKLINE SLOT,LINE
 VAR SX=X
 VAR SY=Y
 VAR PC
 Y=Y-OFF_Y
 DEC X,SCRBAR_H_POS
 VAR CURLINE,CURPOS,SELLINE,SELPOS,SELENDLINE,SELENDPOS
 GWIN_GET_SEL GW OUT CURLINE,CURPOS,SELLINE,SELPOS,SELENDLINE,SELENDPOS
 IF EVENT==#GWIN_EVENT_MMOVE&&(C_GW!=GW||C_FRM) THEN RETURN
 LOOP
  IF Y>=Y2 THEN BREAK
  VAR L$=VSLOT_PRGGET_SLOT$(SLOT,#TRUE)
  VAR LS$=DEBUG_GETLINESTR$(LINE)
  VAR TX=X+LEN(LS$)*FONT_TYPE2*FONT_SCALE_X2
  IF EVENT!=#GWIN_EVENT_PAINT THEN
   VAR OVER_LINE=#FALSE
   IF Y<=MY&&(Y+FONT_TYPE*FONT_SCALE_Y>MY||!LEN(L$)) THEN
    OVER_LINE=#TRUE
   ENDIF
   VAR OVER_BP=#FALSE,OVER_LINE_SEL=#FALSE
   IF X<=MX&&TX>MX&&LEN(L$) THEN
    IF TX-FONT_TYPE2*FONT_SCALE_X2<MX THEN
     OVER_LINE_SEL=#TRUE
    ELSE
     OVER_BP=#TRUE
    ENDIF
   ENDIF
   IF!LEN(L$)THEN DEC LINE
   VAR POS=MAX(MIN((MX-TX) DIV (FONT_TYPE*FONT_SCALE_X),LEN(L$)-1),0)
   IF EVENT==#GWIN_EVENT_LDWN||EVENT==#GWIN_EVENT_RDWN||EVENT==#GWIN_EVENT_LDBL THEN
    IF OVER_LINE THEN
     IF OVER_BP THEN
      VMDBG_GET_PC_LIST SLOT,LINE OUT PC
      VMDBG_TOGGLE_BP_LIST SLOT,PC
      GWIN_PAINT GW,#FALSE
     ELSE
      VAR SELECTED=SELLINE!=SELENDLINE||SELPOS!=SELENDPOS
      IF SELECTED&&EVENT==#GWIN_EVENT_RDWN THEN
       RETURN
      ENDIF
      IF GDEBUG_PRG_CURLINE[GDEBUG_PRG_SLOT]!=LINE||\
         GDEBUG_PRG_CURPOS[GDEBUG_PRG_SLOT]!=POS||\
         SELECTED THEN
       GDEBUG_PRG_CURLINE[GDEBUG_PRG_SLOT]=LINE
       GDEBUG_PRG_CURPOS[GDEBUG_PRG_SLOT]=POS
       GDEBUG_PRG_SELLINE[GDEBUG_PRG_SLOT]=LINE
       GDEBUG_PRG_SELPOS[GDEBUG_PRG_SLOT]=POS
       IF OVER_LINE_SEL THEN
        GWIN_SET_VAR GW,#GDEBUG_PRG_V_SEL_MODE,#GDEBUG_PRG_SEL_MODE_LINE
        GDEBUG_PRG_CURPOS[GDEBUG_PRG_SLOT]=LEN(L$)
       ELSE
        GWIN_SET_VAR GW,#GDEBUG_PRG_V_SEL_MODE,#GDEBUG_PRG_SEL_MODE_NONE
       ENDIF
       GWIN_PAINT GW,#FALSE
      ENDIF
      IF EVENT==#GWIN_EVENT_LDBL THEN
       VAR W$,WORD_SI,WORD_I
       GWIN_PRG_GET_CUR_WORD GW,LINE,POS,#TRUE OUT W$,WORD_SI,WORD_I
       GDEBUG_PRG_SELLINE[GDEBUG_PRG_SLOT]=LINE
       GDEBUG_PRG_SELPOS[GDEBUG_PRG_SLOT]=WORD_SI
       GDEBUG_PRG_CURLINE[GDEBUG_PRG_SLOT]=LINE
       GDEBUG_PRG_CURPOS[GDEBUG_PRG_SLOT]=WORD_I+(WORD_I==WORD_SI)
       GWIN_SET_VAR GW,#GDEBUG_PRG_V_SEL_MODE,#GDEBUG_PRG_SEL_MODE_WORD
       GWIN_SET_VAR GW,#GDEBUG_PRG_V_SEL_WORD_SI,WORD_SI
       GWIN_SET_VAR GW,#GDEBUG_PRG_V_SEL_WORD_I,WORD_I
       GWIN_PAINT GW,#FALSE
      ENDIF
      IF EVENT==#GWIN_EVENT_LDWN THEN
       GWIN_SET_CAPTURE GW,#FALSE
      ENDIF
      RETURN
     ENDIF
    ENDIF
   ELSEIF EVENT==#GWIN_EVENT_MMOVE&&(OVER_LINE||MY<SY) THEN
    IF GWIN_GET_VAR(GW,#GDEBUG_PRG_V_SEL_MODE)==#GDEBUG_PRG_SEL_MODE_LINE THEN
     POS=LEN(L$)
     IF LINE<GDEBUG_PRG_SELLINE[GDEBUG_PRG_SLOT] THEN
      POS=0
     ENDIF
    ENDIF
    IF GDEBUG_PRG_CURLINE[GDEBUG_PRG_SLOT]!=LINE||\
       GDEBUG_PRG_CURPOS[GDEBUG_PRG_SLOT]!=POS THEN
     IF GWIN_GET_VAR(GW,#GDEBUG_PRG_V_SEL_MODE)==#GDEBUG_PRG_SEL_MODE_WORD THEN
      GWIN_PRG_GET_CUR_WORD GW,LINE,POS,#FALSE OUT W$,WORD_SI,WORD_I
      IF GDEBUG_PRG_SELLINE[GDEBUG_PRG_SLOT]>LINE||\
         (GDEBUG_PRG_SELLINE[GDEBUG_PRG_SLOT]==LINE&&\
          GDEBUG_PRG_SELPOS[GDEBUG_PRG_SLOT]>POS) THEN
       POS=WORD_SI
       GDEBUG_PRG_SELPOS[GDEBUG_PRG_SLOT]=GWIN_GET_VAR(GW,#GDEBUG_PRG_V_SEL_WORD_I)
      ELSE
       GDEBUG_PRG_SELPOS[GDEBUG_PRG_SLOT]=GWIN_GET_VAR(GW,#GDEBUG_PRG_V_SEL_WORD_SI)
       POS=WORD_I
      ENDIF
     ENDIF
     GDEBUG_PRG_CURLINE[GDEBUG_PRG_SLOT]=LINE
     GDEBUG_PRG_CURPOS[GDEBUG_PRG_SLOT]=POS
     GWIN_PAINT GW,#FALSE
    ENDIF
    RETURN
   ENDIF
   IF!LEN(L$)THEN BREAK
   GOTO @CONTINUE
  ENDIF
  IF!LEN(L$)THEN BREAK
  VMDBG_GET_PC SLOT,LINE OUT PC
  IF PC!=-1THEN
   VAR HAS_BP=VMDBG_HAS_BP(SLOT,PC)
  ELSE
   HAS_BP=#FALSE
  ENDIF
  VAR TCOL=RGB(255,255,255)
  GCLIP SX,SY,X2,Y2
  IF HAS_BP THEN
   GFILL SX,Y,X2,Y+FONT_TYPE*FONT_SCALE_Y-1,BP_COLOR
  ENDIF
  IF RUNNING&&VSLOT==SLOT&&VLINE==LINE THEN
   VAR DBG_LINE,DBG_LINE_POS,DBG_LINE_END,DBG_LINE_POS_END
   VMDBG_GET_LINE2 SLOT,VPC OUT DBG_LINE,DBG_LINE_POS,DBG_LINE_END,DBG_LINE_POS_END
   GFILL SX,Y,X2,Y+FONT_TYPE*FONT_SCALE_Y-1,CUR_RUN_LOC_COLOR
   GCLIP_SAFE X+SCRBAR_H_POS+LEN(LS$)*FONT_TYPE2*FONT_SCALE_X2,SY,X2,Y2
   GFILL TX+(DBG_LINE_POS-1)*FONT_TYPE*FONT_SCALE_X,Y,TX+(DBG_LINE_POS_END-1)*FONT_TYPE*FONT_SCALE_X-1,Y+FONT_TYPE*FONT_SCALE_Y-1,CUR_RUN_LOC_COLOR2
   TCOL=RGB(255,255,0)
   GCLIP SX,SY,X2,Y2
  ENDIF
  IF HAS_BP THEN
   GBOX SX,Y,X2,Y+FONT_TYPE*FONT_SCALE_Y-1,BP_COLOR
   TCOL=RGB(255,0,0)
  ENDIF
  GPUTCHR X+SCRBAR_H_POS,Y,LS$,FONT_TYPE2,FONT_SCALE_X2,FONT_SCALE_Y2,TCOL,#G_ALPHA2
  GCLIP_SAFE X+SCRBAR_H_POS+LEN(LS$)*FONT_TYPE2*FONT_SCALE_X2,SY,X2,Y2
  '==SELECT==
  VAR CURLINE_SELPOS=0
  VAR CURLINE_SELENDPOS=0
  IF LINE==SELLINE THEN
   CURLINE_SELPOS=SELPOS
   IF SELLINE==SELENDLINE THEN
    CURLINE_SELENDPOS=SELENDPOS
   ELSE
    CURLINE_SELENDPOS=LEN(L$)
   ENDIF
  ELSEIF LINE==SELENDLINE THEN
   CURLINE_SELPOS=0
   CURLINE_SELENDPOS=SELENDPOS
  ELSEIF LINE>SELLINE&&LINE<SELENDLINE THEN
   CURLINE_SELPOS=0
   CURLINE_SELENDPOS=LEN(L$)
  ENDIF
  VAR CURLINE_SEL=CURLINE_SELPOS!=CURLINE_SELENDPOS
  IF CURLINE_SEL THEN
   VAR SELBACKCOL=RGB(255,255,255)
'   GFILL TX+CURLINE_SELPOS*FONT_TYPE*FONT_SCALE_X,Y,TX+CURLINE_SELENDPOS*FONT_TYPE*FONT_SCALE_X,Y+FONT_TYPE*FONT_SCALE_Y-1,SELBACKCOL
  ENDIF
'  TXTED_PRGPRINT TX,Y,L$,(X2-(X+SCRBAR_H_POS+LEN(LS$)*FONT_TYPE*FONT_SCALE_X)) DIV (FONT_TYPE*FONT_SCALE_X),FONT_TYPE
  '==SELECT==

  IF LINE==CURLINE THEN
   VAR CUR_COLOR=RGB(192,192,192)
   GBOX MAX(TX,SX+LEN(LS$)*FONT_TYPE2*FONT_SCALE_X2),Y-2,X2,Y+FONT_TYPE*FONT_SCALE_Y-1,CUR_COLOR
   GBOX MAX(TX,SX+LEN(LS$)*FONT_TYPE2*FONT_SCALE_X2)+1,Y+1-2,X2-1,Y+FONT_TYPE*FONT_SCALE_Y-1-1,CUR_COLOR
   POS=CURPOS
  ENDIF
  IF !CURLINE_SEL&&0 THEN
   TXTED_PRGPRINT2 TX,Y,L$,X2,FONT_TYPE
  ELSE
   TXTED_PRGPRINT2_SEL TX,Y,L$,X2,FONT_TYPE,CURLINE_SELPOS,CURLINE_SELENDPOS,FONT_SCALE_X,FONT_SCALE_Y
  ENDIF

  '==SELECT==
  IF CURLINE_SEL THEN
   VAR SELFORECOL=RGB(0,0,0)
'   GPUTCHR TX+CURLINE_SELPOS*FONT_TYPE*FONT_SCALE_X,Y,MID$(L$,CURLINE_SELPOS,CURLINE_SELENDPOS-CURLINE_SELPOS),FONT_TYPE,FONT_SCALE_X,FONT_SCALE_Y,SELFORECOL,#G_ALPHA2
  ENDIF
  '==SELECT==
  IF LINE==CURLINE THEN
   GFILL TX+POS*FONT_TYPE*FONT_SCALE_X,Y,TX+POS*FONT_TYPE*FONT_SCALE_X+2,Y+FONT_TYPE*FONT_SCALE_Y-1,-1
  ENDIF

'  TXTED_PRGPRINT3 TX,Y,L$,1000,FONT_TYPE,GDEBUG_SYS_FONT
  GDEBUG_PRG_SLOT_MAX_W=MAX(GDEBUG_PRG_SLOT_MAX_W,(LEN(L$)+1)*FONT_TYPE*FONT_SCALE_X)
  @CONTINUE
  INC Y,FONT_TYPE*FONT_SCALE_Y
  INC LINE
 ENDLOOP
 SCRBAR_POS=(LINE-1)*FONT_TYPE*FONT_SCALE_Y
 VAR PAGE_SIZE=H
 IF SCRBAR_GW THEN
  GWIN_SCR_SET SCRBAR_GW,PAGE_SIZE,SLOT_LINE_COUNT*FS,
  GWIN_MOVERESIZE SCRBAR_GW,SX+W-1-SCRBAR_W+1-GWIN_GET_CX(GW),SY-GWIN_GET_CY(GW),SCRBAR_W,H
  GWIN_SCR_SET SCRBAR_H_GW,W-LEN(LS$)*FONT_TYPE*FONT_SCALE_X,GDEBUG_PRG_SLOT_MAX_W,
  GWIN_MOVERESIZE SCRBAR_H_GW,SX-GWIN_GET_CX(GW),SY-GWIN_GET_CY(GW)+H,W-SCRBAR_W,SCRBAR_W
 ENDIF
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GCLIP SX,SY,SX+W-1,SY+H-1
  LOOP
   IF Y>=Y2 THEN BREAK
   LS$=""
   GPUTCHR X+SCRBAR_H_POS,Y,LS$,FONT_TYPE2,FONT_SCALE_X2,FONT_SCALE_Y2,RGB(255,255,255),#G_ALPHA2
   INC Y,FONT_TYPE2*FONT_SCALE_Y2
  ENDLOOP
  GCLIP
  GFILL SX+W-1-SCRBAR_W+1,SY+H,SX+W-1,SY+H-1+SCRBAR_W,RGB(192,192,192)
 ENDIF
END
DEF GWIN_DRAW_BUTTON2 X1,Y1,W,H,STATE
 VAR BTNX2=X1+W-1
 VAR BTNY2=Y1+H-1
 IF STATE==#GWIN_DRAW_BUTTON_ETCHED THEN
  GBOX X1,Y1,BTNX2,BTNY2,RGB(128,128,128)
  GFILL X1+1,Y1+1,BTNX2-1,BTNY2-1,RGB(192,192,192)
  RETURN
 ENDIF
 VAR C5=RGB(192,192,192)
 IF STATE==#GWIN_DRAW_BUTTON_RAIS THEN
  VAR C1=RGB(223,223,223)
  VAR C2=RGB(0,0,0)
  VAR C3=RGB(128,128,128)
  VAR C4=RGB(255,255,255)
 ELSEIF STATE==#GWIN_DRAW_BUTTON_SUNK THEN
  C4=RGB(0,0,0)
  C2=RGB(255,255,255)
  C1=RGB(128,128,128)
  C3=RGB(223,223,223)
 ELSEIF STATE==#GWIN_DRAW_BUTTON_RAISED THEN
  C1=RGB(255,255,255)
  C2=RGB(0,0,0)
  C3=RGB(128,128,128)
  C4=RGB(223,223,223)
 ELSEIF  STATE==#GWIN_DRAW_BUTTON_SUNKEN THEN
  C1=RGB(0,0,0)
  C2=RGB(255,255,255)
  C3=RGB(192,192,192)
  C4=RGB(128,128,128)
 ENDIF
 GFILL X1+2,Y1+2,BTNX2-2,BTNY2-2,C1
 GBOX X1,Y1,BTNX2,BTNY2,C2
 GBOX X1,Y1,BTNX2-1,BTNY2-1,C1
 GBOX X1+1,Y1+1,BTNX2-1,BTNY2-1,C3
 GBOX X1+1,Y1+1,BTNX2-2,BTNY2-2,C4
 GFILL X1+2,Y1+2,BTNX2-2,BTNY2-2,C5
END
VAR GDEBUG_SCRBAR_PAT_W
VAR GDEBUG_SCRBAR_PAT_H
DIM GDEBUG_SCRBAR_PAT[]
DIM GDEBUG_SCRBAR_PAT2[]
DEF GDEBUG_DRAW_SCRBAR GW,EVENT,X1,Y1,W,H
 VAR X2=X1+W-1
 VAR Y2=Y1+H-1
 VAR PAGE,SIZE,POS
 GWIN_GET_VAR GW,#GWIN_SCR_V_PAGE OUT PAGE
 GWIN_GET_VAR GW,#GWIN_SCR_V_SIZE OUT SIZE
 GWIN_GET_VAR GW,#GWIN_SCR_V_POS OUT POS
 VAR C_GW,C_FRAME,C_X,C_Y
 GWIN_GET_CAPTURE OUT C_GW,C_FRAME,C_X,C_Y
 IF EVENT==#GWIN_EVENT_MMOVE THEN
  IF C_GW!=GW THEN
   RETURN
  ENDIF
 ENDIF
 IF TYPEOF(GDEBUG_SCRBAR_PAT)==#T_DEFAULT THEN
  GDEBUG_SCRBAR_PAT_H=63
  GDEBUG_SCRBAR_PAT_W=16
  GDEBUG_SCRBAR_PAT=ARRAY%(GDEBUG_SCRBAR_PAT_H,GDEBUG_SCRBAR_PAT_W)
  GDEBUG_SCRBAR_PAT2=ARRAY%(GDEBUG_SCRBAR_PAT_W,GDEBUG_SCRBAR_PAT_H)
  VAR I
  FOR I=0TO GDEBUG_SCRBAR_PAT_W-2 STEP 2
   GDEBUG_SCRBAR_PAT[0,I]=RGB(192,192,192)
   GDEBUG_SCRBAR_PAT[0,I+1]=RGB(255,255,255)
   GDEBUG_SCRBAR_PAT[1,I]=RGB(255,255,255)
   GDEBUG_SCRBAR_PAT[1,I+1]=RGB(192,192,192)
  NEXT
  FOR I=0TO GDEBUG_SCRBAR_PAT_H-2 STEP 2
   GDEBUG_SCRBAR_PAT2[0,I]=RGB(192,192,192)
   GDEBUG_SCRBAR_PAT2[0,I+1]=RGB(255,255,255)
   GDEBUG_SCRBAR_PAT2[1,I]=RGB(255,255,255)
   GDEBUG_SCRBAR_PAT2[1,I+1]=RGB(192,192,192)
  NEXT
  FOR I=2TO GDEBUG_SCRBAR_PAT_H-2 STEP 2
   COPY GDEBUG_SCRBAR_PAT,I*GDEBUG_SCRBAR_PAT_W,GDEBUG_SCRBAR_PAT,0,GDEBUG_SCRBAR_PAT_W*2
  NEXT
  FOR I=2TO GDEBUG_SCRBAR_PAT_W-2 STEP 2
   COPY GDEBUG_SCRBAR_PAT2,I*GDEBUG_SCRBAR_PAT_H,GDEBUG_SCRBAR_PAT2,0,GDEBUG_SCRBAR_PAT_H*2
  NEXT
 ENDIF
 VAR BUTTON_H=16
 VAR HORIZ=#FALSE
 VAR AREA=H-BUTTON_H*2
 IF H<W THEN
  HORIZ=#TRUE
  AREA=W-BUTTON_H*2
 ENDIF
 VAR BTN2Y=Y2-15
 VAR BTN2X=X2-15
 VAR STATE=GWIN_GET_VAR(GW,#GWIN_SCR_V_STATE)

 VAR BTN1_X,BTN2_X,BTN1_Y,BTN2_Y
 BTN1_X=X1
 BTN1_Y=Y1
 VAR BTN1_W=BUTTON_H
 VAR BTN1_H=BUTTON_H
 IF HORIZ THEN
  BTN2_X=X2-BUTTON_H+1
  BTN2_Y=Y1
 ELSE
  BTN2_X=X1
  BTN2_Y=Y2-BUTTON_H+1
 ENDIF
 VAR BTN2_W=BUTTON_H
 VAR BTN2_H=BUTTON_H
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GCLIP X1,Y1,X2,Y2
  IF HORIZ THEN
   FOR I=X1+16 TO X2-16 STEP GDEBUG_SCRBAR_PAT_H-1
    GLOAD I,Y1,GDEBUG_SCRBAR_PAT_H,GDEBUG_SCRBAR_PAT_W,GDEBUG_SCRBAR_PAT2,#G_NORMAL
   NEXT
  ELSE
   FOR I=Y1+16 TO Y2-16 STEP GDEBUG_SCRBAR_PAT_H-1
    GLOAD X1,I,GDEBUG_SCRBAR_PAT_W,MIN(GDEBUG_SCRBAR_PAT_H,BTN2Y-I),GDEBUG_SCRBAR_PAT,#G_NORMAL
   NEXT
  ENDIF
  GWIN_DRAW_BUTTON2 BTN1_X,BTN1_Y,BTN1_W,BTN1_H,STATE==#GWIN_SCR_STATE_UP
  GWIN_DRAW_BUTTON2 BTN2_X,BTN2_Y,BTN2_W,BTN2_H,STATE==#GWIN_SCR_STATE_DOWN
  IF STATE==#GWIN_SCR_STATE_UP THEN
   INC X1
   INC Y1
  ENDIF
  IF HORIZ THEN
   GPSET X1+5,Y1+7,#C_BLACK
   GLINE X1+6,Y1+6,X1+6,Y1+8,#C_BLACK
   GLINE X1+7,Y1+5,X1+7,Y1+9,#C_BLACK
   GLINE X1+8,Y1+4,X1+8,Y1+10,#C_BLACK
  ELSE
   GPSET X1+7,Y1+6,#C_BLACK
   GLINE X1+6,Y1+7,X1+8,Y1+7,#C_BLACK
   GLINE X1+5,Y1+8,X1+9,Y1+8,#C_BLACK
   GLINE X1+4,Y1+9,X1+10,Y1+9,#C_BLACK
  ENDIF
  IF STATE==#GWIN_SCR_STATE_UP THEN
   DEC X1
   DEC Y1
  ENDIF
  IF STATE==#GWIN_SCR_STATE_DOWN THEN
   INC X1
   INC BTN2Y
   INC BTN2X
   INC Y1
  ENDIF
  IF HORIZ THEN
   GPSET BTN2X+9,Y1+7,#C_BLACK
   GLINE BTN2X+8,Y1+6,BTN2X+8,Y1+8,#C_BLACK
   GLINE BTN2X+7,Y1+5,BTN2X+7,Y1+9,#C_BLACK
   GLINE BTN2X+6,Y1+4,BTN2X+6,Y1+10,#C_BLACK
  ELSE
   GPSET X1+7,BTN2Y+9,#C_BLACK
   GLINE X1+6,BTN2Y+8,X1+8,BTN2Y+8,#C_BLACK
   GLINE X1+5,BTN2Y+7,X1+9,BTN2Y+7,#C_BLACK
   GLINE X1+4,BTN2Y+6,X1+10,BTN2Y+6,#C_BLACK
  ENDIF
  IF STATE==#GWIN_SCR_STATE_DOWN THEN
   DEC X1
   DEC BTN2Y
   DEC BTN2X
   DEC Y1
  ENDIF
 ENDIF
 VAR MX=GWIN_GET_MOUSE_X(GW)
 VAR MY=GWIN_GET_MOUSE_Y(GW)
 IF EVENT==#GWIN_EVENT_LDWN THEN
  IF MX>=BTN1_X&&MX<BTN1_X+BTN1_W&&MY>=BTN1_Y&&MY<BTN1_Y+BTN1_H THEN
   GWIN_SET_VAR GW,#GWIN_SCR_V_STATE,#GWIN_SCR_STATE_UP
   'メインループマワすとかキタナいけど カンイテキなのでこれでいいコトにする(アトでシにそうだけどキにしない)
   VAR DIFF=1
   VAR FIRST=#TRUE
   WHILE GWIN_MOUSE_L_CLK()
    VAR OM=MILLISEC()
    VAR OP=POS
    DEC POS,DIFF
    POS=MAX(0,MIN(POS,SIZE-PAGE+1))
    GWIN_SET_VAR GW,#GWIN_SCR_V_POS,POS
    GWIN_PAINT GW,#FALSE
    GWIN_MAIN_LOOP
    DIFF=INT((MILLISEC()-OM)/16.6667*4)
    IF FIRST THEN
     FOR I=0TO 20
      GWIN_MAIN_LOOP
      IF !GWIN_MOUSE_L_CLK() THEN BREAK
     NEXT
     FIRST=#FALSE
    ENDIF
   WEND
   GWIN_SET_VAR GW,#GWIN_SCR_V_STATE,#GWIN_SCR_STATE_NONE
   GWIN_PAINT GW,#FALSE
   RETURN
  ELSEIF MX>=BTN2_X&&MX<BTN2_X+BTN2_W&&MY>=BTN2_Y&&MY<BTN2_Y+BTN2_H THEN
   GWIN_SET_VAR GW,#GWIN_SCR_V_STATE,#GWIN_SCR_STATE_DOWN
   DIFF=1
   FIRST=#TRUE
   WHILE GWIN_MOUSE_L_CLK()
    OM=MILLISEC()
    OP=POS
    INC POS,DIFF
    POS=MAX(0,MIN(POS,SIZE-PAGE+1))
    GWIN_SET_VAR GW,#GWIN_SCR_V_POS,POS
    GWIN_PAINT GW,#FALSE
    GWIN_MAIN_LOOP
    DIFF=INT((MILLISEC()-OM)/16.6667*4)
    IF FIRST THEN
     FOR I=0TO 20
      GWIN_MAIN_LOOP
      IF !GWIN_MOUSE_L_CLK() THEN BREAK
     NEXT
     FIRST=#FALSE
    ENDIF
   WEND
   GWIN_SET_VAR GW,#GWIN_SCR_V_STATE,#GWIN_SCR_STATE_NONE
   GWIN_PAINT GW,#FALSE
   RETURN
  ENDIF
 ENDIF
 IF SIZE THEN
  VAR THUMB_SIZE=AREA*PAGE DIV SIZE
  VAR MIN_THUMB_SIZE=16
  THUMB_SIZE=MAX(MIN_THUMB_SIZE,THUMB_SIZE)
  VAR AREA2=AREA-THUMB_SIZE
  VAR MAX=SIZE-MAX(PAGE-1,0)
  VAR THUMB_POS
  IF 0>=MAX THEN
   THUMB_POS=0
   THUMB_SIZE=AREA
  ELSE
   IF STATE==#GWIN_SCR_STATE_THUMB&&C_GW!=GW THEN
    GWIN_SET_VAR GW,#GWIN_SCR_V_STATE,#GWIN_SCR_STATE_NONE
    STATE=#GWIN_SCR_STATE_NONE
   ENDIF
   IF STATE==#GWIN_SCR_STATE_THUMB THEN
    IF HORIZ THEN
     THUMB_POS=MX-C_X-X1+GWIN_GET_VAR(GW,#GWIN_SCR_STATE_THUMB_OLD)
    ELSE
     THUMB_POS=MY-C_Y-Y1+GWIN_GET_VAR(GW,#GWIN_SCR_STATE_THUMB_OLD)
    ENDIF
    POS=MAX*THUMB_POS DIV AREA2
    THUMB_POS=AREA2*POS DIV MAX
   ENDIF
   POS=MIN(MAX(0,POS),SIZE-PAGE+1)
   GWIN_SET_VAR GW,#GWIN_SCR_V_POS,POS
   THUMB_POS=AREA2*POS DIV MAX
  ENDIF
  VAR THUMB_X,THUMB_W,THUMB_Y,THUMB_H
  IF HORIZ THEN
   THUMB_X=X1+BUTTON_H+THUMB_POS
   THUMB_Y=Y1
   THUMB_W=THUMB_SIZE
   THUMB_H=16
  ELSE
   THUMB_X=X1
   THUMB_Y=Y1+BUTTON_H+THUMB_POS
   THUMB_W=16
   THUMB_H=THUMB_SIZE
  ENDIF
  IF EVENT==#GWIN_EVENT_PAINT THEN
   GWIN_DRAW_BUTTON2 THUMB_X,THUMB_Y,THUMB_W,THUMB_H,#FALSE
  ELSEIF EVENT==#GWIN_EVENT_LDWN THEN
   IF MX>=THUMB_X&&MX<THUMB_X+THUMB_W&&MY>=THUMB_Y&&MY<THUMB_Y+THUMB_H THEN
    GWIN_SET_VAR GW,#GWIN_SCR_V_STATE,#GWIN_SCR_STATE_THUMB
    GWIN_SET_VAR GW,#GWIN_SCR_STATE_THUMB_OLD,THUMB_POS
    GWIN_SET_CAPTURE GW,#FALSE
   ENDIF
  ENDIF
 ENDIF
 IF EVENT==#GWIN_EVENT_MMOVE THEN
  GWIN_PAINT GW,#FALSE
 ENDIF
END
DEF GDEBUG_SELECT_FRAME I
 GDEBUG_CURRENT_FRAME=I
 GDEBUG_UPDATE_WINDOW #GDEBUG_UPDATE_BACKTRACE OR #GDEBUG_UPDATE_VAR OR #GDEBUG_UPDATE_SRC
END
DEF GDEBUG_DRAW_BACKTRACE GW,EVENT,X,Y,W,H
 VAR FH=16
 VAR SCRBAR_W=16
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GCLIP X,Y,X+W-1,Y+H-1
 ENDIF
 GDEBUG_DRAW_SUNKEN_EDGE EVENT,X,Y,W,H OUT X,Y,W,H
 VAR SY=Y
 VAR SCRBAR_GW=GWIN_FIND(GW,"SCRBAR")
 VAR LIST_H=GDEBUG_SYS_FONT_SIZE+4
 IF SCRBAR_GW THEN
  GWIN_MOVERESIZE SCRBAR_GW,X+W-1-SCRBAR_W+1-GWIN_GET_CX(GW),Y-GWIN_GET_CY(GW),SCRBAR_W,H
  GWIN_SCR_SET SCRBAR_GW,H-LIST_H,,
 ENDIF
 DEC W,SCRBAR_W
 VAR X2=X+W-1
 VAR Y2=Y+H-1
 VAR BACK_COLOR=RGB(0,0,0)
 VAR FONT_TYPE=GDEBUG_SYS_FONT_SIZE,FONT_SCALE_X=1,FONT_SCALE_Y=1
 DIM LIST$[]=[GDEBUG_RES$(#GDBG_BACKTRACE_SLOT),GDEBUG_RES$(#GDBG_BACKTRACE_LINE),GDEBUG_RES$(#GDBG_BACKTRACE_NAME)]
 DIM LIST_W%[]=[60,50,W-50-60]
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GCLIP X,Y,X2,Y2
  GFILL X,Y,X2,Y2,BACK_COLOR
  GDEBUG_DRAW_LIST_HEADER X,Y,W,LIST_H,LIST$,LIST_W%
 ENDIF
 INC Y,LIST_H
 DEC H,LIST_H
 VAR SLOT,LINE,INFO$
 VM_BACKTRACE !#FALSE OUT SLOT,LINE,INFO$
 VAR I
 VAR SCRBAR_POS
 GWIN_SCR_GET SCRBAR_GW OUT ,,SCRBAR_POS
 VAR OFF_Y=SCRBAR_POS MOD GDEBUG_SYS_FONT_SIZE
 SY=Y-OFF_Y
 VAR CURRENT_FRAME=GDEBUG_CURRENT_FRAME
 GWIN_SCR_SET SCRBAR_GW,,LEN(SLOT)*GDEBUG_SYS_FONT_SIZE,
 GCLIP X,Y,X+W-1,Y+H-1
 Y=SY
 FOR I=SCRBAR_POS DIV GDEBUG_SYS_FONT_SIZE TO LAST(SLOT)
  IF EVENT==#GWIN_EVENT_PAINT THEN
   IF I==CURRENT_FRAME THEN
    GFILL X,Y,X2,Y+FONT_TYPE*FONT_SCALE_Y,RGB(0,0,128)
   ENDIF
  ELSEIF EVENT==#GWIN_EVENT_LDWN THEN
   IF Y<=GWIN_GET_MOUSE_Y(GW)&&Y+FONT_TYPE*FONT_SCALE_Y>GWIN_GET_MOUSE_Y(GW)THEN
    GDEBUG_SELECT_FRAME I
    GWIN_PAINT GW,#FALSE
   ENDIF
  ENDIF
  INC Y,FONT_TYPE*FONT_SCALE_Y
 NEXT
 Y=SY
 VAR LINE_X=X+LIST_W%[0]
 VAR NAME_X=LINE_X+LIST_W%[1]
 FOR I=SCRBAR_POS DIV GDEBUG_SYS_FONT_SIZE TO LAST(SLOT)
  IF EVENT==#GWIN_EVENT_PAINT THEN
   GPUTCHR_FONT GDEBUG_SYS_FONT,X,Y,#FALSE,STR$(SLOT[I]),RGB(255,255,255)
   GPUTCHR_FONT GDEBUG_SYS_FONT,LINE_X,Y,#FALSE,STR$(LINE[I]),RGB(255,255,255)
   GPUTCHR_FONT GDEBUG_SYS_FONT,NAME_X,Y,#FALSE,INFO$[I],RGB(255,255,255)
  ENDIF
  INC Y,FONT_TYPE*FONT_SCALE_Y
 NEXT
END
DEF GDEBUG_ARRAY$(V)
 VAR I
 VAR R$=""
 PUSH R$,"["
 FOR I=0TO LAST(V)
  IF LEN(R$)>=50 THEN PUSH R$,"…]":RETURN R$
  IF I THEN
   PUSH R$,","
  ENDIF
  CASE TYPEOF(V[I])
  WHEN #T_STR
   PUSH R$,VSLOT_TEST_ESCAPE$(V[I])
  WHEN #T_INT
   PUSH R$,STR$(V[I])
  WHEN #T_REAL
   PUSH R$,STR$(V[I])
  ENDCASE
 NEXT
 PUSH R$,"]"
 RETURN R$
END
DEF GDEBUG_MOUSE_VAR MX,MY,MW,MBTN,X,Y,W,H
END
DEF GDEBUG_DRAW_LIST_HEADER X,Y,W,H,LIST$[],LIST_W[]
 VAR I
 VAR Y2=Y+H-1
 FOR I=0TO LAST(LIST_W)
  VAR X2=X+LIST_W[I]-1
  GLINE X,Y,X,Y2-1,RGB(255,255,255)
  GLINE X,Y,X2-1,Y,RGB(255,255,255)
  GLINE X,Y2,X2,Y2,RGB(0,0,0)
  GLINE X2,Y,X2,Y2,RGB(0,0,0)
  GLINE X+1,Y2-1,X2-1,Y2-1,RGB(128,128,128)
  GLINE X2-1,Y+1,X2-1,Y2-1,RGB(128,128,128)
  GFILL X+1,Y+1,X2-2,Y2-2,RGB(192,192,192)
  GPUTCHR_FONT GDEBUG_SYS_FONT,X+2,Y,#FALSE,LIST$[I],RGB(0,0,0)
  X=X2+1
 NEXT
END
ENUM #GDEBUG_VAR_TAB_LOCALS,#GDEBUG_VAR_TAB_GLOBALS,#GDEBUG_VAR_TAB_SLOT0,#GDEBUG_VAR_TAB_SLOT1,#GDEBUG_VAR_TAB_SLOT2,#GDEBUG_VAR_TAB_SLOT3,#GDEBUG_VAR_TAB_CONSTS,#GDEBUG_VAR_TAB_C0,#GDEBUG_VAR_TAB_C1,#GDEBUG_VAR_TAB_C2,#GDEBUG_VAR_TAB_C3
'FIXME:GLOBAL
VAR GDEBUG_VAR_TAB
DEF GDEBUG_VAR_GET_VAR TAB,FUNC,BP,IDX OUT V
 CASE TAB
 WHEN #GDEBUG_VAR_TAB_LOCALS
 WHEN #GDEBUG_VAR_TAB_GLOBALS
  V=VMDBG_GET_VAR(FUNC,BP,IDX)
 WHEN #GDEBUG_VAR_TAB_SLOT0
  V=VMDBG_GET_SLOT_VAR(0,IDX)
 WHEN #GDEBUG_VAR_TAB_SLOT1
  V=VMDBG_GET_SLOT_VAR(1,IDX)
 WHEN #GDEBUG_VAR_TAB_SLOT2
  V=VMDBG_GET_SLOT_VAR(2,IDX)
 WHEN #GDEBUG_VAR_TAB_SLOT3
  V=VMDBG_GET_SLOT_VAR(3,IDX)
 WHEN #GDEBUG_VAR_TAB_CONSTS
  V=VMDBG_GET_SLOT_CONST(VM_GET_SLOT(),IDX)
 WHEN #GDEBUG_VAR_TAB_C0
  V=VMDBG_GET_SLOT_CONST(0,IDX)
 WHEN #GDEBUG_VAR_TAB_C1
  V=VMDBG_GET_SLOT_CONST(1,IDX)
 WHEN #GDEBUG_VAR_TAB_C2
  V=VMDBG_GET_SLOT_CONST(2,IDX)
 WHEN #GDEBUG_VAR_TAB_C3
  V=VMDBG_GET_SLOT_CONST(3,IDX)
 ENDCASE
END
DEF GDEBUG_VAR_SET_VAR TAB,FUNC,BP,IDX,V
 CASE TAB
 WHEN #GDEBUG_VAR_TAB_LOCALS
 WHEN #GDEBUG_VAR_TAB_GLOBALS
  VMDBG_SET_VAR FUNC,BP,IDX,V
 WHEN #GDEBUG_VAR_TAB_SLOT0
  VMDBG_SET_SLOT_VAR 0,IDX,V
 WHEN #GDEBUG_VAR_TAB_SLOT1
  VMDBG_SET_SLOT_VAR 1,IDX,V
 WHEN #GDEBUG_VAR_TAB_SLOT2
  VMDBG_SET_SLOT_VAR 2,IDX,V
 WHEN #GDEBUG_VAR_TAB_SLOT3
  VMDBG_SET_SLOT_VAR 3,IDX,V
 ENDCASE
END
DEF GDEBUG_GET_EXPR_LISTBOX_H EVENT,X,Y,W,H,LIST_W% OUT LIST_H
 LIST_H=GDEBUG_SYS_FONT_SIZE+4
END
DEF GDEBUG_DRAW_EXPR_LISTBOX EVENT,X,Y,W,H,LIST_W%,LIST_H
 DIM LIST$[]=[GDEBUG_RES$(#GDBG_VARIABLE_NAME),GDEBUG_RES$(#GDBG_VARIABLE_VALUE),GDEBUG_RES$(#GDBG_VARIABLE_TYPE)]
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GDEBUG_DRAW_LIST_HEADER X,Y,W,LIST_H,LIST$,LIST_W%
 ENDIF
END
DEF GDEBUG_ESCAPE_STR_EXPR$(S$)
 RETURN RIR_DATA_ESCAPE$(S$)
END
ENUM #GDEBUG_EXPR_LIST_NONE,#GDEBUG_EXPR_LIST_DETAIL
CONST #GDEBUG_EXPR_LIST_STAT_SIZE=3
CONST #GDEBUG_EXPR_LIST_STAT_TXTBOX=1
CONST #GDEBUG_EXPR_LIST_STAT_HEAD=3
CONST #GDEBUG_EXPR_LIST_STAT_HEAD_TXTBOX=0
CONST #GDEBUG_EXPR_LIST_STAT_HEAD_SELECTED=1
'ショウライテキにはTREEVIEWテキなモノをドウニュウしていいカンじにしてコウソクカしたい
DEF GDEBUG_DRAW_EXPR_LISTBOX_NEXT GW,EVENT,LIST_W%[],X,SY,IN_Y,W,H,LS$,V,BACK_COLOR,STAT[],IN_INDEX,INDENT,A1,A2,A3,A4,INDEX_BASE,EDITABLE OUT Y,INDEX
 VAR LIST_H=GDEBUG_SYS_FONT_SIZE+4
 Y=IN_Y
 INDEX=IN_INDEX
 VAR ITEM_H=GDEBUG_SYS_FONT_SIZE+2
 IF INDEX<=-1 THEN RETURN
 VAR VALUE_X=X+LIST_W%[0]
 VAR NAME_X2=VALUE_X-1
 VAR TYPE_X=X+LIST_W%[0]+LIST_W%[1]
 VAR VALUE_X2=TYPE_X-1
 VAR TYPE_X2=X+LIST_W%[0]+LIST_W%[1]+LIST_W%[2]-1
 VAR Y2=SY+H-1
' IF Y>Y2 THEN INDEX=-1:RETURN
 IF LEN(STAT)<=INDEX*#GDEBUG_EXPR_LIST_STAT_SIZE+#GDEBUG_EXPR_LIST_STAT_HEAD THEN
  RESIZE STAT,(INDEX+1)*#GDEBUG_EXPR_LIST_STAT_SIZE+#GDEBUG_EXPR_LIST_STAT_HEAD
 ENDIF
 VAR STAT1_INDEX=INDEX*#GDEBUG_EXPR_LIST_STAT_SIZE+#GDEBUG_EXPR_LIST_STAT_HEAD
 VAR STAT1=STAT[STAT1_INDEX]
 VAR STAT2_INDEX=STAT1_INDEX+#GDEBUG_EXPR_LIST_STAT_TXTBOX
 VAR STAT2=STAT[STAT2_INDEX]
 IF EVENT==#GWIN_EVENT_NOTIF THEN
  VAR TXTBOX=STAT2
  IF (A1==#GWIN_NOTIF_ENTER||A1==#GWIN_NOTIF_LOST_FOCUS)&&A2==TXTBOX THEN
   VAR TXT$=GWIN_GET_NAME$(TXTBOX)
   VAR EVAL=GDEBUG_EVAL(TXT$)
   GWIN_DELETE TXTBOX
   STAT[#GDEBUG_EXPR_LIST_STAT_HEAD_TXTBOX]=0
   STAT[STAT2_INDEX]=0
   INDEX=-2
   Y=EVAL
   RETURN
  ENDIF
 ENDIF
 IF EVENT==#GWIN_EVENT_RUP THEN
  IF Y<=GWIN_GET_MOUSE_Y(GW)&&Y+ITEM_H>GWIN_GET_MOUSE_Y(GW)THEN
   GMENU_SET_FLG GDEBUG_VAR_CMENU,#GDBG_VAR_CMENU_OPEN_EVAL_WINDOW,#GMENU_FLG_GRAYED
   GMENU_SET_FLG GDEBUG_VAR_CMENU,#GDBG_VAR_CMENU_EDIT,#GMENU_FLG_GRAYED*!EDITABLE
   GWIN_SHOW_CTX_MENU GW,GDEBUG_VAR_CMENU
   INDEX=-1
   RETURN
  ENDIF
 ENDIF
 VAR DETAILS_BTN_W=8
 IF EVENT==#GWIN_EVENT_LDWN||EVENT==#GWIN_EVENT_RDWN THEN
  IF Y<=GWIN_GET_MOUSE_Y(GW)&&Y+ITEM_H>GWIN_GET_MOUSE_Y(GW)THEN
   IF GWIN_GET_MOUSE_X(GW)>=X&&GWIN_GET_MOUSE_X(GW)<X+DETAILS_BTN_W THEN
    CASE TYPEOF(V)
    WHEN #T_INTARRAY
    WHEN #T_REALARRAY
    WHEN #T_STRARRAY
     'STATE
     VAR INS_LEN=MIN(LEN(V),100)'FIXME
     VAR INS_SIZE=INS_LEN*#GDEBUG_EXPR_LIST_STAT_SIZE+#GDEBUG_EXPR_LIST_STAT_HEAD
     VAR INS_BASE=(INDEX+1)*#GDEBUG_EXPR_LIST_STAT_SIZE+#GDEBUG_EXPR_LIST_STAT_HEAD
     IF STAT1==#GDEBUG_EXPR_LIST_DETAIL THEN
      STAT[INDEX*#GDEBUG_EXPR_LIST_STAT_SIZE+#GDEBUG_EXPR_LIST_STAT_HEAD]=#GDEBUG_EXPR_LIST_NONE
      'FIXME:NEST (IRAN)
      REMOVE STAT,INS_BASE,INS_SIZE
     ELSE
      INSERT STAT,INS_BASE,INS_SIZE
      STAT[INDEX*#GDEBUG_EXPR_LIST_STAT_SIZE+#GDEBUG_EXPR_LIST_STAT_HEAD]=#GDEBUG_EXPR_LIST_DETAIL
     ENDIF
     INDEX=-1
     GWIN_PAINT GW,#FALSE
     RETURN
    ENDCASE
   ENDIF
   STAT[#GDEBUG_EXPR_LIST_STAT_HEAD_SELECTED]=STAT1_INDEX
   INDEX=-1
   GWIN_PAINT GW,#FALSE
   RETURN
  ENDIF
 ENDIF
 IF EVENT==#GWIN_EVENT_LDBL THEN
  IF Y<=GWIN_GET_MOUSE_Y(GW)&&Y+ITEM_H>GWIN_GET_MOUSE_Y(GW)THEN
   IF!EDITABLE THEN
    INDEX=-1
    RETURN
   ENDIF
   CASE TYPEOF(V)
   WHEN #T_DEFAULT
    VAR V$=""
   WHEN #T_INT
   WHEN #T_REAL
    V$=STR$(V)
   WHEN #T_STR
    V$=GDEBUG_ESCAPE_STR_EXPR$(V)
   WHEN #T_INTARRAY
   WHEN #T_REALARRAY
   WHEN #T_STRARRAY
   ENDCASE
   IF STAT[#GDEBUG_EXPR_LIST_STAT_HEAD_TXTBOX] THEN
    GWIN_DELETE STAT[#GDEBUG_EXPR_LIST_STAT_HEAD_TXTBOX]
   ENDIF
   TXTBOX=GWIN_NEW(GW,VALUE_X-GWIN_GET_CX(GW),Y-GWIN_GET_CY(GW),LIST_W%[1],ITEM_H+2,V$,"GWIN_TEXTBOX_EVENT")
   GWIN_FOCUS TXTBOX
   STAT[STAT2_INDEX]=TXTBOX
   STAT[#GDEBUG_EXPR_LIST_STAT_HEAD_TXTBOX]=TXTBOX
   GWIN_TEXTBOX_SELALL TXTBOX
   GWIN_PAINT TXTBOX,#FALSE
   INDEX=-1
   RETURN
  ENDIF
 ENDIF
 VAR DRAWABLE=Y>=SY&&Y<=Y2&&EVENT==#GWIN_EVENT_PAINT
 VAR BACK_COLOR2=BACK_COLOR
 IF DRAWABLE THEN
  IF STAT[#GDEBUG_EXPR_LIST_STAT_HEAD_SELECTED]==STAT1_INDEX THEN
   GCLIP
   BACK_COLOR2=RGB(0,0,128)
   GFILL X+INDENT,MIN(MAX(SY,Y),Y2),X+W-1,MIN(MAX(SY,Y+ITEM_H),Y2),BACK_COLOR2
  ENDIF
  GCLIP X,MIN(MAX(SY,Y),Y2),NAME_X2,Y2
  IF TYPEOF(V)>=#T_INTARRAY&&TYPEOF(V)<=#T_STRARRAY THEN
   IF STAT1==#GDEBUG_EXPR_LIST_DETAIL THEN
    GPUTCHR X+INDENT,Y+(12-8)DIV 2+1,"",8,1,1,RGB(255,255,255),#G_NORMAL2
   ELSE
    GPUTCHR X+INDENT,Y+(12-8)DIV 2+1,"",8,1,1,RGB(255,255,255),#G_NORMAL2
   ENDIF
  ENDIF
  IF TYPEOF(LS$)==#T_INTARRAY THEN
   VAR VOID=GDEBUG_DRAW_ARRAY(X+DETAILS_BTN_W+INDENT,Y,LS$,LIST_W%[0])
  ELSEIF LEN(LS$)&&LS$[0]=="#"THEN
   GPUTCHR_FONT GDEBUG_SYS_FONT,X+DETAILS_BTN_W+INDENT,Y,#FALSE,LS$,RGB(176,208,208)
  ELSE
   GPUTCHR_FONT GDEBUG_SYS_FONT,X+DETAILS_BTN_W+INDENT,Y,#FALSE,LS$,RGB(255,255,255)
  ENDIF
  VAR TS$
  VAR TYPE$
  VAR C=RGB(255,255,255)
  CASE TYPEOF(V)
  WHEN #T_DEFAULT
   TS$="EMPTY"
   TYPE$="DEFAULT"
  WHEN #T_REAL
   TS$=STR$(V)
   TYPE$="REAL"
   C=RGB(240,64,144)
  WHEN #T_INT
   TS$=STR$(V)
   TYPE$="INT"
   C=RGB(240,64,144)
  WHEN #T_STR
   TS$=VSLOT_TEST_ESCAPE$(MID$(V,0,100))
   TYPE$="STR"
   C=RGB(96,128,240)
  WHEN #T_INTARRAY
   TYPE$="INT["+","*(DIM(V)-1)+"]"
  WHEN #T_REALARRAY
   TYPE$="REAL["+","*(DIM(V)-1)+"]"
  WHEN #T_STRARRAY
   TYPE$="STR["+","*(DIM(V)-1)+"]"
  ENDCASE
  GCLIP TYPE_X,MIN(MAX(SY,Y),Y2),TYPE_X2,Y2
  GPUTCHR_FONT GDEBUG_SYS_FONT,TYPE_X,Y,#FALSE,TYPE$,RGB(176,208,208)'RGB(0,192,240)
  GCLIP VALUE_X,MIN(MAX(SY,Y),Y2),VALUE_X2,Y2
 ENDIF
 VAR TXT_W=0
 IF TYPEOF(V)==#T_INTARRAY||TYPEOF(V)==#T_REALARRAY||TYPEOF(V)==#T_STRARRAY THEN
  IF STAT1==#GDEBUG_EXPR_LIST_DETAIL THEN
   VAR I,J,K,L
   VAR INDENT_W=8
   VAR INDEX2=INDEX+2
   INC Y,ITEM_H
   VAR INDEX_ARY=ARRAY%(DIM(V))
   FOR I=0TO LAST(V)
    IF I>=100 THEN BREAK'FIXME
    GDEBUG_DRAW_EXPR_LISTBOX_NEXT GW,EVENT,LIST_W%,X,SY,Y,W,H,INDEX_ARY,V[I],BACK_COLOR,STAT,INDEX2,INDENT+8,A1,A2,A3,A4,(INDEX+1)*#GDEBUG_EXPR_LIST_STAT_SIZE+#GDEBUG_EXPR_LIST_STAT_HEAD,#TRUE OUT Y,INDEX2
    IF INDEX2<0 THEN
     IF INDEX2==-2 THEN
      V[I]=Y
      GWIN_PAINT GW,#FALSE
     ENDIF
     BREAK
    ENDIF
    FOR J=DIM(V)-1 TO 0 STEP -1
     INC INDEX_ARY[J]
     IF INDEX_ARY[J]>=DIM(V,J) THEN
      INDEX_ARY[J]=0
     ELSE
      BREAK
     ENDIF
    NEXT
   NEXT
   INDEX=INDEX2
   DEC Y,ITEM_H
   IF INDEX2<0 THEN RETURN
  ELSEIF DRAWABLE THEN
   TXT_W=GDEBUG_DRAW_ARRAY(VALUE_X,Y,V,LIST_W%[1])
  ENDIF
 ELSEIF DRAWABLE THEN
  TXT_W=GPUTCHR_FONT_W(GDEBUG_SYS_FONT,VALUE_X,Y,#FALSE,TS$,C)
 ENDIF
 IF TXT_W>=LIST_W%[1]&&DRAWABLE THEN
  VAR DOTDOT_W=FONT_CALC_WIDTH(GDEBUG_SYS_FONT,"…")
  GFILL TYPE_X-DOTDOT_W,Y,VALUE_X2,Y+ITEM_H,BACK_COLOR2
  GPUTCHR_FONT GDEBUG_SYS_FONT,TYPE_X-DOTDOT_W,Y,#FALSE,"…",RGB(255,255,255)
 ENDIF
 @CONTINUE
 INC Y,ITEM_H
 INC INDEX
END
DIM GDEBUG_VAR_STAT[]
DEF GDEBUG_DRAW_VAR GW,EVENT,X,Y,W,H,A1,A2,A3,A4
 VAR FH=16
 VAR TABH=20
 VAR LIST_H=GDEBUG_SYS_FONT_SIZE+4
 VAR SCRBAR_W=16
 GCLIP X,Y,X+W-1,Y+H-1
 VAR TABY=Y+H-TABH
 VAR TABX=X
 VAR TABW=W
 GDEBUG_DRAW_SUNKEN_EDGE EVENT,X,Y,W,H-TABH OUT X,Y,W,H
 VAR SW=W
 INC H,TABH
 VAR SCRBAR_GW=GWIN_FIND(GW,"SCRBAR")
 IF SCRBAR_GW THEN
  GWIN_MOVERESIZE SCRBAR_GW,X+W-1-SCRBAR_W+1-GWIN_GET_CX(GW),Y-GWIN_GET_CY(GW),SCRBAR_W,H-TABH
 ENDIF
 DEC W,SCRBAR_W
 VAR X2=X+W-1
 VAR Y2=Y+H-1-TABH
 GCLIP X,Y,X2,Y2
 VAR BACK_COLOR=RGB(0,0,0)
 VAR FONT_TYPE=GDEBUG_SYS_FONT_SIZE,FONT_SCALE_X=1,FONT_SCALE_Y=1
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GFILL X,Y,X2,Y2,BACK_COLOR
 ENDIF
 VAR VNAME$,VIDX
 VAR CURRENT_FRAME=GDEBUG_CURRENT_FRAME
 VAR BP,FUNC
 VAR TAB=GWIN_GET_VAR(GW,#GWIN_VAR_V_TAB)
 CASE TAB
 WHEN #GDEBUG_VAR_TAB_LOCALS
  VMDBG_FIND_FRAME CURRENT_FRAME OUT FUNC,BP,,
  GWIN_SET_VAR GW,#GWIN_VAR_V_FUNC,FUNC
  GWIN_SET_VAR GW,#GWIN_VAR_V_BP,BP
  VMDBG_GET_VAR_LIST FUNC,BP OUT VNAME$,VIDX
 WHEN #GDEBUG_VAR_TAB_GLOBALS
  VMDBG_GET_VAR_LIST 0,0 OUT VNAME$,VIDX
 WHEN #GDEBUG_VAR_TAB_SLOT0
  VMDBG_GET_SLOT_VAR_LIST 0 OUT VNAME$,VIDX
 WHEN #GDEBUG_VAR_TAB_SLOT1
  VMDBG_GET_SLOT_VAR_LIST 1 OUT VNAME$,VIDX
 WHEN #GDEBUG_VAR_TAB_SLOT2
  VMDBG_GET_SLOT_VAR_LIST 2 OUT VNAME$,VIDX
 WHEN #GDEBUG_VAR_TAB_SLOT3
  VMDBG_GET_SLOT_VAR_LIST 3 OUT VNAME$,VIDX
 WHEN #GDEBUG_VAR_TAB_CONSTS
  VMDBG_GET_SLOT_CONST_LIST VM_GET_SLOT() OUT VNAME$,VIDX
 WHEN #GDEBUG_VAR_TAB_C0
  VMDBG_GET_SLOT_CONST_LIST 0 OUT VNAME$,VIDX
 WHEN #GDEBUG_VAR_TAB_C1
  VMDBG_GET_SLOT_CONST_LIST 1 OUT VNAME$,VIDX
 WHEN #GDEBUG_VAR_TAB_C2
  VMDBG_GET_SLOT_CONST_LIST 2 OUT VNAME$,VIDX
 WHEN #GDEBUG_VAR_TAB_C3
  VMDBG_GET_SLOT_CONST_LIST 3 OUT VNAME$,VIDX
 ENDCASE

 VAR SCRBAR=GWIN_FIND(GW,"SCRBAR")
 VAR MX=GWIN_GET_MOUSE_X(GW)
 VAR MY=GWIN_GET_MOUSE_Y(GW)
 VAR OVER=MX>=X&&MX<X+W&&MY>=Y&&MY<Y+H
 IF (EVENT==#GWIN_EVENT_LDWN||EVENT==#GWIN_EVENT_RDWN||EVENT==#GWIN_EVENT_LDWN||EVENT==#GWIN_EVENT_RUP)&&!OVER THEN
  RETURN
 ENDIF
 IF EVENT==#GWIN_EVENT_WHEEL THEN
  VAR POS
  VAR DELTA=A1
  GWIN_SCR_GET SCRBAR OUT ,,POS
  GWIN_SCR_SET SCRBAR,,,POS+(32*-DELTA DIV 120)
  GWIN_PAINT GW,#FALSE
  RETURN
 ENDIF
 DIM LIST_W%[]=[100,W-100-70,70]
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GFILL X,Y,X+W-1,Y+H-1,BACK_COLOR
 ENDIF
 VAR SCRBAR_POS
 GWIN_SCR_GET SCRBAR OUT ,,SCRBAR_POS
 GDEBUG_GET_EXPR_LISTBOX_H EVENT,X,Y,W,H,LIST_W% OUT LIST_H
 VAR LIST_Y=Y+LIST_H-SCRBAR_POS
 VAR PAGE_SIZE=H-LIST_H-TABH
 VAR NAME$=GWIN_GET_VAR$(GW,0)
 VAR INDEX
 VAR SY=LIST_Y
 IF!TYPEOF(GDEBUG_VAR_STAT)THEN GDEBUG_VAR_STAT=ARRAY%(0)
 VAR STAT=GDEBUG_VAR_STAT'ARRAY%(0)
 VAR V,I
 FOR I=0 TO LAST(VNAME$)
  V=GDEBUG_VAR_GET_VAR(TAB,FUNC,BP,VIDX[I])
  GDEBUG_DRAW_EXPR_LISTBOX_NEXT GW,EVENT,LIST_W%,X,Y,LIST_Y,W,PAGE_SIZE+LIST_H,VNAME$[I],V,BACK_COLOR,STAT,INDEX,0,A1,A2,A3,A4,0,#TRUE OUT LIST_Y,INDEX
 NEXT
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GCLIP X,Y,X+W-1,Y+H-1
 ENDIF
 GDEBUG_DRAW_EXPR_LISTBOX EVENT,X,Y,W,H,LIST_W%,LIST_H
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GWIN_SCR_SET SCRBAR,PAGE_SIZE,LIST_Y-SY+1,
 ENDIF

 DIM TABS$[]=[GDEBUG_RES$(#GDBG_VARIABLE_LOCALS),GDEBUG_RES$(#GDBG_VARIABLE_GLOBALS),"0","1","2","3",GDEBUG_RES$(#GDBG_VARIABLE_CONSTS),"C0","C1","C2","C3"]
 GCLIP TABX,TABY-1,TABX+TABW-1,TABY+TABH-1
 VAR GDEBUG_VAR_TAB_SEL
 GDEBUG_DRAW_TABS GW,EVENT,TABX,TABY,TABW,TABH,TABS$,TAB,#TRUE, OUT GDEBUG_VAR_TAB_SEL
 IF TYPEOF(GDEBUG_VAR_TAB_SEL)!=#T_DEFAULT THEN
  GWIN_SET_VAR GW,#GWIN_VAR_V_TAB,GDEBUG_VAR_TAB_SEL
  GWIN_PAINT GW,#FALSE
 ENDIF
END
DEF GDEBUG_DRAW_ARRAY(X,Y,V,MAX_W)
 VAR SX=X
 INC X,GPUTCHR_FONT_W(GDEBUG_SYS_FONT,X,Y,#FALSE,"[",RGB(255,255,255))
 IF X-SX>MAX_W THEN RETURN X-SX
 VAR I
 FOR I=0TO LAST(V)
   IF I THEN
    INC X,GPUTCHR_FONT_W(GDEBUG_SYS_FONT,X,Y,#FALSE,",",RGB(255,255,255))
   ENDIF
   IF TYPEOF(V)==#T_STRARRAY THEN
    INC X,GPUTCHR_FONT_W(GDEBUG_SYS_FONT,X,Y,#FALSE,VSLOT_TEST_ESCAPE$(MID$(V[I],0,100)),RGB(96,128,240))
   ELSE
    INC X,GPUTCHR_FONT_W(GDEBUG_SYS_FONT,X,Y,#FALSE,STR$(V[I]),RGB(240,64,144))
   ENDIF
   IF X-SX>MAX_W THEN RETURN X-SX
 NEXT
 INC X,GPUTCHR_FONT_W(GDEBUG_SYS_FONT,X,Y,#FALSE,"]",RGB(255,255,255))
 RETURN X-SX
END
VAR GDEBUG_EVAL_RESULT
VAR GDEBUG_EVAL_WINDOW
ENUM #GDEBUG_EVAL_V_TXTBOX,#GDEBUG_EVAL_V_BTN
DEF GDEBUG_NEW_EVAL_WINDOW(EXPR$)
 VAR W=300
 VAR H=400
 IF!GDEBUG_EVAL_WINDOW THEN
  GDEBUG_EVAL_WINDOW=GWIN_NEW3(GWIN_ROOT,(GDEBUG_WIDTH-W)DIV 2,(GDEBUG_HEIGHT-H)DIV 2,W,H,GDEBUG_RES$(#GDBG_EVAL),"GWIN_EVAL_EVENT",#GWIN_FLG_RESIZE,EXPR$,0,0,0)
 ELSE
  GWIN_SET_NAME GWIN_GET_VAR(GDEBUG_EVAL_WINDOW,#GDEBUG_EVAL_V_TXTBOX),EXPR$
  GDEBUG_EVAL_WIN_EVAL GDEBUG_EVAL_WINDOW,EXPR$
 ENDIF
 GWIN_FRONT GDEBUG_EVAL_WINDOW
 GWIN_FOCUS GWIN_FIND_BY_EVENT(GDEBUG_EVAL_WINDOW,"GWIN_TEXTBOX_EVENT")
END
DIM GDEBUG_EVAL_STAT[]
DEF GDEBUG_EVAL_WIN_EVAL GW,EXPR$
 GDEBUG_EVAL_RESULT=GDEBUG_EVAL(EXPR$)
 GWIN_SET_VAR$ GW,0,EXPR$
 GDEBUG_EVAL_RESULT=GDEBUG_EVAL_RESULT
 GDEBUG_EVAL_STAT=ARRAY%(0)
 GDEBUG_UPDATE_WINDOW #GDEBUG_UPDATE_BACKTRACE OR #GDEBUG_UPDATE_VAR OR #GDEBUG_UPDATE_SRC
END
DEF GWIN_EVAL_EVENT GW,EVENT,A1,A2,A3,A4
 VAR MARGIN_LEFT=12
 VAR MARGIN_RIGHT=15
 VAR MARGIN_LABEL_1_TOP=10
 VAR MARGIN_TXTBOX_TOP=26
 VAR MARGIN_LABEL_2_TOP=52
 VAR MARGIN_BTN_1_RIGHT=11
 VAR MARGIN_BTN_1_TOP=MARGIN_TXTBOX_TOP
 VAR MARGIN_LIST_TOP=MARGIN_LABEL_2_TOP+MARGIN_TXTBOX_TOP-MARGIN_LABEL_1_TOP
 VAR MARGIN_LIST_BOTTOM=10
 CASE EVENT
 WHEN #GWIN_EVENT_DELETE
  GDEBUG_EVAL_WINDOW=0
  GWIN_FOCUS GDEBUG_PRG_GWIN
 WHEN #GWIN_EVENT_NEW
  'A1:EXPR$
  GWIN_SET_MIN_SIZE GW,300,200
  GDEBUG_EVAL_WIN_EVAL GW,A1
  VAR BTN_1=GWIN_NEW(GW,MARGIN_BTN_1_RIGHT,MARGIN_BTN_1_TOP,88,21,GDEBUG_RES$(#GDBG_EVAL_REEVAL),"GWIN_BUTTON_EVENT")
  VAR LABEL_1=GWIN_NEW(GW,MARGIN_LEFT,MARGIN_LABEL_1_TOP,200,MARGIN_TXTBOX_TOP-MARGIN_LABEL_1_TOP,GDEBUG_RES$(#GDBG_EVAL_EXPR),"GWIN_LABEL_EVENT")
  VAR LABEL_2=GWIN_NEW(GW,MARGIN_LEFT,MARGIN_LABEL_2_TOP,200,MARGIN_TXTBOX_TOP-MARGIN_LABEL_1_TOP,GDEBUG_RES$(#GDBG_EVAL_VALUE),"GWIN_LABEL_EVENT")
  VAR TXTBOX=GWIN_NEW(GW,0,0,0,0,A1,"GWIN_TEXTBOX_EVENT")
  GWIN_SET_VAR GW,#GDEBUG_EVAL_V_TXTBOX,TXTBOX
  GWIN_SET_VAR GW,#GDEBUG_EVAL_V_BTN,BTN_1
  VAR SCRBAR=GWIN_NEW(GW,0,0,0,0,"SCRBAR","GWIN_SCR_EVENT")
  GWIN_FOCUS TXTBOX
 WHEN #GWIN_EVENT_NOTIF
  IF A1==#GWIN_NOTIF_BUTTON_PUSHED||A1==#GWIN_NOTIF_ENTER THEN
   TXTBOX=GWIN_GET_VAR(GW,#GDEBUG_EVAL_V_TXTBOX)
   BTN_1=GWIN_GET_VAR(GW,#GDEBUG_EVAL_V_BTN)
   IF A2==TXTBOX||A2==BTN_1 THEN
    GDEBUG_EVAL_WIN_EVAL GW,GWIN_GET_NAME$(TXTBOX)
    GWIN_PAINT GW,#FALSE
    RETURN
   ENDIF
  ENDIF
  VAR X=GWIN_GET_CX(GW),Y=GWIN_GET_CY(GW)
  VAR W=GWIN_GET_CW(GW),H=GWIN_GET_CH(GW)
  GWIN_DRAW_EVAL GW,EVENT,X+MARGIN_LEFT,Y+MARGIN_LIST_TOP,W-MARGIN_LEFT-MARGIN_RIGHT+4,H-MARGIN_LIST_BOTTOM-MARGIN_LIST_TOP,A1,A2,A3,A4'FIXME:+4
 WHEN #GWIN_EVENT_LDWN
 WHEN #GWIN_EVENT_PAINT
  X=GWIN_GET_CX(GW)
  Y=GWIN_GET_CY(GW)
  W=GWIN_GET_CW(GW)
  H=GWIN_GET_CH(GW)
  TXTBOX=GWIN_GET_VAR(GW,#GDEBUG_EVAL_V_TXTBOX)
  BTN_1=GWIN_FIND_BY_EVENT(GW,"GWIN_BUTTON_EVENT")
  GWIN_MOVE BTN_1,W-MARGIN_BTN_1_RIGHT-GWIN_GET_W(BTN_1),MARGIN_BTN_1_TOP
  GWIN_MOVERESIZE TXTBOX,MARGIN_LEFT,MARGIN_TXTBOX_TOP,W-MARGIN_LEFT-MARGIN_RIGHT-GWIN_GET_W(BTN_1),20+1
  IF EVENT==#GWIN_EVENT_PAINT THEN
   GCLS RGB(192,192,192)
  ENDIF
  GWIN_DRAW_EVAL GW,EVENT,X+MARGIN_LEFT,Y+MARGIN_LIST_TOP,W-MARGIN_LEFT-MARGIN_RIGHT+4,H-MARGIN_LIST_BOTTOM-MARGIN_LIST_TOP,A1,A2,A3,A4'FIXME:+4
 WHEN #GWIN_EVENT_LDBL
 WHEN #GWIN_EVENT_RUP
 WHEN #GWIN_EVENT_RDWN
 WHEN #GWIN_EVENT_WHEEL
  X=GWIN_GET_CX(GW)
  Y=GWIN_GET_CY(GW)
  W=GWIN_GET_CW(GW)
  H=GWIN_GET_CH(GW)
  GWIN_DRAW_EVAL GW,EVENT,X+MARGIN_LEFT,Y+MARGIN_LIST_TOP,W-MARGIN_LEFT-MARGIN_RIGHT+4,H-MARGIN_LIST_BOTTOM-MARGIN_LIST_TOP,A1,A2,A3,A4'FIXME:+4
 ENDCASE
END
DEF GWIN_DRAW_EVAL GW,EVENT,X,Y,W,H,A1,A2,A3,A4
 IF TYPEOF(GDEBUG_EVAL_STAT)==#T_DEFAULT THEN RETURN
 VAR BACK_COLOR=RGB(255,255,255)
 BACK_COLOR=RGB(0,0,0)
 VAR SCRBAR=GWIN_FIND(GW,"SCRBAR")
 VAR SCRBAR_W=16
 VAR MX=GWIN_GET_MOUSE_X(GW)
 VAR MY=GWIN_GET_MOUSE_Y(GW)
 VAR OVER=MX>=X&&MX<X+W&&MY>=Y&&MY<Y+H
 IF (EVENT==#GWIN_EVENT_LDWN||EVENT==#GWIN_EVENT_RDWN||EVENT==#GWIN_EVENT_LDWN||EVENT==#GWIN_EVENT_RUP)&&!OVER THEN
  RETURN
 ENDIF
 IF EVENT==#GWIN_EVENT_WHEEL THEN
  VAR POS
  VAR DELTA=A1
  GWIN_SCR_GET SCRBAR OUT ,,POS
  GWIN_SCR_SET SCRBAR,,,POS+(32*-DELTA DIV 120)
  GWIN_PAINT GW,#FALSE
  RETURN
 ENDIF
 GDEBUG_DRAW_SUNKEN_EDGE EVENT,X,Y,W,H OUT X,Y,W,H
 GWIN_MOVERESIZE SCRBAR,X+W-SCRBAR_W-GWIN_GET_CX(GW),Y-GWIN_GET_CY(GW),SCRBAR_W,H
 DEC W,SCRBAR_W
 DIM LIST_W%[]=[100,W-100-70,70]
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GFILL X,Y,X+W-1,Y+H-1,BACK_COLOR
 ENDIF
 VAR LIST_H
 VAR SCRBAR_POS
 GWIN_SCR_GET SCRBAR OUT ,,SCRBAR_POS
 GDEBUG_GET_EXPR_LISTBOX_H EVENT,X,Y,W,H,LIST_W% OUT LIST_H
 VAR LIST_Y=Y+LIST_H-SCRBAR_POS
 VAR PAGE_SIZE=H-LIST_H
 VAR NAME$=GWIN_GET_VAR$(GW,0)
 VAR INDEX
 VAR SY=LIST_Y
 GDEBUG_DRAW_EXPR_LISTBOX_NEXT GW,EVENT,LIST_W%,X,Y,LIST_Y,W,H,NAME$,GDEBUG_EVAL_RESULT,BACK_COLOR,GDEBUG_EVAL_STAT,INDEX,0,A1,A2,A3,A4,0,#FALSE OUT LIST_Y,INDEX
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GCLIP X,Y,X+W-1,Y+H-1
 ENDIF
 GDEBUG_DRAW_EXPR_LISTBOX EVENT,X,Y,W,H,LIST_W%,LIST_H
 IF EVENT==#GWIN_EVENT_PAINT THEN
  GWIN_SCR_SET SCRBAR,PAGE_SIZE,LIST_Y-SY+1,
 ENDIF
END
'OTWヨリ
'===syntax highlighting===
'HashSet
VAR RTXTEDTRUE
VAR RTXTEDFALSE
VAR RTXTEDVAR
VAR RTXTEDDIM
VAR RTXTEDFOR
VAR RTXTEDNEXT
VAR RTXTEDBREAK
VAR RTXTEDCONTINUE
VAR RTXTEDREPEAT
VAR RTXTEDUNTIL
VAR RTXTEDWHILE
VAR RTXTEDWEND
VAR RTXTEDDATA
VAR RTXTEDREAD
VAR RTXTEDCOMMON
VAR RTXTEDDEF
VAR RTXTEDOUT
VAR RTXTEDEND
VAR RTXTEDRETURN
VAR RTXTEDIF
VAR RTXTEDTHEN
VAR RTXTEDELSE
VAR RTXTEDENDIF
VAR RTXTEDPRINT
VAR RTXTEDREM
VAR RTXTEDINC
VAR RTXTEDDEC
VAR RTXTEDGOTO
VAR RTXTEDGOSUB
VAR RTXTEDRESTORE
VAR RTXTEDAND
VAR RTXTEDOR
VAR RTXTEDXOR
VAR RTXTEDNOT
VAR RTXTEDMOD
VAR RTXTEDDIV
VAR RTXTEDCALL

VAR RTXTEDTO
VAR RTXTEDSTEP
VAR RTXTEDDEFOUT
VAR RTXTEDCONST
VAR RTXTEDLOOP
VAR RTXTEDENDLOOP
VAR RTXTEDCASE
VAR RTXTEDWHEN
VAR RTXTEDENDCASE
VAR RTXTEDENUM
VAR RTXTEDEXEC
VAR RTXTEDELSEIF
VAR RTXTEDSWAP
VAR RTXTEDON
VAR RTXTEDTPRINT
VAR RTXTEDINPUT
VAR RTXTEDLINPUT
VAR RTXTEDOTHERWISE

VAR QTXTEDOPTION
VAR QTXTEDSTOP
COMMON DEF TXTED_PRGPRINT2 X,Y,P$,X2,FONSIZE
 VAR I,L=LAST(P$)
 VAR S$
 WHILE I<=L
  IF X>=X2 THEN RETURN
  VAR C=ASC(P$[I])
  IF C==32 THEN
   INC X,FONSIZE
   INC I
   CONTINUE
  ENDIF
  IF (C>=48&&C<=57)||C==46 THEN
   VAR SI=I
   INC I
   @DRAW_NUM
   VAR HASN_E=#TRUE
   WHILE I<=L
    C=ASC(P$[I])
    IF (C==69||C==101)&&HASN_E THEN
     HASN_E=#FALSE
     INC I
     CONTINUE
    ENDIF
    IF (C>=48&&C<=57)||(C==95) THEN
     INC I
     CONTINUE
    ENDIF
    BREAK
   WEND
   IF C==35 THEN INC I
   GPUTCHR X,Y,MID$(P$,SI,I-SI),FONSIZE,1,1,RGB(240,64,144),#G_ALPHA2
   INC X,(I-SI)*FONSIZE
   CONTINUE
  ELSEIF (C>=65&&C<=90)||(C>=97&&C<=122)THEN
   SI=I
   INC I
   WHILE I<=L
    C=ASC(P$[I])
    IF (C>=65&&C<=90)||(C>=97&&C<=122)||(C>=48&&C<=57)||(C==95) THEN
     INC I
     CONTINUE
    ENDIF
    BREAK
   WEND
   IF C>=35&&C<=37 THEN INC I
   VAR I$=MID$(P$,SI,I-SI)
   IF CHKVAR("RTXTED"+I$)THEN
    C=RGB(0,198,247)
   ELSEIF CHKCALL(NOT_USED_SLOT$+I$)||((I$[0]=="S"||I$[0]=="s"||I$[0]=="O"||I$[0]=="o")&&CHKVAR("QTXTED"+I$))THEN
    C=RGB(123,123,247)
   ELSE
    C=-1
   ENDIF
   GPUTCHR X,Y,I$,FONSIZE,1,1,C,#G_ALPHA2
   INC X,(I-SI)*FONSIZE
   CONTINUE
  ELSEIF C==64THEN
   SI=I
   INC I
   WHILE I<=L
    C=ASC(P$[I])
    IF (C>=65&&C<=90)||(C>=97&&C<=122)||(C>=48&&C<=57)||(C==95) THEN
     INC I
     CONTINUE
    ENDIF
    BREAK
   WEND
   GPUTCHR X,Y,MID$(P$,SI,I-SI),FONSIZE,1,1,RGB(240,160,0),#G_ALPHA2
   INC X,(I-SI)*FONSIZE
   CONTINUE
  ELSEIF C==35THEN
   SI=I
   INC I
   WHILE I<=L
    C=ASC(P$[I])
    IF (C>=65&&C<=90)||(C>=97&&C<=122)||(C>=48&&C<=57)||(C==95) THEN
     INC I
     CONTINUE
    ENDIF
    BREAK
   WEND
   IF C>=35&&C<=37THEN INC I
   IF I-1!=SI THEN
    GPUTCHR X,Y,MID$(P$,SI,I-SI),FONSIZE,1,1,RGB(176,208,208),#G_ALPHA2
    INC X,(I-SI)*FONSIZE
    CONTINUE
   ELSE
    C=35
    DEC I
   ENDIF
  ELSEIF C==34THEN
   SI=I
   I=INSTR(I+1,P$,CHR$(34))
   IF I==-1 THEN I=L-1
   INC I
   GPUTCHR X,Y,MID$(P$,SI,I-SI),FONSIZE,1,1,RGB(96,128,240),#G_ALPHA2
   INC X,(I-SI)*FONSIZE
   CONTINUE
  ELSEIF C==39THEN
   SI=I
   I=INSTR(I+1,P$,CHR$(10))
   IF I==-1 THEN I=L
   GPUTCHR X,Y,MID$(P$,SI,I-SI),FONSIZE,1,1,RGB(32,240,16),#G_ALPHA2
   INC X,(I-SI)*FONSIZE
   CONTINUE
  ELSEIF C==45THEN
   SI=I
   INC I
   IF I<=L THEN
    C=ASC(P$[I])
    IF C>=48&&C<=57 THEN
     GOTO@DRAW_NUM
    ELSE
     DEC I
     C=45
    ENDIF
   ELSE
    DEC I
   ENDIF
  ELSEIF C==38THEN
   SI=I
   INC I
   IF I<=L THEN
    C=ASC(P$[I])
    IF C==72||C==104THEN
     INC I
     WHILE I<=L
      C=ASC(P$[I])
      IF (C>=65&&C<=70)||(C>=97&&C<=102)||(C>=48&&C<=57) THEN
       INC I
       CONTINUE
      ENDIF
      BREAK
     WEND
     IF I==SI+2 THEN
      I=SI
      C=38
     ELSE
      GPUTCHR X,Y,MID$(P$,SI,I-SI),FONSIZE,1,1,RGB(240,64,144),#G_ALPHA2
      INC X,(I-SI)*FONSIZE
     ENDIF
    ELSEIF C==66||C==98THEN
     INC I
     WHILE I<=L
      C=ASC(P$[I])
      IF (C>=48&&C<=57) THEN
       INC I
       CONTINUE
      ENDIF
      BREAK
     WEND
     IF I==SI+2 THEN
      I=SI
      C=38
     ELSE
      GPUTCHR X,Y,MID$(P$,SI,I-SI),FONSIZE,1,1,RGB(240,64,144),#G_ALPHA2
      INC X,(I-SI)*FONSIZE
     ENDIF
    ELSE
     DEC I
     C=38
    ENDIF
   ELSE
    DEC I
   ENDIF
  ENDIF
  GPUTCHR X,Y,C,FONSIZE,1,1,-1,#G_ALPHA2
  INC X,FONSIZE
  INC I
 WEND
END
COMMON DEF TXTED_PRGPRINT2_SEL X,Y,P$,X2,FON_TYPE,SS,SE,SCX,SCY
 VAR I,L=LAST(P$)
 VAR S$
 VAR COLOR
 VAR FONSIZEX=FON_TYPE*SCX
 VAR FONSIZEY=FON_TYPE*SCY
 VAR FONSIZEX2=FONSIZEX-1
 VAR FONSIZEY2=FONSIZEY-1
 WHILE I<=L
  IF X>=X2 THEN RETURN
  VAR C=ASC(P$[I])
  IF C==32 THEN
   IF SS<=I&&SE>I THEN
    GFILL X,Y,X+FONSIZEX2,Y+FONSIZEY2,-1
   ENDIF
   INC X,FONSIZEX
   INC I
   CONTINUE
  ENDIF
  IF (C>=48&&C<=57)||C==46 THEN
   VAR SI=I
   INC I
   @DRAW_NUM
   VAR HASN_E=#TRUE
   WHILE I<=L
    C=ASC(P$[I])
    IF (C==69||C==101)&&HASN_E THEN
     HASN_E=#FALSE
     INC I
     CONTINUE
    ENDIF
    IF (C>=48&&C<=57)||(C==95) THEN
     INC I
     CONTINUE
    ENDIF
    BREAK
   WEND
   IF C==35 THEN INC I
   COLOR=RGB(240,64,144)
   GOTO@DRAW
  ELSEIF (C>=65&&C<=90)||(C>=97&&C<=122)THEN
   SI=I
   INC I
   WHILE I<=L
    C=ASC(P$[I])
    IF (C>=65&&C<=90)||(C>=97&&C<=122)||(C>=48&&C<=57)||(C==95) THEN
     INC I
     CONTINUE
    ENDIF
    BREAK
   WEND
   IF C>=35&&C<=37 THEN INC I
   VAR I$=MID$(P$,SI,I-SI)
   IF CHKVAR("RTXTED"+I$)THEN
    COLOR=RGB(0,198,247)
   ELSEIF CHKCALL(NOT_USED_SLOT$+I$)||((I$[0]=="S"||I$[0]=="s"||I$[0]=="O"||I$[0]=="o")&&CHKVAR("QTXTED"+I$))THEN
    COLOR=RGB(123,123,247)
   ELSE
    COLOR=-1
   ENDIF
   GOTO@DRAW
  ELSEIF C==64THEN
   SI=I
   INC I
   WHILE I<=L
    C=ASC(P$[I])
    IF (C>=65&&C<=90)||(C>=97&&C<=122)||(C>=48&&C<=57)||(C==95) THEN
     INC I
     CONTINUE
    ENDIF
    BREAK
   WEND
   COLOR=RGB(240,160,0)
   GOTO@DRAW
  ELSEIF C==35THEN
   SI=I
   INC I
   WHILE I<=L
    C=ASC(P$[I])
    IF (C>=65&&C<=90)||(C>=97&&C<=122)||(C>=48&&C<=57)||(C==95) THEN
     INC I
     CONTINUE
    ENDIF
    BREAK
   WEND
   IF C>=35&&C<=37THEN INC I
   IF I-1!=SI THEN
    COLOR=RGB(176,208,208)
    GOTO@DRAW
   ELSE
    C=35
    DEC I
   ENDIF
  ELSEIF C==34THEN
   SI=I
   I=INSTR(I+1,P$,CHR$(34))
   IF I==-1 THEN I=L-1
   INC I
   COLOR=RGB(96,128,240)
   GOTO@DRAW
  ELSEIF C==39THEN
   SI=I
   I=INSTR(I+1,P$,CHR$(10))
   IF I==-1 THEN I=L
   COLOR=RGB(32,240,16)
   GOTO@DRAW
  ELSEIF C==45THEN
   SI=I
   INC I
   IF I<=L THEN
    C=ASC(P$[I])
    IF C>=48&&C<=57 THEN
     GOTO@DRAW_NUM
    ELSE
     DEC I
     C=45
    ENDIF
   ELSE
    DEC I
   ENDIF
  ELSEIF C==38THEN
   SI=I
   INC I
   IF I<=L THEN
    C=ASC(P$[I])
    IF C==72||C==104THEN
     INC I
     WHILE I<=L
      C=ASC(P$[I])
      IF (C>=65&&C<=70)||(C>=97&&C<=102)||(C>=48&&C<=57) THEN
       INC I
       CONTINUE
      ENDIF
      BREAK
     WEND
     IF I==SI+2 THEN
      I=SI
      C=38
     ELSE
      COLOR=RGB(240,64,144)
      GOTO@DRAW
     ENDIF
    ELSEIF C==66||C==98THEN
     INC I
     WHILE I<=L
      C=ASC(P$[I])
      IF (C>=48&&C<=57) THEN
       INC I
       CONTINUE
      ENDIF
      BREAK
     WEND
     IF I==SI+2 THEN
      I=SI
      C=38
     ELSE
      COLOR=RGB(240,64,144)
      GOTO@DRAW
     ENDIF
    ELSE
     DEC I
     C=38
    ENDIF
   ELSE
    DEC I
   ENDIF
  ENDIF
  IF SS<=I&&SE>I THEN
   GFILL X,Y,X+FONSIZEX2,Y+FONSIZEY2,-1
   GPUTCHR X,Y,C,FON_TYPE,SCX,SCY,&HFF000000,#G_ALPHA2
  ELSE
   GPUTCHR X,Y,C,FON_TYPE,SCX,SCY,-1,#G_ALPHA2
  ENDIF
  INC X,FONSIZEX
  INC I
  CONTINUE
  @DRAW
  DEC I
  FOR SI=SI TO I
   IF SS<=SI&&SE>SI THEN
    GFILL X,Y,X+FONSIZEX2,Y+FONSIZEY2,COLOR
    GPUTCHR X,Y,P$[SI],FON_TYPE,SCX,SCY,&HFF000000,#G_ALPHA2
   ELSE
    GPUTCHR X,Y,P$[SI],FON_TYPE,SCX,SCY,COLOR,#G_ALPHA2
   ENDIF
   INC X,FONSIZEX
  NEXT
  INC I
 WEND
END
COMMON DEF TXTED_PRGPRINT3 X,Y,P$,X2,FONSIZE,FON
 VAR I,L=LAST(P$)
 VAR S$
 VAR WW
 WHILE I<=L
  IF X>=X2 THEN RETURN
  VAR C=ASC(P$[I])
  IF C==32 THEN
   IF WW THEN
    INC X,WW
   ELSE
    WW=FONT_CALC_WIDTH(FON," ")
    INC X,WW
   ENDIF
   INC I
   CONTINUE
  ENDIF
  IF (C>=48&&C<=57)||C==46 THEN
   VAR SI=I
   INC I
   @DRAW_NUM
   VAR HASN_E=#TRUE
   WHILE I<=L
    C=ASC(P$[I])
    IF (C==69||C==101)&&HASN_E THEN
     HASN_E=#FALSE
     INC I
     CONTINUE
    ENDIF
    IF (C>=48&&C<=57)||(C==95) THEN
     INC I
     CONTINUE
    ENDIF
    BREAK
   WEND
   IF C==35 THEN INC I
   INC X,GPUTCHR_FONT_W(FON,X,Y,#FALSE,MID$(P$,SI,I-SI),RGB(240,64,144))
   CONTINUE
  ELSEIF (C>=65&&C<=90)||(C>=97&&C<=122)THEN
   SI=I
   INC I
   WHILE I<=L
    C=ASC(P$[I])
    IF (C>=65&&C<=90)||(C>=97&&C<=122)||(C>=48&&C<=57)||(C==95) THEN
     INC I
     CONTINUE
    ENDIF
    BREAK
   WEND
   IF C>=35&&C<=37 THEN INC I
   VAR I$=MID$(P$,SI,I-SI)
   IF CHKVAR("RTXTED"+I$)THEN
    C=RGB(0,198,247)
   ELSEIF CHKCALL(NOT_USED_SLOT$+I$)||((I$[0]=="S"||I$[0]=="s"||I$[0]=="O"||I$[0]=="o")&&CHKVAR("QTXTED"+I$))THEN
    C=RGB(123,123,247)
   ELSE
    C=-1
   ENDIF
   INC X,GPUTCHR_FONT_W(FON,X,Y,#FALSE,I$,C)
   CONTINUE
  ELSEIF C==64THEN
   SI=I
   INC I
   WHILE I<=L
    C=ASC(P$[I])
    IF (C>=65&&C<=90)||(C>=97&&C<=122)||(C>=48&&C<=57)||(C==95) THEN
     INC I
     CONTINUE
    ENDIF
    BREAK
   WEND
   INC X,GPUTCHR_FONT_W(FON,X,Y,#FALSE,MID$(P$,SI,I-SI),RGB(240,160,0))
   CONTINUE
  ELSEIF C==35THEN
   SI=I
   INC I
   WHILE I<=L
    C=ASC(P$[I])
    IF (C>=65&&C<=90)||(C>=97&&C<=122)||(C>=48&&C<=57)||(C==95) THEN
     INC I
     CONTINUE
    ENDIF
    BREAK
   WEND
   IF C>=35&&C<=37THEN INC I
   IF I-1!=SI THEN
    INC X,GPUTCHR_FONT_W(FON,X,Y,#FALSE,MID$(P$,SI,I-SI),RGB(176,208,208))
    CONTINUE
   ELSE
    C=35
    DEC I
   ENDIF
  ELSEIF C==34THEN
   SI=I
   I=INSTR(I+1,P$,CHR$(34))
   IF I==-1 THEN I=L
   INC I
   INC X,GPUTCHR_FONT_W(FON,X,Y,#FALSE,MID$(P$,SI,I-SI),RGB(96,128,240))
   CONTINUE
  ELSEIF C==39THEN
   SI=I
   I=INSTR(I+1,P$,CHR$(10))
   IF I==-1 THEN I=L
   INC X,GPUTCHR_FONT_W(FON,X,Y,#FALSE,MID$(P$,SI,I-SI),RGB(32,240,16))
   CONTINUE
  ELSEIF C==45THEN
   SI=I
   INC I
   IF I<=L THEN
    C=ASC(P$[I])
    IF C>=48&&C<=57THEN @DRAW_NUM
    I=SI
    C=45
   ELSE
    DEC I
   ENDIF
  ELSEIF C==38THEN
   SI=I
   INC I
   IF I<=L THEN
    C=ASC(P$[I])
    IF C==72||C==104THEN
     INC I
     WHILE I<=L
      C=ASC(P$[I])
      IF (C>=65&&C<=70)||(C>=97&&C<=102)||(C>=48&&C<=57) THEN
       INC I
       CONTINUE
      ENDIF
      BREAK
     WEND
     IF I==SI+2 THEN
      I=SI
      C=38
     ELSE
     INC X,GPUTCHR_FONT_W(FON,X,Y,#FALSE,MID$(P$,SI,I-SI),RGB(240,64,144))
     ENDIF
    ELSEIF C==66||C==98THEN
     INC I
     WHILE I<=L
      C=ASC(P$[I])
      IF (C>=48&&C<=57) THEN
       INC I
       CONTINUE
      ENDIF
      BREAK
     WEND
     IF I==SI+2 THEN
      I=SI
      C=38
     ELSE
      INC X,GPUTCHR_FONT_W(FON,X,Y,#FALSE,MID$(P$,SI,I-SI),RGB(240,64,144))
     ENDIF
    ELSE
     DEC I
     C=38
    ENDIF
   ELSE
    DEC I
   ENDIF
  ENDIF
  INC X,GPUTCHR_FONT_W(FON,X,Y,#FALSE,CHR$(C),-1)
  INC I
 WEND
END
VAR LEXER_TKN
DEF INIT_LEXER IN$
 LEXER_I=0
 LEXER_IN$=IN$
 LEXER_LINE=1
 LEXER_LINE_POS=0
END
DEF EMPTY OUT A
 RETURN A
END
DEF IS_NUM(C)
 RETURN C>=48&&C<=57
END
DEF IS_ALPHA(C)
 RETURN (C>=65&&C<=90)||(C>=97&&C<=122)
END
DEF TO_UPPER$(S$)
 VAR I
 VAR NS$=COPY(S$)
 FOR I=0TO LAST(S$)
  VAR C=ASC(S$[I])
  IF C>=97&&C<=122THEN
   NS$[I]=CHR$(C-97+65)
  ENDIF
 NEXT
 RETURN NS$
END
DEF TO_UPPER S$
 VAR I,L=LAST(S$)
 FOR I=0TO LAST(S$)
  VAR C=ASC(S$[I])
  IF C>=97&&C<=122THEN
   S$[I]=CHR$(C-97+65)
  ENDIF
 NEXT
END
DEF LEX_CUR OUT T,V
 T=LEXER_TKN
 V=LEXER_VAL
END
DEF LEX_NEXT OUT T,V
 LEXER_PREV_I2=LEXER_I
 LEXER_PREV_LINE=LEXER_LINE
 LEXER_PREV_LINE_POS=LEXER_LINE_POS
 LEX_NEXT_IMPL
 LEX_CUR OUT T,V
 IF TRACE THEN
  ?TKN_STR$(T)
  ??V
 ENDIF
END
DEF LEX_SAVE OUT I,PI,PI2,T,V,L,P,PL,PP
 I=LEXER_I
 PI=LEXER_PREV_I
 PI2=LEXER_PREV_I2
 T=LEXER_TKN
 V=LEXER_VAL
 L=LEXER_LINE
 P=LEXER_LINE_POS
 PL=LEXER_PREV_LINE
 PP=LEXER_PREV_LINE_POS
END
DEF LEX_LOAD I,PI,PI2,T,V,L,P,PL,PP
 LEXER_I=I
 LEXER_PREV_I=PI
 LEXER_PREV_I2=PI2
 LEXER_TKN=T
 LEXER_VAL=V
 LEXER_LINE=L
 LEXER_LINE_POS=P
 LEXER_PREV_LINE=PL
 LEXER_PREV_LINE_POS=PP
END
DEF IS_VARSUFFIX(C$)
 CASE C$
 WHEN "$":WHEN "#":WHEN "%":RETURN #TRUE
 OTHERWISE RETURN #FALSE
 ENDCASE
END
DEF LEX_NEXT_IMPL
 @LOOP
 VAR C$,C
 LEXER_TKN=#TKN_NONE
 LEXER_VAL=EMPTY()
 FOR LEXER_I=LEXER_I TO LAST(LEXER_IN$)
  C$=LEXER_IN$[LEXER_I]
  C=ASC(C$)
  IF C==13||C==10THEN
   LEXER_TKN=#TKN_NEWLINE
   IF C==10THEN
    INC LEXER_LINE
    LEXER_LINE_POS=LEXER_I+1
   ENDIF
   CONTINUE
  ENDIF
  IF C==32||C==9THEN
   CONTINUE
  ENDIF
  BREAK
 NEXT
 LEXER_PREV_I=LEXER_I
 IF LEXER_I>=LEN(LEXER_IN$)THEN
  LEXER_TKN=#TKN_EOF
  RETURN
 ENDIF
 IF LEXER_TKN!=#TKN_NONE THEN
  RETURN
 ENDIF
  VAR N$=MID$(LEXER_IN$,LEXER_I+1,1)
 VAR SI=LEXER_I
 CASE C$
 WHEN "+"
  INC LEXER_I
  LEXER_TKN=#TKN_PLUS
 WHEN "-"
  INC LEXER_I
  LEXER_TKN=#TKN_MINUS
 WHEN "*"
  INC LEXER_I
  LEXER_TKN=#TKN_MUL
 WHEN "/"
  INC LEXER_I
  LEXER_TKN=#TKN_DIV
 WHEN ","
  INC LEXER_I
  LEXER_TKN=#TKN_COMMA
 WHEN "("
  INC LEXER_I
  LEXER_TKN=#TKN_LP
 WHEN ")"
  INC LEXER_I
  LEXER_TKN=#TKN_RP
 WHEN "["
  INC LEXER_I
  LEXER_TKN=#TKN_LB
 WHEN "]"
  INC LEXER_I
  LEXER_TKN=#TKN_RB
 WHEN ";"
  INC LEXER_I
  LEXER_TKN=#TKN_SEMI
 WHEN ":"
  INC LEXER_I
  LEXER_TKN=#TKN_COL
 WHEN "T"
  IF N$=="?"THEN
   INC LEXER_I,2
   LEXER_TKN=#TKN_TPRINT
  ENDIF
 WHEN "?"
  INC LEXER_I
  IF N$=="?"THEN
   INC LEXER_I
   LEXER_TKN=#TKN_INSPECT
  ELSE
   LEXER_TKN=#TKN_PRINT
  ENDIF
 WHEN "!"
  INC LEXER_I
  IF N$=="="THEN
   INC LEXER_I
   LEXER_TKN=#TKN_NEQ
  ELSE
   LEXER_TKN=#TKN_LNOT
  ENDIF
 WHEN "="
  INC LEXER_I
  IF N$=="="THEN
   INC LEXER_I
   LEXER_TKN=#TKN_EQ
  ELSE
   LEXER_TKN=#TKN_ASSIGN
  ENDIF
 WHEN "<"
  INC LEXER_I
  IF N$=="="THEN
   INC LEXER_I
   LEXER_TKN=#TKN_GEQ
  ELSEIF N$=="<"THEN
   INC LEXER_I
   LEXER_TKN=#TKN_LSHIFT
  ELSE
   LEXER_TKN=#TKN_GREAT
  ENDIF
 WHEN ">"
  INC LEXER_I
  IF N$=="="THEN
   INC LEXER_I
   LEXER_TKN=#TKN_LEQ
  ELSEIF N$==">"THEN
   INC LEXER_I
   LEXER_TKN=#TKN_RSHIFT
  ELSE
   LEXER_TKN=#TKN_LESS
  ENDIF
 WHEN "&"
  IF N$=="&"THEN
   INC LEXER_I,2
   LEXER_TKN=#TKN_LAND
  ELSEIF N$=="H"||N$=="h"THEN
   FOR LEXER_I=LEXER_I+2 TO LAST(LEXER_IN$)
    C$=LEXER_IN$[LEXER_I]
    C=ASC(C$)
    IF IS_NUM(C)||(C$>="A"&&C$<="F")||(C$>="a"&&C$<="f")THEN
     CONTINUE
    ENDIF
    BREAK
   NEXT
   LEXER_TKN=#TKN_NUM
   LEXER_VAL=VAL(MID$(LEXER_IN$,SI,LEXER_I-SI))
   RETURN
  ELSEIF N$=="B"||N$=="b"THEN
   FOR LEXER_I=LEXER_I+2 TO LAST(LEXER_IN$)
    C$=LEXER_IN$[LEXER_I]
    IF C$>="0"&&C$<="1"THEN
     CONTINUE
    ENDIF
    BREAK
   NEXT
   LEXER_TKN=#TKN_NUM
   LEXER_VAL=VAL(MID$(LEXER_IN$,SI,LEXER_I-SI))
   RETURN
  ENDIF
 WHEN "|"
  IF N$=="|"THEN
   INC LEXER_I,2
   LEXER_TKN=#TKN_LOR
  ENDIF
 ENDCASE
 IF LEXER_TKN!=#TKN_NONE THEN
  RETURN
 ENDIF
 IF IS_NUM(C)||C$=="." THEN
  'n.nEn
  VAR HAS_POINT,HAS_EXP,HAS_PLS
  FOR LEXER_I=LEXER_I TO LAST(LEXER_IN$)
   C$=LEXER_IN$[LEXER_I]
   C=ASC(C$)
   IF!HAS_EXP&&!HAS_POINT&&C$=="."THEN
    HAS_POINT=#TRUE
    CONTINUE
   ENDIF
   IF !HAS_EXP&&C$=="E"||C$=="e"THEN
    HAS_EXP=#TRUE
    CONTINUE
   ENDIF
   IF HAS_EXP&&!HAS_PLS&&C$=="+"THEN
    HAS_PLS=#TRUE
    HAS_POINT=#TRUE
    CONTINUE
   ENDIF
   IF IS_NUM(C)THEN
    CONTINUE
   ENDIF
   BREAK
  NEXT
  IF C$=="#" THEN INC LEXER_I
  LEXER_TKN=#TKN_NUM
  LEXER_VAL=VAL(MID$(LEXER_IN$,SI,LEXER_I-SI))
  'TYPEOF(VAL("0E0"))==#T_REAL #T_INTかつ0になるのはぶんぽうえらーのときのみ
  IF HAS_EXP&&TYPEOF(LEXER_VAL)==#T_INT&&LEXER_VAL==0THEN
   'しすうひょうきのあとにすうちがない or OVERFLOW
   ?"Syntax error"
   'FIXME:ERROR
   STOP
  ENDIF
  RETURN
 ELSEIF C$=="#"||C$=="@"||IS_ALPHA(C)||C$=="_"THEN
  VAR ISLBL=C$=="@"
  VAR ISCNST=C$=="#"
  VAR ADD1=ISLBL||ISCNST
  FOR LEXER_I=LEXER_I+ADD1 TO LAST(LEXER_IN$)
   C$=LEXER_IN$[LEXER_I]
   C=ASC(C$)
   IF IS_ALPHA(C)||C$=="_"||IS_NUM(C)THEN
    CONTINUE
   ENDIF
   BREAK
  NEXT
  IF !ISLBL&&IS_VARSUFFIX(MID$(LEXER_IN$,LEXER_I,1))THEN
   INC LEXER_I
  ENDIF
  '#% ## #$: VALID
  '#       : INVALID
  IF ISCNST&&LEXER_I-SI==1THEN
   GOTO@ERR
  ENDIF
  LEXER_VAL=MID$(LEXER_IN$,SI,LEXER_I-SI)
  LEXER_VAL=TO_UPPER$(LEXER_VAL)
  IF LEXER_VAL=="REM"THEN @REM
  IF ISLBL THEN
   LEXER_TKN=#TKN_LABEL
  ELSEIF ISCNST THEN
   LEXER_TKN=#TKN_CONSTVAR
  ELSE
   LEXER_TKN=LEX_RECOG_IDEN(LEXER_VAL)
  ENDIF
  RETURN
 ELSEIF C==34 THEN'STRING
  LEXER_VAL=""
  FOR LEXER_I=LEXER_I+1 TO LAST(LEXER_IN$)
   C$=LEXER_IN$[LEXER_I]
   C=ASC(C$)
   IF C==34||C==10||C==13 THEN
    IF C==34 THEN INC LEXER_I
    BREAK
   ENDIF
   PUSH LEXER_VAL,C$
  NEXT
  LEXER_TKN=#TKN_STR
  RETURN
 ELSEIF C$=="'"THEN
  @REM
  FOR LEXER_I=LEXER_I+1 TO LAST(LEXER_IN$)
   C$=LEXER_IN$[LEXER_I]
   C=ASC(C$)
   IF C==10 THEN BREAK
   IF C==13 THEN BREAK
  NEXT
  GOTO @LOOP
 ELSEIF C$=="\"THEN
  IF ASC(N$)==10||ASC(N$)==13 THEN
   IF ASC(N$)==10 THEN
    INC LEXER_LINE
   ENDIF
   LEXER_LINE_POS=LEXER_I+2
   INC LEXER_I,2
   GOTO @LOOP
  ENDIF
 ENDIF
 @ERR
 ?"Synt
 STOP
END
DEF LEX_RECOG_IDEN(V)
 CASE V
 WHEN "PRINT"
  RETURN #TKN_PRINT
 WHEN "DIV"
  RETURN #TKN_DIVINT
 WHEN "MOD"
  RETURN #TKN_MOD
 WHEN "AND"
  RETURN #TKN_AND
 WHEN "OR"
  RETURN #TKN_OR
 WHEN "XOR"
  RETURN #TKN_XOR
 WHEN "NOT"
  RETURN #TKN_NOT
 WHEN "OUT"
  RETURN #TKN_OUT
 WHEN "CALL"
  RETURN #TKN_CALL
 WHEN "DIM"
  RETURN #TKN_DIM
 WHEN "VAR"
  RETURN #TKN_VAR
 WHEN "IF"
  RETURN #TKN_IF
 WHEN "THEN"
  RETURN #TKN_THEN
 WHEN "ENDIF"
  RETURN #TKN_ENDIF
 WHEN "ELSE"
  RETURN #TKN_ELSE
 WHEN "ELSEIF"
  RETURN #TKN_ELSEIF
 WHEN "FOR"
  RETURN #TKN_FOR
 WHEN "NEXT"
  RETURN #TKN_NEXT
 WHEN "GOTO"
  RETURN #TKN_GOTO
 WHEN "GOSUB"
  RETURN #TKN_GOSUB
 WHEN "BREAK"
  RETURN #TKN_BREAK
 WHEN "CONTINUE"
  RETURN #TKN_CONTINUE
 WHEN "REPEAT"
  RETURN #TKN_REPEAT
 WHEN "UNTIL"
  RETURN #TKN_UNTIL
 WHEN "WHILE"
  RETURN #TKN_WHILE
 WHEN "WEND"
  RETURN #TKN_WEND
 WHEN "REPEAT"
  RETURN #TKN_REPEAT
 WHEN "UNTIL"
  RETURN #TKN_UNTIL
 WHEN "LOOP"
  RETURN #TKN_LOOP
 WHEN "ENDLOOP"
  RETURN #TKN_ENDLOOP
 WHEN "RETURN"
  RETURN #TKN_RETURN
 WHEN "DATA"
  RETURN #TKN_DATA
 WHEN "RESTORE"
  RETURN #TKN_RESTORE
 WHEN "CONST"
  RETURN #TKN_CONST
 WHEN "ENUM"
  RETURN #TKN_ENUM
 WHEN "DEF"
  RETURN #TKN_DEF
 WHEN "END"
  RETURN #TKN_END
 WHEN "TPRINT"
  RETURN #TKN_TPRINT
 WHEN "READ"
  RETURN #TKN_READ
 WHEN "INC"
  RETURN #TKN_INC
 WHEN "DEC"
  RETURN #TKN_DEC
 WHEN "ON"
  RETURN #TKN_ON
 WHEN "CASE"
  RETURN #TKN_CASE
 WHEN "WHEN"
  RETURN #TKN_WHEN
 WHEN "OTHERWISE"
  RETURN #TKN_OTHERWISE
 WHEN "ENDCASE"
  RETURN #TKN_ENDCASE
 WHEN "SWAP"
  RETURN #TKN_SWAP
 WHEN "COMMON"
  RETURN #TKN_COMMON
 WHEN "DEFOUT"
  RETURN #TKN_DEFOUT
 WHEN "INPUT"
  RETURN #TKN_INPUT
 WHEN "LINPUT"
  RETURN #TKN_LINPUT
 WHEN "EXEC"
  RETURN #TKN_EXEC
 OTHERWISE
  RETURN #TKN_IDEN
 ENDCASE
END



DIM AST_TYP[]
DIM AST%[]
DIM AST#[]
DIM AST$[]
DIM AST_LEFT[]
DIM AST_RIGHT[]
DIM AST_NEXT[]
DIM AST_PREV[]
DIM AST_A1[]
DIM AST_A2[]
DIM AST_A3[]
DIM AST_A4[]
DIM AST_A5[]
DIM AST_LINE[]
DIM AST_POS[]
DIM AST_LINE_END[]
DIM AST_POS_END[]
DEF INIT_AST
 VAR S=1
 AST_TYP=ARRAY%(S)
 AST%=ARRAY%(S)
 AST#=ARRAY#(S)
 AST$=ARRAY$(S)
 AST_LEFT=ARRAY%(S)
 AST_NEXT=ARRAY%(S)
 AST_RIGHT=ARRAY%(S)
 AST_PREV=ARRAY%(S)
 AST_A1=ARRAY%(S)
 AST_A2=ARRAY%(S)
 AST_A3=ARRAY%(S)
 AST_A4=ARRAY%(S)
 AST_A5=ARRAY%(S)
 AST_LINE=ARRAY%(S)
 AST_POS=ARRAY%(S)
 AST_LINE_END=ARRAY%(S)
 AST_POS_END=ARRAY%(S)
END

'BINOP:AST%-TKN
ENUM\
 #AST_ITEM,\
 #AST_BINOP,\
 #AST_UNAOP,\
 #AST_PRINT,\
 #AST_IMM_INT,\
 #AST_IMM_DBL,\
 #AST_IMM_STR,\
 #AST_STATEMENTS,\
 #AST_PRINT_EXPR_NEWLINE,\
 #AST_PRINT_EXPR_COMMA,\
 #AST_PRINT_EXPR_SEMI,\
 #AST_ASSIGN,\
 #AST_VAR,\
 #AST_IF,\
 #AST_FOR,\
 #AST_BREAK,\
 #AST_CONTINUE,\
 #AST_WHILE,\
 #AST_REPEAT,\
 #AST_LOOP,\
 #AST_LABEL,\
 #AST_GOTO,\
 #AST_GOSUB,\
 #AST_GOTOEXPR,\
 #AST_GOSUBEXPR,\
 #AST_ONGOTO,\
 #AST_ONGOSUB,\
 #AST_ONBREAKGOTO,\
 #AST_ONBREAKGOTOEXPR,\
 #AST_RETURN,\
 #AST_RETURNFUNC,\
 #AST_CALLFUNC,\
 #AST_CALLFUNCEXPR,\
 #AST_OPTIONSTRICT,\
 #AST_OPTIONDEFINT,\
 #AST_RESTORE,\
 #AST_RESTOREEXPR,\
 #AST_DATA,\
 #AST_CONST,\
 #AST_ENUM,\
 #AST_CONSTVAR,\
 #AST_CALLSPRITE,\
 #AST_CALLTEXT,\
 #AST_ARRAYEXPR,\
 #AST_DEF,\
 #AST_END,\
 #AST_TPRINT,\
 #AST_EMPTYEXPR,\
 #AST_DEFVAR,\
 #AST_READ,\
 #AST_DEC,\
 #AST_INC,\
 #AST_CASE,\
 #AST_SWAP,\
 #AST_INPUT,\
 #AST_LINPUT,\
 #AST_DEFOUT,\
 #AST_EXEC,\
 #AST_STOP,\
 #AST_VARREF,\
 #AST_VAREXPR,\
 #AST_,\
 #AST_LAST
DEF AST_STR$(TYP)
 CASE TYP
 WHEN #AST_ITEM:RETURN "#AST_ITEM"WHEN #AST_BINOP:RETURN "#AST_BINOP"WHEN #AST_UNAOP:RETURN "#AST_UNAOP"WHEN #AST_PRINT:RETURN "#AST_PRINT"WHEN #AST_IMM_INT:RETURN "#AST_IMM_INT"WHEN #AST_IMM_DBL:RETURN "#AST_IMM_DBL"WHEN #AST_IMM_STR:RETURN "#AST_IMM_STR"WHEN #AST_STATEMENTS:RETURN "#AST_STATEMENTS"WHEN #AST_PRINT_EXPR_NEWLINE:RETURN "#AST_PRINT_EXPR_NEWLINE"WHEN #AST_PRINT_EXPR_COMMA:RETURN "#AST_PRINT_EXPR_COMMA"WHEN #AST_PRINT_EXPR_SEMI:RETURN "#AST_PRINT_EXPR_SEMI"WHEN #AST_ASSIGN:RETURN "#AST_ASSIGN"WHEN #AST_VAR:RETURN "#AST_VAR"WHEN #AST_IF:RETURN "#AST_IF"WHEN #AST_FOR:RETURN "#AST_FOR"WHEN #AST_BREAK:RETURN "#AST_BREAK"WHEN #AST_CONTINUE:RETURN "#AST_CONTINUE"WHEN #AST_WHILE:RETURN "#AST_WHILE"WHEN #AST_REPEAT:RETURN "#AST_REPEAT"WHEN #AST_LOOP:RETURN "#AST_LOOP"WHEN #AST_LABEL:RETURN "#AST_LABEL"WHEN #AST_GOTO:RETURN "#AST_GOTO"WHEN #AST_GOSUB:RETURN "#AST_GOSUB"WHEN #AST_GOTOEXPR:RETURN "#AST_GOTOEXPR"WHEN #AST_GOSUBEXPR:RETURN "#AST_GOSUBEXPR"WHEN #AST_ONGOTO:RETURN "#AST_ONGOTO"WHEN #AST_ONGOSUB:RETURN "#AST_ONGOSUB"WHEN #AST_ONBREAKGOTO:RETURN "#AST_ONBREAKGOTO"WHEN #AST_ONBREAKGOTOEXPR:RETURN "#AST_ONBREAKGOTOEXPR"WHEN #AST_RETURN:RETURN "#AST_RETURN"WHEN #AST_RETURNFUNC:RETURN "#AST_RETURNFUNC"WHEN #AST_CALLFUNC:RETURN "#AST_CALLFUNC"WHEN #AST_CALLFUNCEXPR:RETURN "#AST_CALLFUNCEXPR"WHEN #AST_OPTIONSTRICT:RETURN "#AST_OPTIONSTRICT"WHEN #AST_OPTIONDEFINT:RETURN "#AST_OPTIONDEFINT"WHEN #AST_RESTORE:RETURN "#AST_RESTORE"WHEN #AST_RESTOREEXPR:RETURN "#AST_RESTOREEXPR"WHEN #AST_DATA:RETURN "#AST_DATA"WHEN #AST_CONST:RETURN "#AST_CONST"WHEN #AST_ENUM:RETURN "#AST_ENUM"WHEN #AST_CONSTVAR:RETURN "#AST_CONSTVAR"WHEN #AST_CALLSPRITE:RETURN "#AST_CALLSPRITE"WHEN #AST_CALLTEXT:RETURN "#AST_CALLTEXT"WHEN #AST_ARRAYEXPR:RETURN "#AST_ARRAYEXPR"WHEN #AST_DEF:RETURN "#AST_DEF"WHEN #AST_END:RETURN "#AST_END"WHEN #AST_TPRINT:RETURN "#AST_TPRINT"WHEN #AST_EMPTYEXPR:RETURN "#AST_EMPTYEXPR"WHEN #AST_DEFVAR:RETURN "#AST_DEFVAR"WHEN #AST_READ:RETURN "#AST_READ"WHEN #AST_DEC:RETURN "#AST_DEC"WHEN #AST_INC:RETURN "#AST_INC"WHEN #AST_CASE:RETURN "#AST_CASE"WHEN #AST_SWAP:RETURN "#AST_SWAP"WHEN #AST_INPUT:RETURN "#AST_INPUT"WHEN #AST_LINPUT:RETURN "#AST_LINPUT"WHEN #AST_DEFOUT:RETURN "#AST_DEFOUT"WHEN #AST_EXEC:RETURN "#AST_EXEC"WHEN #AST_STOP:RETURN "#AST_STOP"WHEN #AST_VARREF:RETURN "#AST_VARREF"WHEN #AST_VAREXPR:RETURN "#AST_VAREXPR"WHEN #AST_:RETURN "#AST_"
 OTHERWISE
  RETURN "#AST"+STR$(TYP)
 ENDCASE
END
DEF NEW_AST(TYP)
 PUSH AST_TYP,TYP
 VAR E$
 PUSH AST%,0
 PUSH AST#,0
 PUSH AST$,E$
 PUSH AST_LEFT,0
 PUSH AST_RIGHT,0
 PUSH AST_NEXT,0
 PUSH AST_PREV,0
 PUSH AST_A1,0
 PUSH AST_A2,0
 PUSH AST_A3,0
 PUSH AST_A4,0
 PUSH AST_A5,0
 PUSH AST_LINE,LEXER_LINE
 PUSH AST_POS,LEXER_PREV_I-LEXER_LINE_POS+1
 PUSH AST_LINE_END,LEXER_LINE
 PUSH AST_POS_END,LEXER_I-LEXER_LINE_POS+1
 RETURN LAST(AST_TYP)
END

DEF AST_SET_POS AST
 AST_LINE[AST]=LEXER_LINE
 AST_POS[AST]=LEXER_PREV_I-LEXER_LINE_POS+1
END
DEF AST_SET_POS_END AST
 AST_LINE_END[AST]=LEXER_PREV_LINE
 AST_POS_END[AST]=LEXER_PREV_I2-LEXER_PREV_LINE_POS+1
END

DEF NEW_AST_LR(TYP,L,R)
 VAR A=NEW_AST(TYP)
 AST_LEFT[A]=L
 AST_RIGHT[A]=R
 RETURN A
END

DEF NEW_AST_APPEND(TYP,PREV)
 VAR A=NEW_AST(TYP)
 AST_PREV[A]=PREV
 AST_NEXT[PREV]=LAST(AST_TYP)
 RETURN LAST(AST_TYP)
END

DEF NEW_AST_INT(TYP,V%)
 VAR A=NEW_AST(TYP)
 AST%[A]=V%
 RETURN A
END

DEF NEW_AST_DBL(TYP,V#)
 VAR A=NEW_AST(TYP)
 AST#[A]=V#
 RETURN A
END
DEF NEW_AST_STR(TYP,V$)
 VAR A=NEW_AST(TYP)
 AST$[A]=V$
 RETURN A
END

DEF NEW_AST_IMM(V)
 VAR A
 CASE TYPEOF(V)
 WHEN #T_INT
  A=NEW_AST_INT(#AST_IMM_INT,V)
 WHEN #T_REAL
  A=NEW_AST_DBL(#AST_IMM_DBL,V)
 WHEN #T_STR
  A=NEW_AST_STR(#AST_IMM_STR,V)
 OTHERWISE
  STOP
 ENDCASE
 RETURN A
END
VAR AST_DUMPAST_END
DEF AST_IND IND
 VAR Y,H
 LOCATE OUT ,Y
 TSCREEN OUT ,,,H
 IF 0&&Y>=H-2 THEN
  LOOP
   VAR K$=INKEY$()
   IF LEN(K$)THEN
    IF K$=="A" THEN
     AST_DUMPAST_END=#TRUE
     BREAK
    ENDIF
    CLS
    BREAK
   ENDIF
   VSYNC
  ENDLOOP
 ENDIF
 ?" "*IND;
END
DEF DUMP_AST A,IND
 IF IND==0 THEN AST_DUMPAST_END=#FALSE
 IF!A THEN RETURN
 IF AST_DUMPAST_END THEN RETURN
 VAR I,J
 CASE AST_TYP[A]
 WHEN #AST_STATEMENTS
  AST_IND IND:?"STATEMENTS"
  I=AST_NEXT[AST_LEFT[A]]
  WHILE I
   IF!I THEN BREAK
   DUMP_AST AST_LEFT[I],IND+1
   I=AST_NEXT[I]
  WEND
 WHEN #AST_TPRINT
 WHEN #AST_PRINT
  VAR P$="PRINT"
  IF AST_TYP[A]==#AST_TPRINT THEN P$="TPRINT"
  AST_IND IND:?P$
  INC IND
  I=AST_NEXT[AST_LEFT[A]]
  WHILE I
   IF!I THEN BREAK
   CASE AST_TYP[I]
   WHEN #AST_PRINT_EXPR_COMMA
    AST_IND IND:?P$;" COMMA"
   WHEN #AST_PRINT_EXPR_NEWLINE
    AST_IND IND:?P$;" NEWLINE"
   WHEN #AST_PRINT_EXPR_SEMI
    AST_IND IND:?P$;" SEMI"
   ENDCASE
   DUMP_AST AST_LEFT[I],IND+1
   I=AST_NEXT[I]
  WEND
 WHEN #AST_IF
  AST_IND IND:?"IF"
  INC IND
  AST_IND IND:?"IF EXPR"
  DUMP_AST AST_A1[A],IND+1
  AST_IND IND:?"IF THEN STATEMENTS"
  DUMP_AST AST_A2[A],IND+1
  IF AST_A3[A] THEN
   I=AST_NEXT[AST_A3[A]]
   WHILE I
    AST_IND IND:?"IF ELSEIF EXPR[";J;"]"
    DUMP_AST AST_A1[I],IND+1
    AST_IND IND:?"IF ELSEIF STATEMENTS[";J;"]"
    DUMP_AST AST_A2[I],IND+1
    INC J
    I=AST_NEXT[I]
   WEND
  ENDIF
  AST_IND IND:?"IF ELSE STATEMENTS"
  DUMP_AST AST_A4[A],IND+1
 WHEN #AST_ASSIGN
  AST_IND IND:?"ASSIGN"
  DUMP_AST AST_LEFT[A],IND+1
  DUMP_AST AST_RIGHT[A],IND+1
 WHEN #AST_FOR
  AST_IND IND:?"FOR"
  DUMP_AST AST_A1[A],IND+1
  DUMP_AST AST_A2[A],IND+1
  DUMP_AST AST_A3[A],IND+1
  DUMP_AST AST_A4[A],IND+1
  DUMP_AST AST_A5[A],IND+1
 WHEN #AST_BINOP
  AST_IND IND:?"BINOP ";TKN_STR$(AST%[A])
  DUMP_AST AST_LEFT[A],IND+1
  DUMP_AST AST_RIGHT[A],IND+1
 WHEN #AST_UNAOP
  AST_IND IND:?"UNAOP ";TKN_STR$(AST%[A])
  DUMP_AST AST_LEFT[A],IND+1
 WHEN #AST_IMM_INT
  AST_IND IND:?"INT ";AST%[A]
 WHEN #AST_IMM_DBL
  AST_IND IND:?"DOUBLE ";AST#[A]
 WHEN #AST_IMM_STR
  AST_IND IND:?"STR ";AST$[A]
 WHEN #AST_VAR
  AST_IND IND:?"VAR ";AST$[A]
 WHEN #AST_CONSTVAR
  AST_IND IND:?"CONST ";AST$[A]
 WHEN #AST_EMPTYEXPR
  AST_IND IND:?"EMPTYEXPR"
 WHEN #AST_DEF
 '$:NAME
 'A1:IN LIST
 'A2:OUT LIST
 'A3:STATEMENTS
 'A4:HAS RETURN VALUE
  IF AST_A4[A] THEN
   AST_IND IND:?"DEF(";AST$[A];")"
  ELSE
   AST_IND IND:?"DEF ";AST$[A]
  ENDIF
  AST_IND IND:?"DEF ARGS(IN)"
  I=AST_NEXT[AST_A1[A]]
  WHILE I
   AST_IND IND+1:?AST$[I]
   INC J
   I=AST_NEXT[I]
  WEND
  AST_IND IND:?"DEF ARGS(OUT)"
  I=AST_NEXT[AST_A2[A]]
  WHILE I
   AST_IND IND+1:?AST$[I]
   INC J
   I=AST_NEXT[I]
  WEND
  AST_IND IND:?"DEF STATEMENTS"
  DUMP_AST AST_A3[A],IND+1
 WHEN #AST_CALLFUNC
  I=AST_NEXT[AST_A1[A]]
  AST_IND IND:?"CALLFUNC ";AST$[A]
  INC IND
  AST_IND IND:?"CALLFUNC ARGS(IN)"
  WHILE I
   DUMP_AST AST_A1[I],IND+1
   INC J
   I=AST_NEXT[I]
  WEND
  I=AST_NEXT[AST_A2[A]]
  AST_IND IND:?"CALLFUNC ARGS(OUT)"
  WHILE I
   DUMP_AST AST_A1[I],IND+1
   INC J
   I=AST_NEXT[I]
  WEND
 WHEN #AST_CALLFUNCEXPR
  I=AST_NEXT[AST_A1[A]]
  AST_IND IND:?"CALLFUNCEXPR ";AST$[A]
  WHILE I
   DUMP_AST AST_A1[I],IND+1
   INC J
   I=AST_NEXT[I]
  WEND
 WHEN #AST_LABEL
  AST_IND IND:?"LABEL ";AST$[A]
 WHEN #AST_DATA
  I=AST_NEXT[AST_A1[A]]
  AST_IND IND:?"DATA"
  WHILE I
   DUMP_AST AST_A1[I],IND+1
   INC J
   I=AST_NEXT[I]
  WEND
 WHEN #AST_RETURN
  AST_IND IND:?"RETURN FROM SUBROUTINE"
 WHEN #AST_RETURNFUNC
  AST_IND IND:?"RETURN FROM FUNCTION"
  DUMP_AST AST_LEFT[A],IND+1
 WHEN #AST_OPTIONSTRICT
  AST_IND IND:?"OPTION STRICT"
 WHEN #AST_OPTIONDEFINT
  AST_IND IND:?"OPTION DEFINT"
 WHEN #AST_END
  AST_IND IND:?"END"
 WHEN #AST_CALLSPRITE
  AST_IND IND:?"CALL SPRITE"
 WHEN #AST_CALLTEXT
  AST_IND IND:?"CALL TEXT"
 WHEN #AST_DEFVAR
  AST_IND IND:?"VAR DEFINITION"
  I=AST_NEXT[AST_A1[A]]
  INC IND
  WHILE I
   AST_IND IND:?"VAR DEFINITION ";AST$[I]
   DUMP_AST AST_A1[I],IND+1
   IF AST_A2[I] THEN
    AST_IND IND:?"ARRAY DIMENSIONS ";AST$[I]
    J=AST_NEXT[AST_A2[I]]
    WHILE J
     DUMP_AST AST_A1[J],IND+2
     J=AST_NEXT[J]
    WEND
   ENDIF
   IF AST_A3[I]THEN
    AST_IND IND:?"ARRAY INITIALIZER ";AST$[I]
    J=AST_NEXT[AST_A3[I]]
    WHILE J
     DUMP_AST AST_A1[J],IND+2
     J=AST_NEXT[J]
    WEND
   ENDIF
   I=AST_NEXT[I]
  WEND
 WHEN #AST_CONST
  I=AST_NEXT[AST_A1[A]]
  INC IND
  WHILE I
   AST_IND IND:?"CONSTANT DEFINITION ";AST$[I]
   DUMP_AST AST_A1[I],IND+1
   I=AST_NEXT[I]
  WEND
 WHEN #AST_ENUM
  I=AST_NEXT[AST_A1[A]]
  INC IND
  WHILE I
   AST_IND IND:?"ENUM DEFINITION ";AST$[I]
   DUMP_AST AST_A1[I],IND+1
   I=AST_NEXT[I]
  WEND
 WHEN #AST_WHILE
  AST_IND IND:?"WHILE"
  DUMP_AST AST_A1[A],IND+1
  DUMP_AST AST_A2[A],IND+1
 OTHERWISE
  AST_IND IND:?AST_STR$(AST_TYP[A])
 ENDCASE
END
DEF TYPE_IS_NUM(V)
 RETURN TYPEOF(V)==#T_INT||TYPEOF(V)==#T_REAL
END
DEF GDEBUG_EVAL(IN$)
 INIT_LEXER IN$
 INIT_AST
 INIT_PARSER VM_GET_SLOT()
 LEX_NEXT OUT ,
 VAR AST=PARSE_EXPR()
 RETURN GDEBUG_EVAL_AST(AST)
END
DEF GDEBUG_EVAL_VAR(NAME$)
 VAR VNAME$,VIDX
 VAR CURRENT_FRAME=GDEBUG_CURRENT_FRAME
 VAR BP,FUNC
 VAR I,L
 IF MID$(NAME$,0,1)=="#"THEN
  VMDBG_GET_SLOT_CONST_LIST VM_GET_SLOT() OUT VNAME$,VIDX
  L=LAST(VNAME$)
  FOR I=0TO L
   IF VNAME$[I]==NAME$ THEN
    RETURN VMDBG_GET_SLOT_CONST(VM_GET_SLOT(),VIDX[I])
   ENDIF
  NEXT
  RETURN
 ENDIF
 NAME$=TO_UPPER$(NAME$)
 VMDBG_FIND_FRAME CURRENT_FRAME OUT FUNC,BP,,
 'BINARY SEARCH?
 VMDBG_GET_VAR_LIST FUNC,BP OUT VNAME$,VIDX
 L=LAST(VNAME$)
 FOR I=0TO L
  IF VNAME$[I]==NAME$ THEN
   RETURN VMDBG_GET_VAR(FUNC,BP,VIDX[I])
  ENDIF
 NEXT
 VMDBG_GET_VAR_LIST 0,0 OUT VNAME$,VIDX
 L=LAST(VNAME$)
 FOR I=0TO L
  IF VNAME$[I]==NAME$ THEN
   RETURN VMDBG_GET_VAR(0,0,VIDX[I])
  ENDIF
 NEXT
END
DEF GDEBUG_EVAL_ARRAY(A,L)
 VAR I=AST_NEXT[AST_RIGHT[A]]
 VAR CNT=AST_GET_ITEM_COUNT(AST_RIGHT[A])
 IF CNT<1||CNT>4 THEN
  RETURN'FIXME:ERR
 ENDIF
 IF TYPEOF(L)!=#T_INTARRAY&&TYPEOF(L)!=#T_REALARRAY&&TYPEOF(L)!=#T_STRARRAY&&TYPEOF(L)!=#T_STR THEN
  RETURN'FIXME:ERR
 ENDIF
 IF CNT!=1&&(TYPEOF(L)==#T_STR||DIM(L)!=CNT) THEN
  RETURN'FIXME:ERR
 ENDIF
 DIM IDX%[CNT]
 VAR J=0
 WHILE I
  VAR V=GDEBUG_EVAL_AST(AST_A1[I])
  IF TYPEOF(V)!=#T_INT&&TYPEOF(V)!=#T_REAL THEN
   RETURN'FIXME:ERR
  ENDIF
  IF CNT==1&&J==0THEN
   IF LEN(L)<=V THEN
    RETURN'FIXME:ERR
   ENDIF
  ELSEIF DIM(L,J)<=V THEN
   RETURN'FIXME:ERR
  ENDIF
  IDX%[J]=V
  INC J
  I=AST_NEXT[I]
 WEND
 CASE CNT
 WHEN 1
  RETURN L[IDX%[0]]
 WHEN 2
  RETURN L[IDX%[0],IDX%[1]]
 WHEN 3
  RETURN L[IDX%[0],IDX%[1],IDX%[2]]
 WHEN 4
  RETURN L[IDX%[0],IDX%[1],IDX%[2],IDX%[3]]
 ENDCASE
END
DEF GDEBUG_EVAL_FUNC(A)
 VAR I=AST_NEXT[AST_A1[A]]
 VAR FUNC$=AST$[A]
 VAR V0,V1,V2,V3,V4,V5,V6,V7,V8,V9,VA,VB,VC,VD,VE,VF
 VAR INDEX=0
 VAR F$=NOT_USED_SLOT$+FUNC$
 IF!CHKCALL(F$)THEN
  V0=FUNC$
  F$=VMDBG_CALL_FUNC$()
  INC INDEX
 ENDIF
 WHILE I
  VAR V=GDEBUG_EVAL_AST(AST_A1[I])
  VAR("V"+HEX$(INDEX))=V
  INC INDEX
  I=AST_NEXT[I]
 WEND
 CASE INDEX
 WHEN 0
  RETURN CALL(F$)
 WHEN 1
  RETURN CALL(F$,V0)
 WHEN 2
  RETURN CALL(F$,V0,V1)
 WHEN 3
  RETURN CALL(F$,V0,V1,V2)
 WHEN 4
  RETURN CALL(F$,V0,V1,V2,V3)
 WHEN 5
  RETURN CALL(F$,V0,V1,V2,V3,V4)
 WHEN 6
  RETURN CALL(F$,V0,V1,V2,V3,V4,V5)
 WHEN 7
  RETURN CALL(F$,V0,V1,V2,V3,V4,V5,V6)
 WHEN 8
  RETURN CALL(F$,V0,V1,V2,V3,V4,V5,V6,V7)
 WHEN 9
  RETURN CALL(F$,V0,V1,V2,V3,V4,V5,V6,V7,V8)
 WHEN 10
  RETURN CALL(F$,V0,V1,V2,V3,V4,V5,V6,V7,V8,V9)
 WHEN 11
  RETURN CALL(F$,V0,V1,V2,V3,V4,V5,V6,V7,V8,V9,VA)
 WHEN 12
  RETURN CALL(F$,V0,V1,V2,V3,V4,V5,V6,V7,V8,V9,VA,VB)
 WHEN 13
  RETURN CALL(F$,V0,V1,V2,V3,V4,V5,V6,V7,V8,V9,VA,VB,VC)
 WHEN 14
  RETURN CALL(F$,V0,V1,V2,V3,V4,V5,V6,V7,V8,V9,VA,VB,VC,VD)
 WHEN 15
  RETURN CALL(F$,V0,V1,V2,V3,V4,V5,V6,V7,V8,V9,VA,VB,VC,VD,VE)
 WHEN 16
  RETURN CALL(F$,V0,V1,V2,V3,V4,V5,V6,V7,V8,V9,VA,VB,VC,VD,VE,VF)
 ENDCASE
END
DEF GDEBUG_EVAL_AST(A)
 CASE AST_TYP[A]
 WHEN #AST_IMM_INT
  RETURN AST%[A]
 WHEN #AST_IMM_DBL
  RETURN AST#[A]
 WHEN #AST_IMM_STR
  RETURN AST$[A]
 WHEN #AST_UNAOP
  VAR L=GDEBUG_EVAL_AST(AST_LEFT[A])
  IF TYPE_IS_NUM(L) THEN
   CASE AST%[A]
   WHEN #TKN_LNOT
    RETURN (!L)
   WHEN #TKN_MINUS
    RETURN (-L)
   WHEN #TKN_NOT
    RETURN (NOT L)
   ENDCASE
  ELSE
   'ERR
   GDEBUG_EVAL_ERR
  ENDIF
 WHEN #AST_CONSTVAR
  RETURN GDEBUG_EVAL_VAR(AST$[A])
 WHEN #AST_VAR
  RETURN GDEBUG_EVAL_VAR(AST$[A])
 WHEN #AST_CALLFUNCEXPR
  RETURN GDEBUG_EVAL_FUNC(A)
 WHEN #AST_BINOP
  L=GDEBUG_EVAL_AST(AST_LEFT[A])
  IF AST%[A]==#TKN_LB THEN
   RETURN GDEBUG_EVAL_ARRAY(A,L)
  ENDIF
  VAR R=GDEBUG_EVAL_AST(AST_RIGHT[A])
  VAR LV=L,RV=R
  CASE AST%[A]
  WHEN #TKN_PLUS
   IF (TYPE_IS_NUM(L)&&TYPE_IS_NUM(R))||(TYPEOF(L)==#T_STR&&TYPEOF(R)==#T_STR)THEN
    RETURN (LV+RV)
   ENDIF
  WHEN #TKN_MINUS
   IF TYPE_IS_NUM(L)&&TYPE_IS_NUM(R)THEN
    RETURN (LV-RV)
   ENDIF
  WHEN #TKN_MUL
   IF TYPE_IS_NUM(R)&&(TYPE_IS_NUM(L)||TYPEOF(L)==#T_STR)THEN
    RETURN (LV*RV)
   ENDIF
  WHEN #TKN_DIV
   IF TYPE_IS_NUM(L)&&TYPE_IS_NUM(R)THEN
    RETURN (LV/RV)
   ENDIF
  WHEN #TKN_DIVINT
   IF TYPE_IS_NUM(L)&&TYPE_IS_NUM(R)THEN
    RETURN (LV DIV RV)
   ENDIF
  WHEN #TKN_MOD
   IF TYPE_IS_NUM(L)&&TYPE_IS_NUM(R)THEN
    RETURN (LV MOD RV)
   ENDIF
  WHEN #TKN_AND
   IF TYPE_IS_NUM(L)&&TYPE_IS_NUM(R)THEN
    RETURN (LV AND RV)
   ENDIF
  WHEN #TKN_OR
   IF TYPE_IS_NUM(L)&&TYPE_IS_NUM(R)THEN
    RETURN (LV OR RV)
   ENDIF
  WHEN #TKN_EQ
   IF (TYPE_IS_NUM(L)&&TYPE_IS_NUM(R))||(TYPEOF(L)==#T_STR&&TYPEOF(R)==#T_STR)THEN
    RETURN (LV==RV)
   ENDIF
  WHEN #TKN_NEQ
   IF (TYPE_IS_NUM(L)&&TYPE_IS_NUM(R))||(TYPEOF(L)==#T_STR&&TYPEOF(R)==#T_STR)THEN
    RETURN (LV!=RV)
   ENDIF
  WHEN #TKN_LSHIFT
   IF TYPE_IS_NUM(L)&&TYPE_IS_NUM(R)THEN
    RETURN (LV<<RV)
   ENDIF
  WHEN #TKN_RSHIFT
   IF TYPE_IS_NUM(L)&&TYPE_IS_NUM(R)THEN
    RETURN (LV>>RV)
   ENDIF
  WHEN #TKN_GREAT
   IF (TYPE_IS_NUM(L)&&TYPE_IS_NUM(R))||(TYPEOF(L)==#T_STR&&TYPEOF(R)==#T_STR)THEN
    RETURN (LV<RV)
   ENDIF
  WHEN #TKN_LESS
   IF (TYPE_IS_NUM(L)&&TYPE_IS_NUM(R))||(TYPEOF(L)==#T_STR&&TYPEOF(R)==#T_STR)THEN
    RETURN (LV>RV)
   ENDIF
  WHEN #TKN_GEQ
   IF (TYPE_IS_NUM(L)&&TYPE_IS_NUM(R))||(TYPEOF(L)==#T_STR&&TYPEOF(R)==#T_STR)THEN
    RETURN (LV<=RV)
   ENDIF
  WHEN #TKN_LEQ
   IF (TYPE_IS_NUM(L)&&TYPE_IS_NUM(R))||(TYPEOF(L)==#T_STR&&TYPEOF(R)==#T_STR)THEN
    RETURN (LV>=RV)
   ENDIF
  ENDCASE
 ENDCASE
END

VAR PARSER_RETURN_EXPR
VAR PARSER_IN_FUNC
VAR PARSER_HAS_ERR
VAR PARSER_SLOT
DEF INIT_PARSER SLOT
 PARSER_SLOT=SLOT
 PARSER_RETURN_EXPR=#FALSE
 PARSER_IN_FUNC=#FALSE
 PARSER_HAS_ERR=#FALSE
END
DEF PARSER_HAS_ERROR()
 RETURN PARSER_HAS_ERR
END
DEF PARSE()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LEX_NEXT OUT T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_EOF THEN
   RETURN ROOT
  ENDIF
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_STATEMENT()
 LOOP
  VAR T
  LEX_CUR OUT T,
  CASE T
  WHEN #TKN_TPRINT
   RETURN PARSE_PRINT(#TRUE)
  WHEN #TKN_PRINT
   RETURN PARSE_PRINT(#FALSE)
  WHEN #TKN_IDEN
   RETURN PARSE_IDEN()
  WHEN #TKN_IF
   RETURN PARSE_IF()
  WHEN #TKN_FOR
   RETURN PARSE_FOR()
  WHEN #TKN_BREAK
   LEX_NEXT OUT ,
   RETURN NEW_AST(#AST_BREAK)
  WHEN #TKN_CONTINUE
   LEX_NEXT OUT ,
   RETURN NEW_AST(#AST_CONTINUE)
  WHEN #TKN_REPEAT
   RETURN PARSE_REPEAT()
  WHEN #TKN_WHILE
   RETURN PARSE_WHILE()
  WHEN #TKN_LOOP
   RETURN PARSE_LOOP()
  WHEN #TKN_LABEL
   RETURN PARSE_LABEL()
  WHEN #TKN_GOTO
   RETURN PARSE_GOTO()
  WHEN #TKN_GOSUB
   RETURN PARSE_GOSUB()
  WHEN #TKN_ON
   RETURN PARSE_ON()
  WHEN #TKN_RETURN
   RETURN PARSE_RETURN()
  WHEN #TKN_DATA
   RETURN PARSE_DATA()
  WHEN #TKN_RESTORE
   RETURN PARSE_RESTORE()
  WHEN #TKN_VAR
  WHEN #TKN_DIM
  WHEN #TKN_CONST
  WHEN #TKN_ENUM
   RETURN PARSE_VAR()
  WHEN #TKN_INSPECT
   VAR AST=NEW_AST(#AST_CALLFUNC)
   LEX_NEXT OUT ,
   RETURN PARSE_CALLFUNC(AST,"INSPECT",#FALSE)
  WHEN #TKN_CALL
   RETURN PARSE_CALL()
  WHEN #TKN_EXEC
   RETURN PARSE_EXEC()
  WHEN #TKN_DEFOUT
   RETURN PARSE_DEFOUT()
  WHEN #TKN_COMMON
  WHEN #TKN_DEF
   RETURN PARSE_DEF()
  WHEN #TKN_END
   RETURN PARSE_END()
  WHEN #TKN_READ
   RETURN PARSE_READ()
  WHEN #TKN_DEC
  WHEN #TKN_INC
   RETURN PARSE_INC()
  WHEN #TKN_CASE
   RETURN PARSE_CASE()
  WHEN #TKN_SWAP
   RETURN PARSE_SWAP()
  WHEN #TKN_INPUT
   RETURN PARSE_INPUT()
  WHEN #TKN_LINPUT
   RETURN PARSE_LINPUT()
  WHEN #TKN_LP
   RETURN PARSE_ASSIGN_EXPR()
  WHEN #TKN_ENDIF
   PARSER_ENDIF_WITHOUT_IF
   GOTO @ERR
  WHEN #TKN_WEND
   PARSER_WEND_WITHOUT_WHILE
   GOTO @ERR
  WHEN #TKN_UNTIL
   PARSER_UNTIL_WITHOUT_REPEAT
   GOTO @ERR
  WHEN #TKN_ENDCASE
   PARSER_ENDCASE_WITHOUT_CASE
   GOTO @ERR
  WHEN #TKN_WHEN
   PARSER_WHEN_WITHOUT_CASE
   GOTO @ERR
  WHEN #TKN_ENDLOOP
   PARSER_ENDLOOP_WITHOUT_LOOP
   GOTO @ERR
  ENDCASE
  PARSER_SYNTAX_ERROR "(STATEMENT)"
  IF T==#TKN_EOF THEN RETURN 0
  @ERR
  LEX_NEXT OUT ,
 ENDLOOP
END
DEF PARSE_ASSIGN_EXPR()
 VAR AST=NEW_AST(#AST_ASSIGN)
 VAR EXPR=PARSE_EXPR()
 VAR T,V
 LEX_CUR OUT T,V
 IF T!=#TKN_ASSIGN THEN
  PARSER_SYNTAX_ERROR "EXPECTED '='(ASSIGN)"
  RETURN AST
 ENDIF
 RETURN PARSE_ASSIGN(AST,EXPR)
END
DEF PARSE_DEFOUT()
 VAR AST=NEW_AST(#AST_DEFOUT)
 IF!PARSER_IN_FUNC THEN
  CANT_USE_OUTSIDE_DEF "DEFOUT"
 ENDIF
 VAR T,V
 LEX_NEXT OUT ,
 AST_A1[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T!=#TKN_COMMA THEN
  PARSER_SYNTAX_ERROR "EXPECTED ','"
  RETURN AST
 ENDIF
 LEX_NEXT OUT ,
 AST_A2[AST]=PARSE_EXPR()
 AST_SET_POS_END AST
 RETURN AST
END
DEF PARSE_EXEC()
 VAR AST=NEW_AST(#AST_EXEC)
 VAR T,V
 LEX_NEXT OUT ,
 AST_A1[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T!=#TKN_COMMA THEN
  AST_SET_POS_END AST
  RETURN AST
 ENDIF
 LEX_NEXT OUT ,
 AST_A2[AST]=PARSE_EXPR()
 AST_SET_POS_END AST
 RETURN AST
END
DEF PARSE_INPUT()
 VAR AST=NEW_AST(#AST_INPUT)
 VAR T,V
 LEX_NEXT OUT ,
 VAR GUIDE_EXPR=PARSE_EXPR()
 AST_A1[AST]=GUIDE_EXPR
 LEX_CUR OUT T,V
 VAR ITEM=NEW_AST(#AST_ITEM)
 VAR P=ITEM
 VAR FIRST=ITEM
 AST_A2[AST]=ITEM
 IF T==#TKN_SEMI THEN
  AST_A3[AST]=#TRUE
 ELSEIF T==#TKN_COMMA THEN
  AST_A3[AST]=#FALSE
  IF AST_TYP[GUIDE_EXPR]!=#AST_IMM_STR THEN
   AST_A1[AST]=0
   ITEM=NEW_AST(#AST_ITEM)
   AST_NEXT[P]=ITEM
   AST_PREV[ITEM]=P
   P=ITEM
   AST_A1[ITEM]=GUIDE_EXPR
  ENDIF
 ELSE
  AST_A1[AST]=0
  ITEM=NEW_AST(#AST_ITEM)
  AST_NEXT[P]=ITEM
  AST_PREV[ITEM]=P
  P=ITEM
  AST_A1[ITEM]=GUIDE_EXPR
  AST_PREV[FIRST]=P
  RETURN AST
 ENDIF
 LOOP
  LEX_NEXT OUT ,
  VAR EXPR=PARSE_EXPR()
  ITEM=NEW_AST(#AST_ITEM)
  AST_NEXT[P]=ITEM
  AST_PREV[ITEM]=P
  P=ITEM
  AST_A1[ITEM]=EXPR
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN
   BREAK
  ENDIF
 ENDLOOP
 AST_PREV[FIRST]=P
 AST_SET_POS_END AST
 RETURN AST
END
DEF PARSE_LINPUT()
 VAR AST=NEW_AST(#AST_LINPUT)
 LEX_NEXT OUT ,
 VAR EXPR=PARSE_EXPR()
 VAR T,V
 LEX_CUR OUT T,V
 IF T==#TKN_SEMI THEN
  LEX_NEXT OUT ,
  AST_A1[AST]=EXPR
  AST_A2[AST]=PARSE_EXPR()
 ELSE
  AST_A2[AST]=EXPR
 ENDIF
 AST_SET_POS_END AST
 RETURN AST
END
DEF PARSE_SWAP()
 VAR AST=NEW_AST(#AST_SWAP)
 LEX_NEXT OUT ,
 AST_LEFT[AST]=PARSE_EXPR()
 VAR T,V
 LEX_CUR OUT T,V
 IF T!=#TKN_COMMA THEN
  PARSER_SYNTAX_ERROR "EXPECTED ','"
  RETURN AST
 ENDIF
 LEX_NEXT OUT ,
 AST_RIGHT[AST]=PARSE_EXPR()
 AST_SET_POS_END AST
 RETURN AST
END
DEF PARSE_CASE()
 VAR AST=NEW_AST(#AST_CASE)
 VAR T,V
 LEX_NEXT OUT ,
 AST_A1[AST]=PARSE_EXPR()
 AST_SET_POS_END AST
 VAR ITEM=NEW_AST(#AST_ITEM)
 VAR P=ITEM
 AST_A2[AST]=ITEM
 VAR HAS_OTHERWISE
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_COL||T==#TKN_NEWLINE THEN
   LEX_NEXT OUT ,
   CONTINUE
  ENDIF
  IF T==#TKN_WHEN THEN
   IF HAS_OTHERWISE THEN
    PARSER_SYNTAX_ERROR "EXPECTED 'ENDCASE', ':' or '\n'"
   ENDIF
   ITEM=NEW_AST(#AST_ITEM)
   LEX_NEXT OUT ,
   AST_NEXT[P]=ITEM
   P=ITEM
   AST_A1[ITEM]=PARSE_EXPR()
   AST_SET_POS_END ITEM
   AST_A2[ITEM]=PARSE_WHEN_STATEMENTS()
  ELSEIF T==#TKN_OTHERWISE THEN
   ITEM=NEW_AST(#AST_ITEM)
   LEX_NEXT OUT ,
   HAS_OTHERWISE=#TRUE
   AST_NEXT[P]=ITEM
   P=ITEM
   AST_A2[ITEM]=PARSE_WHEN_STATEMENTS()
  ELSEIF T==#TKN_ENDCASE THEN
   LEX_NEXT OUT ,
   BREAK
  ELSE
   PARSER_SYNTAX_ERROR "EXPECTED 'WHEN', 'OTHERWISE', 'ENDCASE', ':' or '\n'"
  ENDIF
 ENDLOOP
 RETURN AST
END

DEF PARSE_WHEN_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_ENDCASE THEN RETURN ROOT
  IF T==#TKN_WHEN THEN RETURN ROOT
  IF T==#TKN_OTHERWISE THEN RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'WEND', 'ENDCASE' or 'OTHERWISE', but EOF"
   RETURN ROOT
  ENDIF
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_INC()
 VAR T,V,AST
 LEX_CUR OUT T,V
 IF T==#TKN_INC THEN
  AST=NEW_AST(#AST_INC)
 ELSE
  AST=NEW_AST(#AST_DEC)
 ENDIF
 LEX_NEXT OUT ,
 AST_LEFT[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T==#TKN_COMMA THEN
  LEX_NEXT OUT ,
  AST_RIGHT[AST]=PARSE_EXPR()
 ENDIF
 AST_SET_POS_END AST
 RETURN AST
END
DEF PARSE_READ()
 VAR T,V
 VAR AST=NEW_AST(#AST_READ)
 VAR P=NEW_AST(#AST_ITEM)
 AST_A1[AST]=P
 LOOP
  LEX_NEXT OUT ,
  VAR EXPR=PARSE_EXPR()
  VAR ITEM=NEW_AST(#AST_ITEM)
  AST_A1[ITEM]=EXPR
  AST_NEXT[P]=ITEM
  P=ITEM
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN
   BREAK
  ENDIF
 ENDLOOP
 AST_SET_POS_END AST
 RETURN AST
END
DEF PARSE_IDEN()
 VAR T,NAME$,V
 VAR AST=NEW_AST(#AST_CALLFUNC)
 LEX_CUR OUT T,NAME$
 IF NAME$=="OPTION"THEN
  RETURN PARSE_OPTION(AST)
 ELSEIF NAME$=="STOP"THEN
  RETURN PARSE_STOP(AST)
 ENDIF
 VAR SI,SPI,SPI2,ST,SV,SL,SP,SPL,SPP
 LEX_SAVE OUT SI,SPI,SPI2,ST,SV,SL,SP,SPL,SPP
 VAR EXPR=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T==#TKN_ASSIGN THEN
  RETURN PARSE_ASSIGN(AST,EXPR)
 ELSE
  LEX_LOAD SI,SPI,SPI2,ST,SV,SL,SP,SPL,SPP
  RETURN PARSE_CALLFUNC(AST,NAME$,#TRUE)
 ENDIF
 'IDEN=EXPR
 'IDEN [EXPR,EXPR...] [OUT REF-EXPR...]
END
DEF PARSE_STOP(AST)
 AST_TYP[AST]=#AST_STOP
 VAR T,V
 LEX_NEXT OUT T,V
 IF IS_EXPR_TKN(T)THEN
  AST_A1[AST]=PARSE_EXPR()
 ENDIF
 RETURN AST
END
DEF PARSE_OPTION(AST)
 VAR T,V
 LEX_NEXT OUT T,V
 IF T==#TKN_IDEN&&TO_UPPER$(V)=="STRICT"THEN
  LEX_NEXT OUT T,V
  AST_TYP[AST]=#AST_OPTIONSTRICT
  RETURN AST
 ELSEIF T==#TKN_IDEN&&TO_UPPER$(V)=="DEFINT"THEN
  LEX_NEXT OUT T,V
  AST_TYP[AST]=#AST_OPTIONDEFINT
  RETURN AST
 ENDIF
 PARSER_SYNTAX_ERROR "EXPECTED 'STRICT' or 'DEFINT' (OPTION)"
END
DEF PARSE_RESTORE()
 VAR T,V,AST
 LEX_NEXT OUT T,V
 IF T==#TKN_LABEL THEN
  AST=NEW_AST(#AST_RESTORE)
  AST$[AST]=V
  LEX_NEXT OUT T,V
 ELSEIF IS_EXPR_TKN(T) THEN
  AST=NEW_AST(#AST_RESTOREEXPR)
  AST_LEFT[AST]=PARSE_EXPR()
 ELSE
  AST=NEW_AST(#AST_RESTORE)
 ENDIF
 RETURN AST
END
DEF PARSE_CALL()
 VAR T,V
 VAR AST=NEW_AST(#AST_CALLFUNC)
 LEX_NEXT OUT T,V
 IF T==#TKN_IDEN&&TO_UPPER$(V)=="SPRITE"THEN
  LEX_NEXT OUT T,V
  AST_TYP[AST]=#AST_CALLSPRITE
  AST_SET_POS_END AST
  RETURN AST
 ELSEIF T==#TKN_IDEN&&TO_UPPER$(V)=="TEXT"THEN
  LEX_NEXT OUT T,V
  AST_TYP[AST]=#AST_CALLTEXT
  AST_SET_POS_END AST
  RETURN AST
 ELSE
  RETURN PARSE_CALLFUNC(AST,"CALL",#FALSE)
 ENDIF
END
DEF PARSE_CALLFUNC(AST,NAME$,NXT)
 VAR T,V
 'A1:IN ARGS
 'A2:OUT ARGS
 VAR P=NEW_AST(#AST_ITEM)
 AST_A1[AST]=P
 AST$[AST]=NAME$
 VAR FIRST=P
 IF TRACE THEN ?"callfunc",NAME$
 VAR FRST=#TRUE,ITEM
 VAR EXPR
 LOOP
  IF NXT THEN
   LEX_NEXT OUT T,V
  ELSE
   LEX_CUR OUT T,V
   NXT=#TRUE
  ENDIF
  IF T==#TKN_COMMA THEN
   EXPR=NEW_AST(#AST_EMPTYEXPR)
  ELSEIF!IS_EXPR_TKN(T) THEN
   IF !FRST THEN
    EXPR=NEW_AST(#AST_EMPTYEXPR)
    ITEM=NEW_AST(#AST_ITEM)
    AST_PREV[ITEM]=P
    AST_A1[ITEM]=EXPR
    AST_NEXT[P]=ITEM
    P=ITEM
   ENDIF
   BREAK
  ELSE
   EXPR=PARSE_EXPR()
  ENDIF
  FRST=#FALSE
  ITEM=NEW_AST(#AST_ITEM)
  AST_A1[ITEM]=EXPR
  AST_PREV[ITEM]=P
  AST_NEXT[P]=ITEM
  LEX_CUR OUT T,V
  P=ITEM
  IF T!=#TKN_COMMA THEN
   BREAK
  ENDIF
 ENDLOOP
 AST_PREV[FIRST]=P
 IF T!=#TKN_OUT THEN
  AST_SET_POS_END AST
  RETURN AST
 ENDIF
 P=NEW_AST(#AST_ITEM)
 AST_A2[AST]=P
 FIRST=P
 FRST=#TRUE
 LOOP
  IF NXT THEN
   LEX_NEXT OUT T,V
  ELSE
   LEX_CUR OUT T,V
   NXT=#TRUE
  ENDIF
  IF T==#TKN_COMMA THEN
   EXPR=NEW_AST(#AST_EMPTYEXPR)
  ELSEIF!IS_EXPR_TKN(T) THEN
   IF !FRST THEN
    EXPR=NEW_AST(#AST_EMPTYEXPR)
    ITEM=NEW_AST(#AST_ITEM)
    AST_PREV[ITEM]=P
    AST_A1[ITEM]=EXPR
    AST_NEXT[P]=ITEM
    P=ITEM
   ENDIF
   BREAK
  ELSE
   EXPR=PARSE_EXPR()
  ENDIF
  FRST=#FALSE
  ITEM=NEW_AST(#AST_ITEM)
  AST_A1[ITEM]=EXPR
  AST_PREV[ITEM]=P
  AST_NEXT[P]=ITEM
  LEX_CUR OUT T,V
  P=ITEM
  IF T!=#TKN_COMMA THEN
   BREAK
  ENDIF
 ENDLOOP
 AST_SET_POS_END AST
 AST_PREV[FIRST]=P
 RETURN AST
END
DEF PARSE_ASSIGN(AST,EXPR)
 AST_TYP[AST]=#AST_ASSIGN
 LEX_NEXT OUT ,
 AST_LEFT[AST]=EXPR
 IF TRACE THEN ?"assign
 AST_RIGHT[AST]=PARSE_EXPR()
 AST_SET_POS_END AST
 RETURN AST
END
DEF PARSE_IF()
 VAR AST=NEW_AST(#AST_IF)
 LEX_NEXT OUT ,
 VAR EXPR=PARSE_EXPR()
 VAR T,V
 LEX_CUR OUT T,V
 CASE T
 WHEN #TKN_GOTO
  AST_SET_POS_END AST
  RETURN PARSE_MULTILINE_IF(AST,EXPR,#FALSE)
 WHEN #TKN_THEN
  LEX_NEXT OUT T,V
  AST_SET_POS_END AST
  IF T==#TKN_NEWLINE THEN
   RETURN PARSE_MULTILINE_IF(AST,EXPR,#TRUE)
  ENDIF
  RETURN PARSE_MULTILINE_IF(AST,EXPR,#FALSE)
 OTHERWISE
  PARSER_SYNTAX_ERROR "EXPECTED 'THEN' or 'GOTO'"
 ENDCASE
END
'AST_A5->ENDIFのイチ
DEF PARSE_MULTILINE_IF(AST,EXPR,MULT)
 VAR THENSTMTS=PARSE_MULTILINE_IF_STATEMENTS(MULT,#FALSE)
 VAR T,V
 AST_A1[AST]=EXPR
 AST_A2[AST]=THENSTMTS
 LEX_CUR OUT T,V
 IF !MULT&&T==#TKN_NEWLINE THEN
  RETURN AST
 ENDIF
 VAR T2,V2
 IF T==#TKN_ENDIF THEN
  AST_A5[AST]=NEW_AST(#AST_ITEM)
  LEX_NEXT OUT T2,V2
  RETURN AST
 ENDIF
 IF T==#TKN_ELSE THEN
  LEX_NEXT OUT T2,V2
  AST_A4[AST]=PARSE_MULTILINE_ELSE_STATEMENTS(MULT,T2==#TKN_NEWLINE)
  LEX_CUR OUT T,V
  IF T==#TKN_ENDIF THEN
   LEX_NEXT OUT,
   AST_A5[AST]=NEW_AST(#AST_ITEM)
  ENDIF
  RETURN AST
 ENDIF
 IF T==#TKN_ELSEIF THEN
  VAR P=NEW_AST(#AST_ITEM)
  AST_A3[AST]=P
  LOOP
   VAR ITEM=NEW_AST(#AST_ITEM)
   AST_SET_POS ITEM
   LEX_NEXT OUT ,
   VAR ELIFEXPR=PARSE_EXPR()
   LEX_CUR OUT T,V
   IF T!=#TKN_THEN THEN'LEAK ITEM?
    PARSER_SYNTAX_ERROR "EXPECTED 'THEN'"
    RETURN AST
   ENDIF
   LEX_NEXT OUT T,V
   AST_SET_POS_END ITEM
   VAR M=T==#TKN_NEWLINE
   VAR ELIFSTMTS=PARSE_MULTILINE_IF_STATEMENTS(MULT,M)
   AST_A1[ITEM]=ELIFEXPR
   AST_A2[ITEM]=ELIFSTMTS
   AST_NEXT[P]=ITEM
   P=ITEM
   LEX_CUR OUT T,V
   IF !MULT&&T==#TKN_NEWLINE THEN
    RETURN AST
   ENDIF
   IF T==#TKN_ENDIF THEN
    AST_A5[AST]=NEW_AST(#AST_ITEM)
    LEX_NEXT OUT T2,V2
    RETURN AST
   ENDIF
   IF T==#TKN_ELSE THEN
    LEX_NEXT OUT T2,V2
    AST_A4[AST]=PARSE_MULTILINE_ELSE_STATEMENTS(MULT,T2==#TKN_NEWLINE)
    LEX_CUR OUT T,V
    IF T==#TKN_ENDIF THEN
     AST_A5[AST]=NEW_AST(#AST_ITEM)
     LEX_NEXT OUT,
    ENDIF
    RETURN AST
   ENDIF
  ENDLOOP
  RETURN AST
 ENDIF
 PARSER_SYNTAX_ERROR "EXPECTED 'ENDIF', 'ELSE' or 'ELSEIF'"
 RETURN AST
END
DEF PARSE_MULTILINE_IF_STATEMENTS(MULT,MULT_ELSEIF)
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LEX_CUR OUT T,V
 VAR S
 IF (!MULT||!MULT_ELSEIF)&&T==#TKN_LABEL THEN
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=NEW_AST_STR(#AST_GOTO,V)
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
  LEX_NEXT OUT ,
 ENDIF
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE&&!MULT THEN RETURN ROOT
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_ENDIF THEN RETURN ROOT
  IF T==#TKN_ELSE THEN RETURN ROOT
  IF T==#TKN_ELSEIF THEN RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'ENDIF', 'ELSE' or 'ELSEIF'"
   RETURN ROOT
  ENDIF
  S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_MULTILINE_ELSE_STATEMENTS(MULT,MULT_ELSE)
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 VAR S
 LEX_CUR OUT T,V
 IF (!MULT||!MULT_ELSE)&&T==#TKN_LABEL THEN
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=NEW_AST_STR(#AST_GOTO,V)
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
  LEX_NEXT OUT ,
 ENDIF
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE&&!MULT THEN RETURN ROOT
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_ENDIF THEN RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'ENDIF'"
   RETURN ROOT
  ENDIF
  S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_FOR_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_NEXT THEN RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'NEXT'"
   RETURN ROOT
  ENDIF
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_FOR()
 'A1:INDEXREFEXPR
 'A2:INITEXPR
 'A3:TOEXPR
 'A4:STEPEXPR
 'A5:STATEMENTS
 VAR T,V
 VAR AST=NEW_AST(#AST_FOR)
 LEX_NEXT OUT ,
 'REFEXPR
 AST_A1[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T!=#TKN_ASSIGN THEN
  PARSER_SYNTAX_ERROR "EXPECTED '='"
 ENDIF
 LEX_NEXT OUT ,
 'INITEXPR
 AST_A2[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T!=#TKN_IDEN||V!="TO" THEN
  PARSER_SYNTAX_ERROR "EXPECTED 'TO'"
 ENDIF
 LEX_NEXT OUT ,
 'TOEXPR
 AST_A3[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T==#TKN_IDEN&&V=="STEP" THEN
  LEX_NEXT OUT ,
  'STEPEXPR
  AST_A4[AST]=PARSE_EXPR()
 ENDIF
 AST_SET_POS_END AST
 AST_A5[AST]=PARSE_FOR_STATEMENTS()
 LEX_NEXT OUT T,V
 'NEXT [IDEN]
 'NEXT IDEN1,IDEN2 NOT ALLOWED
 IF T==#TKN_IDEN THEN LEX_NEXT OUT ,
 RETURN AST
END

DEF PARSE_WHILE()
 VAR AST=NEW_AST(#AST_WHILE)
 VAR T,V
 LEX_NEXT OUT ,
 AST_A1[AST]=PARSE_EXPR()
 AST_A2[AST]=PARSE_WHILE_STATEMENTS()
 RETURN AST
END
DEF PARSE_WHILE_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_WEND THEN LEX_NEXT OUT,:RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'WEND'"
   RETURN ROOT
  ENDIF
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END

DEF PARSE_REPEAT()
 VAR AST=NEW_AST(#AST_REPEAT)
 VAR T,V
 LEX_NEXT OUT ,
 AST_A2[AST]=PARSE_REPEAT_STATEMENTS()
 AST_SET_POS AST
 LEX_NEXT OUT ,
 AST_A1[AST]=PARSE_EXPR()
 AST_SET_POS_END AST
 RETURN AST
END
DEF PARSE_REPEAT_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_UNTIL THEN RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'UNTIL'"
   RETURN ROOT
  ENDIF
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_LOOP()
 VAR AST=NEW_AST(#AST_LOOP)
 VAR T,V
 LEX_NEXT OUT ,
 AST_A2[AST]=PARSE_LOOP_STATEMENTS()
 RETURN AST
END
DEF PARSE_LOOP_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_ENDLOOP THEN LEX_NEXT OUT ,:RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'ENDLOOP'"
   RETURN ROOT
  ENDIF
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_LABEL()
 VAR T,V
 VAR AST=NEW_AST(#AST_LABEL)
 LEX_CUR OUT T,V
 LEX_NEXT OUT ,
 AST$[AST]=V
 RETURN AST
END
DEF PARSE_GOTO()
 VAR T,V,AST
 AST=NEW_AST(#AST_GOTO)
 LEX_NEXT OUT T,V
 IF T==#TKN_LABEL THEN
  AST$[AST]=V
  LEX_NEXT OUT T,V
  AST_SET_POS_END AST
 ELSE
  AST_TYP[AST]=#AST_GOTOEXPR
  AST_LEFT[AST]=PARSE_EXPR()
  AST_SET_POS_END AST
 ENDIF
 RETURN AST
END
DEF PARSE_GOSUB()
 VAR T,V,AST
 AST=NEW_AST(#AST_GOSUB)
 LEX_NEXT OUT T,V
 IF T==#TKN_LABEL THEN
  AST$[AST]=V
  LEX_NEXT OUT T,V
  AST_SET_POS_END AST
 ELSE
  AST_TYP[AST]=#AST_GOSUBEXPR
  AST_LEFT[AST]=PARSE_EXPR()
  AST_SET_POS_END AST
 ENDIF
 RETURN AST
END
DEF PARSE_ON()
 VAR T,V,AST
 LEX_NEXT OUT T,V
 IF T==#TKN_BREAK THEN
  LEX_NEXT OUT T,V
  IF T!=#TKN_GOTO THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'GOTO' (ON BREAK GOTO)"
   RETURN AST
  ENDIF
  LEX_NEXT OUT T,V
  IF T==#TKN_LABEL THEN
   AST=NEW_AST(#AST_ONBREAKGOTO)
   AST$[AST]=V
   LEX_NEXT OUT T,V
  ELSE
   AST=NEW_AST(#AST_ONBREAKGOTOEXPR)
   AST_LEFT[AST]=PARSE_EXPR()
  ENDIF
 ELSE
  VAR EXPR=PARSE_EXPR()
  LEX_CUR OUT T,V
  IF T==#TKN_GOTO THEN
   AST=NEW_AST(#AST_ONGOTO)
  ELSEIF T==#TKN_GOSUB THEN
   AST=NEW_AST(#AST_ONGOSUB)
  ELSE
   PARSER_SYNTAX_ERROR "EXPECTED 'GOTO' or 'GOSUB'(ON GOTO)"
   RETURN AST
  ENDIF
  AST_A1[AST]=EXPR
  VAR P=NEW_AST(#AST_ITEM)
  AST_A2[AST]=P
  LOOP
   LEX_NEXT OUT T,V
   IF T!=#TKN_LABEL THEN
    PARSER_SYNTAX_ERROR "EXPECTED @LABEL(ON GOTO)"
    RETURN AST
   ENDIF
   VAR ITEM=NEW_AST(#AST_ITEM)
   AST$[ITEM]=V
   AST_NEXT[P]=ITEM
   P=ITEM
   LEX_NEXT OUT T,V
   IF T!=#TKN_COMMA THEN BREAK
  ENDLOOP
 ENDIF
 RETURN AST
END
DEF PARSE_RETURN()
 VAR AST
 IF PARSER_IN_FUNC THEN
  AST=NEW_AST(#AST_RETURNFUNC)
 ELSE
  AST=NEW_AST(#AST_RETURN)
 ENDIF
 VAR T,V
 LEX_NEXT OUT T,V
 IF IS_EXPR_TKN(T)&&PARSER_RETURN_EXPR THEN
  AST_LEFT[AST]=PARSE_EXPR()
 ENDIF
 AST_SET_POS_END AST
 RETURN AST
END
DEF PARSE_DATA()
 VAR AST=NEW_AST(#AST_DATA)
 VAR T,V
 VAR P=NEW_AST(#AST_ITEM)
 AST_A1[AST]=P
 LOOP
  LEX_NEXT OUT ,
  VAR EXPR=PARSE_EXPR()
  VAR ITEM=NEW_AST(#AST_ITEM)
  AST_A1[ITEM]=EXPR
  AST_NEXT[P]=ITEM
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN BREAK
  P=ITEM
 ENDLOOP
 RETURN AST
END
DEF PARSE_ARRAY_INDEX()
 VAR T,V
 VAR P=NEW_AST(#AST_ITEM)
 VAR R=P
 LOOP
  LEX_CUR OUT T,V
  IF R==P&&T==#TKN_RB THEN
   LEX_NEXT OUT T,V
   BREAK
  ENDIF
  IF TRACE THEN ?"PARSE_ARRAY_INDEX==
  VAR EXPR
  IF T==#TKN_COMMA||T==#TKN_RB THEN
   EXPR=NEW_AST(#AST_EMPTYEXPR)
  ELSE
   EXPR=PARSE_EXPR()
  ENDIF
  IF TRACE THEN ?"PARSE_ARRAY_INDEX==~~
  VAR ITEM=NEW_AST(#AST_ITEM)
  AST_A1[ITEM]=EXPR
  AST_NEXT[P]=ITEM
  AST_PREV[ITEM]=P
  P=ITEM
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN
   IF T==#TKN_RB THEN
    LEX_NEXT OUT T,V
   ELSE
    PARSER_SYNTAX_ERROR "EXPECTED ']'"
   ENDIF
   BREAK
  ENDIF
  LEX_NEXT OUT T,V
 ENDLOOP
 AST_PREV[R]=P
 RETURN R
END
DEF PARSE_VAR()
 VAR T,V
 VAR SI,SPI,SPI2,ST,SV,SL,SP,SPL,SPP
 LEX_SAVE OUT SI,SPI,SPI2,ST,SV,SL,SP,SPL,SPP
 LEX_CUR OUT T,V
 VAR AST
 VAR VAR_
 VAR CONST_
 CASE T
 WHEN #TKN_DIM
 WHEN #TKN_VAR
  AST=NEW_AST(#AST_DEFVAR)
  VAR_=#TRUE
 WHEN #TKN_CONST
  AST=NEW_AST(#AST_CONST)
  CONST_=#TRUE
 WHEN #TKN_ENUM
  AST=NEW_AST(#AST_ENUM)
 ENDCASE
 'VAR IDEN[\[EXPR[,EXPR[,EXPR[,EXPR]]]\]](=EXPR|=\[EXPR...\]|)...
 'DIM ARY[N]=[]'TYPEMISMATCH
 LEX_NEXT OUT T,V
 IF T==#TKN_LP THEN
  LEX_LOAD SI,SPI,SPI2,ST,SV,SL,SP,SPL,SPP
  RETURN PARSE_ASSIGN(AST,PARSE_EXPR())
 ENDIF
 VAR P=NEW_AST(#AST_ITEM)
 AST_A1[AST]=P
 VAR HAS
 LOOP
  IF VAR_&&T!=#TKN_IDEN THEN
   'VAR HA KETSU COMMA OK
   IF HAS THEN
    BREAK
   ENDIF
   PARSER_SYNTAX_ERROR "EXPECTED IDENTIFIER(VAR)"
   RETURN AST
  ENDIF
  HAS=#TRUE
  IF !VAR_&&T!=#TKN_CONSTVAR THEN
   PARSER_SYNTAX_ERROR "EXPECTED IDENTIFIER(CONST/ENUM)"
   RETURN AST
  ENDIF
  VAR ITEM=NEW_AST(#AST_ITEM)
  AST_NEXT[P]=ITEM
  AST$[ITEM]=V
  P=ITEM
  '$:NAME
  'A1:INIT EXPR
  'A2:ARRAY DIM
  'A3:ARRAY INIT LIST
  LEX_NEXT OUT T,V
  IF VAR_&&T==#TKN_LB THEN
   'DEFINE ARRAY
   LEX_NEXT OUT T,V
   AST_A2[ITEM]=PARSE_ARRAY_INDEX()
   IF TRACE THEN ?"END ARRAY INDEX INIT"
   LEX_CUR OUT T,V
  ENDIF
  IF T==#TKN_ASSIGN THEN
   LEX_NEXT OUT T,V
   'INIT ARRAY
   IF VAR_&&T==#TKN_LB THEN
    LEX_NEXT OUT T,V
    AST_A3[ITEM]=PARSE_ARRAY_INDEX()
    LEX_CUR OUT T,V
   ELSE
    AST_A1[ITEM]=PARSE_EXPR()
   ENDIF
  ELSEIF CONST_ THEN
   PARSER_SYNTAX_ERROR "EXPECTED '='(CONST)"
  ENDIF
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN
   BREAK
  ENDIF
  LEX_NEXT OUT T,V
 ENDLOOP
 AST_SET_POS_END AST
 RETURN AST
END
DEF PARSE_DEF_ARG$()
 VAR T,V
 VAR VN$
 LEX_CUR OUT T,V
 IF T!=#TKN_IDEN THEN
  PARSER_SYNTAX_ERROR
  RETURN ""
 ENDIF
 VN$=V
 LEX_NEXT OUT T,V
 IF T==#TKN_LB THEN
  LEX_NEXT OUT T,V
  IF T!=#TKN_RB THEN
   PARSER_SYNTAX_ERROR "EXPECTED ']'(DEF ARGUMENT)"
  ENDIF
  LEX_NEXT OUT T,V
 ENDIF
 RETURN VN$
END
DEF PARSE_DEF_LIST()
 VAR T,V
 VAR P=NEW_AST(#AST_ITEM)
 VAR R=P
 LOOP
  LEX_CUR OUT T,V
  IF T!=#TKN_IDEN THEN
   BREAK
  ENDIF
  VAR V$=PARSE_DEF_ARG$()
  VAR ITEM=NEW_AST(#AST_ITEM)
  AST$[ITEM]=V$
  AST_NEXT[P]=ITEM
  AST_PREV[ITEM]=P
  P=ITEM
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN
   BREAK
  ENDIF
  LEX_NEXT OUT T,V
 ENDLOOP
 AST_PREV[R]=P
 RETURN R
END
CONST #AST_DEF_A4_HAS_RET_VAL=&B0000001
CONST #AST_DEF_A4_IN_VAARGS  =&B0000010
CONST #AST_DEF_A4_OUT_VAARGS =&B0000100
CONST #AST_DEF_A4_COMMON_DEF =&B0001000
DEF PARSE_DEF()
 'DEF IDEN ([IDEN[\[\]]...]|*) OUT ([IDEN[\[\]]...]|*)
 VAR AST=NEW_AST(#AST_DEF)
 '$:NAME
 'A1:IN LIST
 'A2:OUT LIST
 'A3:STATEMENTS
 'A4:FLGS
 VAR T,V
 LEX_CUR OUT T,V
 IF T==#TKN_COMMON THEN
  AST_A4[AST]=AST_A4[AST]OR #AST_DEF_A4_COMMON_DEF
  LEX_NEXT OUT T,V
  IF T!=#TKN_DEF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'DEF'(COMMON DEF)"
   RETURN AST
  ENDIF
 ENDIF
 LEX_NEXT OUT T,V
 IF PARSER_IN_FUNC THEN
  NESTED_DEF
 ENDIF
 PARSER_IN_FUNC=#TRUE
 AST$[AST]=PARSE_DEF_ARG$()
 LEX_CUR OUT T,V
 IF T==#TKN_LP THEN
  PARSER_RETURN_EXPR=#TRUE
  LEX_NEXT OUT T,V
 ENDIF
 IF T==#TKN_MUL THEN
  AST_A4[AST]=AST_A4[AST]OR #AST_DEF_A4_IN_VAARGS
  LEX_NEXT OUT ,
 ELSE
  AST_A1[AST]=PARSE_DEF_LIST()
 ENDIF
 LEX_CUR OUT T,V
 IF PARSER_RETURN_EXPR THEN
  AST_A4[AST]=AST_A4[AST]OR #AST_DEF_A4_HAS_RET_VAL
  IF T!=#TKN_RP THEN
   PARSER_SYNTAX_ERROR "EXPECTED ')'(DEF)"
  ELSE
   LEX_NEXT OUT ,
  ENDIF
 ELSE
  LEX_CUR OUT T,V
  IF T==#TKN_OUT THEN
   LEX_NEXT OUT T,V
   IF T==#TKN_MUL THEN
    AST_A4[AST]=AST_A4[AST]OR #AST_DEF_A4_OUT_VAARGS
    LEX_NEXT OUT ,
   ELSE
    AST_A2[AST]=PARSE_DEF_LIST()
    IF !AST_NEXT[AST_A2[AST]]THEN
     PARSER_SYNTAX_ERROR "EXPECTED PARAMETER(DEF OUT)"
    ENDIF
   ENDIF
  ENDIF
 ENDIF
 AST_A3[AST]=PARSE_DEF_STATEMENTS()
 PARSER_IN_FUNC=#FALSE
 PARSER_RETURN_EXPR=#FALSE
 RETURN AST
END

DEF PARSE_DEF_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V,S
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_EOF THEN PARSER_SYNTAX_ERROR:RETURN ROOT
  IF T==#TKN_END THEN
   S=NEW_AST(#AST_RETURNFUNC)
   LEX_NEXT OUT ,
  ELSE
   S=PARSE_STATEMENT()
  ENDIF
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
  IF T==#TKN_END THEN
   RETURN ROOT
  ENDIF
 ENDLOOP
END
DEF PARSE_END()
 VAR AST=NEW_AST(#AST_END)
 LEX_NEXT OUT ,
 RETURN AST
END
DEF IS_EXPR_TKN(T)
 CASE T
 WHEN #TKN_NUM
 WHEN #TKN_STR
 WHEN #TKN_IDEN
 WHEN #TKN_LP
 WHEN #TKN_MINUS
 WHEN #TKN_NOT
 WHEN #TKN_LNOT
 WHEN #TKN_LABEL
 WHEN #TKN_CONSTVAR
 WHEN #TKN_VAR
 WHEN #TKN_DIM
 WHEN #TKN_CALL
  RETURN #TRUE
 ENDCASE
 RETURN #FALSE
END
DEF PARSE_PRINT(TPRNT)
 VAR T,V
 VAR AST
 IF TPRNT THEN
  AST=NEW_AST(#AST_TPRINT)
 ELSE
  AST=NEW_AST(#AST_PRINT)
 ENDIF
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[AST]=PRV
 LEX_NEXT OUT T,V
 IF !IS_EXPR_TKN(T)THEN
  IF TRACE THEN ?"PRINT_E"
  RETURN AST
 ENDIF
 WHILE 1
  VAR EXPR=PARSE_EXPR()
  LEX_CUR OUT T,V
  VAR A
  IF T==#TKN_COMMA THEN
   IF TRACE THEN ?"PRINT_COMMA"
   A=NEW_AST(#AST_PRINT_EXPR_COMMA)
   LEX_NEXT OUT ,
  ELSEIF T==#TKN_SEMI THEN
   IF TPRNT&&AST_LEFT[AST]==PRV THEN
    PARSER_SYNTAX_ERROR "EXPECTED ','(TPRINT)"
   ENDIF
   IF TRACE THEN ?"PRINT_SEMI"
   A=NEW_AST(#AST_PRINT_EXPR_SEMI)
   LEX_NEXT OUT ,
  ELSE
   IF TRACE THEN ?"PRINT"
   A=NEW_AST(#AST_PRINT_EXPR_NEWLINE)
  ENDIF
  AST_LEFT[A]=EXPR
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
  IF T!=#TKN_COMMA&&T!=#TKN_SEMI THEN
   AST_SET_POS_END AST
   RETURN AST
  ENDIF
  LEX_CUR OUT T,V
  IF !IS_EXPR_TKN(T)THEN
   AST_SET_POS_END AST
   RETURN AST
  ENDIF
 WEND
END

ENUM\
 #OPRANK_NOTANOP,\
 #OPRANK_MIN,\
 #OPRANK_PARENT,\
 #OPRANK_UNA,\
 #OPRANK_MUL,\
 #OPRANK_PLUS,\
 #OPRANK_SHIFT,\
 #OPRANK_EQ,\
 #OPRANK_BIT,\
 #OPRANK_LOG,\
 #OPRANK_MAX
DEF GET_OP_RANK(T)
 CASE T
 WHEN #TKN_LP
 WHEN #TKN_LB
  RETURN #OPRANK_PARENT
 WHEN #TKN_MUL
 WHEN #TKN_DIV
 WHEN #TKN_DIVINT
 WHEN #TKN_MOD
  RETURN #OPRANK_MUL
 WHEN #TKN_PLUS
 WHEN #TKN_MINUS
  RETURN #OPRANK_PLUS
 WHEN #TKN_LSHIFT
 WHEN #TKN_RSHIFT
  RETURN #OPRANK_SHIFT
 WHEN #TKN_EQ
 WHEN #TKN_NEQ
 WHEN #TKN_LESS
 WHEN #TKN_LEQ
 WHEN #TKN_GREAT
 WHEN #TKN_GEQ
  RETURN #OPRANK_EQ
 WHEN #TKN_AND
 WHEN #TKN_OR
 WHEN #TKN_XOR
  RETURN #OPRANK_BIT
 WHEN #TKN_LAND
 WHEN #TKN_LOR
  RETURN #OPRANK_LOG
 ENDCASE
 RETURN #OPRANK_NOTANOP
END
DEF GET_OP_RANK2(T)
 CASE T
 WHEN #TKN_LP
 WHEN #TKN_LB
  RETURN #OPRANK_PARENT
 WHEN #TKN_LNOT
 WHEN #TKN_NOT
  RETURN #OPRANK_UNA
 WHEN #TKN_MUL
 WHEN #TKN_DIV
 WHEN #TKN_DIVINT
 WHEN #TKN_MOD
  RETURN #OPRANK_MUL
 WHEN #TKN_PLUS
 WHEN #TKN_MINUS
  RETURN #OPRANK_PLUS
 WHEN #TKN_LSHIFT
 WHEN #TKN_RSHIFT
  RETURN #OPRANK_SHIFT
 WHEN #TKN_EQ
 WHEN #TKN_NEQ
 WHEN #TKN_LESS
 WHEN #TKN_LEQ
 WHEN #TKN_GREAT
 WHEN #TKN_GEQ
  RETURN #OPRANK_EQ
 WHEN #TKN_AND
 WHEN #TKN_OR
 WHEN #TKN_XOR
  RETURN #OPRANK_BIT
 WHEN #TKN_LAND
 WHEN #TKN_LOR
  RETURN #OPRANK_LOG
 ENDCASE
 RETURN #OPRANK_NOTANOP
END
DEF PARSE_TERM()
 VAR T,V
 LEX_CUR OUT T,V
 VAR AST
 CASE T
 WHEN #TKN_LNOT
 WHEN #TKN_NOT
 WHEN #TKN_MINUS
  AST=NEW_AST(#AST_UNAOP)
  LEX_NEXT OUT ,
  AST%[AST]=T
  AST_LEFT[AST]=PARSE_EXPR0(#OPRANK_UNA)
  IF TRACE THEN ?"UNARY"
 'FIXME:EXPND CONST EXPR
 WHEN #TKN_NUM
  IF TRACE THEN ?"IMM",V
  IF TYPEOF(V)==#T_INT THEN
   AST=NEW_AST_INT(#AST_IMM_INT,V)
   LEX_NEXT OUT ,
  ELSEIF TYPEOF(V)==#T_REAL THEN
   AST=NEW_AST_DBL(#AST_IMM_DBL,V)
   LEX_NEXT OUT ,
  ELSE
  STOP
  ENDIF
 WHEN #TKN_LABEL
 WHEN #TKN_STR
  IF TRACE THEN ?"IMM",V
  AST=NEW_AST_STR(#AST_IMM_STR,V)
  LEX_NEXT OUT ,
 WHEN #TKN_CONSTVAR
  IF TRACE THEN ?"CONSTVAR",V
  AST=NEW_AST_STR(#AST_CONSTVAR,V)
  LEX_NEXT OUT ,
 WHEN #TKN_VAR
  VAR T2,V2
  AST=NEW_AST(#AST_VAREXPR)
  LEX_NEXT OUT T2,V2
  IF T2==#TKN_LP THEN
   LEX_NEXT OUT ,
   AST_LEFT[AST]=PARSE_EXPR()
   LEX_CUR OUT T2,V2
   IF T2==#TKN_RP THEN
    LEX_NEXT OUT ,
   ELSE
    PARSER_SYNTAX_ERROR "EXPECTED '('(VAR())"
   ENDIF
  ELSE
   PARSER_SYNTAX_ERROR "EXPECTED '('(VAR())"
  ENDIF
 
 WHEN #TKN_DIM
  LEX_NEXT OUT T2,V2
  IF T2==#TKN_LP THEN
   AST=PARSE_CALLFUNCEXPR("DIM")
  ELSE
   PARSER_SYNTAX_ERROR "EXPECTED '('(DIM())"
  ENDIF
 WHEN #TKN_CALL
 WHEN #TKN_IDEN
  LEX_NEXT OUT T2,V2
  IF T2==#TKN_LP THEN
   AST=PARSE_CALLFUNCEXPR(V)
  ELSE
   IF TRACE THEN ?"VAR",V
   AST=NEW_AST_STR(#AST_VAR,V)
  ENDIF
 WHEN #TKN_LP
  LEX_NEXT OUT ,
  AST=PARSE_EXPR()
  LEX_CUR OUT T,V
  IF T!=#TKN_RP THEN
   PARSER_SYNTAX_ERROR "EXPECTED ')'(EXPRESSION)"
  ELSE
   LEX_NEXT OUT ,
  ENDIF
 OTHERWISE
  PARSER_SYNTAX_ERROR "(EXPRESSION)"
  LEX_NEXT OUT ,
 ENDCASE
 RETURN AST
END
DEF PARSE_CALLFUNCEXPR(NAME$)
 VAR AST=NEW_AST_STR(#AST_CALLFUNCEXPR,NAME$)
 VAR T,V
 VAR P=NEW_AST(#AST_ITEM)
 AST_A1[AST]=P
 AST$[AST]=NAME$
 VAR FIRST=P
 LOOP
  LEX_NEXT OUT T,V
  IF FIRST==P&&T==#TKN_RP THEN
   LEX_NEXT OUT T,V
   BREAK
  ENDIF
  VAR EXPR
  IF T==#TKN_COMMA||T==#TKN_RP THEN
   EXPR=NEW_AST(#AST_EMPTYEXPR)
  ELSE
   EXPR=PARSE_EXPR()
  ENDIF
  VAR ITEM=NEW_AST(#AST_ITEM)
  AST_A1[ITEM]=EXPR
  AST_PREV[ITEM]=P
  AST_NEXT[P]=ITEM
  P=ITEM
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN
   IF T==#TKN_RP THEN
    LEX_NEXT OUT T,V
   ELSE
    PARSER_SYNTAX_ERROR "EXPECTED ')'"
   ENDIF
   BREAK
  ENDIF
 ENDLOOP
 AST_PREV[FIRST]=P
 RETURN AST
END
VAR PPP
'ためしにじっそうしたけどあんまりはやくなかったのでボツ
CONST #PARSE_EXPR_SHUNTING_YARD_LP=-1
DEF PARSE_EXPR_SHUNTING_YARD()
'' VAR AAA=PARSE_EXPR0(#OPRANK_MAX)
'' DUMP_AST AAA,0
''STOP
'' RETURN AAA
 VAR T,V
 DIM OUTARY=ARRAY%(100)
 DIM STK=ARRAY%(100)
 VAR OI=0
 VAR SP=0
 VAR AST
 VAR PREV_IS_BIN=#TRUE
 LOOP
  LEX_CUR OUT T,V
  CASE T
  WHEN #TKN_NUM
   IF !PREV_IS_BIN THEN BREAK
   PREV_IS_BIN=#FALSE
   IF TYPEOF(V)==#T_INT THEN
    AST=NEW_AST_INT(#AST_IMM_INT,V)
    LEX_NEXT OUT ,
   ELSEIF TYPEOF(V)==#T_REAL THEN
    AST=NEW_AST_DBL(#AST_IMM_DBL,V)
    LEX_NEXT OUT ,
   ELSE
   STOP
   ENDIF
  WHEN #TKN_LABEL
  WHEN #TKN_STR
   IF !PREV_IS_BIN THEN BREAK
   PREV_IS_BIN=#FALSE
   AST=NEW_AST_STR(#AST_IMM_STR,V)
   LEX_NEXT OUT ,
  WHEN #TKN_CONSTVAR
   IF !PREV_IS_BIN THEN BREAK
   PREV_IS_BIN=#FALSE
   IF TRACE THEN ?"CONSTVAR",V
   AST=NEW_AST_STR(#AST_CONSTVAR,V)
   LEX_NEXT OUT ,
  WHEN #TKN_LP
   IF !PREV_IS_BIN THEN BREAK
   PREV_IS_BIN=#TRUE
   STK[SP]=#PARSE_EXPR_SHUNTING_YARD_LP
   INC SP
   LEX_NEXT OUT ,
   CONTINUE
  WHEN #TKN_RP
   PREV_IS_BIN=#FALSE
   LOOP
    DEC SP
    IF SP==-1 THEN BREAK
    IF STK[SP]==#PARSE_EXPR_SHUNTING_YARD_LP THEN
     BREAK
    ELSE
     OUTARY[OI]=STK[SP]
     INC OI
    ENDIF
   ENDLOOP
   IF SP==-1 THEN BREAK
   LEX_NEXT OUT ,
   CONTINUE
  WHEN #TKN_VAR
   IF !PREV_IS_BIN THEN BREAK
   PREV_IS_BIN=#FALSE
   VAR T2,V2
   AST=NEW_AST(#AST_VAREXPR)
   LEX_NEXT OUT T2,V2
   IF T2==#TKN_LP THEN
    LEX_NEXT OUT ,
    AST_LEFT[AST]=PARSE_EXPR()
    LEX_CUR OUT T2,V2
    IF T2==#TKN_RP THEN
     LEX_NEXT OUT ,
    ELSE
     PARSER_SYNTAX_ERROR "EXPECTED '('(VAR())"
    ENDIF
   ELSE
    PARSER_SYNTAX_ERROR "EXPECTED '('(VAR())"
   ENDIF
  WHEN #TKN_DIM
   PREV_IS_BIN=#FALSE
   LEX_NEXT OUT T2,V2
   IF T2==#TKN_LP THEN
    AST=PARSE_CALLFUNCEXPR("DIM")
   ELSE
    PARSER_SYNTAX_ERROR "EXPECTED '('(DIM())"
   ENDIF
  WHEN #TKN_CALL
  WHEN #TKN_IDEN
   IF !PREV_IS_BIN THEN BREAK
   PREV_IS_BIN=#FALSE
   LEX_NEXT OUT T2,V2
   IF T2==#TKN_LP THEN
    AST=PARSE_CALLFUNCEXPR(V)
   ELSE
    AST=NEW_AST_STR(#AST_VAR,V)
   ENDIF
  OTHERWISE
   VAR RANK=GET_OP_RANK2(T)
   IF RANK==#OPRANK_NOTANOP THEN
    BREAK
   ENDIF
   IF PREV_IS_BIN&&T==#TKN_MINUS THEN
    RANK=#OPRANK_UNA
   ENDIF
   IF SP&&STK[SP-1]>0THEN
    IF AST_TYP[STK[SP-1]]==#AST_UNAOP THEN
     VAR PRANK=#OPRANK_UNA
     GOTO @P
    ELSE
     PRANK=GET_OP_RANK2(AST%[STK[SP-1]])
    ENDIF
    IF PRANK<=RANK THEN
     DEC SP
     OUTARY[OI]=STK[SP]
     INC OI
     CONTINUE
    ENDIF
   ENDIF
   @P
   IF RANK==#OPRANK_UNA THEN
    PREV_IS_BIN=#TRUE
    AST=NEW_AST(#AST_UNAOP)
   ELSE
    PREV_IS_BIN=#TRUE
    AST=NEW_AST(#AST_BINOP)
   ENDIF
   AST%[AST]=T
   STK[SP]=AST
   LEX_NEXT OUT ,
   INC SP
   IF T==#TKN_LB THEN
    OUTARY[OI]=PARSE_ARRAY_INDEX()
    INC OI
   ENDIF
   CONTINUE
  ENDCASE
  OUTARY[OI]=AST
  INC OI
 ENDLOOP
 WHILE SP>0
  DEC SP
  OUTARY[OI]=STK[SP]
  INC OI
 WEND
 VAR I
 DEC OI
 SP=0
' FOR I=0TO OI
'  AST=OUTARY[I]
'  IF AST>0 THEN
'   DUMP_AST AST,0
'  ELSEIF AST==#PARSE_EXPR_SHUNTING_YARD_END_CALL THEN
'   ?"#PARSE_EXPR_SHUNTING_YARD_END_CALL"
'  ELSE
'   ?"ERR",AST
'  ENDIF
' NEXT
' ?"========"
 FOR I=0TO OI
  AST=OUTARY[I]
  CASE AST_TYP[AST]
  WHEN #AST_IMM_INT
  WHEN #AST_IMM_DBL
  WHEN #AST_IMM_STR
  WHEN #AST_CONSTVAR
  WHEN #AST_VAR
  WHEN #AST_VAREXPR
  WHEN #AST_CALLFUNCEXPR
  WHEN #AST_ITEM
   STK[SP]=AST
   INC SP
  WHEN #AST_BINOP
   DEC SP
   AST_RIGHT[AST]=STK[SP]
   DEC SP
   AST_LEFT[AST]=STK[SP]
   STK[SP]=AST
   INC SP
  WHEN #AST_UNAOP
   DEC SP
   AST_LEFT[AST]=STK[SP]
   STK[SP]=AST
   INC SP
  OTHERWISE
   STOP
  ENDCASE
 NEXT
' DUMP_AST STK[0],0
 RETURN STK[0]
END
DEF PARSE_EXPR()
' RETURN PARSE_EXPR_SHUNTING_YARD()
 RETURN PARSE_EXPR0(#OPRANK_MAX)
END
DEF PARSE_EXPR0(RANK)
 IF RANK==#OPRANK_MIN THEN
  RETURN PARSE_TERM()
 ENDIF
 VAR T,V
 VAR LEFT=PARSE_EXPR0(RANK-1)
 LOOP
  LEX_CUR OUT T,V
  IF GET_OP_RANK(T)==RANK THEN
   LEX_NEXT OUT ,
   VAR RIGHT
   IF T==#TKN_LB THEN
    RIGHT=PARSE_ARRAY_INDEX()
    IF TRACE THEN ?"BINARY OP",TKN_STR$(T)
    LEFT=NEW_AST_LR(#AST_BINOP,LEFT,RIGHT)
    AST%[LEFT]=T
   ELSE
    RIGHT=PARSE_EXPR0(RANK-1)
    IF TRACE THEN ?"BINARY OP",TKN_STR$(T)
    LEFT=NEW_AST_LR(#AST_BINOP,LEFT,RIGHT)
    AST%[LEFT]=T
   ENDIF
   CONTINUE
  ENDIF
  BREAK
 ENDLOOP
 RETURN LEFT
END

DEF PARSER_GET_CURLOC$()
 RETURN " in "+STR$(PARSER_SLOT)+":"+STR$(LEXER_PREV_LINE)+":"+STR$(LEXER_PREV_I2-LEXER_PREV_LINE_POS+1)
END
DEF PARSER_RAISE_ERR2 E1$,E2$
 ?E1$;PARSER_GET_CURLOC$()
 ?E2$
 PARSER_HAS_ERR=#TRUE
END
DEF PARSER_SYNTAX_ERROR *
 VAR I,T,V
 LEX_CUR OUT T,V
 PARSER_RAISE_ERR2 "Syntax error","文法まちがい"
 ?"UNEXPECTED ";TKN_STR$(T)
 FOR I=0TO DEFARGC()-1
  ?DEFARG(I);
 NEXT
 IF DEFARGC() THEN
  ?
 ENDIF
END

DEF PARSER_ENDIF_WITHOUT_IF
 PARSER_RAISE_ERR2 "ENDIF without IF","ENDIFに対応するIFがありません"
END
DEF PARSER_WEND_WITHOUT_WHILE
 PARSER_RAISE_ERR2 "WEND without WHILE","WENDに対応するWHILEがありません"
END
DEF PARSER_UNTIL_WITHOUT_REPEAT
 PARSER_RAISE_ERR2 "UNTIL without REPEAT","UNTILに対応するREPEATがありません"
END
DEF PARSER_ENDCASE_WITHOUT_CASE
 PARSER_RAISE_ERR2 "ENDCASE without CASE","ENDCASEに対応するCASEがありません"
END
DEF PARSER_WHEN_WITHOUT_CASE
 PARSER_RAISE_ERR2 "WHEN without CASE","WHENに対応するCASEがありません"
END
DEF PARSER_ENDLOOP_WITHOUT_LOOP
 PARSER_RAISE_ERR2 "ENDLOOP without LOOP","ENDLOOPに対応するLOOPがありません"
END

ENUM\
 #VMT_DEFAULT,\
 #VMT_INT,\
 #VMT_REAL,\
 #VMT_STR,\
 #VMT_NONE,\
 #VMT_INTARRAY,\
 #VMT_REALARRAY,\
 #VMT_STRARRAY,\
 #VMT_VARREF,\
 #VMT_VARREFSLOT,\
 #VMT_LVARREF,\
 #VMT_EMPTYREF,\
 #VMT_ARYREF,\
 #VMT_SUBROUTINE,\
 #VMT_LAST
DEF VMT_STR$(T)
 CASE T
 WHEN #VMT_DEFAULT:RETURN "#VMT_DEFAULT"WHEN #VMT_INT:RETURN "#VMT_INT"WHEN #VMT_REAL:RETURN "#VMT_REAL"WHEN #VMT_STR:RETURN "#VMT_STR"WHEN #VMT_INTARRAY:RETURN "#VMT_INTARRAY"WHEN #VMT_REALARRAY:RETURN "#VMT_REALARRAY"WHEN #VMT_STRARRAY:RETURN "#VMT_STRARRAY"WHEN #VMT_VARREF:RETURN "#VMT_VARREF"WHEN #VMT_VARREFSLOT:RETURN "#VMT_VARREFSLOT"WHEN #VMT_LVARREF:RETURN "#VMT_LVARREF"WHEN #VMT_EMPTYREF:RETURN "#VMT_EMPTYREF"WHEN #VMT_ARYREF:RETURN "#VMT_ARYREF"WHEN #VMT_SUBROUTINE:RETURN "#VMT_SUBROUTINE"
 OTHERWISE
  RETURN "#VMT_"+STR$(T)
 ENDCASE
END
ENUM\
 #VMPRINT_EMPTY,\
 #VMPRINT_COMMA,\
 #VMPRINT_NEWLINE,\
 #VMPRINT_SEMI

VAR CMP_REPL
VAR CMP_STRICT
VAR CMP_DEFINT
VAR CMP_GVARTBL
VAR CMP_GLBLTBL
VAR CMP_FUNCTBL
VAR CMP_CONSTTBL
VAR CMP_BCONSTTBL

VAR CMP_GVARNUM

DIM CMP_BREAK[]
DIM CMP_CONTINUE[]
VAR CMP_CURFUNC

DIM FUNC_NAME$[]
DIM FUNC_ADDR[]
'-1:VAARGS
DIM FUNC_INCNT[]
DIM FUNC_OUTCNT[]
DIM FUNC_VARTBL[]
DIM FUNC_LBLTBL[]
DIM FUNC_VARNUM[]
DIM FUNC_SLOT[]
DIM FUNC_COMMON[]
VAR FUNC_FREE

DIM VAR_IDX[]
DIM VAR_TYP[]
VAR VAR_FREE

DIM LABEL_ADDR[]
DIM LABEL_DATA_ADDR[]
VAR LABEL_FREE

DIM CMP_DATA_TYP[]
DIM CMP_DATA%[]
DIM CMP_DATA#[]
DIM CMP_DATA$[]

DIM CMP_CONST_TYP[]
DIM CMP_CONST%[]
DIM CMP_CONST#[]
DIM CMP_CONST$[]
VAR CONST_FREE

VAR CMP_SLOT
VAR CMP_FILENAME$
VAR CMP_HAS_ERR
DEF INIT_COMPILER_VAR
 VAR S=1
 VAR_IDX=ARRAY%(S)
 VAR_TYP=ARRAY%(S)
 VAR_FREE=0
END
DEF NEW_VAR(IDX,TYP)
 IF VAR_FREE THEN
  VAR L=VAR_FREE
  VAR_FREE=VAR_IDX[VAR_FREE]
  VAR_IDX[L]=IDX
  VAR_TYP[L]=TYP
  RETURN L
 ENDIF
 PUSH VAR_IDX,IDX
 PUSH VAR_TYP,TYP
 RETURN LAST(VAR_IDX)
END
DEF DELETE_VAR V
 VAR_IDX[V]=VAR_FREE
 VAR_FREE=V
END
DEF INIT_COMPILER_LABEL
 VAR S=1
 LABEL_ADDR=ARRAY%(S)
 LABEL_DATA_ADDR=ARRAY%(S)
 LABEL_FREE=0
END
DEF NEW_LABEL(ADDR,DADDR)
 IF LABEL_FREE THEN
  VAR L=LABEL_FREE
  LABEL_FREE=LABEL_ADDR[LABEL_FREE]
  LABEL_ADDR[L]=ADDR
  LABEL_DATA_ADDR[L]=DADDR
  RETURN L
 ENDIF
 PUSH LABEL_ADDR,ADDR
 PUSH LABEL_DATA_ADDR,DADDR
 RETURN LAST(LABEL_ADDR)
END
DEF DELETE_LABEL LABEL
 LABEL_ADDR[LABEL]=LABEL_FREE
 LABEL_FREE=LABEL
END
DEF INIT_COMPILER_FUNC
 VAR S=1
 FUNC_NAME$=ARRAY$(S)
 FUNC_ADDR=ARRAY%(S)
 FUNC_INCNT=ARRAY%(S)
 FUNC_OUTCNT=ARRAY%(S)
 FUNC_VARTBL=ARRAY%(S)
 FUNC_LBLTBL=ARRAY%(S)
 FUNC_VARNUM=ARRAY%(S)
 FUNC_SLOT=ARRAY%(S)
 FUNC_COMMON=ARRAY%(S)
 FUNC_FREE=0
END
DEF NEW_FUNC(NAME$,ADDR,INCNT,OUTCNT,SLOT,COMMO)
 IF FUNC_FREE THEN
  VAR L=FUNC_FREE
  FUNC_FREE=FUNC_ADDR[FUNC_FREE]
  FUNC_NAME$[L]=NAME$
  FUNC_ADDR[L]=ADDR
  FUNC_INCNT[L]=INCNT
  FUNC_OUTCNT[L]=OUTCNT
  FUNC_VARTBL[L]=NEW_SPLAY_TREE()
  FUNC_LBLTBL[L]=NEW_SPLAY_TREE()
  FUNC_VARNUM[L]=0
  FUNC_SLOT[L]=SLOT
  FUNC_COMMON[L]=COMMO
  RETURN L
 ENDIF
 PUSH FUNC_NAME$,NAME$
 PUSH FUNC_ADDR,ADDR
 PUSH FUNC_INCNT,INCNT
 PUSH FUNC_OUTCNT,OUTCNT
 PUSH FUNC_VARTBL,NEW_SPLAY_TREE()
 PUSH FUNC_LBLTBL,NEW_SPLAY_TREE()
 PUSH FUNC_VARNUM,0
 PUSH FUNC_SLOT,SLOT
 PUSH FUNC_COMMON,COMMO
 RETURN LAST(FUNC_LBLTBL)
END
DEF DELETE_FUNC FUNC
 FUNC_ADDR[FUNC]=FUNC_FREE
 FUNC_FREE=FUNC
END
DEF INIT_COMPILER_CONST
 VAR S=1
 CMP_BCONSTTBL=NEW_SPLAY_TREE()
 CMP_CONST_TYP=ARRAY%(S)
 CMP_CONST%=ARRAY%(S)
 CMP_CONST#=ARRAY#(S)
 CMP_CONST$=ARRAY$(S)
 CONST_FREE=0
 ADD_BCONST "#ON",#ON:ADD_BCONST "#OFF",#OFF:ADD_BCONST "#YES",#YES:ADD_BCONST "#NO",#NO:ADD_BCONST "#TRUE",#TRUE:ADD_BCONST "#FALSE",#FALSE:ADD_BCONST "#PI",#PI:ADD_BCONST "#EXP",#EXP:ADD_BCONST "#C_CLEAR",#C_CLEAR:ADD_BCONST "#C_AQUA",#C_AQUA:ADD_BCONST "#C_BLACK",#C_BLACK:ADD_BCONST "#C_BLUE",#C_BLUE:ADD_BCONST "#C_CYAN",#C_CYAN:ADD_BCONST "#C_FUCHSIA",#C_FUCHSIA:ADD_BCONST "#C_GRAY",#C_GRAY:ADD_BCONST "#C_GREEN",#C_GREEN:ADD_BCONST "#C_LIME",#C_LIME:ADD_BCONST "#C_MAGENTA",#C_MAGENTA:ADD_BCONST "#C_MAROON",#C_MAROON:ADD_BCONST "#C_NAVY",#C_NAVY:ADD_BCONST "#C_OLIVE",#C_OLIVE:ADD_BCONST "#C_PURPLE",#C_PURPLE:ADD_BCONST "#C_RED",#C_RED:ADD_BCONST "#C_SILVER",#C_SILVER:ADD_BCONST "#C_TEAL",#C_TEAL:ADD_BCONST "#C_WHITE",#C_WHITE:ADD_BCONST "#C_YELLOW",#C_YELLOW:ADD_BCONST "#B_RUP",#B_RUP:ADD_BCONST "#B_RDOWN",#B_RDOWN:ADD_BCONST "#B_RLEFT",#B_RLEFT:ADD_BCONST "#B_RRIGHT",#B_RRIGHT:ADD_BCONST "#B_LUP",#B_LUP:ADD_BCONST "#B_LDOWN",#B_LDOWN:ADD_BCONST "#B_LLEFT",#B_LLEFT:ADD_BCONST "#B_LRIGHT",#B_LRIGHT:ADD_BCONST "#B_L1",#B_L1:ADD_BCONST "#B_R1",#B_R1:ADD_BCONST "#B_L2",#B_L2:ADD_BCONST "#B_R2",#B_R2:ADD_BCONST "#B_SL",#B_SL:ADD_BCONST "#B_SR",#B_SR:ADD_BCONST "#B_S1",#B_S1:ADD_BCONST "#B_S2",#B_S2:ADD_BCONST "#B_LSTICK",#B_LSTICK:ADD_BCONST "#B_RSTICK",#B_RSTICK:ADD_BCONST "#B_RANY",#B_RANY:ADD_BCONST "#B_LANY",#B_LANY:ADD_BCONST "#B_ANY",#B_ANY:ADD_BCONST "#A_ROT0",#A_ROT0:ADD_BCONST "#A_ROT90",#A_ROT90:ADD_BCONST "#A_ROT180",#A_ROT180:ADD_BCONST "#A_ROT270",#A_ROT270:ADD_BCONST "#A_REVH",#A_REVH:ADD_BCONST "#A_REVV",#A_REVV:ADD_BCONST "#A_ADD",#A_ADD:ADD_BCONST "#CHKXY",#CHKXY:ADD_BCONST "#CHKZ",#CHKZ:ADD_BCONST "#CHKR",#CHKR:ADD_BCONST "#CHKS",#CHKS:ADD_BCONST "#CHKC",#CHKC:ADD_BCONST "#CHKV",#CHKV:ADD_BCONST "#CHKUV",#CHKUV:ADD_BCONST "#CHKI",#CHKI:ADD_BCONST "#T_DEFAULT",#T_DEFAULT:ADD_BCONST "#T_INT",#T_INT:ADD_BCONST "#T_REAL",#T_REAL:ADD_BCONST "#T_STR",#T_STR:ADD_BCONST "#T_INTARRAY",#T_INTARRAY:ADD_BCONST "#T_REALARRAY",#T_REALARRAY:ADD_BCONST "#T_STRARRAY",#T_STRARRAY:ADD_BCONST "#G_NORMAL",#G_NORMAL:ADD_BCONST "#G_NORMAL2",#G_NORMAL2:ADD_BCONST "#G_ALPHA",#G_ALPHA:ADD_BCONST "#G_ALPHA2",#G_ALPHA2:ADD_BCONST "#G_ADD",#G_ADD:ADD_BCONST "#BQAPF",#BQAPF:ADD_BCONST "#BQLPF",#BQLPF:ADD_BCONST "#BQHPF",#BQHPF:ADD_BCONST "#BQBPF",#BQBPF:ADD_BCONST "#BQBSF",#BQBSF:ADD_BCONST "#BQLSF",#BQLSF:ADD_BCONST "#BQHSF",#BQHSF:ADD_BCONST "#BQPEQ",#BQPEQ:ADD_BCONST "#WFRECT",#WFRECT:ADD_BCONST "#WFHAMM",#WFHAMM:ADD_BCONST "#WFHANN",#WFHANN:ADD_BCONST "#WFBLKM",#WFBLKM:ADD_BCONST "#AOPADD",#AOPADD:ADD_BCONST "#AOPSUB",#AOPSUB:ADD_BCONST "#AOPMUL",#AOPMUL:ADD_BCONST "#AOPDIV",#AOPDIV:ADD_BCONST "#AOPMAD",#AOPMAD:ADD_BCONST "#AOPLIP",#AOPLIP:ADD_BCONST "#AOPCLP",#AOPCLP:ADD_BCONST "#EFCOFF",#EFCOFF:ADD_BCONST "#EFCON",#EFCON:ADD_BCONST "#EFCBATH",#EFCBATH:ADD_BCONST "#EFCCAVE",#EFCCAVE:ADD_BCONST "#EFCSPACE",#EFCSPACE:ADD_BCONST "#EFCREFSROOM",#EFCREFSROOM:ADD_BCONST "#EFCREFLROOM",#EFCREFLROOM:ADD_BCONST "#EFCREFHALL",#EFCREFHALL:ADD_BCONST "#EFCREFCAVE",#EFCREFCAVE:ADD_BCONST "#EFCREFNONE",#EFCREFNONE:ADD_BCONST "#EFCREVROOM",#EFCREVROOM:ADD_BCONST "#EFCREVHALL",#EFCREVHALL:ADD_BCONST "#EFCREVMETAL",#EFCREVMETAL:ADD_BCONST "#EFCREVCAVE",#EFCREVCAVE:ADD_BCONST "#EFCREVREV",#EFCREVREV:ADD_BCONST "#PVLEFT",#PVLEFT:ADD_BCONST "#PVRIGHT",#PVRIGHT:ADD_BCONST "#GRPWIDTH",#GRPWIDTH:ADD_BCONST "#GRPHEIGHT",#GRPHEIGHT:ADD_BCONST "#GRPF",#GRPF:ADD_BCONST "#GSPRITE",#GSPRITE:ADD_BCONST "#TCONSOLE",#TCONSOLE:ADD_BCONST "#MAXT",#MAXT:ADD_BCONST "#MAXSP",#MAXSP:ADD_BCONST "#MAXGRP",#MAXGRP:ADD_BCONST "#HARDWARE",#HARDWARE
 ADD_BCONST "#VERSION",#VERSION
 ADD_BCONST "#_SLOT",0
 ADD_BCONST "#_LINE",0
 ADD_BCONST "#_FILENAME",""
END
DEF NEW_CONST(C)
 VAR N$
 IF !CONST_FREE THEN
  PUSH CMP_CONST_TYP,0
  PUSH CMP_CONST%,0
  PUSH CMP_CONST#,0
  PUSH CMP_CONST$,N$
  VAR L=LAST(CMP_CONST%)
 ELSE
  L=CONST_FREE
  CONST_FREE=CMP_CONST_TYP[CONST_FREE]
  CMP_CONST_TYP[L]=0
  CMP_CONST%[L]=0
  CMP_CONST#[L]=0
  CMP_CONST$[L]=N$
 ENDIF
 CASE TYPEOF(C)
 WHEN #T_INT
  CMP_CONST%[L]=C
  CMP_CONST_TYP[L]=#VMT_INT
 WHEN #T_REAL
  CMP_CONST#[L]=C
  CMP_CONST_TYP[L]=#VMT_REAL
 WHEN #T_STR
  CMP_CONST$[L]=C
  CMP_CONST_TYP[L]=#VMT_STR
 ENDCASE
 RETURN L
END
DEF DELETE_CONST C
 CMP_CONST_TYP[C]=CONST_FREE
 CONST_FREE=C
END
DEF COMPILER_GET_CURLOC$()
 VAR LINE,POS,LINE_END,POS_END,PC
 VMDBG_GET_SRC_INFO OUT LINE,POS,LINE_END,POS_END,PC
 RETURN STR$(CMP_SLOT)+":"+STR$(LINE)+":"+STR$(POS)
END
DEF COMPILER_HAS_ERROR()
 RETURN CMP_HAS_ERR
END
DEF COMPILER_RAISE_ERR2 E1$,E2$
 ?E1$;" in ";COMPILER_GET_CURLOC$()
 ?E2$
 CMP_HAS_ERR=#TRUE
END

DEF COMPILER_DUPLICATE_VARIABLE V$
 COMPILER_RAISE_ERR2 "Duplicate variable","同じ名前の変数はすでに定義されています"
END
DEF COMPILER_DUPLICATE_LABEL V$
STOP
 COMPILER_RAISE_ERR2 "Duplicate label","同じ名前のラベルはすでに定義されています"
END
DEF COMPILER_DUPLICATE_FUNCTION V$
 COMPILER_RAISE_ERR2 "Duplicate function","同じ名前の命令はすでに定義されています"
END
DEF COMPILER_DUPLICATE_CONSTANT V$
 COMPILER_RAISE_ERR2 "Duplicate constant","同じ名前の定数はすでに定義されています"
END
DEF COMPILER_UNDEFINED_CONSTANT V$
 COMPILER_RAISE_ERR2 "Undefined constant","未定義定数"
END
DEF INIT_COMPILER SLOT
 CMP_REPL=#FALSE
 CMP_STRICT=#FALSE
 CMP_DEFINT=#FALSE
 CMP_GVARTBL=NEW_SPLAY_TREE()
 CMP_GLBLTBL=NEW_SPLAY_TREE()
 CMP_FUNCTBL=NEW_SPLAY_TREE()
 CMP_CONSTTBL=NEW_SPLAY_TREE()
 CMP_GVARNUM=1
 CMP_BREAK=EMPTY()
 CMP_CONTINUE=EMPTY()
 CMP_DATA%=ARRAY%(0)
 CMP_DATA#=ARRAY#(0)
 CMP_DATA$=ARRAY$(0)
 CMP_DATA_TYP=ARRAY%(0)
 INIT_VM_CODEGEN
 CMP_SLOT=SLOT
 CMP_HAS_ERR=#FALSE
END
DEF ADD_DATA V
 VAR N$
 PUSH CMP_DATA%,0
 PUSH CMP_DATA#,0
 PUSH CMP_DATA$,N$
 PUSH CMP_DATA_TYP,0
 CASE TYPEOF(V)
 WHEN #T_INT
  CMP_DATA_TYP[LAST(CMP_DATA_TYP)]=#VMT_INT
  CMP_DATA%[LAST(CMP_DATA%)]=V
 WHEN #T_REAL
  CMP_DATA_TYP[LAST(CMP_DATA_TYP)]=#VMT_REAL
  CMP_DATA#[LAST(CMP_DATA#)]=V
 WHEN #T_STR
  CMP_DATA_TYP[LAST(CMP_DATA_TYP)]=#VMT_STR
  CMP_DATA$[LAST(CMP_DATA$)]=V
 OTHERWISE
  INTERNAL_COMPILER_ERROR
 ENDCASE
END
DEF DETER_VAR_TYPE NAME$,ARY OUT TYP
 CASE RIGHT$(NAME$,1)
 WHEN "$"
  IF ARY THEN
   TYP=#VMT_STRARRAY
  ELSE
   TYP=#VMT_STR
  ENDIF
 WHEN "%"
  IF ARY THEN
   TYP=#VMT_INTARRAY
  ELSE
   TYP=#VMT_INT
  ENDIF
 WHEN "#"
  IF ARY THEN
   TYP=#VMT_REALARRAY
  ELSE
   TYP=#VMT_REAL
  ENDIF
 OTHERWISE
  IF CMP_DEFINT THEN
   IF ARY THEN
    TYP=#VMT_INTARRAY
   ELSE
    TYP=#VMT_INT
   ENDIF
  ELSE
   IF ARY THEN
    TYP=#VMT_REALARRAY
   ELSE
    TYP=#VMT_REAL
   ENDIF
  ENDIF
 ENDCASE
END
DEF DEFINE_VAR NAME$,ARY OUT IDX,LOCAL
 VAR TYP
 VAR FOUND,VA
 DETER_VAR_TYPE NAME$,ARY OUT TYP
 IF ARY THEN TYP=#VMT_DEFAULT
 IF CMP_CURFUNC THEN
  LOCAL=#TRUE
  SPLAY_GET% FUNC_VARTBL[CMP_CURFUNC],NAME$ OUT FOUND,VA
  IF FOUND THEN
   COMPILER_DUPLICATE_VARIABLE NAME$
   IDX=VAR_IDX[VA]
   RETURN
  ENDIF
  SPLAY_INSERT% FUNC_VARTBL[CMP_CURFUNC],NAME$,NEW_VAR(FUNC_VARNUM[CMP_CURFUNC],TYP)
  INC FUNC_VARNUM[CMP_CURFUNC]
  IDX=FUNC_VARNUM[CMP_CURFUNC]-1
 ELSE
  LOCAL=#FALSE
  SPLAY_GET% CMP_GVARTBL,NAME$ OUT FOUND,VA
  IF FOUND THEN
   COMPILER_DUPLICATE_VARIABLE NAME$
   IDX=VAR_IDX[VA]
   RETURN
  ENDIF
  SPLAY_INSERT% CMP_GVARTBL,NAME$,NEW_VAR(CMP_GVARNUM,TYP)
  INC CMP_GVARNUM
  IDX=CMP_GVARNUM-1
 ENDIF
END
DEF GET_VAR_INDEX NAME$ OUT IDX,LOCAL
 VAR FOUND,V
 IF CMP_CURFUNC THEN
  LOCAL=#TRUE
  SPLAY_GET% FUNC_VARTBL[CMP_CURFUNC],NAME$ OUT FOUND,V
 ENDIF
 IF !FOUND THEN
  LOCAL=#FALSE
  SPLAY_GET% CMP_GVARTBL,NAME$ OUT FOUND,V
 ENDIF
 IF !FOUND THEN
  IF CMP_STRICT THEN
   UNDEFINED_VARIABLE_ERROR
  ENDIF
  DEFINE_VAR NAME$,#FALSE OUT IDX,LOCAL
 ELSE
  IDX=VAR_IDX[V]
 ENDIF
END
DEF DEFINE_LABEL NAME$
 VAR L
 DEFINE_LABEL2 NAME$ OUT L
END
DEF DEFINE_LABEL2 NAME$ OUT L
 'TODO:LOCAL
 VAR FOUND
 VAR TBL
 IF CMP_CURFUNC THEN
  TBL=FUNC_LBLTBL[CMP_CURFUNC]
 ELSE
  TBL=CMP_GLBLTBL
 ENDIF
 SPLAY_GET% TBL,NAME$ OUT FOUND,
 IF FOUND THEN
  COMPILER_DUPLICATE_LABEL NAME$
 ENDIF
 L=NEW_LABEL(COMPILER_CURRENT_ADDR(),LEN(CMP_DATA_TYP))
 SPLAY_INSERT% TBL,NAME$,L
END
DEF COMPILE AST
 COMPILE_STATEMENTS AST
 IF CMP_REPL THEN
  LOAD_VM_SLOT_REPL
 ELSE
  LOAD_VM_SLOT CMP_SLOT
 ENDIF
END
DEF COMPILE_STATEMENTS A
 VAR I
 CASE AST_TYP[A]
 WHEN #AST_STATEMENTS
  I=AST_NEXT[AST_LEFT[A]]
  WHILE I
   IF!I THEN BREAK
   COMPILE_STATEMENT AST_LEFT[I]
   I=AST_NEXT[I]
  WEND
 OTHERWISE
  COMPILE_ERROR
 ENDCASE
END
DEF COMPILE_STATEMENT A
 IF AST_TYP[A]!=#AST_DEF THEN
  VMDBG_ADD_SRC_INFO AST_LINE[A],AST_POS[A],AST_LINE_END[A],AST_POS_END[A]
 ENDIF
 CASE AST_TYP[A]
 WHEN #AST_PRINT
  COMPILE_PRINT A
 WHEN #AST_ASSIGN
  COMPILE_EXPR AST_RIGHT[A]
  COMPILE_REFEXPR AST_LEFT[A]
  EMIT_ASSIGN
 'A1:EXPR
 'A2:THEN STATEMENTS
 'A3:ELSEIF STATEMENTS
 'A4:ELSE STATEMENTS
 WHEN #AST_IF
  COMPILE_IF A
 WHEN #AST_FOR
  COMPILE_FOR A
 WHEN #AST_BREAK
  COMPILE_BREAK
 WHEN #AST_CONTINUE
  COMPILE_CONTINUE
 WHEN #AST_WHILE
  COMPILE_WHILE A
 WHEN #AST_REPEAT
  COMPILE_REPEAT A
 WHEN #AST_LOOP
  COMPILE_LOOP A
 WHEN #AST_LABEL
  COMPILE_LABEL A
 WHEN #AST_GOTO
  COMPILE_GOTO A
 WHEN #AST_GOSUB
  COMPILE_GOSUB A
 WHEN #AST_GOTOEXPR
  COMPILE_GOTOEXPR A
 WHEN #AST_GOSUBEXPR
  COMPILE_GOSUBEXPR A
 WHEN #AST_ONGOTO
 WHEN #AST_ONGOSUB
  COMPILE_ONGOTO A
 WHEN #AST_ONBREAKGOTO
  COMPILE_ONBREAKGOTO A
 WHEN #AST_ONBREAKGOTOEXPR
  COMPILE_ONBREAKGOTOEXPR A
 WHEN #AST_RETURN
  COMPILE_RETURN A
 WHEN #AST_CALLFUNC
  COMPILE_CALLFUNC A
 WHEN #AST_DEF
  COMPILE_DEF A
 WHEN #AST_RETURNFUNC
  COMPILE_RETURNFUNC A
 WHEN #AST_DEFVAR
  COMPILE_DEFVAR A
 WHEN #AST_END
  COMPILE_END A
 WHEN #AST_OPTIONSTRICT
  CMP_STRICT=#TRUE
 WHEN #AST_OPTIONDEFINT
  CMP_DEFINT=#TRUE
 WHEN #AST_DATA
  COMPILE_DATA A
 WHEN #AST_CONST
  COMPILE_CONST A
 WHEN #AST_ENUM
  COMPILE_ENUM A
 WHEN #AST_READ
  COMPILE_READ A
 WHEN #AST_RESTORE
  COMPILE_RESTORE A
 WHEN #AST_RESTOREEXPR
  COMPILE_RESTOREEXPR A
 WHEN #AST_CALLSPRITE
  EMIT_CALLSPRITE
 WHEN #AST_CALLTEXT
  EMIT_CALLTEXT
 WHEN #AST_TPRINT
  COMPILE_TPRINT A
 WHEN #AST_INC
 WHEN #AST_DEC
  COMPILE_INC A
 WHEN #AST_CASE
  COMPILE_CASE A
 WHEN #AST_SWAP
  COMPILE_SWAP A
 WHEN #AST_INPUT
  COMPILE_INPUT A
 WHEN #AST_LINPUT
  COMPILE_LINPUT A
 WHEN #AST_DEFOUT
  COMPILE_DEFOUT A
 WHEN #AST_EXEC
  COMPILE_EXEC A
 WHEN #AST_STOP
  COMPILE_STOP A
 OTHERWISE
  ?AST_STR$(AST_TYP[A])
  COMPILE_ERROR
 ENDCASE
END

DEF COMPILE_STOP A
 IF AST_A1[A]THEN
  COMPILE_EXPR AST_A1[A]
  EMIT_STOP2
 ELSE
  EMIT_STOP1
 ENDIF
END
DEF COMPILE_EXEC A
 'RIGHT TO LEFT
 IF AST_A2[A]THEN
  COMPILE_EXPR AST_A2[A]
  COMPILE_EXPR AST_A1[A]
  EMIT_EXEC2
 ELSE
  COMPILE_EXPR AST_A1[A]
  EMIT_EXEC1
 ENDIF
END
DEF COMPILE_DEFOUT A
 'RIGHT TO LEFT
 COMPILE_EXPR AST_A2[A]
 COMPILE_EXPR AST_A1[A]
 EMIT_DEFOUT
END
DEF COMPILE_INPUT A
 'RIGHT TO LEFT
 VAR I=AST_PREV[AST_A2[A]]
 VAR CNT
 WHILE I!=AST_A2[A]
  COMPILE_REFEXPR AST_A1[I]
  INC CNT
  I=AST_PREV[I]
 WEND
 IF AST_A1[A]THEN
  COMPILE_EXPR AST_A1[A]
  EMIT_INPUT #TRUE,AST_A3[A],CNT
 ELSE
  EMIT_INPUT #FALSE,AST_A3[A],CNT
 ENDIF
END
DEF COMPILE_LINPUT A
 IF AST_A1[A]THEN
  COMPILE_EXPR AST_A1[A]
  EMIT_LINPUT #TRUE
 ELSE
  EMIT_LINPUT #FALSE
 ENDIF
 COMPILE_REFEXPR AST_A2[A]
 EMIT_ASSIGN
END
DEF COMPILE_SWAP A
 'RIGHT TO LEFT
 COMPILE_REFEXPR AST_RIGHT[A]
 COMPILE_REFEXPR AST_LEFT[A]
 EMIT_SWAP
END
DEF AST_IS_EMPTY_STMTS(A)
 RETURN AST_NEXT[AST_LEFT[A]]==0
END
DEF COMPILE_CASE A
 COMPILE_EXPR AST_A1[A]
 VAR I
 I=AST_NEXT[AST_A2[A]]
 VAR LBL
 DIM BRLIST=ARRAY%(0)
 DIM ENDCASELIST=ARRAY%(0)
 VAR EXPR,STMTS
 VAR HAS_OTHERWISE
 WHILE I
  EXPR=AST_A1[I]
  STMTS=AST_A2[I]
  IF EXPR THEN
   VMDBG_ADD_SRC_INFO AST_LINE[I],AST_POS[I],AST_LINE_END[I],AST_POS_END[I]
   COMPILE_EXPR EXPR
   PUSH BRLIST,EMIT_WHEN()
  ELSE
   VMDBG_ADD_SRC_INFO AST_LINE[I],AST_POS[I],AST_LINE_END[I],AST_POS_END[I]
   HAS_OTHERWISE=#TRUE
   EMIT_POP 1
   PUSH BRLIST,EMIT_BR()
  ENDIF
  I=AST_NEXT[I]
 WEND
 IF !HAS_OTHERWISE THEN
  EMIT_POP 1
  PUSH ENDCASELIST,EMIT_BR()
 ENDIF
 I=AST_NEXT[AST_A2[A]]
 VAR J
 WHILE I
  EXPR=AST_A1[I]
  STMTS=AST_A2[I]
  EMIT_ADDR BRLIST[J]
  IF EXPR THEN
   IF !AST_IS_EMPTY_STMTS(STMTS)THEN
    COMPILE_STATEMENTS STMTS
    PUSH ENDCASELIST,EMIT_BR()
   ENDIF
  ELSE
   COMPILE_STATEMENTS STMTS
  ENDIF
  INC J
  I=AST_NEXT[I]
 WEND
 FOR I=0TO LAST(ENDCASELIST)
  EMIT_ADDR ENDCASELIST[I]
 NEXT
END
DEF COMPILE_ONGOTO A
 COMPILE_EXPR AST_A1[A]
 VAR I=AST_NEXT[AST_A2[A]]
 DIM LBL$[]
 WHILE I
  PUSH LBL$,AST$[I]
  I=AST_NEXT[I]
 WEND
 EMIT_ONGOTO LBL$,AST_TYP[A]==#AST_ONGOSUB
END
DEF COMPILE_INC A
 'RIGHT TO LEFT
 IF AST_RIGHT[A] THEN
  COMPILE_EXPR AST_RIGHT[A]
 ELSE
  EMIT_PUSHINT 1
 ENDIF
 COMPILE_REFEXPR AST_LEFT[A]
 IF AST_TYP[A]==#AST_INC THEN
  EMIT_INC
 ELSE
  EMIT_DEC
 ENDIF
END
DEF COMPILE_TPRINT A
 VAR I=AST_NEXT[AST_LEFT[A]]
 IF !I THEN
  TYPE_MISMATCH'FIXME:RUNTIME ERROR
 ENDIF
 COMPILE_EXPR AST_LEFT[I]
 I=AST_NEXT[I]
 IF !I THEN
  EMIT_TPRINT #VMPRINT_EMPTY
 ENDIF
 WHILE I
  IF!I THEN BREAK
  COMPILE_EXPR AST_LEFT[I]
  CASE AST_TYP[I]
  WHEN #AST_PRINT_EXPR_COMMA
   EMIT_TPRINT #VMPRINT_COMMA
  WHEN #AST_PRINT_EXPR_NEWLINE
   EMIT_TPRINT #VMPRINT_NEWLINE
  WHEN #AST_PRINT_EXPR_SEMI
   EMIT_TPRINT #VMPRINT_SEMI
  ENDCASE
  I=AST_NEXT[I]
 WEND
 EMIT_POP 1
END
DEF COMPILE_PRINT A
 VAR I=AST_NEXT[AST_LEFT[A]]
 IF !I THEN
  EMIT_PRINT #VMPRINT_EMPTY
 ENDIF
 WHILE I
  IF!I THEN BREAK
  COMPILE_EXPR AST_LEFT[I]
  CASE AST_TYP[I]
  WHEN #AST_PRINT_EXPR_COMMA
   EMIT_PRINT #VMPRINT_COMMA
  WHEN #AST_PRINT_EXPR_NEWLINE
   EMIT_PRINT #VMPRINT_NEWLINE
  WHEN #AST_PRINT_EXPR_SEMI
   EMIT_PRINT #VMPRINT_SEMI
  ENDCASE
  I=AST_NEXT[I]
 WEND
END
DEF FOLD_CONSTEXPR_ARGS(A)
 VAR I=AST_NEXT[A]
 DIM RESULT=ARRAY%(0)
 WHILE I
  PUSH RESULT,FOLD_CONSTEXPR(AST_A1[I])
  I=AST_NEXT[I]
 WEND
 RETURN RESULT
END
DEF AST_IS_NUM(A)
 RETURN AST_TYP[A]==#AST_IMM_INT||AST_TYP[A]==#AST_IMM_DBL
END
DEF AST_IMM(A)
 CASE AST_TYP[A]
 WHEN #AST_IMM_INT
  RETURN AST%[A]
 WHEN #AST_IMM_DBL
  RETURN AST#[A]
 WHEN #AST_IMM_STR
  RETURN AST$[A]
 OTHERWISE
  STOP
 ENDCASE
END
DEF FOLD_CONSTEXPR(A)
 IF !A THEN RETURN 0
 CASE AST_TYP[A]
 WHEN #AST_IMM_INT
 WHEN #AST_IMM_DBL
 WHEN #AST_IMM_STR
  RETURN A
 WHEN #AST_CONSTVAR
  VAR FOUND,C
  SPLAY_GET% CMP_CONSTTBL,AST$[A] OUT FOUND,C
  IF AST$[A]=="#_LINE"THEN
   RETURN NEW_AST_INT(#AST_IMM_INT,AST_LINE[A])
  ELSEIF AST$[A]=="#_SLOT"THEN
   RETURN NEW_AST_INT(#AST_IMM_INT,CMP_SLOT)
  ELSEIF AST$[A]=="#_FILENAME"THEN
    RETURN NEW_AST_STR(#AST_IMM_STR,CMP_FILENAME$)
  ENDIF
  IF!FOUND THEN
   SPLAY_GET% CMP_BCONSTTBL,AST$[A] OUT FOUND,C
  ENDIF
  IF!FOUND THEN
   COMPILER_UNDEFINED_CONSTANT AST$[A]
   RETURN NEW_AST_INT(#AST_IMM_INT,0)
  ELSE
   CASE CMP_CONST_TYP[C]
   WHEN #VMT_INT
    RETURN NEW_AST_INT(#AST_IMM_INT,CMP_CONST%[C])
   WHEN #VMT_REAL
    RETURN NEW_AST_DBL(#AST_IMM_DBL,CMP_CONST#[C])
   WHEN #VMT_STR
    RETURN NEW_AST_STR(#AST_IMM_STR,CMP_CONST$[C])
   OTHERWISE
    INTERNAL_COMPILER_ERROR
   ENDCASE
  ENDIF
 WHEN #AST_CALLFUNCEXPR
  VAR ARGS=FOLD_CONSTEXPR_ARGS(AST_A1[A])
  CASE AST$[A]
  WHEN "RGB"
   IF LEN(ARGS)!=3&&LEN(ARGS)!=4 THEN
    RETURN A
   ENDIF
   IF AST_IS_NUM(ARGS[0])&&AST_IS_NUM(ARGS[1])&&AST_IS_NUM(ARGS[2])THEN
    IF LEN(ARGS)==4 THEN
     IF!AST_IS_NUM(ARGS[3])THEN
      RETURN A
     ELSE
      RETURN NEW_AST_INT(#AST_IMM_INT,RGB(AST_IMM(ARGS[0]),AST_IMM(ARGS[1]),AST_IMM(ARGS[2]),AST_IMM(ARGS[3])))
     ENDIF
    ENDIF
    RETURN NEW_AST_INT(#AST_IMM_INT,RGB(AST_IMM(ARGS[0]),AST_IMM(ARGS[1]),AST_IMM(ARGS[2])))
   ELSE
    RETURN A
   ENDIF
  WHEN "DEG"
   IF LEN(ARGS)!=1 THEN
    RETURN A
   ENDIF
   RETURN NEW_AST_DBL(#AST_IMM_DBL,DEG(AST_IMM(ARGS[0])))
  WHEN "RAD"
   IF LEN(ARGS)!=1 THEN
    RETURN A
   ENDIF
   RETURN NEW_AST_DBL(#AST_IMM_DBL,RAD(AST_IMM(ARGS[0])))
  WHEN "CHR$"
   IF LEN(ARGS)!=1 THEN
    RETURN A
   ENDIF
   RETURN NEW_AST_STR(#AST_IMM_STR,CHR$(AST_IMM(ARGS[0])))
  ENDCASE
 WHEN #AST_UNAOP
  VAR L=FOLD_CONSTEXPR(AST_LEFT[A])
  IF AST_IS_NUM(L) THEN
   L=AST_IMM(L)
   CASE AST%[A]
   WHEN #TKN_LNOT
    RETURN NEW_AST_IMM(!L)
   WHEN #TKN_MINUS
    RETURN NEW_AST_IMM(-L)
   WHEN #TKN_NOT
    RETURN NEW_AST_IMM(NOT L)
   ENDCASE
  ELSE
   RETURN A
  ENDIF
 WHEN #AST_BINOP
  L=FOLD_CONSTEXPR(AST_LEFT[A])
  VAR R=FOLD_CONSTEXPR(AST_RIGHT[A])
  VAR LV=AST_IMM(L)
  VAR RV=AST_IMM(R)
  CASE AST%[A]
  WHEN #TKN_PLUS
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV+RV)
   ENDIF
  WHEN #TKN_MINUS
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV-RV)
   ENDIF
  WHEN #TKN_MUL
   IF AST_IS_NUM(R)&&(AST_IS_NUM(L)||AST_TYP[L]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV*RV)
   ENDIF
  WHEN #TKN_DIV
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV/RV)
   ENDIF
  WHEN #TKN_DIVINT
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV DIV RV)
   ENDIF
  WHEN #TKN_MOD
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV MOD RV)
   ENDIF
  WHEN #TKN_AND
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV AND RV)
   ENDIF
  WHEN #TKN_OR
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV OR RV)
   ENDIF
  WHEN #TKN_EQ
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV==RV)
   ENDIF
  WHEN #TKN_NEQ
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV!=RV)
   ENDIF
  WHEN #TKN_LSHIFT
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV<<RV)
   ENDIF
  WHEN #TKN_RSHIFT
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV>>RV)
   ENDIF
  WHEN #TKN_GREAT
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV<RV)
   ENDIF
  WHEN #TKN_LESS
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV>RV)
   ENDIF
  WHEN #TKN_GEQ
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV<=RV)
   ENDIF
  WHEN #TKN_LEQ
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV>=RV)
   ENDIF
  OTHERWISE
   RETURN A
  ENDCASE
 OTHERWISE
  RETURN A
 ENDCASE
 RETURN A
END
DEF COMPILE_RESTORE A
 IF LEN(AST$[A])THEN
  EMIT_RESTORE_PLACEHOLDER AST$[A]
 ELSE
  'CURRENT SLOT??FIXME
  EMIT_RESTORE CMP_SLOT,0'4.0.1,4.0.2:TYPEMISMATCH
 ENDIF
END
DEF COMPILE_RESTOREEXPR A
 COMPILE_EXPR AST_LEFT[A]
 EMIT_RESTOREEXPR
END
DEF COMPILE_GOTOEXPR A
 COMPILE_EXPR AST_LEFT[A]
 EMIT_GOTOEXPR
END
DEF COMPILE_GOSUBEXPR A
 COMPILE_EXPR AST_LEFT[A]
 EMIT_GOSUBEXPR
END
DEF COMPILE_READ A
 VAR I=AST_NEXT[AST_A1[A]]
 WHILE I
  COMPILE_REFEXPR AST_A1[I]
  ' BAD:READ->EVAL REFEXPR->ASSIGN
  'GOOD:EVAL REFEXPR->READ->ASSIGN
  EMIT_READ
  I=AST_NEXT[I]
 WEND
END
DEF COMPILE_DATA A
 VAR I=AST_NEXT[AST_A1[A]]
 WHILE I
  VAR EXPR=FOLD_CONSTEXPR(AST_A1[I])
  CASE AST_TYP[EXPR]
  WHEN #AST_IMM_INT
   ADD_DATA AST%[EXPR]
  WHEN #AST_IMM_DBL
   ADD_DATA AST#[EXPR]
  WHEN #AST_IMM_STR
   ADD_DATA AST$[EXPR]
  OTHERWISE
   SYNTAX_ERROR "DATA"
  ENDCASE
  I=AST_NEXT[I]
 WEND
END
DEF ADD_CONST N$,C
 VAR FOUND
 SPLAY_GET% CMP_CONSTTBL,N$ OUT FOUND,
 IF FOUND THEN
  COMPILER_DUPLICATE_CONSTANT N$
  RETURN
 ENDIF
 SPLAY_INSERT% CMP_CONSTTBL,N$,NEW_CONST(C)
END
DEF ADD_BCONST N$,C
 VAR FOUND
 SPLAY_GET% CMP_BCONSTTBL,N$ OUT FOUND,
 IF FOUND THEN
  COMPILER_DUPLICATE_CONSTANT N$
  RETURN
 ENDIF
 SPLAY_INSERT% CMP_BCONSTTBL,N$,NEW_CONST(C)
END
DEF COMPILE_END A
 EMIT_END
END
DEF COMPILE_CONST A
 VAR I=AST_NEXT[AST_A1[A]]
 WHILE I
  VAR NAME$=AST$[I]
  VAR EXPR=FOLD_CONSTEXPR(AST_A1[I])
  CASE AST_TYP[EXPR]
  WHEN #AST_IMM_INT
   ADD_CONST NAME$,AST%[EXPR]
  WHEN #AST_IMM_DBL
   ADD_CONST NAME$,AST#[EXPR]
  WHEN #AST_IMM_STR
   ADD_CONST NAME$,AST$[EXPR]
  OTHERWISE
   SYNTAX_ERROR "CONST"
  ENDCASE
  I=AST_NEXT[I]
 WEND
END
DEF COMPILE_ENUM A
 VAR I=AST_NEXT[AST_A1[A]]
 VAR C%
 WHILE I
  VAR NAME$=AST$[I]
  VAR EXPR=FOLD_CONSTEXPR(AST_A1[I])
  IF!EXPR THEN
   ADD_CONST NAME$,C%
   INC C%
  ELSE
   CASE AST_TYP[EXPR]
   WHEN #AST_IMM_INT
    C%=AST%[EXPR]
    ADD_CONST NAME$,C%
    INC C%
   WHEN #AST_IMM_DBL
   WHEN #AST_IMM_STR
    SYNTAX_ERROR "TYPE MISMATCH"
   OTHERWISE
    SYNTAX_ERROR "ENUM"
   ENDCASE
  ENDIF
  I=AST_NEXT[I]
 WEND
END
DEF COMPILE_DEFVAR A
 'A1:LIST
  '$:NAME
  'A1:INIT EXPR
  'A2:ARRAY DIM
  'A3:ARRAY INIT LIST 
 'LEFT TO RIGHT
 VAR I=AST_NEXT[AST_A1[A]]
 WHILE I
  VAR NAME$=AST$[I]
  VAR IDX,LOCAL,ARY
  IF AST_A2[I] THEN
   ARY=#TRUE
  ELSE
   ARY=#FALSE
  ENDIF
  DEFINE_VAR NAME$,ARY OUT IDX,LOCAL
  IF AST_A1[I] THEN
   COMPILE_EXPR AST_A1[I]
   'FIXME:EXTRACT FUNCTION
   IF LOCAL THEN
    EMIT_PUSHLVARREF IDX
   ELSE
    EMIT_PUSHVARREF IDX
   ENDIF
   EMIT_ASSIGN
  ELSEIF ARY THEN
   'RIGHT TO LEFT
   VAR DM=COMPILE_ARRAY_INDEX_EXPR(AST_A2[I])
   IF DM==0THEN
    DM=1
    EMIT_PUSHINT AST_GET_ITEM_COUNT(AST_A3[I])
   ENDIF
   EMIT_NEWARRAY DM,DETER_VAR_TYPE(NAME$,#TRUE)
   IF LOCAL THEN
    EMIT_PUSHLVARREF IDX
   ELSE
    EMIT_PUSHVARREF IDX
   ENDIF
   EMIT_ASSIGN
   IF AST_A3[I]THEN
    'RIGHT TO LEFT
    VAR INITCOUNT=COMPILE_ARRAY_INDEX_EXPR(AST_A3[I])
    IF LOCAL THEN
     EMIT_PUSHLVARREF IDX
    ELSE
     EMIT_PUSHVARREF IDX
    ENDIF
    EMIT_REF
    EMIT_INITARRAY INITCOUNT
   ENDIF
  ENDIF
  I=AST_NEXT[I]
 WEND
END
'RET:DIM
DEF AST_GET_ITEM_COUNT(A)
 IF!A THEN RETURN 0
 VAR I=AST_NEXT[A]
 VAR CNT
 WHILE I
  INC CNT
  I=AST_NEXT[I]
 WEND
 RETURN CNT
END
DEF COMPILE_ARRAY_INDEX_EXPR(A)
 VAR I=AST_PREV[A]
 VAR DM
 WHILE I!=A
  INC DM
  COMPILE_EXPR AST_A1[I]
  I=AST_PREV[I]
 WEND
 RETURN DM
END
CONST #VM_LVAROFF=-7
DEF COMPILE_RETURNFUNC A
 VAR EXPR=AST_LEFT[A]
 IF EXPR THEN
  COMPILE_EXPR EXPR
  IF FUNC_INCNT[CMP_CURFUNC]==-1 THEN
   EMIT_PUSHLVARREF #VM_LVAROFF
   EMIT_ASSIGN
  ELSE
   EMIT_PUSHLVARREF #VM_LVAROFF-FUNC_INCNT[CMP_CURFUNC]
   EMIT_ASSIGN
  ENDIF
 ENDIF
 EMIT_RETURNFUNC
END
DEF COMPILE_DEF A
 '$:NAME
 'A1:IN LIST
 'A2:OUT LIST
 'A3:STATEMENTS
 'A4:HAS RETURN VALUE
 VAR SKIP=EMIT_BR()
 VAR FN$=AST$[A]
 VAR INCNT
 VAR I
 VAR OUTCNT
 VAR CMN
 INCNT=AST_GET_ITEM_COUNT(AST_A1[A])
 OUTCNT=AST_GET_ITEM_COUNT(AST_A2[A])
 IF AST_A4[A]AND #AST_DEF_A4_HAS_RET_VAL THEN
  INC OUTCNT
 ENDIF
 IF AST_A4[A]AND #AST_DEF_A4_OUT_VAARGS THEN
  OUTCNT=-1
 ENDIF
 IF AST_A4[A]AND #AST_DEF_A4_IN_VAARGS THEN
  INCNT=-1
 ENDIF
 IF AST_A4[A]AND #AST_DEF_A4_COMMON_DEF THEN
  CMN=#TRUE
 ENDIF
 CMP_CURFUNC=DEFINE_FUNC(FN$,COMPILER_CURRENT_ADDR(),INCNT,OUTCNT,CMN)
 IF CMN THEN
  VM_DEFINE_COMMON_DEF FN$,CMP_CURFUNC
 ENDIF
 I=AST_NEXT[AST_A1[A]]
 VAR IDX=#VM_LVAROFF+1
 WHILE I
  DEC IDX
  DEFINE_LOCAL_VAR CMP_CURFUNC,AST$[I],IDX
  I=AST_NEXT[I]
 WEND
 I=AST_PREV[AST_A2[A]]
 WHILE I!=AST_A2[A]
  DEC IDX
  DEFINE_LOCAL_VAR CMP_CURFUNC,AST$[I],IDX
  I=AST_PREV[I]
 WEND
 COMPILE_STATEMENTS AST_A3[A]
' EMIT_RETURNFUNC
 EMIT_ADDR SKIP
 CMP_CURFUNC=0
END
DEF DEFINE_LOCAL_VAR FUNC,V$,IDX
 VAR FOUND
 SPLAY_GET% FUNC_VARTBL[FUNC],V$ OUT FOUND,
 IF FOUND THEN
  'NO ERROR!?
  'IF VER<4.0.2 THEN RETURN
  COMPILER_DUPLICATE_VARIABLE V$
  RETURN
 ENDIF
 SPLAY_INSERT% FUNC_VARTBL[FUNC],V$,NEW_VAR(IDX,#VMT_DEFAULT)
END
DEF DEFINE_FUNC(FN$,ADDR,INCNT,OUTCNT,CMN)
 VAR FOUND
 SPLAY_GET% CMP_FUNCTBL,FN$ OUT FOUND,
 IF FOUND THEN
  COMPILER_DUPLICATE_FUNCTION FN$
 ENDIF
 VAR F=NEW_FUNC(FN$,ADDR,INCNT,OUTCNT,CMP_SLOT,CMN)
 SPLAY_INSERT% CMP_FUNCTBL,FN$,F
 RETURN F
END
DEF COMPILE_CALLFUNC A
 'A1:IN ARGS
 'A2:OUT ARGS
 VAR FN$=AST$[A]
 VAR INCNT=0
 VAR I
 VAR OUTCNT
 IF AST_TYP[A]==#AST_CALLFUNC THEN
  OUTCNT=AST_GET_ITEM_COUNT(AST_A2[A])
 ELSE
  OUTCNT=1
 ENDIF
 EMIT_PUSHEMPTY OUTCNT
 I=AST_PREV[AST_A1[A]]
 WHILE I!=AST_A1[A]
  COMPILE_EXPR AST_A1[I]
  I=AST_PREV[I]
  INC INCNT
 WEND
 EMIT_CALLFUNC FN$,INCNT,OUTCNT
 IF AST_TYP[A]==#AST_CALLFUNC THEN
  I=AST_PREV[AST_A2[A]]
  WHILE I!=AST_A2[A]
   COMPILE_REFEXPR AST_A1[I]
   EMIT_ASSIGN
   I=AST_PREV[I]
   INC OUTCNT
  WEND
 ENDIF
END
DEF COMPILE_IF A
 COMPILE_EXPR AST_A1[A]
 VAR ENDIF_POS=AST_A5[A]
 VAR ADDR_ELSE=EMIT_BRFALSE()
 COMPILE_STATEMENTS AST_A2[A]
 IF AST_A4[A]||AST_A3[A]THEN
  IF ENDIF_POS THEN
   VMDBG_ADD_SRC_INFO AST_LINE[ENDIF_POS],AST_POS[ENDIF_POS],AST_LINE_END[ENDIF_POS],AST_POS_END[ENDIF_POS]
  ENDIF
  VAR ADDR_ENDIF=EMIT_BR()
 ENDIF
 EMIT_ADDR ADDR_ELSE
 IF AST_A3[A]THEN'ELSEIF
  DIM BRLIST[0]
  VAR I=AST_NEXT[AST_A3[A]]
  WHILE I
   VMDBG_ADD_SRC_INFO2 AST_LINE[I],AST_POS[I],AST_LINE_END[I],AST_POS_END[I],RIR_NEXT_ADDR()
   COMPILE_EXPR AST_A1[I]
   VAR ADDR_AFTER_ELSEIF=EMIT_BRFALSE()
   COMPILE_STATEMENTS AST_A2[I]
   I=AST_NEXT[I]
   IF ENDIF_POS THEN
    VMDBG_ADD_SRC_INFO AST_LINE[ENDIF_POS],AST_POS[ENDIF_POS],AST_LINE_END[ENDIF_POS],AST_POS_END[ENDIF_POS]
   ENDIF
   PUSH BRLIST,EMIT_BR()
   EMIT_ADDR ADDR_AFTER_ELSEIF
  WEND
 ENDIF
 IF AST_A4[A]THEN'ELSE
  COMPILE_STATEMENTS AST_A4[A]
 ENDIF
 IF AST_A4[A]||AST_A3[A]THEN
  EMIT_ADDR ADDR_ENDIF
 ENDIF
 IF AST_A3[A]THEN'ELSEIF
  FOR I=0TO LAST(BRLIST)
   EMIT_ADDR BRLIST[I]
  NEXT
 ENDIF
END
DEF COMPILE_CONTINUE
 IF TYPEOF(CMP_CONTINUE)!=#T_INTARRAY THEN
  SYNTAX_ERROR
  RETURN
 ENDIF
 PUSH CMP_CONTINUE,EMIT_BR()
END
DEF COMPILE_BREAK
 IF TYPEOF(CMP_CONTINUE)!=#T_INTARRAY THEN
  SYNTAX_ERROR
  RETURN
 ENDIF
 PUSH CMP_BREAK,EMIT_BR()
END
DEF COMPILE_FOR A
 'A1:INDEXREFEXPR
 'A2:INITEXPR
 'A3:TOEXPR
 'A4:STEPEXPR
 'A5:STATEMENTS
 VAR INDEXREF=AST_A1[A]
 VAR INITEXPR=AST_A2[A]
 VAR TOEXPR=AST_A3[A]
 VAR STEPEXPR=AST_A4[A]
 VAR STATEMENTS=AST_A5[A]
 COMPILE_EXPR INITEXPR
 COMPILE_REFEXPR INDEXREF
 EMIT_ASSIGN
 'FOR INDEXREF=INITEXPR TO TOEXPR STEP STEPEXPR
 'PUSH INITEXPR
 'PUSH INDEXREF
 'ASSIGN
 '@CONT
 'PUSH INDEXREF
 'PUSH STEPEXPR
 'PUSH TOEXPR
 '*FOR STEP INSTR* @BRK
 'STATEMENTS... (GOTO @CONT,@BRK
 'GOTO @CONT
 '@BRK


 'FOR INDEXREF=INITEXPR TO TOEXPR
 'PUSH INITEXPR
 'PUSH INDEXREF
 'ASSIGN
 '@CONT
 'PUSH INDEXREF
 'PUSH TOEXPR
 '*FOR INSTR* @BRK
 'STATEMENTS... (GOTO @CONT,@BRK
 'GOTO @CONT
 '@BRK
 COMPILE_REFEXPR INDEXREF
 IF STEPEXPR THEN
  COMPILE_EXPR STEPEXPR
 ELSE
  EMIT_PUSHINT 1
 ENDIF
 COMPILE_EXPR TOEXPR
 VAR BRKADDR
 BRKADDR=EMIT_FORINIT()
 VAR LOOPADDR=COMPILER_CURRENT_ADDR()
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  COMPILE_STATEMENTS STATEMENTS
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   EMIT_ADDR CMP_CONTINUE[I]
  NEXT
  VMDBG_ADD_SRC_INFO AST_LINE[A],AST_POS[A],AST_LINE_END[A],AST_POS_END[A]
  COMPILE_REFEXPR INDEXREF
  IF STEPEXPR THEN
   COMPILE_EXPR STEPEXPR
  ELSE
   EMIT_PUSHINT 1
  ENDIF
  COMPILE_EXPR TOEXPR
  VAR BRKADDR2
  BRKADDR2=EMIT_FOR()
  EMIT_ADDR BRKADDR
  EMIT_ADDR2 BRKADDR2,LOOPADDR
  FOR I=0TO LAST(CMP_BREAK)
   EMIT_ADDR CMP_BREAK[I]
  NEXT
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF COMPILE_WHILE A
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  VAR CONTADDR=COMPILER_CURRENT_ADDR()
  COMPILE_EXPR AST_A1[A]
  VAR BRL=EMIT_BRFALSE()
  COMPILE_STATEMENTS AST_A2[A]
  EMIT_ADDR2 EMIT_BR(),CONTADDR
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   EMIT_ADDR2 CMP_CONTINUE[I],CONTADDR
  NEXT
  FOR I=0TO LAST(CMP_BREAK)
   EMIT_ADDR CMP_BREAK[I]
  NEXT
  EMIT_ADDR BRL
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF COMPILE_REPEAT A
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  VAR LOOPADDR=COMPILER_CURRENT_ADDR()
  COMPILE_STATEMENTS AST_A2[A]
  VAR CONTADDR=COMPILER_CURRENT_ADDR()
  VMDBG_ADD_SRC_INFO AST_LINE[A],AST_POS[A],AST_LINE_END[A],AST_POS_END[A]
  COMPILE_EXPR AST_A1[A]
  EMIT_ADDR2 EMIT_BRFALSE(),LOOPADDR
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   EMIT_ADDR2 CMP_CONTINUE[I],CONTADDR
  NEXT
  FOR I=0TO LAST(CMP_BREAK)
   EMIT_ADDR CMP_BREAK[I]
  NEXT
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF COMPILE_LOOP A
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  VAR CONTADDR=COMPILER_CURRENT_ADDR()
  COMPILE_STATEMENTS AST_A2[A]
  VMDBG_ADD_SRC_INFO AST_LINE[A],AST_POS[A],AST_LINE_END[A],AST_POS_END[A]
  EMIT_ADDR2 EMIT_BR(),CONTADDR
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   EMIT_ADDR2 CMP_CONTINUE[I],CONTADDR
  NEXT
  FOR I=0TO LAST(CMP_BREAK)
   EMIT_ADDR CMP_BREAK[I]
  NEXT
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF COMPILE_REFEXPR A
 CASE AST_TYP[A]
 WHEN #AST_VAR
  VAR IDX,LC
  GET_VAR_INDEX AST$[A] OUT IDX,LC
  IF LC THEN
   EMIT_PUSHLVARREF IDX
  ELSE
   EMIT_PUSHVARREF IDX
  ENDIF
 WHEN #AST_EMPTYEXPR
  EMIT_PUSHEMPTYREF
 WHEN #AST_BINOP
  VAR TYP=AST%[A]
  IF TYP!=#TKN_LB THEN
   SYNTAX_ERROR "EXPECTED '['"
   RETURN
  ENDIF
  VAR DM=COMPILE_ARRAY_INDEX_EXPR(AST_RIGHT[A])
  COMPILE_EXPR AST_LEFT[A]
  EMIT_PUSHARYREF DM
 WHEN #AST_VAREXPR
  COMPILE_EXPR AST_LEFT[A]
  EMIT_PUSHVAREXPRREF
 OTHERWISE
  COMPILE_ERROR
 ENDCASE
END
DEF COMPILE_EXPR A
 CASE AST_TYP[A]
 WHEN #AST_BINOP
  VAR TYP=AST%[A]
  IF TYP==#TKN_LAND THEN
   COMPILE_EXPR AST_LEFT[A]
   VAR BR1=EMIT_BRAND()
   COMPILE_EXPR AST_RIGHT[A]
   VAR BR2=EMIT_BRAND()
   EMIT_PUSHINT #TRUE
   EMIT_ADDR BR1
   EMIT_ADDR BR2
  ELSEIF TYP==#TKN_LOR THEN
   COMPILE_EXPR AST_LEFT[A]
   BR1=EMIT_BROR()
   COMPILE_EXPR AST_RIGHT[A]
   BR2=EMIT_BROR()
   EMIT_PUSHINT #FALSE
   EMIT_ADDR BR1
   EMIT_ADDR BR2
  ELSEIF TYP==#TKN_LB THEN
   VAR DM=COMPILE_ARRAY_INDEX_EXPR(AST_RIGHT[A])
   COMPILE_EXPR AST_LEFT[A]
   EMIT_PUSHARYREF DM
   EMIT_REF
  ELSE
   COMPILE_EXPR AST_LEFT[A]
   COMPILE_EXPR AST_RIGHT[A]
   EMIT_BINOP AST%[A]
  ENDIF
 WHEN #AST_IMM_INT
  EMIT_PUSHINT AST%[A]
 WHEN #AST_IMM_DBL
  EMIT_PUSHDBL AST#[A]
 WHEN #AST_IMM_STR
  EMIT_PUSHSTR AST$[A]
 WHEN #AST_VAR
  COMPILE_REFEXPR A
  EMIT_REF
 WHEN #AST_CALLFUNCEXPR
  COMPILE_CALLFUNC A
 WHEN #AST_CONSTVAR
  COMPILE_EXPR FOLD_CONSTEXPR(A)
 WHEN #AST_UNAOP
  COMPILE_EXPR AST_LEFT[A]
  EMIT_UNAOP AST%[A]
 WHEN #AST_EMPTYEXPR
  EMIT_PUSHEMPTY 1
 WHEN #AST_VAREXPR
  COMPILE_EXPR AST_LEFT[A]
  EMIT_PUSHVAREXPR
 OTHERWISE
  ?AST_STR$(AST_TYP[A])
  COMPILE_ERROR
 ENDCASE
END
DEF COMPILE_LABEL A
 DEFINE_LABEL AST$[A]
END
DEF COMPILE_GOTO A
 EMIT_GOTO_PLACEHOLDER AST$[A]
END
DEF COMPILE_GOSUB A
 EMIT_GOSUB_PLACEHOLDER AST$[A]
END
DEF COMPILE_RETURN A
 EMIT_RETURN
END
DIM VM_OPS[]
DIM VMDBG_LINE_PC[]
DIM VMDBG_LINE[]
DIM VMDBG_LINE_POS[]
DIM VMDBG_LINE_END[]
DIM VMDBG_LINE_POS_END[]
DIM VM_IMM#[]
DIM VM_IMM$[]

DIM VM_STK_TYP[]
DIM VM_STK%[]
DIM VM_STK#[]
DIM VM_STK$[]
VAR VM_STK_SIZE
VAR VM_SP
VAR VM_BP
DIM VM_GVAR_TYP[]
DIM VM_GVAR%[]
DIM VM_GVAR#[]
DIM VM_GVAR$[]
VAR VM_GLBLTBL
VAR VM_GVARTBL
VAR VM_CFUNCTBL
VAR VM_FUNCTBL
VAR VM_PC
VAR VM_PREV_PC
VAR VM_RUNNING

DIM VM_DATA_TYP[]
DIM VM_DATA%[]
DIM VM_DATA#[]
DIM VM_DATA$[]
DIM VM_DATA_IDX
VAR VM_CURFUNC
VAR VM_CURSLOT
VAR VM_CURDATASLOT

VAR VM_ALLOC_ARRAY
COMMON DEF VM_ALLOC_ARRAY(ARY)

 IF TYPEOF(ARY)<#T_INTARRAY THEN
  STOP
 ENDIF
 VAR S=AllocSBArray()
'?"Akic!";S,TYPEOF(ARY)
'IF LEN(ARY)<10THEN
'??ARY
'ENDIF
 SetSBArray S,ARY
 RETURN S
 SPVAR #GSPRITE,VM_ALLOC_ARRAY,ARY
 INC VM_ALLOC_ARRAY
 RETURN VM_ALLOC_ARRAY-1
END
COMMON DEF VM_FREE_ARRAY ARY
 VAR B=GetSBArray(ARY)
'?"free!";ARY
'IF LEN(B)<10THEN
'??B
'ENDIF
 FreeSBArray ARY
' SPVAR #GSPRITE,ARY,EMPTY()
END
DEF VM_GET_ARRAY(ARY)
' ?"get";ARY
 RETURN GetSBArray(ARY)
 RETURN SPVAR(#GSPRITE,ARY)
END

COMMON DEF VM_GETFREE_ARRAY(ARY)
 VAR B=GetSBArray(ARY)
'?"free!";ARY
'IF LEN(B)<10THEN
'??B
'ENDIF
 FreeSBArray ARY
 RETURN B
 VAR A=SPVAR(#GSPRITE,ARY)
' SPVAR #GSPRITE,ARY,EMPTY()
 RETURN A
END

ENUM\
 #VM_NOP,\
 #VM_PUSHINT,\
 #VM_PUSHDBL,\
 #VM_PUSHSTR,\
 #VM_BINOP,\
 #VM_PRINT,\
 #VM_TPRINT,\
 #VM_ASSIGN,\
 #VM_PUSHVARREF,\
 #VM_PUSHLVARREF,\
 #VM_REF,\
 #VM_BR,\
 #VM_BRTRUE,\
 #VM_BRFALSE,\
 #VM_FOR,\
 #VM_FORINIT,\
 #VM_BRAND,\
 #VM_BROR,\
 #VM_GOTO_PLACEHOLDER,\
 #VM_GOSUB_PLACEHOLDER,\
 #VM_GOSUB,\
 #VM_GOTOEXPR,\
 #VM_GOSUBEXPR,\
 #VM_ONGOTO,\
 #VM_ONGOSUB,\
 #VM_RETURN,\
 #VM_CALLFUNC,\
 #VM_PUSHEMPTY,\
 #VM_RETURNFUNC,\
 #VM_PUSHEMPTYREF,\
 #VM_PUSHARYREF,\
 #VM_END,\
 #VM_NEWARRAY,\
 #VM_INITARRAY,\
 #VM_READ,\
 #VM_RESTORE,\
 #VM_RESTORE_PLACEHOLDER,\
 #VM_RESTOREEXPR,\
 #VM_UNAOP,\
 #VM_CALLSPRITE,\
 #VM_CALLTEXT,\
 #VM_INC,\
 #VM_DEC,\
 #VM_POP,\
 #VM_WHEN,\
 #VM_SWAP,\
 #VM_INPUT,\
 #VM_LINPUT,\
 #VM_DEFOUT,\
 #VM_EXEC1,\
 #VM_EXEC2,\
 #VM_STOP1,\
 #VM_STOP2,\
 #VM_PUSHVAREXPR,\
 #VM_PUSHVAREXPRREF,\
 #VM_INITCALLSPRITE,\
 #VM_INITCALLTEXT,\
 #VM_,\
 #VM_LAST

DIM VM_SLOT_OPS[]
DIM VMDBG_SLOT_LINE[]
DIM VMDBG_SLOT_LINE_PC[]
DIM VMDBG_SLOT_LINE_POS[]
DIM VMDBG_SLOT_LINE_END[]
DIM VMDBG_SLOT_LINE_POS_END[]
DIM VMDBG_SLOT_LINE_PC_INDEX[]
DIM VMDBG_SLOT_LINE_PC_INDEX2[]
DIM VM_SLOT_IMM#[]
DIM VM_SLOT_IMM$[]
DIM VM_SLOT_GVARTBL[]
DIM VM_SLOT_GLBLTBL[]
DIM VM_SLOT_FUNCTBL[]
DIM VM_SLOT_CONSTTBL[]
DIM VM_SLOT_CONST_TYP[]
DIM VM_SLOT_CONST%[]
DIM VM_SLOT_CONST#[]
DIM VM_SLOT_CONST$[]
DIM VM_SLOT_GVAR_TYP[]
DIM VM_SLOT_GVAR%[]
DIM VM_SLOT_GVAR#[]
DIM VM_SLOT_GVAR$[]
DIM VM_SLOT_DATA_TYP[]
DIM VM_SLOT_DATA%[]
DIM VM_SLOT_DATA#[]
DIM VM_SLOT_DATA$[]
DIM VM_SLOT_EXEC_ADDR[]
DIM VM_SLOT_EXEC_FUNC[]
DIM VM_SLOT_EXEC_SLOT[]
VAR VM_TYPE$
DEF VM_IS_SLOT_COMPILED(SLOT)
 RETURN VM_SLOT_OPS[SLOT]!=0
END
DEF VM_GET_MAX_SLOT()
 RETURN LAST(VM_SLOT_OPS)
END
DEF VM_SWITCH_SLOT SLOT
 VM_OPS=VM_GET_ARRAY(VM_SLOT_OPS[SLOT])
 VM_IMM#=VM_GET_ARRAY(VM_SLOT_IMM#[SLOT])
 VM_IMM$=VM_GET_ARRAY(VM_SLOT_IMM$[SLOT])
 VM_GVAR_TYP=VM_GET_ARRAY(VM_SLOT_GVAR_TYP[SLOT])
 VM_GVAR%=VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT])
 VM_GVAR#=VM_GET_ARRAY(VM_SLOT_GVAR#[SLOT])
 VM_GVAR$=VM_GET_ARRAY(VM_SLOT_GVAR$[SLOT])
 VM_GVARTBL=VM_SLOT_GVARTBL[SLOT]
 VM_GLBLTBL=VM_SLOT_GLBLTBL[SLOT]
 VM_FUNCTBL=VM_SLOT_FUNCTBL[SLOT]
END
DEF VM_SWITCH_SLOT_DATA SLOT
 VM_DATA_TYP=VM_GET_ARRAY(VM_SLOT_DATA_TYP[SLOT])
 VM_DATA%=VM_GET_ARRAY(VM_SLOT_DATA%[SLOT])
 VM_DATA#=VM_GET_ARRAY(VM_SLOT_DATA#[SLOT])
 VM_DATA$=VM_GET_ARRAY(VM_SLOT_DATA$[SLOT])
END
DEF INIT_VM_CODEGEN
 VM_OPS=ARRAY%(0)
 VM_IMM#=ARRAY#(0)
 VM_IMM$=ARRAY$(0)
 VMDBG_LINE=ARRAY%(0)
 VMDBG_LINE_PC=ARRAY%(0)
 VMDBG_LINE_POS=ARRAY%(0)
 VMDBG_LINE_END=ARRAY%(0)
 VMDBG_LINE_POS_END=ARRAY%(0)
END

DIM SPFUNC_LIST[]
DIM SBTHUNK_SPFUNC$[]
DIM SBTHUNK_SPFUNC_SLOT[]
DIM SBTHUNK_SPFUNC_ADDR[]
DIM SBTHUNK_SPFUNC_ISFUNC[]
DIM TFUNC_LIST[]
DIM SBTHUNK_TFUNC$[]
DIM SBTHUNK_TFUNC_SLOT[]
DIM SBTHUNK_TFUNC_ADDR[]
DIM SBTHUNK_TFUNC_ISFUNC[]
VAR VM_CALLIDX
VAR VM_COMPILED
DEF INIT_VM
 VM_CALLIDX=0
 VM_COMPILED=#FALSE
 SPFUNC_LIST=ARRAY%(4096)
 SBTHUNK_SPFUNC$=ARRAY$(4096)
 SBTHUNK_SPFUNC_SLOT=ARRAY%(4096)
 SBTHUNK_SPFUNC_ADDR=ARRAY%(4096)
 SBTHUNK_SPFUNC_ISFUNC=ARRAY%(4096)
 TFUNC_LIST=ARRAY%(4)
 SBTHUNK_TFUNC$=ARRAY$(4)
 SBTHUNK_TFUNC_SLOT=ARRAY%(4096)
 SBTHUNK_TFUNC_ADDR=ARRAY%(4096)
 SBTHUNK_TFUNC_ISFUNC=ARRAY%(4096)
 VM_TYPE$="S"
 VM_STK_SIZE=65536
 VM_STK_TYP=ARRAY%(VM_STK_SIZE)
 VM_STK%=ARRAY%(VM_STK_SIZE)
 VM_STK#=ARRAY#(VM_STK_SIZE)
 VM_STK$=ARRAY$(VM_STK_SIZE)
 VM_PC=0
 VM_DATA_IDX=0
 VM_CURFUNC=0
 VM_BP=0
 VM_SP=0
 INIT_COMPILER_VAR
 INIT_COMPILER_LABEL
 INIT_COMPILER_FUNC
 INIT_COMPILER_CONST
 OTX_INIT_SBARRAY
 VM_CFUNCTBL=NEW_SPLAY_TREE()

 VM_CURSLOT=0
 VM_CURDATASLOT=0
 VAR MAX_SLOT=4
 VM_SLOT_OPS=ARRAY%(MAX_SLOT)
 VMDBG_SLOT_LINE=ARRAY%(MAX_SLOT)
 VMDBG_SLOT_LINE_PC=ARRAY%(MAX_SLOT)
 VMDBG_SLOT_LINE_POS=ARRAY%(MAX_SLOT)
 VMDBG_SLOT_LINE_END=ARRAY%(MAX_SLOT)
 VMDBG_SLOT_LINE_POS_END=ARRAY%(MAX_SLOT)
 VMDBG_SLOT_LINE_PC_INDEX=ARRAY%(MAX_SLOT)
 VMDBG_SLOT_LINE_PC_INDEX2=ARRAY%(MAX_SLOT)
 VM_SLOT_IMM#=ARRAY%(MAX_SLOT)
 VM_SLOT_IMM$=ARRAY%(MAX_SLOT)
 VM_SLOT_GVARTBL=ARRAY%(MAX_SLOT)
 VM_SLOT_GLBLTBL=ARRAY%(MAX_SLOT)
 VM_SLOT_FUNCTBL=ARRAY%(MAX_SLOT)
 VM_SLOT_CONSTTBL=ARRAY%(MAX_SLOT)
 VM_SLOT_CONST_TYP=ARRAY%(MAX_SLOT)
 VM_SLOT_CONST%=ARRAY%(MAX_SLOT)
 VM_SLOT_CONST#=ARRAY%(MAX_SLOT)
 VM_SLOT_CONST$=ARRAY%(MAX_SLOT)
 VM_SLOT_GVAR_TYP=ARRAY%(MAX_SLOT)
 VM_SLOT_GVAR%=ARRAY%(MAX_SLOT)
 VM_SLOT_GVAR#=ARRAY%(MAX_SLOT)
 VM_SLOT_GVAR$=ARRAY%(MAX_SLOT)
 VM_SLOT_DATA_TYP=ARRAY%(MAX_SLOT)
 VM_SLOT_DATA%=ARRAY%(MAX_SLOT)
 VM_SLOT_DATA#=ARRAY%(MAX_SLOT)
 VM_SLOT_DATA$=ARRAY%(MAX_SLOT)
 VM_SLOT_EXEC_FUNC=ARRAY%(MAX_SLOT)
 VM_SLOT_EXEC_ADDR=ARRAY%(MAX_SLOT)
 VM_SLOT_EXEC_SLOT=ARRAY%(MAX_SLOT)
END
DEF VM_RESET
 INIT_VM
END
'SLOTをのこしてしょきかじょうたいにする
DEF VM_RESTART SLOT
 VAR TYP=VM_GET_ARRAY(VM_SLOT_GVAR_TYP[SLOT])
 VAR V%=VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT])
 VAR V#=VM_GET_ARRAY(VM_SLOT_GVAR#[SLOT])
 VAR V$=VM_GET_ARRAY(VM_SLOT_GVAR$[SLOT])
 FILL V%,0
 FILL V#,0
 RESIZE V$,0
 RESIZE V$,LEN(V#)'TODO:NULLもじれつをFILL?
 INIT_VM_GLOBAL_VAR TYP,GET_SPLAY_ROOT(VM_SLOT_GVARTBL[SLOT])
 VAR I
 FOR I=0TO LAST(VM_SLOT_OPS)
  IF I!=SLOT&&VM_IS_SLOT_COMPILED(I) THEN
   VM_FREE_SLOT SLOT
  ENDIF
 NEXT
 FOR I=0TO VM_SP-1
  VM_POP OUT ,
 NEXT
 VM_SLOT_EXEC_SLOT[SLOT]=-1
 VM_SLOT_EXEC_ADDR[SLOT]=-1
 VM_SLOT_EXEC_FUNC[SLOT]=-1
 VM_PC=0
 VM_PREV_PC=0
 VM_DATA_IDX=0
 VM_CURFUNC=0
 VM_BP=0
 VM_SP=0
 VM_CURSLOT=SLOT
 VM_CURDATASLOT=SLOT
END
DEF INIT_VM_GLOBAL_VAR TYPA,N
 IF !N THEN RETURN
 INIT_VM_GLOBAL_VAR TYPA,GET_SPLAYN_LEFT(N)
 VAR K$=GET_SPLAYN_KEY$(N)
 VAR V=GET_SPLAYN_VAL%(N)
 TYPA[VAR_IDX[V]]=VAR_TYP[V]
 INIT_VM_GLOBAL_VAR TYPA,GET_SPLAYN_RIGHT(N)
END
DEF LOAD_VM_SLOT SLOT
 VAR TYP=ARRAY%(CMP_GVARNUM)
 VAR G%=ARRAY%(CMP_GVARNUM)
 VAR G#=ARRAY#(CMP_GVARNUM)
 VAR G$=ARRAY$(CMP_GVARNUM)
 VM_COMPILED=#TRUE
 VM_SLOT_OPS[SLOT]=VM_ALLOC_ARRAY(VM_OPS)
 VMDBG_SLOT_LINE[SLOT]=VM_ALLOC_ARRAY(VMDBG_LINE)
 VMDBG_SLOT_LINE_PC[SLOT]=VM_ALLOC_ARRAY(VMDBG_LINE_PC)
 VMDBG_SLOT_LINE_POS[SLOT]=VM_ALLOC_ARRAY(VMDBG_LINE_POS)
 VMDBG_SLOT_LINE_END[SLOT]=VM_ALLOC_ARRAY(VMDBG_LINE_END)
 VMDBG_SLOT_LINE_POS_END[SLOT]=VM_ALLOC_ARRAY(VMDBG_LINE_POS_END)
 VM_SLOT_IMM#[SLOT]=VM_ALLOC_ARRAY(VM_IMM#)
 VM_SLOT_IMM$[SLOT]=VM_ALLOC_ARRAY(VM_IMM$)
 VM_SLOT_GVAR_TYP[SLOT]=VM_ALLOC_ARRAY(TYP)
 VM_SLOT_GVAR%[SLOT]=VM_ALLOC_ARRAY(G%)
 VM_SLOT_GVAR#[SLOT]=VM_ALLOC_ARRAY(G#)
 VM_SLOT_GVAR$[SLOT]=VM_ALLOC_ARRAY(G$)
 INIT_VM_GLOBAL_VAR TYP,GET_SPLAY_ROOT(CMP_GVARTBL)
 VM_SLOT_GLBLTBL[SLOT]=CMP_GLBLTBL
 VM_SLOT_FUNCTBL[SLOT]=CMP_FUNCTBL
 VM_SLOT_GVARTBL[SLOT]=CMP_GVARTBL
 VM_SLOT_CONSTTBL[SLOT]=CMP_CONSTTBL
 VM_SLOT_DATA_TYP[SLOT]=VM_ALLOC_ARRAY(CMP_DATA_TYP)
 VM_SLOT_DATA%[SLOT]=VM_ALLOC_ARRAY(CMP_DATA%)
 VM_SLOT_DATA#[SLOT]=VM_ALLOC_ARRAY(CMP_DATA#)
 VM_SLOT_DATA$[SLOT]=VM_ALLOC_ARRAY(CMP_DATA$)
 VM_SLOT_EXEC_SLOT[SLOT]=-1
 VM_SLOT_EXEC_ADDR[SLOT]=-1
 VM_SLOT_EXEC_FUNC[SLOT]=-1
 IF VM_TYPE$=="S"THEN
  IF !LEN(VM_OPS)||VM_OPS[LAST(VM_OPS)]!=#VM_END THEN
   PUSH VM_OPS,#VM_END
  ENDIF
 ENDIF
END
VAR VM_REPL_NEW_VAR_IDX
DEF INIT_COMPILER_REPL
 IF TYPEOF(VM_GVAR_TYP)==#T_DEFAULT THEN
  INIT_COMPILER 0
  CMP_REPL=!#FALSE
  RETURN
 ENDIF
 CMP_REPL=!#FALSE
 CMP_HAS_ERR=#FALSE
 VMDBG_LINE=ARRAY%(0)
 VMDBG_LINE_PC=ARRAY%(0)
 VMDBG_LINE_POS=ARRAY%(0)
 CMP_DATA_TYP=VM_DATA_TYP
 CMP_DATA%=VM_DATA%
 CMP_DATA#=VM_DATA#
 CMP_DATA$=VM_DATA$
 CMP_GLBLTBL=VM_GLBLTBL
 CMP_FUNCTBL=VM_FUNCTBL
 CMP_GVARTBL=VM_GVARTBL
 CMP_CONSTTBL=VM_SLOT_CONSTTBL[VM_CURSLOT]
 CMP_GVARNUM=LEN(VM_GVAR_TYP)
 VM_REPL_NEW_VAR_IDX=CMP_GVARNUM
 CMP_STRICT=#FALSE
 CMP_DEFINT=#FALSE
 CMP_BREAK=EMPTY()
 CMP_CONTINUE=EMPTY()
 CMP_SLOT=VM_CURSLOT
 VM_PC=LEN(VM_OPS)
END

DEF INIT_VM_GLOBAL_VAR_REPL NEW_VAR_IDX,TYPA,N
 IF !N THEN RETURN
 INIT_VM_GLOBAL_VAR_REPL NEW_VAR_IDX,TYPA,GET_SPLAYN_LEFT(N)
 VAR V=GET_SPLAYN_VAL%(N)
 IF VAR_IDX[V]>=NEW_VAR_IDX THEN
  VAR K$=GET_SPLAYN_KEY$(N)
  TYPA[VAR_IDX[V]]=VAR_TYP[V]
 ENDIF
 INIT_VM_GLOBAL_VAR_REPL NEW_VAR_IDX,TYPA,GET_SPLAYN_RIGHT(N)
END
DEF LOAD_VM_SLOT_REPL
 IF TYPEOF(VM_GVAR_TYP)==#T_DEFAULT THEN
  LOAD_VM_SLOT 0
  VM_RUN_SLOT 0
  RETURN
 ENDIF
 IF !LEN(VM_OPS)||VM_OPS[LAST(VM_OPS)]!=#VM_END THEN
  PUSH VM_OPS,#VM_END
 ENDIF
 VAR NEW_VAR_IDX=LEN(VM_GVAR_TYP)
 RESIZE VM_GVAR_TYP,CMP_GVARNUM
 RESIZE VM_GVAR%,CMP_GVARNUM
 RESIZE VM_GVAR#,CMP_GVARNUM
 RESIZE VM_GVAR$,CMP_GVARNUM
 INIT_VM_GLOBAL_VAR_REPL NEW_VAR_IDX,VM_GVAR_TYP,GET_SPLAY_ROOT(CMP_GVARTBL)
END

DEF VM_DEFINE_COMMON_DEF N$,FUNC
 VAR FOUND
 SPLAY_GET% VM_CFUNCTBL,N$ OUT FOUND,
 IF FOUND THEN
  COMPILER_DUPLICATE_FUNCTION N$
  RETURN
 ENDIF
 SPLAY_INSERT% VM_CFUNCTBL,N$,FUNC
END

DEF VM_RUN_SLOT SLOT
 VM_SWITCH_SLOT SLOT
 VM_SWITCH_SLOT_DATA SLOT
 VM_PC=0
 VM_PREV_PC=0
 VM_DATA_IDX=0
 VM_CURFUNC=0
 VM_BP=0
 VM_SP=0
 VM_CURSLOT=SLOT
 VM_CURDATASLOT=SLOT
END

DEF VM_STR$(T)
 CASE T
 WHEN #VM_NOP:RETURN "#VM_NOP"WHEN #VM_PUSHINT:RETURN "#VM_PUSHINT"WHEN #VM_PUSHDBL:RETURN "#VM_PUSHDBL"WHEN #VM_PUSHSTR:RETURN "#VM_PUSHSTR"WHEN #VM_BINOP:RETURN "#VM_BINOP"WHEN #VM_PRINT:RETURN "#VM_PRINT"WHEN #VM_TPRINT:RETURN "#VM_TPRINT"WHEN #VM_ASSIGN:RETURN "#VM_ASSIGN"WHEN #VM_PUSHVARREF:RETURN "#VM_PUSHVARREF"WHEN #VM_PUSHLVARREF:RETURN "#VM_PUSHLVARREF"WHEN #VM_REF:RETURN "#VM_REF"WHEN #VM_BR:RETURN "#VM_BR"WHEN #VM_BRTRUE:RETURN "#VM_BRTRUE"WHEN #VM_BRFALSE:RETURN "#VM_BRFALSE"WHEN #VM_FOR:RETURN "#VM_FOR"WHEN #VM_FORINIT:RETURN "#VM_FORINIT"WHEN #VM_BRAND:RETURN "#VM_BRAND"WHEN #VM_BROR:RETURN "#VM_BROR"WHEN #VM_GOTO_PLACEHOLDER:RETURN "#VM_GOTO_PLACEHOLDER"WHEN #VM_GOSUB_PLACEHOLDER:RETURN "#VM_GOSUB_PLACEHOLDER"WHEN #VM_GOSUB:RETURN "#VM_GOSUB"WHEN #VM_GOTOEXPR:RETURN "#VM_GOTOEXPR"WHEN #VM_GOSUBEXPR:RETURN "#VM_GOSUBEXPR"WHEN #VM_ONGOTO:RETURN "#VM_ONGOTO"WHEN #VM_ONGOSUB:RETURN "#VM_ONGOSUB"WHEN #VM_RETURN:RETURN "#VM_RETURN"WHEN #VM_CALLFUNC:RETURN "#VM_CALLFUNC"WHEN #VM_PUSHEMPTY:RETURN "#VM_PUSHEMPTY"WHEN #VM_RETURNFUNC:RETURN "#VM_RETURNFUNC"WHEN #VM_PUSHEMPTYREF:RETURN "#VM_PUSHEMPTYREF"WHEN #VM_PUSHARYREF:RETURN "#VM_PUSHARYREF"WHEN #VM_END:RETURN "#VM_END"WHEN #VM_NEWARRAY:RETURN "#VM_NEWARRAY"WHEN #VM_INITARRAY:RETURN "#VM_INITARRAY"WHEN #VM_READ:RETURN "#VM_READ"WHEN #VM_RESTORE:RETURN "#VM_RESTORE"WHEN #VM_RESTORE_PLACEHOLDER:RETURN "#VM_RESTORE_PLACEHOLDER"WHEN #VM_RESTOREEXPR:RETURN "#VM_RESTOREEXPR"WHEN #VM_UNAOP:RETURN "#VM_UNAOP"WHEN #VM_CALLSPRITE:RETURN "#VM_CALLSPRITE"WHEN #VM_CALLTEXT:RETURN "#VM_CALLTEXT"WHEN #VM_INC:RETURN "#VM_INC"WHEN #VM_DEC:RETURN "#VM_DEC"WHEN #VM_POP:RETURN "#VM_POP"WHEN #VM_:RETURN "#VM_"WHEN #VM_LAST:RETURN "#VM_LAST" OTHERWISE
  RETURN "#VM_"+STR$(T)
 ENDCASE
END

'CODE GEN INTERFACE
DEF EMIT_PUSHINT V
 PUSH VM_OPS,#VM_PUSHINT
 PUSH VM_OPS,V
END
DEF VM_ADDIMMDBL(V#)
 PUSH VM_IMM#,V#
 RETURN LAST(VM_IMM#)
END
DEF VM_ADDIMMSTR(V$)
 PUSH VM_IMM$,V$
 RETURN LAST(VM_IMM$)
END
DEF EMIT_PUSHDBL V#
 PUSH VM_OPS,#VM_PUSHDBL
 PUSH VM_OPS,VM_ADDIMMDBL(V#)
END
DEF EMIT_PUSHSTR V$
 PUSH VM_OPS,#VM_PUSHSTR
 PUSH VM_OPS,VM_ADDIMMSTR(V$)
END
DEF EMIT_BINOP TYP
 PUSH VM_OPS,#VM_BINOP
 PUSH VM_OPS,TYP
END
DEF EMIT_PRINT TYP
 PUSH VM_OPS,#VM_PRINT
 PUSH VM_OPS,TYP
END
DEF EMIT_TPRINT TYP
 PUSH VM_OPS,#VM_TPRINT
 PUSH VM_OPS,TYP
END
DEF EMIT_PUSHVARREF IDX
 PUSH VM_OPS,#VM_PUSHVARREF
 PUSH VM_OPS,IDX
END
DEF EMIT_PUSHLVARREF IDX
 PUSH VM_OPS,#VM_PUSHLVARREF
 PUSH VM_OPS,IDX
END
DEF EMIT_REF
 PUSH VM_OPS,#VM_REF
END
DEF EMIT_ASSIGN
 PUSH VM_OPS,#VM_ASSIGN
END
DEF EMIT_BRFALSE()
 PUSH VM_OPS,#VM_BRFALSE
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_BRTRUE()
 PUSH VM_OPS,#VM_BRTRUE
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_BR()
 PUSH VM_OPS,#VM_BR
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_FOR()
 PUSH VM_OPS,#VM_FOR
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_FORINIT()
 PUSH VM_OPS,#VM_FORINIT
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_BRAND()
 PUSH VM_OPS,#VM_BRAND
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_BROR()
 PUSH VM_OPS,#VM_BROR
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_WHEN()
 PUSH VM_OPS,#VM_WHEN
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_ADDR ADDR
 VM_OPS[ADDR]=LEN(VM_OPS)
END
DEF EMIT_ADDR2 ADDR,ADDR2
 VM_OPS[ADDR]=ADDR2
END
DEF EMIT_GOTO_PLACEHOLDER LABEL$
 PUSH VM_OPS,#VM_GOTO_PLACEHOLDER
 PUSH VM_OPS,VM_ADDIMMSTR(LABEL$)
END
DEF EMIT_GOSUB_PLACEHOLDER LABEL$
 PUSH VM_OPS,#VM_GOSUB_PLACEHOLDER
 PUSH VM_OPS,VM_ADDIMMSTR(LABEL$)
END
DEF EMIT_RETURN
 PUSH VM_OPS,#VM_RETURN
END
DEF EMIT_CALLFUNC FN$,INCNT,OUTCNT
 PUSH VM_OPS,#VM_CALLFUNC
 PUSH VM_OPS,VM_ADDIMMSTR(FN$)
 PUSH VM_OPS,INCNT
 PUSH VM_OPS,OUTCNT
END
DEF EMIT_RETURNFUNC
 PUSH VM_OPS,#VM_RETURNFUNC
END
DEF EMIT_PUSHEMPTY N
 PUSH VM_OPS,#VM_PUSHEMPTY
 PUSH VM_OPS,N
END
DEF EMIT_PUSHEMPTYREF
 PUSH VM_OPS,#VM_PUSHEMPTYREF
END
DEF EMIT_END
 PUSH VM_OPS,#VM_END
END
DEF EMIT_NEWARRAY DM,TYP
 PUSH VM_OPS,#VM_NEWARRAY
 PUSH VM_OPS,DM
 PUSH VM_OPS,TYP
END
DEF EMIT_INITARRAY CNT
 PUSH VM_OPS,#VM_INITARRAY
 PUSH VM_OPS,CNT
END
DEF EMIT_PUSHARYREF DM
 PUSH VM_OPS,#VM_PUSHARYREF
 PUSH VM_OPS,DM
END
DEF EMIT_READ
 PUSH VM_OPS,#VM_READ
END
DEF EMIT_RESTORE_PLACEHOLDER LABEL$
 PUSH VM_OPS,#VM_RESTORE_PLACEHOLDER
 PUSH VM_OPS,VM_ADDIMMSTR(LABEL$)
END
DEF EMIT_RESTORE SLOT,ADDR
 PUSH VM_OPS,#VM_RESTORE
 PUSH VM_OPS,SLOT
 PUSH VM_OPS,ADDR
END
DEF EMIT_UNAOP TYP
 PUSH VM_OPS,#VM_UNAOP
 PUSH VM_OPS,TYP
END
DEF EMIT_CALLSPRITE
 PUSH VM_OPS,#VM_INITCALLSPRITE
 PUSH VM_OPS,#VM_CALLSPRITE
END
DEF EMIT_CALLTEXT
 PUSH VM_OPS,#VM_INITCALLTEXT
 PUSH VM_OPS,#VM_CALLTEXT
END
DEF EMIT_RESTOREEXPR
 PUSH VM_OPS,#VM_RESTOREEXPR
END
DEF EMIT_GOTOEXPR
 PUSH VM_OPS,#VM_GOTOEXPR
END
DEF EMIT_GOSUBEXPR
 PUSH VM_OPS,#VM_GOSUBEXPR
END
DEF EMIT_INC
 PUSH VM_OPS,#VM_INC
END
DEF EMIT_DEC
 PUSH VM_OPS,#VM_DEC
END
DEF EMIT_POP N
 PUSH VM_OPS,#VM_POP
 PUSH VM_OPS,N
END
DEF EMIT_SWAP
 PUSH VM_OPS,#VM_SWAP
END
DEF EMIT_INPUT GUIDE,SEMI,CNT
 PUSH VM_OPS,#VM_INPUT
 PUSH VM_OPS,GUIDE
 PUSH VM_OPS,SEMI
 PUSH VM_OPS,CNT
END
DEF EMIT_LINPUT GUIDE
 PUSH VM_OPS,#VM_LINPUT
 PUSH VM_OPS,GUIDE
END
DEF EMIT_ONGOTO LBL$[],GSB
 IF!GSB THEN
  PUSH VM_OPS,#VM_ONGOTO
 ELSE
  PUSH VM_OPS,#VM_ONGOSUB
 ENDIF
 PUSH VM_OPS,LEN(LBL$)
 VAR I
 FOR I=0TO LAST(LBL$)
  PUSH VM_OPS,VM_ADDIMMSTR(LBL$[I])
 NEXT
END
DEF EMIT_DEFOUT
 PUSH VM_OPS,#VM_DEFOUT
END
DEF EMIT_EXEC1
 PUSH VM_OPS,#VM_EXEC1
END
DEF EMIT_EXEC2
 PUSH VM_OPS,#VM_EXEC2
END
DEF EMIT_STOP1
 PUSH VM_OPS,#VM_STOP1
END
DEF EMIT_STOP2
 PUSH VM_OPS,#VM_STOP2
END
DEF EMIT_PUSHVAREXPR
 PUSH VM_OPS,#VM_PUSHVAREXPR
END
DEF EMIT_PUSHVAREXPRREF
 PUSH VM_OPS,#VM_PUSHVAREXPRREF
END
DEF COMPILER_CURRENT_ADDR()
 RETURN LEN(VM_OPS)
END
DEF VMDBG_ADD_SRC_INFO LINE,POS,LINE_END,POS_END
 VMDBG_ADD_SRC_INFO2 LINE,POS,LINE_END,POS_END,LEN(VM_OPS)
END
DEF VMDBG_ADD_SRC_INFO2 LINE,POS,LINE_END,POS_END,PC
 VAR L=LAST(VMDBG_LINE)
 IF L>=0&&VMDBG_LINE_PC[L]==PC THEN
  '?
  VMDBG_LINE[L]=LINE
  VMDBG_LINE_PC[L]=PC
  VMDBG_LINE_POS[L]=POS
  VMDBG_LINE_END[L]=LINE_END
  VMDBG_LINE_POS_END[L]=POS_END
  RETURN
 ENDIF
 PUSH VMDBG_LINE,LINE
 PUSH VMDBG_LINE_PC,PC
 PUSH VMDBG_LINE_POS,POS
 PUSH VMDBG_LINE_END,LINE_END
 PUSH VMDBG_LINE_POS_END,POS_END
END
DEF VMDBG_GET_SRC_INFO OUT LINE,POS,LINE_END,POS_END,PC
 VAR L=LAST(VMDBG_LINE)
 LINE=VMDBG_LINE[L]
 POS=VMDBG_LINE_POS[L]
 LINE_END=VMDBG_LINE_END[L]
 POS_END=VMDBG_LINE_POS_END[L]
 PC=VMDBG_LINE_PC[L]
END

'CODE GEN INTERFACE END




DEF VM_GET_PC()
 RETURN VM_PC
END
DEF VM_GET_BP()
 RETURN VM_BP
END
DEF VM_GET_SLOT()
 RETURN VM_CURSLOT
END
'VM
DEF VM_PUSHINT V%
 VM_STK_TYP[VM_SP]=#VMT_INT
 VM_STK%[VM_SP]=V%
 INC VM_SP
END
DEF VM_PUSHDBL V#
 VM_STK_TYP[VM_SP]=#VMT_REAL
 VM_STK#[VM_SP]=V#
 INC VM_SP
END
DEF VM_PUSHSTR V$
 VM_STK_TYP[VM_SP]=#VMT_STR
 VM_STK$[VM_SP]=V$
 INC VM_SP
END
DEF VM_V(TYP,V)
 IF TYP==#VMT_INTARRAY||TYP==#VMT_REALARRAY||TYP==#VMT_STRARRAY THEN
  V=VM_ALLOC_ARRAY(V)
 ENDIF
 RETURN V
END
DEF VM_GETV(TYP,V)
 IF TYP==#VMT_INTARRAY||TYP==#VMT_REALARRAY||TYP==#VMT_STRARRAY THEN
  V=VM_GET_ARRAY(V)
 ENDIF
 IF TYP==#VMT_DEFAULT THEN
  RETURN EMPTY()
 ENDIF
 RETURN V
END
DEF VM_PUSHTYP V,TYP
 VM_STK_TYP[VM_SP]=TYP
 VAR A=VM_GETSTKARY(TYP)
 IF TYP==#VMT_INTARRAY||TYP==#VMT_REALARRAY||TYP==#VMT_STRARRAY THEN
  V=VM_ALLOC_ARRAY(V)
 ENDIF
 IF TYP==#VMT_DEFAULT THEN
  INC VM_SP
  RETURN
 ENDIF
 A[VM_SP]=V
 INC VM_SP
END
DEF VM_PUSH V
 CASE TYPEOF(V)
 WHEN #T_DEFAULT
  VM_STK_TYP[VM_SP]=#VMT_DEFAULT
 WHEN #T_INT
  VM_STK_TYP[VM_SP]=#VMT_INT
  VM_STK%[VM_SP]=V
 WHEN #T_REAL
  VM_STK_TYP[VM_SP]=#VMT_REAL
  VM_STK#[VM_SP]=V
 WHEN #T_STR
  VM_STK_TYP[VM_SP]=#VMT_STR
  VM_STK$[VM_SP]=V
 WHEN #T_INTARRAY
  VM_STK_TYP[VM_SP]=#VMT_INTARRAY
  VM_STK%[VM_SP]=VM_ALLOC_ARRAY(V)
 WHEN #T_REALARRAY
  VM_STK_TYP[VM_SP]=#VMT_REALARRAY
  VM_STK%[VM_SP]=VM_ALLOC_ARRAY(V)
 WHEN #T_STRARRAY
  VM_STK_TYP[VM_SP]=#VMT_STRARRAY
  VM_STK%[VM_SP]=VM_ALLOC_ARRAY(V)
 OTHERWISE
  STOP
 ENDCASE
 INC VM_SP
END
DEF VM_POP * OUT T,V
 DEC VM_SP
 T=VM_STK_TYP[VM_SP]
 V=VM_GETSTKARY(T)[VM_SP]
 CASE T
 WHEN #VMT_INTARRAY
 WHEN #VMT_REALARRAY
 WHEN #VMT_STRARRAY
  IF DEFARGC()==1&&DEFARG(0)THEN
   V=VM_GET_ARRAY(V)
   RETURN
  ENDIF
  V=VM_GETFREE_ARRAY(V)
 ENDCASE
END
DEF VMINSTR_BINOP T
 VAR LT,LV
 VAR RT,RV
 VM_POP OUT RT,RV
 VM_POP OUT LT,LV
 CASE T
 WHEN #TKN_PLUS
  VM_PUSH LV+RV
 WHEN #TKN_MINUS
  VM_PUSH LV-RV
 WHEN #TKN_MUL
  VM_PUSH LV*RV
 WHEN #TKN_DIV
  VM_PUSH LV/RV
 WHEN #TKN_DIVINT
  VM_PUSH LV DIV RV
 WHEN #TKN_MOD
  VM_PUSH LV MOD RV
 WHEN #TKN_AND
  VM_PUSH LV AND RV
 WHEN #TKN_OR
  VM_PUSH LV OR RV
 WHEN #TKN_XOR
  VM_PUSH LV XOR RV
 WHEN #TKN_EQ
  VM_PUSH LV==RV
 WHEN #TKN_NEQ
  VM_PUSH LV!=RV
 WHEN #TKN_LSHIFT
  VM_PUSH LV<<RV
 WHEN #TKN_RSHIFT
  VM_PUSH LV>>RV
 WHEN #TKN_GREAT
  VM_PUSH LV<RV
 WHEN #TKN_LESS
  VM_PUSH LV>RV
 WHEN #TKN_GEQ
  VM_PUSH LV<=RV
 WHEN #TKN_LEQ
  VM_PUSH LV>=RV
 OTHERWISE
  STOP
 ENDCASE
END
DEF VMINSTR_UNAOP T
 VAR LT,LV
 VM_POP OUT LT,LV
 CASE T
 WHEN #TKN_MINUS
  VM_PUSH -LV
 WHEN #TKN_LNOT
  VM_PUSH !LV
 WHEN #TKN_NOT
  VM_PUSH NOT LV
 OTHERWISE
  STOP
 ENDCASE
END

DEF VM_PRINT IS_TPRINT,TYP
 VAR TP=#TCONSOLE
 VAR OFF=-2
 IF TYP==#VMPRINT_EMPTY THEN
  OFF=-1
 ENDIF
 IF IS_TPRINT THEN
  TP=VM_GETSTK(OFF)
 ENDIF
 IF TYP==#VMPRINT_EMPTY THEN
  TPRINT TP
  RETURN
 ENDIF
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_STR&&T!=#VMT_INT&&T!=#VMT_REAL THEN
  TYPE_MISMATCH "PRINT"
  RETURN
 ENDIF
 CASE TYP
 WHEN #VMPRINT_COMMA
  TPRINT TP,V,
 WHEN #VMPRINT_NEWLINE
  TPRINT TP,V
 WHEN #VMPRINT_SEMI
  TPRINT TP,V;
 ENDCASE
END
DEF VMINSTR_PUSHVARREF IDX
 VM_PUSHTYP IDX,#VMT_VARREF
END
DEF VMINSTR_PUSHLVARREF IDX
 VM_PUSHTYP IDX,#VMT_LVARREF
END
DEF VM_GETVAR(IDX)
 VAR TYP=VM_GVAR_TYP[IDX]
 CASE TYP
 WHEN #VMT_REAL
  RETURN VM_GVAR#[IDX]
 WHEN #VMT_DEFAULT
  RETURN
 WHEN #VMT_INT
  RETURN VM_GVAR%[IDX]
 WHEN #VMT_STR
  RETURN VM_GVAR$[IDX]
 WHEN #VMT_INTARRAY
 WHEN #VMT_REALARRAY
 WHEN #VMT_STRARRAY
  RETURN VM_GET_ARRAY(VM_GVAR%[IDX])
 ENDCASE
 VM_ERROR
END
DEF VM_GETVAR2 IDX OUT TYP,V
 TYP=VM_GVAR_TYP[IDX]
 CASE TYP
 WHEN #VMT_REAL
  V=VM_GVAR#[IDX]
  RETURN
 WHEN #VMT_DEFAULT
  RETURN
 WHEN #VMT_INT
  V=VM_GVAR%[IDX]
  RETURN
 WHEN #VMT_STR
  V=VM_GVAR$[IDX]
  RETURN
 WHEN #VMT_INTARRAY
 WHEN #VMT_REALARRAY
 WHEN #VMT_STRARRAY
  STOP
  RETURN VM_ALLOC_ARRAY(VM_GET_ARRAY(VM_GVAR%[IDX]))
 ENDCASE
 VM_ERROR
END
DEF VM_GETVAR2_SLOT SLOT,VIDX OUT TYP,V
 TYP=VM_GET_ARRAY(VM_SLOT_GVAR_TYP[SLOT])[VIDX]
 CASE TYP
 WHEN #VMT_INT
  V=VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT])[VIDX]
  RETURN
 WHEN #VMT_REAL
  V=VM_GET_ARRAY(VM_SLOT_GVAR#[SLOT])[VIDX]
  RETURN
 WHEN #VMT_STR
  V=VM_GET_ARRAY(VM_SLOT_GVAR$[SLOT])[VIDX]
  RETURN
 WHEN #VMT_INTARRAY
 WHEN #VMT_REALARRAY
 WHEN #VMT_STRARRAY
  V=VM_GET_ARRAY(VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT])[VIDX])
  RETURN
 WHEN #VMT_DEFAULT
  RETURN
 ENDCASE
 VM_ERROR
END
DEF VM_SETVAR_SLOT SLOT,VIDX,TYP,V
 VAR VM_GVAR_TYP=VM_GET_ARRAY(VM_SLOT_GVAR_TYP[SLOT])
 VM_GVAR_TYP[VIDX]=TYP
 CASE TYP
 WHEN #VMT_INT
  VAR GV=VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT])
  GV[VIDX]=V
  RETURN
 WHEN #VMT_REAL
  GV=VM_GET_ARRAY(VM_SLOT_GVAR#[SLOT])
  GV[VIDX]=V
  RETURN
 WHEN #VMT_STR
  GV=VM_GET_ARRAY(VM_SLOT_GVAR$[SLOT])
  GV[VIDX]=V
  RETURN
 WHEN #VMT_INTARRAY
 WHEN #VMT_REALARRAY
 WHEN #VMT_STRARRAY
  GV=VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT])
  GV[VIDX]=VM_ALLOC_ARRAY(V)
  RETURN
 WHEN #VMT_DEFAULT
  RETURN
 ENDCASE
 VM_ERROR
END
DEF VM_SETVAR IDX,TYP,V
 IF VM_GVAR_TYP[IDX]>=#VMT_INTARRAY&&VM_GVAR_TYP[IDX]<=#VMT_STRARRAY THEN
  VM_FREE_ARRAY VM_GVAR%[IDX]
 ENDIF
 VM_GVAR_TYP[IDX]=TYP
 CASE TYP
 WHEN #VMT_REAL
  VM_GVAR#[IDX]=V
 WHEN #VMT_INT
  VM_GVAR%[IDX]=V
 WHEN #VMT_STR
  VM_GVAR$[IDX]=V
 WHEN #VMT_INTARRAY
 WHEN #VMT_STRARRAY
 WHEN #VMT_REALARRAY
  VM_GVAR%[IDX]=VM_ALLOC_ARRAY(V)
 WHEN #VMT_DEFAULT
  RETURN
 OTHERWISE
  VM_ERROR_NOTIMPL
 ENDCASE
END
DEF VM_GETSTKARY(TYP)
 CASE TYP
 WHEN #VMT_REAL
  RETURN VM_STK#
 WHEN #VMT_ARYREF
 WHEN #VMT_INTARRAY
 WHEN #VMT_REALARRAY
 WHEN #VMT_STRARRAY
 WHEN #VMT_EMPTYREF
 WHEN #VMT_VARREF
 WHEN #VMT_VARREFSLOT
 WHEN #VMT_LVARREF
 WHEN #VMT_INT
 WHEN #VMT_SUBROUTINE
 WHEN #VMT_DEFAULT
  RETURN VM_STK%
 WHEN #VMT_STR
  RETURN VM_STK$
 OTHERWISE
  STOP
 ENDCASE
END
ENUM\
 #VMSTK_STARTARGS=#VM_LVAROFF,\
 #VMSTK_OUTCNT,\
 #VMSTK_INCNT,\
 #VMSTK_FUNC,\
 #VMSTK_BP,\
 #VMSTK_SLOT,\
 #VMSTK_PC
DEF VM_GETLVAR IDX OUT T,V
 IF IDX<0&&FUNC_INCNT[VM_CURFUNC]==-1 THEN
  'VAARGS
  VAR IC=VM_STK%[VM_BP+#VMSTK_INCNT]
  DEC IDX,IC
 ENDIF
 T=VM_STK_TYP[VM_BP+IDX]
 V=VM_GETV(T,VM_GETSTKARY(T)[VM_BP+IDX])
END
DEF VM_SETSTK IDX,V
 IF VM_STK_TYP[VM_SP+IDX]>=#VMT_INTARRAY&&VM_STK_TYP[VM_SP+IDX]<=#VMT_STRARRAY THEN
  VM_FREE_ARRAY VM_STK%[VM_SP+IDX]
 ENDIF
 VAR T=VM_TYPE(V)
 VM_STK_TYP[VM_SP+IDX]=T
 VAR A=VM_GETSTKARY(T)
 A[VM_SP+IDX]=VM_V(T,V)
END
DEF VM_GETSTK IDX OUT V
 VAR T=VM_STK_TYP[VM_SP+IDX]
 V=VM_GETV(T,VM_GETSTKARY(T)[VM_SP+IDX])
END
DEF VM_SETLVAR IDX,T,V
 IF IDX<0&&FUNC_INCNT[VM_CURFUNC]==-1 THEN
  'VAARGS
  VAR IC=VM_STK%[VM_BP+#VMSTK_INCNT]
  DEC IDX,IC
 ENDIF
 IF VM_STK_TYP[VM_BP+IDX]>=#VMT_INTARRAY&&VM_STK_TYP[VM_BP+IDX]<=#VMT_STRARRAY THEN
  VM_FREE_ARRAY VM_STK%[VM_BP+IDX]
 ENDIF
 VM_STK_TYP[VM_BP+IDX]=T
 VAR A=VM_GETSTKARY(T)
 A[VM_BP+IDX]=VM_V(T,V)
END
DEF VM_TYPE(V)
 CASE TYPEOF(V)
 WHEN #T_DEFAULT
  RETURN #VMT_DEFAULT
 WHEN #T_INT
  RETURN #VMT_INT
 WHEN #T_REAL
  RETURN #VMT_REAL
 WHEN #T_STR
  RETURN #VMT_STR
 WHEN #T_INTARRAY
  RETURN #VMT_INTARRAY
 WHEN #T_REALARRAY
  RETURN #VMT_REALARRAY
 WHEN #T_STRARRAY
  RETURN #VMT_STRARRAY
 OTHERWISE
  STOP
 ENDCASE
END
DEF VMINSTR_REF
 VAR T,V
 VM_POP OUT T,V
 CASE T
 WHEN #VMT_VARREF
  VM_PUSH VM_GETVAR(V)
 WHEN #VMT_VARREFSLOT
  VAR SLOT_V
  VM_POP OUT ,SLOT_V
  VM_GETVAR2_SLOT SLOT_V,V OUT T,V
  VM_PUSHTYP V,T
 WHEN #VMT_LVARREF
  VM_GETLVAR V OUT T,V
  VM_PUSHTYP V,T
 WHEN #VMT_ARYREF
  VAR DM1,DM2,DM3,DM4
  VAR ARYT,ARYV
  VM_POP OUT ARYT,ARYV
  IF!VM_ISARYTYP(ARYT)THEN
   TYPE_MISMATCH "ARRAY EXPECTED BUT "+VMT_STR$(ARYT)
   RETURN
  ENDIF
  VAR ERR
  VM_POP_DIMS V OUT DM1,DM2,DM3,DM4,ERR
  IF ERR THEN RETURN
  IF ARYT==#VMT_STR THEN
   IF V!=1THEN
    SYNTAX_ERROR "DIM MISMATCH"
    RETURN
   ENDIF
  ELSEIF ARYT==#VMT_INTARRAY||ARYT==#VMT_STRARRAY||ARYT==#VMT_REALARRAY THEN
   IF V!=1&&DIM(ARYV)!=V THEN
    SYNTAX_ERROR "DIM MISMATCH"
    RETURN
   ENDIF
  ENDIF
  CASE V
  WHEN 1
   IF LEN(ARYV)<=DM1 THEN
    SUBSCRIPT_OUT_OF_RANGE "REF ARRAY"
    RETURN
   ENDIF
   VM_PUSH ARYV[DM1]
  WHEN 2
   IF DIM(ARYV,0)<=DM1||DIM(ARYV,1)<=DM2 THEN
    SUBSCRIPT_OUT_OF_RANGE "REF ARRAY(2D)"
    RETURN
   ENDIF
   VM_PUSH ARYV[DM1,DM2]
  WHEN 3
   IF DIM(ARYV,0)<=DM1||DIM(ARYV,1)<=DM2||DIM(ARYV,2)<=DM3 THEN
    SUBSCRIPT_OUT_OF_RANGE "REF ARRAY(3D)"
    RETURN
   ENDIF
   VM_PUSH ARYV[DM1,DM2,DM3]
  WHEN 4
   IF DIM(ARYV,0)<=DM1||DIM(ARYV,1)<=DM2||DIM(ARYV,2)<=DM3||DIM(ARYV,3)<=DM4 THEN
    SUBSCRIPT_OUT_OF_RANGE "REF ARRAY(4D)"
    RETURN
   ENDIF
   VM_PUSH ARYV[DM1,DM2,DM3,DM4]
  OTHERWISE
   INTERNAL_VM_ERROR
  ENDCASE
 OTHERWISE
  INTERNAL_VM_ERROR
 ENDCASE
END
DEF VMINSTR_ASSIGN
 VAR T,V
 VAR REFT,REFV
 VM_POP OUT REFT,REFV
 VM_ASSIGN REFT,REFV,#TRUE,T,V,
END
DEF VM_ASSIGN REFT,REFV,POP,T,V,ERR
 ERR=#FALSE
 CASE REFT
 WHEN #VMT_LVARREF
  IF POP THEN VM_POP OUT T,V
  VM_SETLVAR REFV,T,V
 WHEN #VMT_VARREF
  IF POP THEN VM_POP OUT T,V
  VM_SETVAR REFV,T,V
 WHEN #VMT_VARREFSLOT
  VAR SLOT_V
  VM_POP OUT ,SLOT_V
  IF POP THEN VM_POP OUT T,V
  VM_SETVAR_SLOT SLOT_V,REFV,T,V
 WHEN #VMT_EMPTYREF
  IF POP THEN VM_POP OUT T,V
  RETURN
 WHEN #VMT_ARYREF
  VAR DM1,DM2,DM3,DM4
  VAR ARYT,ARYV
  VM_POP OUT ARYT,ARYV
  IF!VM_ISARYTYP(ARYT)THEN
   ERR=#TRUE
   TYPE_MISMATCH "ARRAY EXPECTED BUT "+VMT_STR$(ARYT)
   RETURN
  ENDIF
  VM_POP_DIMS REFV OUT DM1,DM2,DM3,DM4,ERR
  IF ERR THEN RETURN
  IF POP THEN VM_POP OUT T,V
  IF ARYT==#VMT_STR||ARYT==#VMT_STRARRAY THEN
   IF T!=#VMT_STR THEN
    ERR=#TRUE
    TYPE_MISMATCH "ASSIGN ARRAY"
    RETURN
   ENDIF
  ELSEIF !VM_ISNUMTYPE(T) THEN
   ERR=#TRUE
   TYPE_MISMATCH "ASSIGN ARRAY"
   RETURN
  ENDIF
  IF REFV!=1&&DIM(ARYV)!=REFV THEN
   ERR=#TRUE
   SYNTAX_ERROR "DIM MISMATCH"
   RETURN
  ENDIF
  CASE REFV
  WHEN 1
   IF LEN(ARYV)<=DM1 THEN
   STOP
    ERR=#TRUE
    SUBSCRIPT_OUT_OF_RANGE "ASSIGN ARRAY"
    RETURN
   ENDIF
   ARYV[DM1]=V
  WHEN 2
   IF DIM(ARYV,0)<=DM1||DIM(ARYV,1)<=DM2 THEN
    ERR=#TRUE
    SUBSCRIPT_OUT_OF_RANGE "ASSIGN ARRAY(2D)"
    RETURN
   ENDIF
   ARYV[DM1,DM2]=V
  WHEN 3
   IF DIM(ARYV,0)<=DM1||DIM(ARYV,1)<=DM2||DIM(ARYV,2)<=DM3 THEN
    ERR=#TRUE
    SUBSCRIPT_OUT_OF_RANGE "ASSIGN ARRAY(3D)"
    RETURN
   ENDIF
   ARYV[DM1,DM2,DM3]=V
  WHEN 4
   IF DIM(ARYV,0)<=DM1||DIM(ARYV,1)<=DM2||DIM(ARYV,2)<=DM3||DIM(ARYV,3)<=DM4 THEN
    ERR=#TRUE
    SUBSCRIPT_OUT_OF_RANGE "ASSIGN ARRAY(4D)"
    RETURN
   ENDIF
   ARYV[DM1,DM2,DM3,DM4]=V
  OTHERWISE
   INTERNAL_VM_ERROR
  ENDCASE
 OTHERWISE
  INTERNAL_VM_ERROR
 ENDCASE
END
DEF VM_REF OUT REFT,REFV,T,V,ERR
 ERR=#FALSE
 VM_POP OUT REFT,REFV
 CASE REFT
 WHEN #VMT_LVARREF
  VM_GETLVAR REFV OUT T,V
 WHEN #VMT_VARREF
  VM_GETVAR2 REFV OUT T,V
 WHEN #VMT_VARREFSLOT
  VAR SLOT_V
  VM_POP OUT ,SLOT_V
  VM_GETVAR2_SLOT SLOT_V,REFV OUT T,V
 WHEN #VMT_EMPTYREF
  RETURN
 WHEN #VMT_ARYREF
  VAR DM1,DM2,DM3,DM4
  VAR ARYT,ARYV
  VM_POP #TRUE OUT ARYT,ARYV
  IF!VM_ISARYTYP(ARYT)THEN
   ERR=#TRUE
   TYPE_MISMATCH "ARRAY EXPECTED BUT "+VMT_STR$(ARYT)
   RETURN
  ENDIF
  VM_POP_DIMS REFV OUT DM1,DM2,DM3,DM4,ERR
  IF ERR THEN RETURN
  CASE REFV
  WHEN 1
   V=ARYV[DM1]
  WHEN 2
   V=ARYV[DM1,DM2]
  WHEN 3
   V=ARYV[DM1,DM2,DM3]
  WHEN 4
   V=ARYV[DM1,DM2,DM3,DM4]
  OTHERWISE
   INTERNAL_VM_ERROR
  ENDCASE
  T=VM_TYPE(V)
 OTHERWISE
  INTERNAL_VM_ERROR
 ENDCASE
END
DEF VM_ISNUMTYPE(TYP)
 RETURN TYP==#VMT_INT||TYP==#VMT_REAL
END
DEF VMINSTR_FOR INIT
 VAR BRKADDR=VM_OPS[VM_PC]
 INC VM_PC
 VAR T_TO,V_TO
 VAR T_STEP=#VMT_INT,V_STEP=1
 VAR RT_IDX,RV_IDX
 VAR T_IDX,V_IDX
 VM_POP OUT T_TO,V_TO
 VM_POP OUT T_STEP,V_STEP
 VAR OSP=VM_SP
 VAR ERR
 VM_REF OUT RT_IDX,RV_IDX,T_IDX,V_IDX,ERR
 IF ERR THEN RETURN
 VM_SP=OSP-1
 IF!VM_ISNUMTYPE(T_IDX)||!VM_ISNUMTYPE(T_STEP)||!VM_ISNUMTYPE(T_TO) THEN
  TYPEMISMATCH "FOR"
  RETURN
 ENDIF
 IF !INIT THEN
  V_IDX=V_IDX+V_STEP
  VM_ASSIGN RT_IDX,RV_IDX,#FALSE,T_IDX,V_IDX,ERR
  IF ERR THEN RETURN
 ENDIF
 IF V_STEP>0&&V_IDX>V_TO THEN
  IF INIT THEN
   VM_PC=BRKADDR
  ENDIF
 ELSEIF V_STEP<0&&V_IDX<V_TO THEN
  IF INIT THEN
   VM_PC=BRKADDR
  ENDIF
 ELSE
  IF !INIT THEN
   VM_PC=BRKADDR
  ENDIF
 ENDIF
END
DEF VMINSTR_BRAND ADDR
 VAR T,V
 VM_POP OUT T,V
 IF!VM_ISNUMTYPE(T) THEN
  TYPEMISMATCH "&&"
  RETURN
 ENDIF
 IF !V THEN
  VM_PUSHINT #FALSE
  VM_PC=ADDR
 ENDIF
END
DEF VMINSTR_BROR ADDR
 VAR T,V
 VM_POP OUT T,V
 IF!VM_ISNUMTYPE(T) THEN
  TYPEMISMATCH "||"
  RETURN
 ENDIF
 IF V THEN
  VM_PC=ADDR
  VM_PUSHINT #TRUE
 ENDIF
END

DEF VM_CHKLABEL(LABEL$,F)
 'FIXME:SLOT
 VAR FOUND
 VM_GET_LABEL LABEL$,F==1 OUT ,,FOUND
 RETURN FOUND
END
'"0:FUNC"  :1
'"00:FUNC" :1
'" 00:FUNC":0
'"&H0:FUNC":0
'"0 :FUNC" :0
DEF VM_PARSE_SLOT L$,LABEL OUT ILL_FMT,HAS_SLOT,SLOT,N$
 N$=L$
 VAR POS=INSTR(L$,":")
 IF POS==-1 THEN
  HAS_SLOT=#FALSE
  ILL_FMT=#FALSE
  IF LABEL&&MID$(L$,0,1)!="@"THEN
   ILL_FMT=#TRUE
   RETURN
  ENDIF
  RETURN
 ENDIF
 N$=MID$(L$,POS+1,&H7FFFFFFF)
 VAR S$=MID$(L$,0,POS)
 VAR I
 FOR I=0TO LAST(S$)
  IF S$[I]<"0"||S$[I]>"9"THEN
   ILL_FMT=#TRUE
   RETURN
  ENDIF
 NEXT
 SLOT=VAL(S$)
 IF LABEL&&MID$(N$,0,1)!="@"THEN
  ILL_FMT=#TRUE
  RETURN
 ENDIF
 IF SLOT<0||SLOT>=4 THEN
  ILL_FMT=#TRUE
  RETURN
 ENDIF
 ILL_FMT=#FALSE
 HAS_SLOT=#TRUE
END

DEF VM_CHKCALL(FUNC$)
 VAR ILL_FMT,HAS_SLOT,SLOT
 VM_PARSE_SLOT FUNC$,#FALSE OUT ILL_FMT,HAS_SLOT,SLOT,FUNC$
 IF ILL_FMT THEN
  RETURN #FALSE
 ENDIF
 VAR FOUND
 IF!HAS_SLOT THEN SLOT=VM_CURSLOT
 SPLAY_GET% VM_SLOT_FUNCTBL[SLOT],FUNC$ OUT FOUND,
 IF !FOUND&&!HAS_SLOT THEN
  SPLAY_GET% VM_CFUNCTBL,FUNC$ OUT FOUND,
 ENDIF
 'HAS SLOT && BUILTIN FUNCTION->#TRUE
 RETURN FOUND||CHKCALL(NOT_USED_SLOT$+FUNC$)||CHKCALL("SBSB_"+FUNC$)
END
DEF VM_GET_LABEL LABEL$,SEARCH_GLOBAL OUT SLOT,LABEL,FOUND
 VAR TBL
 VAR ILL_FMT,HAS_SLOT
 FOUND=#FALSE
 VAR LBL$=LABEL$
 VM_PARSE_SLOT LABEL$,#TRUE OUT ILL_FMT,HAS_SLOT,SLOT,LABEL$

 IF ILL_FMT THEN
  ILLEGAL_LABEL_STRING LABEL$
  SLOT=-1
  LABEL=-1
  RETURN
 ENDIF
 IF !SEARCH_GLOBAL&&VM_CURFUNC&&HAS_SLOT THEN
  UNDEFINED_LABEL LABEL$
  FOUND=#FALSE
  SLOT=-1
  LABEL=-1
  RETURN
 ENDIF
 IF !HAS_SLOT THEN
  SLOT=VM_CURSLOT
 ENDIF
 IF SEARCH_GLOBAL!=2&&VM_CURFUNC THEN
  TBL=FUNC_LBLTBL[VM_CURFUNC]
 ELSE
  TBL=VM_SLOT_GLBLTBL[SLOT]
 ENDIF
 SPLAY_GET% TBL,LABEL$ OUT FOUND,LABEL
 IF SEARCH_GLOBAL&&!FOUND&&VM_CURFUNC THEN
  TBL=VM_SLOT_GLBLTBL[SLOT]
  SPLAY_GET% TBL,LABEL$ OUT FOUND,LABEL
 ENDIF
 IF !FOUND THEN
'  UNDEFINED_LABEL LABEL$
  SLOT=-1
  LABEL=-1
  RETURN
 ENDIF
END

DEF VM_GET_LABEL_DATA_ADDR LABEL$ OUT SLOT,ADDR,FOUND
 VAR LABEL
 VM_GET_LABEL LABEL$,#TRUE OUT SLOT,LABEL,FOUND
 IF !FOUND THEN RETURN
 ADDR=LABEL_DATA_ADDR[LABEL]
END
DEF VM_GET_LABEL_ADDR LABEL$ OUT SLOT,ADDR,FOUND
 VAR LABEL
 VM_GET_LABEL LABEL$,#FALSE OUT SLOT,LABEL,FOUND
 IF !FOUND THEN RETURN
 ADDR=LABEL_ADDR[LABEL]
END
DEF VMINSTR_GOTO_PLACEHOLDER
 VAR ADDR,SLOT,FOUND
 VM_GET_LABEL_ADDR VM_IMM$[VM_OPS[VM_PC]] OUT SLOT,ADDR,FOUND
 IF !FOUND THEN RETURN
 VM_ASSERT VM_CURSLOT==SLOT
 VM_OPS[VM_PC-1]=#VM_BR
 VM_OPS[VM_PC]=ADDR
 VM_PC=ADDR
END
DEF VMINSTR_GOSUB_PLACEHOLDER
 VAR ADDR,SLOT,FOUND
 VM_GET_LABEL_ADDR VM_IMM$[VM_OPS[VM_PC]] OUT SLOT,ADDR,FOUND
 IF !FOUND THEN RETURN
 VM_ASSERT VM_CURSLOT==SLOT
 VM_OPS[VM_PC-1]=#VM_GOSUB
 VM_OPS[VM_PC]=ADDR
 DEC VM_PC
END
DEF VMINSTR_GOSUB SLOT,ADDR
 VAR RETADDR=VM_PC
 VM_PUSHTYP VM_CURSLOT,#VMT_SUBROUTINE
 VM_PUSHTYP RETADDR,#VMT_SUBROUTINE
 VM_PC=ADDR
 IF VM_CURSLOT!=SLOT THEN
  VM_CURSLOT=SLOT
  VM_SWITCH_SLOT VM_CURSLOT
 ENDIF
END
DEF VMINSTR_RETURN
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_SUBROUTINE THEN
  RETURN_WITHOUT_GOSUB
  RETURN
 ENDIF
 VAR TS,VS
 VM_POP OUT TS,VS
 IF TS!=#VMT_SUBROUTINE THEN
  VM_INTERNAL_ERROR
  RETURN
 ENDIF
 IF VS!=VM_CURSLOT THEN
  VM_CURSLOT=VS
  VM_SWITCH_SLOT VM_CURSLOT
 ENDIF
 VM_PC=V
END
DEF VMINSTR_PUSHEMPTY N
 FILL VM_STK_TYP,#VMT_DEFAULT,VM_SP,N
 INC VM_SP,N
END
DEF VM_GETFUNC NAME$,INCNT1,OUTCNT1 OUT FOUND,FUNC
 VAR ILL_FMT,HAS_SLOT,SLOT,FUNC$
 VM_PARSE_SLOT NAME$,#FALSE OUT ILL_FMT,HAS_SLOT,SLOT,FUNC$
 IF ILL_FMT THEN
  FOUND=#FALSE
  RETURN
 ENDIF
 IF!HAS_SLOT THEN SLOT=VM_CURSLOT
 SPLAY_GET% VM_SLOT_FUNCTBL[SLOT],FUNC$ OUT FOUND,FUNC
 IF !FOUND&&!HAS_SLOT THEN
  SPLAY_GET% VM_CFUNCTBL,FUNC$ OUT FOUND,FUNC
 ENDIF
END
DEF GENERATE_NATIVE_RELAY
 VAR I,O
 VAR R$=""
 VAR IM=9,OM=9
 PUSH R$,"DEF RELAY_NATIVE_FUNC N$,I,O"
 PUSH R$,CHR$(10)
 PUSH R$," DEC VM_SP,I"
 PUSH R$,CHR$(10)
 PUSH R$," VAR "
 FOR O=1TO OM
  PUSH R$,"O"
  PUSH R$,STR$(O)
  PUSH R$,","
 NEXT
 PUSH R$,CHR$(10)
 PUSH R$," ON I*"+STR$(OM+1)+"+O GOTO "
 FOR I=0TO IM
  FOR O=0TO OM
   PUSH R$,"@I"
   PUSH R$,STR$(I)
   PUSH R$,"O"
   PUSH R$,STR$(O)
   'TAILING COMMA NOT ALLOWED
   IF I!=IM||O!=OM THEN
    PUSH R$,","
   ENDIF
  NEXT
 NEXT
 PUSH R$,CHR$(10)
 FOR I=0TO IM
  FOR O=0TO OM
   PUSH R$," @I"
   PUSH R$,STR$(I)
   PUSH R$,"O"
   PUSH R$,STR$(O)
   PUSH R$,":"
   PUSH R$,"CALL N$"
   VAR I2
   FOR I2=1TO I
    PUSH R$,",VM_GETSTK(
    PUSH R$,STR$(I-I2)
    PUSH R$,")"
   NEXT
   FOR I2=1TO O
    IF I2==1 THEN
     PUSH R$," OUT O1"
    ELSE
     PUSH R$,",O"
     PUSH R$,STR$(I2)
    ENDIF
   NEXT
   PUSH R$,":"
   FOR I2=1TO O
    PUSH R$,"VM_SETSTK -"
    PUSH R$,STR$(I2)
    PUSH R$,",O"
    PUSH R$,STR$(O+1-I2)
    PUSH R$,":"
   NEXT
   PUSH R$,"RETURN"
   PUSH R$,CHR$(10)
  NEXT
 NEXT
 PUSH R$,"END"
 PUSH R$,CHR$(10)
 CLIPBOARD R$
END












DEF RELAY_NATIVE_FUNC N$,I,O
 DEC VM_SP,I
 VAR O1,O2,O3,O4,O5,O6,O7,O8,O9,
 ON I*10+O GOTO @I0O0,@I0O1,@I0O2,@I0O3,@I0O4,@I0O5,@I0O6,@I0O7,@I0O8,@I0O9,@I1O0,@I1O1,@I1O2,@I1O3,@I1O4,@I1O5,@I1O6,@I1O7,@I1O8,@I1O9,@I2O0,@I2O1,@I2O2,@I2O3,@I2O4,@I2O5,@I2O6,@I2O7,@I2O8,@I2O9,@I3O0,@I3O1,@I3O2,@I3O3,@I3O4,@I3O5,@I3O6,@I3O7,@I3O8,@I3O9,@I4O0,@I4O1,@I4O2,@I4O3,@I4O4,@I4O5,@I4O6,@I4O7,@I4O8,@I4O9,@I5O0,@I5O1,@I5O2,@I5O3,@I5O4,@I5O5,@I5O6,@I5O7,@I5O8,@I5O9,@I6O0,@I6O1,@I6O2,@I6O3,@I6O4,@I6O5,@I6O6,@I6O7,@I6O8,@I6O9,@I7O0,@I7O1,@I7O2,@I7O3,@I7O4,@I7O5,@I7O6,@I7O7,@I7O8,@I7O9,@I8O0,@I8O1,@I8O2,@I8O3,@I8O4,@I8O5,@I8O6,@I8O7,@I8O8,@I8O9,@I9O0,@I9O1,@I9O2,@I9O3,@I9O4,@I9O5,@I9O6,@I9O7,@I9O8,@I9O9
 @I0O0:CALL N$:RETURN
 @I0O1:CALL N$ OUT O1:VM_SETSTK -1,O1:RETURN
 @I0O2:CALL N$ OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I0O3:CALL N$ OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I0O4:CALL N$ OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I0O5:CALL N$ OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I0O6:CALL N$ OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I0O7:CALL N$ OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I0O8:CALL N$ OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I0O9:CALL N$ OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I1O0:CALL N$,VM_GETSTK(0):RETURN
 @I1O1:CALL N$,VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I1O2:CALL N$,VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I1O3:CALL N$,VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I1O4:CALL N$,VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I1O5:CALL N$,VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I1O6:CALL N$,VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I1O7:CALL N$,VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I1O8:CALL N$,VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I1O9:CALL N$,VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I2O0:CALL N$,VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I2O1:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I2O2:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I2O3:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I2O4:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I2O5:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I2O6:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I2O7:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I2O8:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I2O9:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I3O0:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I3O1:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I3O2:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I3O3:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I3O4:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I3O5:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I3O6:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I3O7:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I3O8:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I3O9:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I4O0:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I4O1:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I4O2:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I4O3:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I4O4:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I4O5:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I4O6:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I4O7:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I4O8:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I4O9:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I5O0:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I5O1:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I5O2:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I5O3:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I5O4:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I5O5:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I5O6:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I5O7:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I5O8:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I5O9:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I6O0:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I6O1:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I6O2:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I6O3:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I6O4:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I6O5:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I6O6:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I6O7:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I6O8:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I6O9:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I7O0:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I7O1:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I7O2:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I7O3:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I7O4:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I7O5:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I7O6:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I7O7:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I7O8:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I7O9:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I8O0:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I8O1:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I8O2:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I8O3:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I8O4:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I8O5:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I8O6:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I8O7:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I8O8:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I8O9:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I9O0:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I9O1:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I9O2:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I9O3:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I9O4:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I9O5:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I9O6:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I9O7:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I9O8:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I9O9:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
END








COMMON DEF SBSB_CHKLABEL * OUT *
 IF DEFOUTC()!=1||(DEFARGC()!=1&&DEFARGC()!=2) THEN
  MISSING_PARAMETER "CHKLABEL"
  RETURN
 ENDIF
 IF DEFARGC()==2 THEN
  DEFOUT 0,VM_CHKLABEL(DEFARG(0),DEFARG(1))
 ELSEIF DEFARGC()==1 THEN
  DEFOUT 0,VM_CHKLABEL(DEFARG(0),#FALSE)
 ENDIF
END

COMMON DEF SBSB_CHKCALL * OUT *
 IF DEFOUTC()!=1||(DEFARGC()!=1) THEN
  MISSING_PARAMETER "CHKFUNC"
  RETURN
 ENDIF
 DEFOUT 0,VM_CHKCALL(DEFARG(0))
END
DEF CALL_NATIVE_FUNC NAME$,INCNT,OUTCNT
 CASE NAME$
 WHEN "CHKLABEL"
  IF OUTCNT!=1||(INCNT!=1&&INCNT!=2) THEN
   MISSING_PARAMETER "CHKLABEL"
   RETURN
  ENDIF
  DEC VM_SP,INCNT
  VAR I1,I2,O1
  IF INCNT==2 THEN
   I1=VM_GETSTK(1)
   I2=VM_GETSTK(0)
   O1=VM_CHKLABEL(I1,I2)
  ELSE
   I1=VM_GETSTK(0)
   O1=VM_CHKLABEL(I1,#FALSE)
  ENDIF
  VM_SETSTK -1,O1
  RETURN
 WHEN "CHKCALL"
  IF OUTCNT!=1||INCNT!=1 THEN
   MISSING_PARAMETER "CHKCALL"
   RETURN
  ENDIF
  DEC VM_SP,INCNT
  I1=VM_GETSTK(0)
  O1=VM_CHKCALL(I1)
  VM_SETSTK -1,O1
  RETURN
 WHEN "DEFARGC"
  IF OUTCNT!=1||INCNT!=0 THEN
   MISSING_PARAMETER "DEFARGC"
   RETURN
  ENDIF
  DEC VM_SP,INCNT
  IF!VM_CURFUNC THEN
   VM_SETSTK -1,0
  ENDIF
  VAR T,V
  VM_GETLVAR #VMSTK_INCNT OUT T,V
  IF T!=#VMT_INT THEN
   VM_INTERNAL_ERROR "TYPE OF #VMSTK_INCNT SHOULD BE #VMT_INT"
  ENDIF
  VM_SETSTK -1,V
 WHEN "DEFARG"
  IF OUTCNT!=1||INCNT!=1 THEN
   MISSING_PARAMETER "DEFARG"
   RETURN
  ENDIF
  DEC VM_SP,INCNT
  IF!VM_CURFUNC THEN
   CANT_USE_OUTSIDE_DEF "DEFARG"
   RETURN
  ENDIF
  I1=VM_GETSTK(0)
  IF TYPEOF(I1)!=#T_INT&&TYPEOF(I1)!=#T_REAL THEN
   TYPE_MISMATCH "DEFARG"
   RETURN
  ENDIF
  VM_GETLVAR #VMSTK_STARTARGS-I1 OUT T,V
  IF !VM_ISPRITYP(T)THEN
   VM_INTERNAL_ERROR "DEFARG"
  ENDIF
  VM_SETSTK -1,V
 WHEN "DEFOUTC"
  IF OUTCNT!=1||INCNT!=0 THEN
   MISSING_PARAMETER "DEFOUTC"
   RETURN
  ENDIF
  DEC VM_SP,INCNT
  IF!VM_CURFUNC THEN
   VM_SETSTK -1,0
  ENDIF
  VM_GETLVAR #VMSTK_OUTCNT OUT T,V
  IF T!=#VMT_INT THEN
   VM_INTERNAL_ERROR "TYPE OF #VMSTK_OUTCNT SHOULD BE #VMT_INT"
  ENDIF
  VM_SETSTK -1,V
 OTHERWISE
  RELAY_NATIVE_FUNC NAME$,INCNT,OUTCNT
 ENDCASE
 'CLEANUP ARRAYS
 VAR I,L=VM_SP+INCNT-1
 FOR I=VM_SP TO L
  T=VM_STK_TYP[I]
  IF T==#VMT_INTARRAY||T==#VMT_REALARRAY||T==#VMT_STRARRAY THEN
   VM_FREE_ARRAY VM_STK%[I]
  ENDIF
 NEXT
END
DEF VMINSTR_CALLFUNC
 VAR NAME$=VM_IMM$[VM_OPS[VM_PC]]
 INC VM_PC
 VAR INCNT=VM_OPS[VM_PC]
 INC VM_PC
 VAR OUTCNT=VM_OPS[VM_PC]
 INC VM_PC
 SVM_CALL NAME$,INCNT,OUTCNT
END
DEF SVM_CALL NAME$,INCNT,OUTCNT
 VAR ADDR
 VAR FUNC,INCNTF,OUTCNTF,FOUND
 IF NAME$=="CALL" THEN
  DEC INCNT
  VAR NAMET,NAMEV
  VM_POP OUT NAMET,NAMEV
  IF NAMET!=#VMT_STR THEN
   TYPE_MISMATCH "CALL"
   RETURN
  ENDIF
  NAME$=TO_UPPER$(NAMEV)
 ENDIF
 VM_GETFUNC NAME$,INCNT,OUTCNT OUT FOUND,FUNC
 IF !FOUND THEN
  IF CHKCALL("SBSB_"+NAME$) THEN
   CALL_NATIVE_FUNC "SBSB_"+NAME$,INCNT,OUTCNT
   RETURN
  ENDIF
  IF CHKCALL(NOT_USED_SLOT$+NAME$)THEN
   CALL_NATIVE_FUNC NAME$,INCNT,OUTCNT
   RETURN
  ENDIF
  SYNTAX_ERROR "UNDEFINED FUNCTION "+NAME$
  RETURN
 ENDIF
 IF (FUNC_INCNT[FUNC]!=-1&&FUNC_INCNT[FUNC]!=INCNT)||\
    (FUNC_OUTCNT[FUNC]!=-1&&FUNC_OUTCNT[FUNC]!=OUTCNT)THEN
  MISSING_PARAMETER NAME$
  RETURN
 ENDIF
 VM_PUSHINT OUTCNT
 VM_PUSHINT INCNT
 VM_PUSHINT VM_CURFUNC
 VM_PUSHINT VM_BP
 VM_PUSHINT VM_CURSLOT
 VM_PUSHINT VM_PC
 IF VM_CURSLOT!=FUNC_SLOT[FUNC]THEN
  VM_CURSLOT=FUNC_SLOT[FUNC]
  VM_SWITCH_SLOT VM_CURSLOT
 ENDIF
 VM_BP=VM_SP
 VM_PC=FUNC_ADDR[FUNC]
 INC VM_SP,FUNC_VARNUM[FUNC]+1
 VM_INITLVARSTK GET_SPLAY_ROOT(FUNC_VARTBL[FUNC])
 VM_CURFUNC=FUNC
END
DEF VM_INITLVARSTK NODE
 IF !NODE THEN RETURN
 VM_INITLVARSTK GET_SPLAYN_LEFT(NODE)
 VAR V=GET_SPLAYN_VAL%(NODE)
 VAR IDX=VAR_IDX[V]
 VAR TYP=VAR_TYP[V]
 IF IDX>=0 THEN
  VM_STK_TYP[VM_BP+IDX]=TYP
  VM_STK%[VM_BP+IDX]=0
  VM_STK#[VM_BP+IDX]=0
  VAR N$
  VM_STK$[VM_BP+IDX]=N$
 ENDIF
 VM_INITLVARSTK GET_SPLAYN_RIGHT(NODE)
END
DEF VM_ASSERT *
 IF DEFARG(0)THEN
  RETURN
 ELSE
  IF DEFARGC()==1 THEN
   ?"Assertion failed(VM)"
  ELSEIF DEFARGC()==2 THEN
   ?"Assertion failed(VM) ";DEFARG(1)
  ELSE
   ?"Assertion failed(VM) MISSING PARAMETER(ASSERT)"
  ENDIF
  STOP
 ENDIF
END
DEF VMINSTR_RETURNFUNC
 VAR I,L=VM_BP+FUNC_VARNUM[VM_CURFUNC]-1
 FOR I=VM_BP TO L
  VAR T=VM_STK_TYP[I]
  IF T==#VMT_INTARRAY||T==#VMT_REALARRAY||T==#VMT_STRARRAY THEN
   VM_FREE_ARRAY VM_STK%[I]
  ENDIF
 NEXT
 VM_SP=VM_BP
 VAR RETADDR_T,RETADDR_V
 VM_POP OUT RETADDR_T,RETADDR_V
 VM_ASSERT RETADDR_T==#VMT_INT
 VAR RETSLOT_T,RETSLOT_V
 VM_POP OUT RETSLOT_T,RETSLOT_V
 VM_ASSERT RETADDR_T==#VMT_INT
 VAR OLDBP_T,OLDBP_V
 VM_POP OUT OLDBP_T,OLDBP_V
 VM_ASSERT OLDBP_T==#VMT_INT
 VAR OLDFUNC_T,OLDFUNC_V
 VM_POP OUT OLDFUNC_T,OLDFUNC_V
 VM_ASSERT OLDFUNC_T==#VMT_INT
 VM_CURFUNC=OLDFUNC_V
 VAR INCNT_T,OUTCNT_T
 VAR INCNT_V,OUTCNT_V
 VM_POP OUT INCNT_T,INCNT_V
 VM_ASSERT INCNT_T==#VMT_INT
 VM_POP OUT OUTCNT_T,OUTCNT_V
 VM_ASSERT OUTCNT_T==#VMT_INT
 L=VM_SP-1
 FOR I=VM_SP-INCNT_V TO L
  T=VM_STK_TYP[I]
  IF T==#VMT_INTARRAY||T==#VMT_REALARRAY||T==#VMT_STRARRAY THEN
   VM_FREE_ARRAY VM_STK%[I]
  ENDIF
 NEXT
 VM_BP=OLDBP_V
 IF RETSLOT_V!=VM_CURSLOT THEN
  VM_CURSLOT=RETSLOT_V
  VM_SWITCH_SLOT VM_CURSLOT
 ENDIF
 VM_PC=RETADDR_V
 DEC VM_SP,INCNT_V
END
DEF VMINSTR_PUSHEMPTYREF
 VM_PUSHTYP 0,#VMT_EMPTYREF
END
DEF VM_POP_DIMS DM OUT DM1,DM2,DM3,DM4,ERR
 VAR T
 ERR=#FALSE
 IF DM>=1 THEN
  VM_POP OUT T,DM1
  IF!VM_ISNUMTYPE(T) THEN
   ERR=#TRUE
   TYPE_MISMATCH "ARRAY DIM"
   RETURN
  ENDIF
 ENDIF
 IF DM>=2 THEN
  VM_POP OUT T,DM2
  IF!VM_ISNUMTYPE(T) THEN
   ERR=#TRUE
   TYPE_MISMATCH "ARRAY DIM"
   RETURN
  ENDIF
 ENDIF
 IF DM>=3 THEN
  VM_POP OUT T,DM3
  IF!VM_ISNUMTYPE(T) THEN
   ERR=#TRUE
   TYPE_MISMATCH "ARRAY DIM"
   RETURN
  ENDIF
 ENDIF
 IF DM>=4 THEN
  VM_POP OUT T,DM4
  IF!VM_ISNUMTYPE(T) THEN
   ERR=#TRUE
   TYPE_MISMATCH "ARRAY DIM"
   RETURN
  ENDIF
 ENDIF
END
DEF VMINSTR_NEWARRAY
 VAR DM=VM_OPS[VM_PC]
 INC VM_PC
 VAR TYP=VM_OPS[VM_PC]
 INC VM_PC
 VAR V
 VAR DM1,DM2,DM3,DM4,ERR
 VAR T
 VM_POP_DIMS DM OUT DM1,DM2,DM3,DM4,ERR
 IF ERR THEN RETURN
 CASE TYP
 WHEN #VMT_INTARRAY
  CASE DM
  WHEN 1
   V=ARRAY%(DM1)
  WHEN 2
   V=ARRAY%(DM1,DM2)
  WHEN 3
   V=ARRAY%(DM1,DM2,DM3)
  WHEN 4
   V=ARRAY%(DM1,DM2,DM3,DM4)
  ENDCASE
 WHEN #VMT_REALARRAY
  CASE DM
  WHEN 1
   V=ARRAY#(DM1)
  WHEN 2
   V=ARRAY#(DM1,DM2)
  WHEN 3
   V=ARRAY#(DM1,DM2,DM3)
  WHEN 4
   V=ARRAY#(DM1,DM2,DM3,DM4)
  ENDCASE
 WHEN #VMT_STRARRAY
  CASE DM
  WHEN 1
   V=ARRAY$(DM1)
  WHEN 2
   V=ARRAY$(DM1,DM2)
  WHEN 3
   V=ARRAY$(DM1,DM2,DM3)
  WHEN 4
   V=ARRAY$(DM1,DM2,DM3,DM4)
  ENDCASE
 OTHERWISE
  VM_ERROR
 ENDCASE
 VM_PUSHTYP V,TYP
END
DEF VM_ISARYTYP(T)
 RETURN T==#VMT_INTARRAY||T==#VMT_REALARRAY||T==#VMT_STRARRAY||T==#VMT_STR
END
DEF VM_ISSCALARTYP(T)
 RETURN T==#VMT_INT||T==#VMT_REAL||T==#VMT_STR
END
DEF VM_ISPRITYP(T)
 RETURN T==#VMT_INT||T==#VMT_REAL||T==#VMT_STR||T==#VMT_INTARRAY||T==#VMT_REALARRAY||T==#VMT_STRARRAY||T==#VMT_DEFAULT
END
DEF VMINSTR_PUSHARYREF
 VAR DM=VM_OPS[VM_PC]
 INC VM_PC
 VM_PUSHTYP DM,#VMT_ARYREF
 RETURN
END
DEF VMINSTR_INITARRAY
 VAR CNT=VM_OPS[VM_PC]
 INC VM_PC
 VAR REFT,REFV
 VM_POP OUT REFT,REFV
 VAR I
 FOR I=0TO CNT-1
  VAR T,V
  VM_POP OUT T,V
  IF !VM_ISSCALARTYP(T) THEN
   TYPE_MISMATCH "INITARRAY"
   RETURN
  ENDIF
  REFV[I]=V
 NEXT
END
DEF VM_READ OUT TYP,V
 IF LEN(VM_DATA_TYP)<=VM_DATA_IDX THEN
  TYP=#VMT_DEFAULT
  RETURN
 ENDIF
 TYP=VM_DATA_TYP[VM_DATA_IDX]
 CASE TYP
 WHEN #VMT_INT
  V=VM_DATA%[VM_DATA_IDX]
 WHEN #VMT_REAL
  V=VM_DATA#[VM_DATA_IDX]
 WHEN #VMT_STR
  V=VM_DATA$[VM_DATA_IDX]+""
 OTHERWISE
  INTERNAL_VM_ERROR
 ENDCASE
 INC VM_DATA_IDX
END

DEF VMINSTR_READ
 IF VM_DATA_IDX>=LEN(VM_DATA_TYP)THEN
  OUT_OF_DATA "READ"
  RETURN
 ENDIF
 VAR REFT,REFV
 VM_POP OUT REFT,REFV
 VAR V,TYP
 VM_READ OUT TYP,V
 IF TYP==#VMT_DEFAULT THEN
  OUT_OF_DATA "READ"
  RETURN
 ENDIF
 VAR ERR
 VM_ASSIGN REFT,REFV,#FALSE,TYP,V,ERR
 IF ERR THEN RETURN
END
DEF VMINSTR_RESTORE
 VM_CURDATASLOT=VM_OPS[VM_PC]
 INC VM_PC
 VM_DATA_IDX=VM_OPS[VM_PC]
 INC VM_PC
 VM_SWITCH_SLOT_DATA VM_CURDATASLOT
END
DEF VM_RESTORE LBL$ OUT *
 VAR SLOT,ADDR,FOUND
 VM_GET_LABEL_DATA_ADDR LBL$ OUT SLOT,ADDR,FOUND
 IF!FOUND THEN
  UNDEFINED_LABEL LBL$
  IF DEFOUTC()==1 THEN DEFOUT 0,#TRUE
  RETURN
 ENDIF
 IF SLOT!=VM_CURDATASLOT THEN
  VM_CURDATASLOT=SLOT
  VM_SWITCH_SLOT_DATA VM_CURDATASLOT
 ENDIF
 VM_DATA_IDX=ADDR
 IF DEFOUTC()==1 THEN DEFOUT 0,#FALSE
END
DEF VMINSTR_RESTORE_PLACEHOLDER
 VAR ADDR,SLOT,FOUND
 VM_GET_LABEL_DATA_ADDR VM_IMM$[VM_OPS[VM_PC]] OUT SLOT,ADDR,FOUND
 IF!FOUND THEN
  RETURN
 ENDIF
 VM_OPS[VM_PC-2]=#VM_RESTORE
 VM_OPS[VM_PC-1]=SLOT
 VM_OPS[VM_PC]=ADDR
 DEC VM_PC,2
END
DEF VMINSTR_RESTOREEXPR
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_STR THEN
  TYPE_MISMATCH "RESTORE"
 ENDIF
 VM_RESTORE V
END
DEF VMINSTR_GOTOEXPR
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_STR THEN
  TYPE_MISMATCH "GOTO(EXPR)"
  RETURN
 ENDIF
 VAR SLOT,ADDR,FOUND
 VM_GET_LABEL_ADDR V OUT SLOT,ADDR,FOUND
 IF !FOUND THEN
  RETURN
 ENDIF
 ADDR=VM_PC
 IF SLOT!=VM_CURSLOT THEN
  VM_CURSLOT=SLOT
  VM_SWITCH_SLOT VM_CURSLOT
 ENDIF
END
DEF VMINSTR_GOSUBEXPR
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_STR THEN
  TYPE_MISMATCH "GOSUB(EXPR)"
  RETURN
 ENDIF
 VM_GOSUB V
END
DEF VM_GOSUB L$
 VAR SLOT,ADDR,FOUND
 VM_GET_LABEL_ADDR L$ OUT SLOT,ADDR,FOUND
 IF !FOUND THEN
  RETURN
 ENDIF
 VMINSTR_GOSUB SLOT,ADDR
END
DEF VMINSTR_INC MINUS
 VAR T,V
 VAR OSP=VM_SP
 VAR RT,RV
 VAR ERR
 VM_REF OUT RT,RV,T,V,ERR
 IF ERR THEN RETURN
 VAR DT,DV
 VM_POP OUT DT,DV
 VAR S=VM_SP
 VM_SP=OSP-1
 IF (T==#VMT_STR&&DT==#VMT_STR)||(VM_ISNUMTYPE(T)&&VM_ISNUMTYPE(DT))THEN
 ELSE
  TYPE_MISMATCH "INC"
  RETURN
 ENDIF
 IF MINUS THEN
  DEC V,DV
 ELSE
  INC V,DV
 ENDIF
 VM_ASSIGN RT,RV,#FALSE,T,V,ERR
 VM_SP=S
 IF ERR THEN RETURN
END
DEF VMINSTR_ONGOTO GSB
 VAR T,V
 VM_POP OUT T,V
 IF!VM_ISNUMTYPE(T)THEN
  TYPE_MISMATCH "ON GOTO"
  RETURN
 ENDIF
 VAR CNT=VM_OPS[VM_PC]
 INC VM_PC
 IF V<0||V>=CNT THEN
  INC VM_PC,CNT
  RETURN
 ENDIF
 VAR ADDR=VM_OPS[VM_PC+V]
 IF ADDR>0 THEN
  VAR SLOT,FOUND
  VM_GET_LABEL_ADDR VM_IMM$[ADDR] OUT SLOT,ADDR,FOUND
  IF !FOUND THEN
   RETURN
  ENDIF
  VM_ASSERT SLOT==VM_CURSLOT
  VM_OPS[VM_PC+V]=-ADDR
 ELSE
  ADDR=-ADDR
 ENDIF
 INC VM_PC,CNT
 IF GSB THEN
  VMINSTR_GOSUB VM_CURSLOT,ADDR
 ELSE
  VM_PC=ADDR
 ENDIF
END
DEF VMINSTR_WHEN
 VAR ADDR=VM_OPS[VM_PC]
 INC VM_PC
 VAR T,V
 VAR T2,V2
 VM_POP OUT T,V
 VAR OSP=VM_SP
 VM_POP OUT T2,V2
 VM_SP=OSP
 IF (VM_ISNUMTYPE(T)&&VM_ISNUMTYPE(T2))||(T==#VMT_STR&&T2==#VMT_STR)THEN
 ELSE
  STOP
  TYPE_MISMATCH "WHEN"
  RETURN
 ENDIF
 IF V==V2 THEN
  VM_PC=ADDR
  DEC VM_SP
 ENDIF
END
DEF VMINSTR_SWAP
 VAR T1,V1,RT1,RV1
 VAR T2,V2,RT2,RV2
 VAR OSP1=VM_SP
 VAR ERR
 VM_REF OUT RT1,RV1,T1,V1,ERR
 IF ERR THEN RETURN
 VAR OSP2=VM_SP
 VM_REF OUT RT2,RV2,T2,V2,ERR
 IF ERR THEN RETURN
 VAR OSP3=VM_SP
 VM_SP=OSP1-1
 VM_ASSIGN RT1,RV1,#FALSE,T2,V2,ERR
 IF ERR THEN RETURN
 VM_SP=OSP2-1
 VM_ASSIGN RT2,RV2,#FALSE,T1,V1,ERR
 IF ERR THEN RETURN
 VM_SP=OSP3
END
DEF VMINSTR_INPUT
 VAR GUIDE=VM_OPS[VM_PC]
 INC VM_PC
 VAR SEMI=VM_OPS[VM_PC]
 INC VM_PC
 VAR CNT=VM_OPS[VM_PC]
 INC VM_PC
 VAR GUIDET,GUIDEV=""
 VAR RT1,RV1,T1,V1,SP1
 VAR RT2,RV2,T2,V2,SP2
 VAR RT3,RV3,T3,V3,SP3
 VAR RT4,RV4,T4,V4,SP4
 IF GUIDE THEN
  VM_POP OUT GUIDET,GUIDEV
  IF GUIDET!=#VMT_STR THEN
'   TYPE_MISMATCH "INPUT(GUIDE)"
   SYNTAX_ERROR "INPUT(GUIDE)"'FIXME:(INPUT:1)
   RETURN
  ENDIF
  ?GUIDEV;
 ENDIF
 IF !SEMI&&!GUIDE THEN
  ?"? ";
 ENDIF
 VAR ERR
 IF CNT>=1 THEN
  SP1=VM_SP-1
  VM_REF OUT RT1,RV1,T1,V1,ERR
  IF ERR THEN RETURN
  IF CNT==1 THEN
   IF SEMI THEN
    INPUT "";V1
   ELSE
    INPUT "",V1
   ENDIF
  ENDIF
 ENDIF
 IF CNT>=2 THEN
  SP2=VM_SP-1
  VM_REF OUT RT2,RV2,T2,V2,ERR
  IF ERR THEN RETURN
  IF CNT==2 THEN
   IF SEMI THEN
    INPUT "";V1,V2
   ELSE
    INPUT "",V1,V2
   ENDIF
  ENDIF
 ENDIF
 IF CNT>=3 THEN
  SP3=VM_SP-1
  VM_REF OUT RT3,RV3,T3,V3,ERR
  IF ERR THEN RETURN
  IF CNT==3 THEN
   IF SEMI THEN
    INPUT "";V1,V2,V3
   ELSE
    INPUT "",V1,V2,V3
   ENDIF
  ENDIF
 ENDIF
 IF CNT>=4 THEN
  SP4=VM_SP-1
  VM_REF OUT RT4,RV4,T4,V4,ERR
  IF ERR THEN RETURN
  IF CNT==4 THEN
   IF SEMI THEN
    INPUT "";V1,V2,V3,V4
   ELSE
    INPUT "",V1,V2,V3,V4
   ENDIF
  ELSE
   VM_ERROR
  ENDIF
 ENDIF
 IF CNT>=1 THEN
  VM_SP=SP1
  VM_ASSIGN RT1,RV1,#FALSE,T1,V1,ERR
  IF ERR THEN RETURN
 ENDIF
 IF CNT>=2 THEN
  VM_SP=SP2
  VM_ASSIGN RT2,RV2,#FALSE,T2,V2,ERR
  IF ERR THEN RETURN
 ENDIF
 IF CNT>=3 THEN
  VM_SP=SP3
  VM_ASSIGN RT3,RV3,#FALSE,T3,V3,ERR
  IF ERR THEN RETURN
 ENDIF
 IF CNT>=4 THEN
  VM_SP=SP4
  VM_ASSIGN RT4,RV4,#FALSE,T4,V4,ERR
  IF ERR THEN RETURN
 ENDIF
END
DEF VMINSTR_LINPUT
 VAR GUIDE=VM_OPS[VM_PC]
 INC VM_PC
 VAR V
 VAR GUIDET,GUIDEV
 IF GUIDE THEN
  VM_POP OUT GUIDET,GUIDEV
  IF GUIDET!=#VMT_STR THEN
   TYPE_MISMATCH "INPUT(GUIDE)"
   RETURN
  ENDIF
  ?GUIDEV;
 ENDIF
 LINPUT V
 VM_PUSHSTR V
END
DEF VMINSTR_DEFOUT
 VAR T1,V1
 VAR T2,V2
 VM_POP OUT T1,V1
 VM_POP OUT T2,V2
 IF!VM_ISNUMTYPE(T1)THEN
  TYPE_MISMATCH "DEFOUT"
  RETURN
 ENDIF
 VAR IT,IV
 VM_GETLVAR #VMSTK_INCNT OUT IT,IV
 IF IT!=#VMT_INT THEN
  VM_INTERNAL_ERROR "TYPE OF #VMSTK_INCNT SHOULD BE #VMT_INT(DEFOUT)"
 ENDIF
 VAR OT,OV
 VM_GETLVAR #VMSTK_OUTCNT OUT OT,OV
 IF IT!=#VMT_INT THEN
  VM_INTERNAL_ERROR "TYPE OF #VMSTK_INCNT SHOULD BE #VMT_INT(DEFOUT)"
 ENDIF
 IF V1>=OV THEN
  OUT_OF_RANGE "DEFOUT"
  RETURN
 ENDIF
 VM_SETLVAR #VMSTK_STARTARGS-IV-OV+V1+1,T2,V2
END

DEF VM_FREE_GLBLTBL NODE
 IF !NODE THEN RETURN
 VM_FREE_GLBLTBL GET_SPLAYN_LEFT(NODE)
 DELETE_LABEL GET_SPLAYN_VAL%(NODE)
 VM_FREE_GLBLTBL GET_SPLAYN_RIGHT(NODE)
END
DEF VM_FREE_FUNCTBL NODE
 IF !NODE THEN RETURN
 VM_FREE_FUNCTBL GET_SPLAYN_LEFT(NODE)
 DELETE_FUNC GET_SPLAYN_VAL%(NODE)
 VM_FREE_FUNCTBL GET_SPLAYN_RIGHT(NODE)
END
DEF VM_FREE_GVARTBL NODE
 IF !NODE THEN RETURN
 VM_FREE_GVARTBL GET_SPLAYN_LEFT(NODE)
 DELETE_VAR GET_SPLAYN_VAL%(NODE)
 VM_FREE_GVARTBL GET_SPLAYN_RIGHT(NODE)
END
DEF VM_FREE_CONSTTBL NODE
 IF !NODE THEN RETURN
 VM_FREE_CONSTTBL GET_SPLAYN_LEFT(NODE)
 DELETE_CONST GET_SPLAYN_VAL%(NODE)
 VM_FREE_CONSTTBL GET_SPLAYN_RIGHT(NODE)
END
DEF VM_FREE_SLOT SLOT
 IF VM_CURDATASLOT==SLOT THEN
  '?
  VM_CURDATASLOT=-1
  VM_DATA_IDX=0
  VM_DATA_TYP=ARRAY%(0)
  VM_DATA%=ARRAY%(0)
  VM_DATA#=ARRAY#(0)
  VM_DATA$=ARRAY$(0)
 ENDIF
 VM_FREE_ARRAY VM_SLOT_OPS[SLOT]:VM_SLOT_OPS[SLOT]=0
 VM_FREE_ARRAY VMDBG_SLOT_LINE[SLOT]:VMDBG_SLOT_LINE[SLOT]=0
 VM_FREE_ARRAY VMDBG_SLOT_LINE_PC[SLOT]:VMDBG_SLOT_LINE_PC[SLOT]=0
 VM_FREE_ARRAY VMDBG_SLOT_LINE_POS[SLOT]:VMDBG_SLOT_LINE_POS[SLOT]=0
 VM_FREE_ARRAY VMDBG_SLOT_LINE_END[SLOT]:VMDBG_SLOT_LINE_END[SLOT]=0
 VM_FREE_ARRAY VMDBG_SLOT_LINE_POS_END[SLOT]:VMDBG_SLOT_LINE_POS_END[SLOT]=0
 VM_FREE_ARRAY VMDBG_SLOT_LINE_PC_INDEX[SLOT]:VMDBG_SLOT_LINE_PC_INDEX[SLOT]=0
 VM_FREE_ARRAY VMDBG_SLOT_LINE_PC_INDEX2[SLOT]:VMDBG_SLOT_LINE_PC_INDEX2[SLOT]=0

 VM_FREE_ARRAY VM_SLOT_IMM#[SLOT]:VM_SLOT_IMM#[SLOT]=0
 VM_FREE_ARRAY VM_SLOT_IMM$[SLOT]:VM_SLOT_IMM$[SLOT]=0
 VAR TYP=VM_GET_ARRAY(VM_SLOT_GVAR_TYP[SLOT])
 VAR GV=VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT])
 VAR I
 FOR I=0TO LAST(TYP)
  IF VM_ISARYTYP(TYP[I])THEN
   VM_FREE_ARRAY GV[I]
  ENDIF
 NEXT
 VM_FREE_ARRAY VM_SLOT_GVAR_TYP[SLOT]:VM_SLOT_GVAR_TYP[SLOT]=0
 VM_FREE_ARRAY VM_SLOT_GVAR%[SLOT]:VM_SLOT_GVAR%[SLOT]=0
 VM_FREE_ARRAY VM_SLOT_GVAR#[SLOT]:VM_SLOT_GVAR#[SLOT]=0
 VM_FREE_ARRAY VM_SLOT_GVAR$[SLOT]:VM_SLOT_GVAR$[SLOT]=0
 VM_FREE_GLBLTBL GET_SPLAY_ROOT(VM_SLOT_GLBLTBL[SLOT])
 DELETE_SPLAY_TREE VM_SLOT_GLBLTBL[SLOT]
 VM_SLOT_GLBLTBL[SLOT]=0
 VM_FREE_FUNCTBL GET_SPLAY_ROOT(VM_SLOT_FUNCTBL[SLOT])
 DELETE_SPLAY_TREE VM_SLOT_FUNCTBL[SLOT]
 VM_SLOT_FUNCTBL[SLOT]=0
 VM_FREE_GVARTBL GET_SPLAY_ROOT(VM_SLOT_GVARTBL[SLOT])
 DELETE_SPLAY_TREE VM_SLOT_GVARTBL[SLOT]
 VM_SLOT_GVARTBL[SLOT]=0
 VM_FREE_CONSTTBL GET_SPLAY_ROOT(VM_SLOT_CONSTTBL[SLOT])
 DELETE_SPLAY_TREE VM_SLOT_CONSTTBL[SLOT]
 VM_SLOT_CONSTTBL[SLOT]=0
 VM_FREE_ARRAY VM_SLOT_DATA_TYP[SLOT]:VM_SLOT_DATA_TYP[SLOT]=0
 VM_FREE_ARRAY VM_SLOT_DATA%[SLOT]:VM_SLOT_DATA%[SLOT]=0
 VM_FREE_ARRAY VM_SLOT_DATA#[SLOT]:VM_SLOT_DATA#[SLOT]=0
 VM_FREE_ARRAY VM_SLOT_DATA$[SLOT]:VM_SLOT_DATA$[SLOT]=0
 VM_SLOT_EXEC_SLOT[SLOT]=-1
 VM_SLOT_EXEC_ADDR[SLOT]=-1
 VM_SLOT_EXEC_FUNC[SLOT]=-1
END
DEF VMINSTR_EXEC1
 VAR T,V
 VM_POP OUT T,V
 VAR SLOT=VM_CURSLOT
 IF VM_ISNUMTYPE(T)THEN
  V=INT(V)
  SLOT=V
 ELSEIF T==#VMT_STR THEN
  SLOT=VM_CURSLOT
  SBSB_LOAD V
 ELSE
  TYPE_MISMATCH "EXEC"
  RETURN
 ENDIF
 VMINSTR_EXEC SLOT
END
DEF VMINSTR_EXEC SLOT
 VAR RESET
 VAR IN$=GET_VSLOT$(SLOT)
 IF VM_SLOT_OPS[SLOT] THEN
'  DIM B_SLOT,B_LINE,B_POS
'  VM_BACKTRACE #TRUE OUT B_SLOT,B_LINE,B_POS
  VAR I
'  FOR I=0TO LAST(B_SLOT)
'   IF SLOT==B_SLOT[I] THEN
'    RESET=#TRUE
'    BREAK
'   ENDIF
'  NEXT
  RESET=VM_SLOT_EXEC_ADDR[SLOT]!=-1||VM_CURSLOT==SLOT
  IF RESET THEN
   VAR L=VM_SP
   FOR I=1TO L
    VM_POP OUT ,
   NEXT
   VM_BP=0
   VM_CURFUNC=0
   VM_SP=0
  ENDIF
  VM_FREE_SLOT SLOT
 ENDIF
 INIT_LEXER IN$
 INIT_AST
 INIT_PARSER SLOT
 VAR AST=PARSE()
 INIT_COMPILER SLOT
 COMPILE AST
' LOAD_VM_SLOT SLOT
 IF!RESET THEN
  VM_SLOT_EXEC_ADDR[SLOT]=VM_PC
  VM_SLOT_EXEC_FUNC[SLOT]=VM_CURFUNC
  VM_SLOT_EXEC_SLOT[SLOT]=VM_CURSLOT
 ENDIF
 VM_CURSLOT=SLOT
 VM_SWITCH_SLOT VM_CURSLOT
 VM_PC=0
 VM_CURFUNC=0
 VM_PREV_PC=0
END
DEF VMINSTR_EXEC2
 VAR FT,FV
 VAR ST,SV
 VM_POP OUT FT,FV
 VM_POP OUT ST,SV
 IF FT!=#VMT_STR THEN
  TYPE_MISMATCH "EXEC"
 ENDIF
 IF ST!=#VMT_INT||ST!=#VMT_REAL THEN
  TYPE_MISMATCH "EXEC"
 ENDIF
 SBSB_LOAD FV,SV
 VMINSTR_EXEC SV
END
ENUM #VM_LASTERR_NONE,#VM_LASTERR_EN,#VM_LASTERR_ENJA
VAR VM_LASTERR
VAR VM_CONTINUABLE
VAR VM_LASTERR_EN$
VAR VM_LASTERR_JA$
VAR VM_STOP
VAR VM_STOP_MSG$
DEF VMINSTR_STOP1
 VM_STOP=#TRUE
 VM_RAISE_ERR1 "Break on "+VM_GET_CURLOC$()
 VM_CONTINUABLE=#TRUE
END
DEF VMINSTR_STOP2
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_STR THEN
  TYPE_MISMATCH "STOP"
  RETURN
 ENDIF
 VM_STOP=#TRUE
 VM_STOP_MSG$=V
 VM_RAISE_ERR1 "Break on "+VM_GET_CURLOC$()+CHR$(10)+V
 VM_CONTINUABLE=#TRUE
END
DEF VMINSTR_PUSHVAREXPR
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_STR THEN
  UNDEFINED_VARIABLE "Type mismatch(VAR())"
  RETURN
 ENDIF
 VAR SLOT,LOCAL,IDX,FOUND
 VM_CHKVAR V OUT SLOT,LOCAL,IDX,FOUND
 IF!FOUND THEN
  UNDEFINED_VARIABLE "Type mismatch(VAR())"
  RETURN
 ENDIF
 IF LOCAL THEN
  VM_GETLVAR IDX OUT T,V
  VM_PUSHTYP V,T
 ELSE
  VM_GETVAR2_SLOT SLOT,IDX OUT T,V
  VM_PUSHTYP V,T
 ENDIF
END
DEF VM_CHKVAR NAME$ OUT SLOT,LOCAL,IDX,FOUND
 VAR ILL_FMT,HAS_SLOT,N$
 VM_PARSE_SLOT NAME$,#FALSE OUT ILL_FMT,HAS_SLOT,SLOT,N$
 IF ILL_FMT THEN
  FOUND=#FALSE
  RETURN
 ENDIF
 VAR TBL
 IF HAS_SLOT THEN
 ELSEIF VM_CURFUNC THEN
  SPLAY_GET% FUNC_VARTBL[VM_CURFUNC],N$ OUT FOUND,IDX
  IF FOUND THEN
   IDX=VAR_IDX[IDX]
   LOCAL=#TRUE
   RETURN
  ENDIF
  SLOT=VM_CURSLOT
 ELSE
  SLOT=VM_CURSLOT
 ENDIF
 SPLAY_GET% VM_SLOT_GVARTBL[SLOT],N$ OUT FOUND,IDX
 LOCAL=#FALSE
 IF FOUND THEN
  IDX=VAR_IDX[IDX]
 ENDIF
END
DEF VMINSTR_PUSHVAREXPRREF
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_STR THEN
  UNDEFINED_VARIABLE "Type mismatch(VAR())"
  RETURN
 ENDIF
 VAR SLOT,LOCAL,IDX,FOUND
 VM_CHKVAR V OUT SLOT,LOCAL,IDX,FOUND
 IF!FOUND THEN
  UNDEFINED_VARIABLE "Type mismatch(VAR())"
  RETURN
 ENDIF
 IF LOCAL THEN
  VM_PUSHTYP IDX,#VMT_LVARREF
 ELSE
  IF SLOT==VM_CURSLOT THEN
   VM_PUSHTYP IDX,#VMT_VARREF
  ELSE
   VM_PUSHTYP SLOT,#VMT_VARREFSLOT
   VM_PUSHTYP IDX,#VMT_VARREFSLOT
  ENDIF
 ENDIF
END
DEF VMINSTR_RETURNFUNCEXPR
 ?"FIXME:NOTIMPL"
 STOP
 VAR T,V,OT,OV
 VM_POP OUT T,V
 VM_GETLVAR #VMSTK_OUTCNT OUT T,V

 VMINSTR_RETURUFUNC
END

COMMON DEF SBSB_CALLIDX * OUT *
 IF DEFARGC()!=0 THEN
  MISSING_PARAMETER "CALLIDX"
  RETURN
 ENDIF
 IF DEFOUTC()!=1 THEN
  MISSING_OUT_PARAMETER "CALLIDX"
  RETURN
 ENDIF
 DEFOUT 0,VM_CALLIDX
END
DEF VM_CALLBACK F$
 IF INSTR(F$,"@")!=-1THEN
  VM_GOSUB F$
 ELSE
  SVM_CALL F$,0,0
 ENDIF
END
COMMON DEF VMINSTR_INITCALLSPRITE
 FILL SPFUNC_LIST,0
 CALL SPRITE
 VM_CALLIDX=-1
END
COMMON DEF VMINSTR_INITCALLTEXT
 FILL TFUNC_LIST,0
 CALL TEXT
 VM_CALLIDX=-1
END
DEF VMINSTR_CALLSPRITE
 VMINSTR_CALLXXX SPFUNC_LIST,SBTHUNK_SPFUNC$
END
DEF VMINSTR_CALLXXX LIST,FUNC$
 IF VM_CALLIDX>=4096 THEN
  RETURN
 ENDIF
 INC VM_CALLIDX
 LOOP
  IF!LIST[VM_CALLIDX] THEN
   INC VM_CALLIDX
  ELSE
   BREAK
  ENDIF
  IF VM_CALLIDX>=4096 THEN
   RETURN
  ENDIF
 ENDLOOP
 DEC VM_PC
 IF LIST[VM_CALLIDX]THEN
  VM_CALLBACK FUNC$[VM_CALLIDX]
 ENDIF
END
DEF VMINSTR_CALLTEXT
 VMINSTR_CALLXXX TFUNC_LIST,SBTHUNK_TFUNC$
END
DEF VM_BACKTRACE INCLUDE_SUB OUT SLOT,LINE,INFO$
 IF !VM_COMPILED THEN
  SLOT=ARRAY%(0)
  LINE=ARRAY%(0)
  INFO$=ARRAY$(0)
  RETURN
 ENDIF
 CALL VM_TYPE$+"VM_BACKTRACE",INCLUDE_SUB OUT SLOT,LINE,INFO$
END
DEF SVM_BACKTRACE INCLUDE_SUB OUT SLOT,LINE,INFO$
 VAR I,BP=VM_BP
 SLOT=ARRAY%(0)
 LINE=ARRAY%(0)
 INFO$=ARRAY$(0)
 VAR FUNC=VM_CURFUNC
 VAR A,S,L
 IF !INCLUDE_SUB THEN
  FUNC=0
  IF VM_CURFUNC THEN
   VMDBG_GET OUT S,L,
   PUSH LINE,L
   PUSH SLOT,S
   PUSH INFO$,FUNC_NAME$[VM_CURFUNC]
  ENDIF
 ENDIF
 FOR I=VM_SP-1 TO 0 STEP -1
  IF INCLUDE_SUB&&VM_STK_TYP[I]==#VMT_SUBROUTINE THEN
   A=VM_STK%[I]
   DEC I
   S=VM_STK%[I]
   VMDBG_GET_LINE S,A OUT L,
   PUSH LINE,L
   PUSH SLOT,S
   PUSH INFO$,""
  ELSEIF I==BP&&I THEN
   IF !INCLUDE_SUB THEN
    FUNC=VM_STK%[I+#VMSTK_FUNC]
   ENDIF
   A=VM_STK%[I+#VMSTK_PC]
   S=VM_STK%[I+#VMSTK_SLOT]
   BP=VM_STK%[I+#VMSTK_BP]
   VMDBG_GET_LINE S,A OUT L,
   PUSH LINE,L
   PUSH SLOT,S
   PUSH INFO$,FUNC_NAME$[FUNC]
   IF INCLUDE_SUB THEN
    FUNC=VM_STK%[I+#VMSTK_FUNC]
   ENDIF
  ENDIF
 NEXT
 IF !VM_BP THEN
  VMDBG_GET_LINE VM_CURSLOT,VM_PC OUT L,
  PUSH LINE,L
  PUSH SLOT,VM_CURSLOT
  PUSH INFO$,""
 ENDIF
END
DEF VM_IS_STOPPED()
 RETURN VM_STOP
END
DEF VM_IS_CONTINUABLE()
 RETURN VM_CONTINUABLE
END
DEF VM_CONT
 IF !VM_STOP||!VM_CONTINUABLE THEN
  VM_RAISE_ERR2 "Can't continue","CONTできません"
  RETURN
 ENDIF
 VM_RUN
END
DEF VMDBG_BINSEARCH(ARY,KEY)
 VAR MIN=0
 VAR L=LEN(ARY)
 VAR MAX=L
 LOOP
  IF MAX<MIN THEN
   RETURN MAX
  ENDIF
  VAR MID=MIN+(MAX-MIN) DIV 2
  IF L<=MID THEN
   RETURN L-1
  ENDIF
  IF MID<0 THEN
   RETURN 0
  ENDIF
  IF ARY[MID]>KEY THEN
   MAX=MID-1
  ELSEIF ARY[MID]<KEY THEN
   MIN=MID+1
  ELSE
   RETURN MID
  ENDIF
 ENDLOOP
END
DEF VMDBG_LINEARSEARCH(ARY,KEY)
 VAR I,L=LAST(ARY)
 FOR I=0TO L
  IF ARY[I]==KEY THEN RETURN MAX(0,I)
 NEXT
 RETURN -1
END
DEF VMDBG_GET_VAR_LIST FUNC,BP OUT VNAME$[],VIDX[]
 IF FUNC THEN
  CALL VM_TYPE$+"VMDBG_GET_VAR_LIST",FUNC,BP OUT VNAME$,VIDX
 ELSE
  VNAME$=ARRAY$(0)
  VIDX=ARRAY%(0)
  VMDBG_ENUM_VAR_LIST VNAME$,VIDX,GET_SPLAY_ROOT(VM_SLOT_GVARTBL[VM_CURSLOT])
 ENDIF
END
DEF VMDBG_GET_FUNC_LIST SLOT OUT FUNC$[]
 FUNC$=ARRAY$(0)
 VMDBG_ENUM_FUNC_LIST FUNC$,GET_SPLAY_ROOT(VM_SLOT_FUNCTBL[SLOT])
END
DEF VMDBG_GET_LABEL_LIST SLOT OUT FUNC$[]
 FUNC$=ARRAY$(0)
 VMDBG_ENUM_LABEL_LIST FUNC$,GET_SPLAY_ROOT(VM_SLOT_GLBLTBL[SLOT])
END
DEF VMDBG_GET_LABEL_ADDR SLOT,FUNC$ OUT ADDR
 IF SLOT!=VM_CURSLOT THEN
  FUNC$=STR$(SLOT)+":"+FUNC$
 ENDIF
 VAR FOUND,FUNC
 VM_GET_LABEL FUNC$,2 OUT ,FUNC,FOUND
 IF!FOUND THEN
  ADDR=-1
 ELSE
  CALL VM_TYPE$+"VMDBG_GET_LABEL_ADDR",FUNC OUT ADDR
 ENDIF
END
DEF VMDBG_GET_FUNC_ADDR SLOT,FUNC$ OUT ADDR
 IF SLOT!=VM_CURSLOT THEN
  FUNC$=STR$(SLOT)+":"+FUNC$
 ENDIF
 VAR FOUND,FUNC
 VM_GETFUNC FUNC$,-1,-1 OUT FOUND,FUNC
 IF!FOUND THEN
  ADDR=-1
 ELSE
  CALL VM_TYPE$+"VMDBG_GET_FUNC_ADDR",FUNC OUT ADDR
 ENDIF
END
DEF SVMDBG_GET_FUNC_ADDR FUNC OUT ADDR
 ADDR=FUNC_ADDR[FUNC]
END
DEF SVMDBG_GET_LABEL_ADDR FUNC OUT ADDR
 ADDR=FUNC_ADDR[FUNC]
END
DEF VMDBG_ENUM_FUNC_LIST FUNC$[],NODE
 IF !NODE THEN RETURN
 VMDBG_ENUM_FUNC_LIST FUNC$,GET_SPLAYN_LEFT(NODE)
 VAR V=GET_SPLAYN_VAL%(NODE)
 PUSH FUNC$,GET_SPLAYN_KEY$(NODE)
 VMDBG_ENUM_FUNC_LIST FUNC$,GET_SPLAYN_RIGHT(NODE)
END
DEF VMDBG_ENUM_LABEL_LIST FUNC$[],NODE
 IF !NODE THEN RETURN
 VMDBG_ENUM_LABEL_LIST FUNC$,GET_SPLAYN_LEFT(NODE)
 VAR V=GET_SPLAYN_VAL%(NODE)
 PUSH FUNC$,GET_SPLAYN_KEY$(NODE)
 VMDBG_ENUM_LABEL_LIST FUNC$,GET_SPLAYN_RIGHT(NODE)
END
DEF SVMDBG_GET_VAR_LIST FUNC,BP OUT VNAME$[],VIDX[]
 VNAME$=ARRAY$(0)
 VIDX=ARRAY%(0)
 VMDBG_ENUM_VAR_LIST VNAME$,VIDX,GET_SPLAY_ROOT(FUNC_VARTBL[FUNC])
END
DEF VMDBG_ENUM_VAR_LIST VNAME$,VIDX,NODE
 IF !NODE THEN RETURN
 VMDBG_ENUM_VAR_LIST VNAME$,VIDX,GET_SPLAYN_LEFT(NODE)
 VAR V=GET_SPLAYN_VAL%(NODE)
 VAR IDX=VAR_IDX[V]
 PUSH VNAME$,GET_SPLAYN_KEY$(NODE)
 PUSH VIDX,IDX
 VMDBG_ENUM_VAR_LIST VNAME$,VIDX,GET_SPLAYN_RIGHT(NODE)
END
DEF VMDBG_ENUM_CONST_LIST VNAME$,VIDX,NODE
 IF !NODE THEN RETURN
 VMDBG_ENUM_CONST_LIST VNAME$,VIDX,GET_SPLAYN_LEFT(NODE)
 VAR V=GET_SPLAYN_VAL%(NODE)
 PUSH VNAME$,GET_SPLAYN_KEY$(NODE)
 PUSH VIDX,V
 VMDBG_ENUM_CONST_LIST VNAME$,VIDX,GET_SPLAYN_RIGHT(NODE)
END
DEF VMDBG_GET_SLOT_VAR_LIST SLOT OUT VNAME$[],VIDX[]
 VNAME$=ARRAY$(0)
 VIDX=ARRAY%(0)
 IF VM_SLOT_GVARTBL[SLOT] THEN
  VMDBG_ENUM_VAR_LIST VNAME$,VIDX,GET_SPLAY_ROOT(VM_SLOT_GVARTBL[SLOT])
 ENDIF
END
DEF VMDBG_GET_SLOT_CONST_LIST SLOT OUT VNAME$[],VIDX[]
 VNAME$=ARRAY$(0)
 VIDX=ARRAY%(0)
 IF VM_SLOT_CONSTTBL[SLOT] THEN
  VMDBG_ENUM_CONST_LIST VNAME$,VIDX,GET_SPLAY_ROOT(VM_SLOT_CONSTTBL[SLOT])
 ENDIF
END
DEF VMDBG_GET_VAR FUNC,BP,VIDX OUT V
 IF FUNC THEN
  CALL VM_TYPE$+"VMDBG_GET_VAR",FUNC,BP,VIDX OUT V
 ELSE
  VMDBG_GET_SLOT_VAR VM_CURSLOT,VIDX OUT V
 ENDIF
END
DEF VMDBG_SET_SLOT_VAR SLOT,VIDX,V
 RVMDBG_SET VIDX,VM_GET_ARRAY(VM_SLOT_GVAR_TYP[SLOT]),VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT]),VM_GET_ARRAY(VM_SLOT_GVAR#[SLOT]),VM_GET_ARRAY(VM_SLOT_GVAR$[SLOT]),V
END
DEF VMDBG_SET_VAR FUNC,BP,VIDX,V
 IF FUNC THEN
  CALL VM_TYPE$+"VMDBG_SET_VAR",FUNC,BP,VIDX,V
 ELSE
  VMDBG_SET_SLOT_VAR VM_CURSLOT,VIDX,V
 ENDIF
END
DEF SVMDBG_GET_VAR FUNC,BP,VIDX OUT V
 IF VIDX<0&&FUNC_INCNT[FUNC]==-1 THEN
  'VAARGS
  VAR IC=VM_STK%[BP+#VMSTK_INCNT]
  DEC VIDX,IC
 ENDIF
 VAR T=VM_STK_TYP[BP+VIDX]
 V=VM_GETV(T,VM_GETSTKARY(T)[BP+VIDX])
END
DEF VMDBG_GET_SLOT_VAR SLOT,VIDX OUT V
 CASE VM_GET_ARRAY(VM_SLOT_GVAR_TYP[SLOT])[VIDX]
 WHEN #VMT_INT
  V=VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT])[VIDX]
 WHEN #VMT_REAL
  V=VM_GET_ARRAY(VM_SLOT_GVAR#[SLOT])[VIDX]
 WHEN #VMT_STR
  V=VM_GET_ARRAY(VM_SLOT_GVAR$[SLOT])[VIDX]
 WHEN #VMT_INTARRAY
 WHEN #VMT_REALARRAY
 WHEN #VMT_STRARRAY
  V=VM_GET_ARRAY(VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT])[VIDX])
 WHEN #VMT_DEFAULT
 ENDCASE
END
DEF VMDBG_GET_SLOT_CONST SLOT,VIDX OUT V
 CASE CMP_CONST_TYP[VIDX]
 WHEN #VMT_INT
  V=CMP_CONST%[VIDX]
 WHEN #VMT_REAL
  V=CMP_CONST#[VIDX]
 WHEN #VMT_STR
  V=CMP_CONST$[VIDX]
 ENDCASE
END
DEF VMDBG_FIND_FRAME FRAME_NO OUT FUNC,BP,SLOT,PC
 CALL VM_TYPE$+"VMDBG_FIND_FRAME",FRAME_NO OUT FUNC,BP,SLOT,PC
END
DEF SVMDBG_FIND_FRAME FRAME_NO OUT FUNC,BP,SLOT,PC
 VAR I
 FUNC=VM_CURFUNC
 BP=VM_BP
 PC=VM_PC
 SLOT=VM_CURSLOT
 VAR FRAME_NO_CUR
 FOR I=VM_SP-1 TO 0 STEP -1
  IF FRAME_NO_CUR==FRAME_NO THEN RETURN
  IF I==BP&&I THEN
   FUNC=VM_STK%[I+#VMSTK_FUNC]
   BP=VM_STK%[I+#VMSTK_BP]
   SLOT=VM_STK%[I+#VMSTK_SLOT]
   PC=VM_STK%[I+#VMSTK_PC]
   INC FRAME_NO_CUR
  ENDIF
 NEXT
END
DEF SVMDBG_SET_BP SLOT,PC
 IF PC==-1 THEN RETURN
 VAR OPS=VM_GET_ARRAY(VM_SLOT_OPS[SLOT])
 OPS[PC]=&H80000000 OR OPS[PC]
END
DEF VMDBG_SET_BP SLOT,PC
 CALL VM_TYPE$+"VMDBG_SET_BP",SLOT,PC
END
DEF SVMDBG_TOGGLE_BP SLOT,PC
 IF PC==-1 THEN RETURN
 VAR OPS=VM_GET_ARRAY(VM_SLOT_OPS[SLOT])
 OPS[PC]=&H80000000 XOR OPS[PC]
END
DEF VMDBG_TOGGLE_BP SLOT,PC
 CALL VM_TYPE$+"VMDBG_TOGGLE_BP",SLOT,PC
END
DEF SVMDBG_TOGGLE_BP_LIST SLOT,PC_LIST
 VAR I
 FOR I=0TO LAST(PC_LIST)
  VAR OPS=VM_GET_ARRAY(VM_SLOT_OPS[SLOT])
  OPS[PC_LIST[I]]=&H80000000 XOR OPS[PC_LIST[I]]
 NEXT
END
DEF VMDBG_TOGGLE_BP_LIST SLOT,PC_LIST
 CALL VM_TYPE$+"VMDBG_TOGGLE_BP_LIST",SLOT,PC_LIST
END
DEF SVMDBG_HAS_BP(SLOT,PC)
 IF PC==-1 THEN RETURN #FALSE
 VAR OPS=VM_GET_ARRAY(VM_SLOT_OPS[SLOT])
 RETURN &H80000000 AND OPS[PC]
END
DEF VMDBG_HAS_BP(SLOT,PC)
 RETURN CALL(VM_TYPE$+"VMDBG_HAS_BP",SLOT,PC)
END
DEF VMDBG_GENERATE_LINE_PC_INDEX SLOT
 VAR L=VM_GET_ARRAY(VMDBG_SLOT_LINE[SLOT])
 IF VMDBG_SLOT_LINE_PC_INDEX[SLOT] THEN
  RETURN
 ENDIF
 'BUGBUG
 IF LEN(L)==0 THEN
  VMDBG_SLOT_LINE_PC_INDEX[SLOT]=VM_ALLOC_ARRAY(ARRAY%(0))
  VMDBG_SLOT_LINE_PC_INDEX2[SLOT]=VM_ALLOC_ARRAY(ARRAY%(0))
  RETURN
 ENDIF
 VAR LINE_ARY=COPY(L)
 VAR I,LAST=LAST(L)
 VAR MAX_LINE=MAX(L)+1
 VAR LINE_INDEX=ARRAY%(MAX_LINE)
 VAR SEQ_ARY=ARRAY%(LEN(L))
 FOR I=0TO LAST
  SEQ_ARY[I]=I
 NEXT
 SORT LINE_ARY,SEQ_ARY
 VAR OLD_LINE=-1
 VAR OLD_LINE_I
 FILL LINE_INDEX,-1
 FOR I=0TO LAST+1
  IF I>LAST||OLD_LINE!=LINE_ARY[I]THEN
   IF OLD_LINE!=-1 THEN
    LINE_INDEX[OLD_LINE]=OLD_LINE_I
   ENDIF
   IF I<=LAST THEN
    OLD_LINE=LINE_ARY[I]
    OLD_LINE_I=I
   ENDIF
  ENDIF
 NEXT
 VMDBG_SLOT_LINE_PC_INDEX[SLOT]=VM_ALLOC_ARRAY(LINE_INDEX)
 VMDBG_SLOT_LINE_PC_INDEX2[SLOT]=VM_ALLOC_ARRAY(SEQ_ARY)
END
DEF VMDBG_GET_PC SLOT,LINE OUT PC
 IF !VMDBG_SLOT_LINE[SLOT] THEN
  PC=-1
  RETURN
 ENDIF
 VMDBG_GENERATE_LINE_PC_INDEX SLOT
 VAR LINE_PC_INDEX=VM_GET_ARRAY(VMDBG_SLOT_LINE_PC_INDEX[SLOT])
 VAR LINE_PC_INDEX2=VM_GET_ARRAY(VMDBG_SLOT_LINE_PC_INDEX2[SLOT])
 IF LINE<=0||LEN(LINE_PC_INDEX)<=LINE THEN
  PC=-1
  RETURN
 ENDIF
 VAR INDEX=LINE_PC_INDEX[LINE]
 IF INDEX==-1 THEN
  PC=-1
  RETURN
 ENDIF
 VAR LPC=VM_GET_ARRAY(VMDBG_SLOT_LINE_PC[SLOT])
 'O(1)
 PC=LPC[LINE_PC_INDEX2[LINE_PC_INDEX[LINE]]]
 RETURN
 'LINEAR SEARCH O(n)
 VAR L=VM_GET_ARRAY(VMDBG_SLOT_LINE[SLOT])
 VAR LPOS=VM_GET_ARRAY(VMDBG_SLOT_LINE_POS[SLOT])
 VAR IND=VMDBG_LINEARSEARCH(L,LINE)
 IF IND<0||IND>=LEN(LPC)THEN
  PC=-1
  RETURN
 ENDIF
 PC=LPC[IND]
END
DEF VMDBG_GET_PC_LIST SLOT,LINE OUT PC_LIST
 PC_LIST=ARRAY%(0)
 IF !VMDBG_SLOT_LINE[SLOT] THEN
  RETURN
 ENDIF
 VMDBG_GENERATE_LINE_PC_INDEX SLOT
 VAR LINE_PC_INDEX=VM_GET_ARRAY(VMDBG_SLOT_LINE_PC_INDEX[SLOT])
 VAR LINE_PC_INDEX2=VM_GET_ARRAY(VMDBG_SLOT_LINE_PC_INDEX2[SLOT])
 IF LINE<=0||LEN(LINE_PC_INDEX)<=LINE THEN
  RETURN
 ENDIF
 VAR INDEX=LINE_PC_INDEX[LINE]
 IF INDEX==-1 THEN
  RETURN
 ENDIF
 VAR LPC=VM_GET_ARRAY(VMDBG_SLOT_LINE_PC[SLOT])
 VAR L=VM_GET_ARRAY(VMDBG_SLOT_LINE[SLOT])
 VAR PC=LINE_PC_INDEX[LINE]
 FOR PC=PC TO LAST(LINE_PC_INDEX2)
  IF LINE==L[LINE_PC_INDEX2[PC]] THEN
   PUSH PC_LIST,LPC[LINE_PC_INDEX2[PC]]
  ELSE
   BREAK
  ENDIF
 NEXT
 RETURN
 'LINEAR SEARCH O(n)
 VAR LPOS=VM_GET_ARRAY(VMDBG_SLOT_LINE_POS[SLOT])
 PC_LIST=ARRAY%(0)
 IF TYPEOF(L)==#T_DEFAULT THEN
  RETURN
 ENDIF
 VAR I,LAST=LAST(L)
 FOR I=0TO LAST
  IF L[I]==LINE THEN
   PUSH PC_LIST,LPC[I]
  ENDIF
 NEXT
END
DEF VMDBG_GET OUT SLOT,LINE,LINE_POS
 SLOT=VM_CURSLOT
 VMDBG_GET_LINE SLOT,VM_PC OUT LINE,LINE_POS
END
DEF VMDBG_GET_LINE SLOT,PC OUT LINE,LINE_POS
 VMDBG_GET_LINE2 SLOT,PC OUT LINE,LINE_POS,,
END
DEF VMDBG_GET_LINE2 SLOT,PC OUT LINE,LINE_POS,LINE_END,LINE_POS_END
 VAR L=VM_GET_ARRAY(VMDBG_SLOT_LINE[VM_CURSLOT])
 VAR LPC=VM_GET_ARRAY(VMDBG_SLOT_LINE_PC[VM_CURSLOT])
 VAR LPOS=VM_GET_ARRAY(VMDBG_SLOT_LINE_POS[VM_CURSLOT])
 VAR L_END=VM_GET_ARRAY(VMDBG_SLOT_LINE_END[VM_CURSLOT])
 VAR LPOS_END=VM_GET_ARRAY(VMDBG_SLOT_LINE_POS_END[VM_CURSLOT])
 IF TYPEOF(LPC)==#T_DEFAULT THEN
  LINE=0
  LINE_POS=0
  LINE_END=0
  LINE_POS_END=0
  RETURN
 ENDIF
 VAR IND=VMDBG_BINSEARCH(LPC,PC)
 IF IND<0||IND>=LEN(LPC)THEN
  LINE=0
  LINE_POS=0
  LINE_END=0
  LINE_POS_END=0
  RETURN
 ENDIF
 LINE=L[IND]
 LINE_POS=LPOS[IND]
 LINE_END=L_END[IND]
 LINE_POS_END=LPOS_END[IND]
END
DEF VMDBG_CALL_FUNC$()
 RETURN VM_TYPE$+"VMDBG_CALL_FUNC"
END
DEF VM_GET_CURLOC$()
 VAR SLOT=VM_CURSLOT,LINE,LINE_POS
 VMDBG_GET_LINE SLOT,VM_PREV_PC OUT LINE,LINE_POS
 RETURN STR$(SLOT)+":"+STR$(LINE)+":"+STR$(LINE_POS)
END
DEF SYNTAX_ERROR MSG$
 VM_RAISE_ERR2 "Syntax error","文法まちがい"
END
'A$[0]=1<=UNDEFINED VAR
DEF TYPE_MISMATCH MSG$
 VM_RAISE_ERR2 "Type mismatch","指定できない型の値です"
END
DEF SUBSCRIPT_OUT_OF_RANGE MSG$
 VM_RAISE_ERR2 "Subscript out of range","配列サイズを越えたアクセスです"
END
DEF OUT_OF_DATA MSG$
 VM_RAISE_ERR2 "Out of DATA","読み込めるDATA文がありません"
END
DEF UNDEFINED_LABEL MSG$
 VM_RAISE_ERR2 "Undefined label","未定義ラベル"
END
DEF ILLEGAL_LABEL_STRING MSG$
 VM_RAISE_ERR2 "Illegal label string","ラベル名として使えない文字列です"
END
DEF VM_RAISE_ERR1 E1$
 VM_LASTERR=#VM_LASTERR_EN
 VM_LASTERR=#TRUE
 VM_LASTERR_EN$=E1$
 VM_LASTERR_JA$=""
 VM_STOP=#TRUE
 VM_CONTINUABLE=#FALSE
 VM_RUNNING=#FALSE
END
DEF VM_RAISE_ERR2 E1$,E2$
 VM_LASTERR=#VM_LASTERR_ENJA
 'NOT DIRMODE
 VM_LASTERR_EN$=E1$+" in "+VM_GET_CURLOC$()
 VM_LASTERR_JA$=E2$
 VM_STOP=#TRUE
 VM_CONTINUABLE=#FALSE
 STOP
END
DEF VM_LASTERR$()
 CASE VM_LASTERR
 WHEN #VM_LASTERR_EN
  RETURN VM_LASTERR_EN$
 WHEN #VM_LASTERR_ENJA
  RETURN VM_LASTERR_EN$+CHR$(10)+VM_LASTERR_JA$
 ENDCASE
END
VAR VMDBG_BREAK
VAR VMDBG_TRACE
VAR VMDBG_TRACE_BREAK
VAR VMDBG_TRACE_BP
VAR VMDBG_TRACE_STEPIN
VAR VMDBG_ENABLE_BREAK_KEY
DEF VM_TRACE_RUN STEPIN
 VMDBG_TRACE=#TRUE
 VMDBG_TRACE_BP=VM_BP
 VMDBG_TRACE_STEPIN=STEPIN
 VMDBG_ENABLE_BREAK_KEY=#TRUE
 CALL VM_TYPE$+"VM_RUN"
 VMDBG_TRACE=#FALSE
END
DEF VM_DEBUG_RUN
 VMDBG_ENABLE_BREAK_KEY=#TRUE
 CALL VM_TYPE$+"VM_RUN"
END
CONST #VMMSK_INSTR=&HFFFF
CONST #VMMSK_MASK=&HFFFF0000
ENUM #VMMSK_BREAK_POINT=&H80000000
DEF VM_RUN
 CALL VM_TYPE$+"VM_RUN"
END
DEF SVM_RUN
 VM_RUNNING=#TRUE
 VMDBG_TRACE_BREAK=#FALSE
 VM_STOP=#FALSE
 VAR T,V
 VAR C
 VM_PREV_PC=VM_PC
 VAR TRACE=VMDBG_TRACE
 IF VMDBG_BREAK&&(VM_OPS[VM_PC]AND #VMMSK_MASK)==#VMMSK_BREAK_POINT THEN
  C=VM_OPS[VM_PC] AND #VMMSK_INSTR
  VMDBG_BREAK=#FALSE
  INC VM_PC
  GOTO@LOOP
 ENDIF
 VMDBG_BREAK=#FALSE
 LOOP
'  VAR K
'  VM_DUMPINSTR VM_PC OUT K
  IF VMDBG_ENABLE_BREAK_KEY THEN
   IF KEYBOARD(7) THEN
    VAR MODI
    KEYBOARD 7 OUT ,MODI
    IF MODI AND 4 THEN
     VM_STOP_MSG$="Break(Debugger)"
     VM_RAISE_ERR1 "Break on "+VM_GET_CURLOC$()+CHR$(10)+VM_STOP_MSG$
     VM_CONTINUABLE=#TRUE
     VM_STOP=#TRUE
     BREAK
    ENDIF
   ENDIF
  ENDIF
  VM_PREV_PC=VM_PC
  C=VM_OPS[VM_PC]
  INC VM_PC
  @LOOP
  ON C GOTO @VM_NOP,@VM_PUSHINT,@VM_PUSHDBL,@VM_PUSHSTR,@VM_BINOP,@VM_PRINT,@VM_TPRINT,@VM_ASSIGN,@VM_PUSHVARREF,@VM_PUSHLVARREF,@VM_REF,@VM_BR,@VM_BRTRUE,@VM_BRFALSE,@VM_FOR,@VM_FORINIT,@VM_BRAND,@VM_BROR,@VM_GOTO_PLACEHOLDER,@VM_GOSUB_PLACEHOLDER,@VM_GOSUB,@VM_GOTOEXPR,@VM_GOSUBEXPR,@VM_ONGOTO,@VM_ONGOSUB,@VM_RETURN,@VM_CALLFUNC,@VM_PUSHEMPTY,@VM_RETURNFUNC,@VM_PUSHEMPTYREF,@VM_PUSHARYREF,@VM_END,@VM_NEWARRAY,@VM_INITARRAY,@VM_READ,@VM_RESTORE,@VM_RESTORE_PLACEHOLDER,@VM_RESTOREEXPR,@VM_UNAOP,@VM_CALLSPRITE,@VM_CALLTEXT,@VM_INC,@VM_DEC,@VM_POP,@VM_WHEN,@VM_SWAP,@VM_INPUT,@VM_LINPUT,@VM_DEFOUT,@VM_EXEC1,@VM_EXEC2,@VM_STOP1,@VM_STOP2,@VM_PUSHVAREXPR,@VM_PUSHVAREXPRREF,@VM_INITCALLSPRITE,@VM_INITCALLTEXT
  @VM_NOP
  GOTO @VM_INVAL
  CASE C
  WHEN #VM_PUSHINT:@VM_PUSHINT
   VM_PUSHINT VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_PUSHDBL:@VM_PUSHDBL
   VM_PUSHDBL VM_IMM#[VM_OPS[VM_PC]]
   INC VM_PC
  WHEN #VM_PUSHSTR:@VM_PUSHSTR
   VM_PUSHSTR (VM_IMM$[VM_OPS[VM_PC]])+""
   INC VM_PC
  WHEN #VM_BINOP:@VM_BINOP
   T=VM_OPS[VM_PC]
   INC VM_PC
   VMINSTR_BINOP T
  WHEN #VM_PRINT:@VM_PRINT
   INC VM_PC
   VM_PRINT #FALSE,VM_OPS[VM_PC-1]
  WHEN #VM_TPRINT:@VM_TPRINT
   INC VM_PC
   VM_PRINT #TRUE,VM_OPS[VM_PC-1]
  WHEN #VM_PUSHVARREF:@VM_PUSHVARREF
   VMINSTR_PUSHVARREF VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_PUSHLVARREF:@VM_PUSHLVARREF
   VMINSTR_PUSHLVARREF VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_REF:@VM_REF
   VMINSTR_REF
  WHEN #VM_ASSIGN:@VM_ASSIGN
   VMINSTR_ASSIGN
  WHEN #VM_BR:@VM_BR
   VM_PC=VM_OPS[VM_PC]-1
   INC VM_PC
  WHEN #VM_BRFALSE:@VM_BRFALSE
   VM_POP OUT T,V
   CASE T
   WHEN #VMT_INT
   WHEN #VMT_REAL
    IF !V THEN VM_PC=VM_OPS[VM_PC]-1
   OTHERWISE
    TYPEMISMATCH
   ENDCASE
   INC VM_PC
  WHEN #VM_BRTRUE:@VM_BRTRUE
   VM_POP OUT T,V
   CASE T
   WHEN #VMT_INT
   WHEN #VMT_REAL
    IF V THEN VM_PC=VM_OPS[VM_PC]-1
   OTHERWISE
    TYPEMISMATCH
   ENDCASE
   INC VM_PC
  WHEN #VM_FOR:@VM_FOR
   VMINSTR_FOR #FALSE
  WHEN #VM_FORINIT:@VM_FORINIT
   VMINSTR_FOR #TRUE
  WHEN #VM_BROR:@VM_BROR
   INC VM_PC
   VMINSTR_BROR VM_OPS[VM_PC-1]
  WHEN #VM_BRAND:@VM_BRAND
   INC VM_PC
   VMINSTR_BRAND VM_OPS[VM_PC-1]
  WHEN #VM_GOTO_PLACEHOLDER:@VM_GOTO_PLACEHOLDER
   VMINSTR_GOTO_PLACEHOLDER
  WHEN #VM_GOSUB_PLACEHOLDER:@VM_GOSUB_PLACEHOLDER
   VMINSTR_GOSUB_PLACEHOLDER
  WHEN #VM_GOSUB:@VM_GOSUB
   INC VM_PC
   VMINSTR_GOSUB VM_CURSLOT,VM_OPS[VM_PC-1]
  WHEN #VM_RETURN:@VM_RETURN
   VMINSTR_RETURN
  WHEN #VM_CALLFUNC:@VM_CALLFUNC
   VMINSTR_CALLFUNC
  WHEN #VM_PUSHEMPTY:@VM_PUSHEMPTY
   INC VM_PC
   VMINSTR_PUSHEMPTY VM_OPS[VM_PC-1]
  WHEN #VM_RETURNFUNC:@VM_RETURNFUNC
   VMINSTR_RETURNFUNC
  WHEN #VM_PUSHEMPTYREF:@VM_PUSHEMPTYREF
   VMINSTR_PUSHEMPTYREF
  WHEN #VM_END:@VM_END
   IF VM_SLOT_EXEC_SLOT[VM_CURSLOT]!=-1THEN
    VAR OS=VM_CURSLOT
    VM_PC=VM_SLOT_EXEC_ADDR[OS]
    VM_CURSLOT=VM_SLOT_EXEC_SLOT[OS]
    VM_CURFUNC=VM_SLOT_EXEC_FUNC[OS]
    VM_SWITCH_SLOT VM_CURSLOT
    VM_SLOT_EXEC_FUNC[OS]=-1
    VM_SLOT_EXEC_ADDR[OS]=-1
    VM_SLOT_EXEC_SLOT[OS]=-1
   ELSE
    BREAK
   ENDIF
  WHEN #VM_NEWARRAY:@VM_NEWARRAY
   VMINSTR_NEWARRAY
  WHEN #VM_PUSHARYREF:@VM_PUSHARYREF
   VMINSTR_PUSHARYREF
  WHEN #VM_INITARRAY:@VM_INITARRAY
   VMINSTR_INITARRAY
  WHEN #VM_READ:@VM_READ
   VMINSTR_READ
  WHEN #VM_RESTORE:@VM_RESTORE
   VMINSTR_RESTORE
  WHEN #VM_RESTORE_PLACEHOLDER:@VM_RESTORE_PLACEHOLDER
   VMINSTR_RESTORE_PLACEHOLDER
  WHEN #VM_UNAOP:@VM_UNAOP
   INC VM_PC
   VMINSTR_UNAOP VM_OPS[VM_PC-1]
  WHEN #VM_CALLSPRITE:@VM_CALLSPRITE
   VMINSTR_CALLSPRITE
  WHEN #VM_CALLTEXT:@VM_CALLTEXT
   VMINSTR_CALLTEXT
  WHEN #VM_RESTOREEXPR:@VM_RESTOREEXPR
   VMINSTR_RESTOREEXPR
  WHEN #VM_GOTOEXPR:@VM_GOTOEXPR
   VMINSTR_GOTOEXPR
  WHEN #VM_GOSUBEXPR:@VM_GOSUBEXPR
   VMINSTR_GOSUBEXPR
  WHEN #VM_INC:@VM_INC
   VMINSTR_INC #FALSE
  WHEN #VM_DEC:@VM_DEC
   VMINSTR_INC #TRUE
  WHEN #VM_POP:@VM_POP
   DEC VM_SP,VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_ONGOTO:@VM_ONGOTO
   VMINSTR_ONGOTO #FALSE
  WHEN #VM_ONGOSUB:@VM_ONGOSUB
   VMINSTR_ONGOTO #TRUE
  WHEN #VM_WHEN:@VM_WHEN
   VMINSTR_WHEN
  WHEN #VM_SWAP:@VM_SWAP
   VMINSTR_SWAP
  WHEN #VM_INPUT:@VM_INPUT
   VMINSTR_INPUT
  WHEN #VM_LINPUT:@VM_LINPUT
   VMINSTR_LINPUT
  WHEN #VM_DEFOUT:@VM_DEFOUT
   VMINSTR_DEFOUT
  WHEN #VM_EXEC1:@VM_EXEC1
   VMINSTR_EXEC1
  WHEN #VM_EXEC2:@VM_EXEC2
   VMINSTR_EXEC2
  WHEN #VM_STOP1:@VM_STOP1
   VMINSTR_STOP1
   BREAK
  WHEN #VM_STOP2:@VM_STOP2
   VMINSTR_STOP2
   BREAK
  WHEN #VM_PUSHVAREXPR:@VM_PUSHVAREXPR
   VMINSTR_PUSHVAREXPR
  WHEN #VM_PUSHVAREXPRREF:@VM_PUSHVAREXPRREF
   VMINSTR_PUSHVAREXPRREF
  WHEN #VM_INITCALLSPRITE:@VM_INITCALLSPRITE
   VMINSTR_INITCALLSPRITE
  WHEN #VM_INITCALLTEXT:@VM_INITCALLTEXT
   VMINSTR_INITCALLTEXT
  WHEN #VM_
   VMINSTR_
  OTHERWISE:@VM_INVAL
   VAR MSK=C AND #VMMSK_MASK
   VAR OP=C AND #VMMSK_INSTR
   IF MSK==#VMMSK_BREAK_POINT THEN
    DEC VM_PC
    'BREAK!
    VMDBG_BREAK=#TRUE
    RETURN
   ENDIF
   VM_ERROR
  ENDCASE
  IF TRACE THEN
   IF VMDBG_TRACE_STEPIN||VM_BP<=VMDBG_TRACE_BP THEN
    VMDBG_TRACE_BREAK=#TRUE
    RETURN
   ENDIF
  ENDIF
 ENDLOOP
 VM_RUNNING=#FALSE
END
DEF VM_IS_COMPILED()
 RETURN VM_COMPILED
END
DEF VM_IS_RUNNING()
 IF LEN(VM_OPS)<=VM_PC THEN VM_RUNNING=#FALSE
 RETURN VM_RUNNING
END

DEF VMDBG_IS_STOPPED_AT_BP()
 RETURN VMDBG_BREAK
END

DEF VM_DUMP_STR$(A$)
 RETURN CHR$(34)+A$+CHR$(34)
END
DEF VM_DUMP
 VAR VM_PC=0
 LOOP
  IF LEN(VM_OPS)<=VM_PC THEN BREAK
  VM_DUMPINSTR VM_PC OUT VM_PC
 ENDLOOP
END
DEF VM_DUMP_CURRENT
 VAR O
 VM_DUMPINSTR VM_PC OUT O
END
DEF VM_DUMP_ADDR$(ADDR)
 RETURN HEX$(ADDR,4)
END
DEF VM_DUMPINSTR VM_PC OUT VM_PC2
 ?HEX$(VM_PC,4);" ";
 VAR C=VM_OPS[VM_PC] AND &HFFFF
 VAR MSK=VM_OPS[VM_PC] AND &HFFFF0000
 IF MSK==&H80000000 THEN
  ?"BREAKPOINT ";
 ENDIF
 INC VM_PC
 ON C GOTO @VM_NOP,@VM_PUSHINT,@VM_PUSHDBL,@VM_PUSHSTR,@VM_BINOP,@VM_PRINT,@VM_TPRINT,@VM_ASSIGN,@VM_PUSHVARREF,@VM_PUSHLVARREF,@VM_REF,@VM_BR,@VM_BRTRUE,@VM_BRFALSE,@VM_FOR,@VM_FORINIT,@VM_BRAND,@VM_BROR,@VM_GOTO_PLACEHOLDER,@VM_GOSUB_PLACEHOLDER,@VM_GOSUB,@VM_GOTOEXPR,@VM_GOSUBEXPR,@VM_ONGOTO,@VM_ONGOSUB,@VM_RETURN,@VM_CALLFUNC,@VM_PUSHEMPTY,@VM_RETURNFUNC,@VM_PUSHEMPTYREF,@VM_PUSHARYREF,@VM_END,@VM_NEWARRAY,@VM_INITARRAY,@VM_READ,@VM_RESTORE,@VM_RESTORE_PLACEHOLDER,@VM_RESTOREEXPR,@VM_UNAOP,@VM_CALLSPRITE,@VM_CALLTEXT,@VM_INC,@VM_DEC,@VM_POP,@VM_WHEN,@VM_SWAP,@VM_INPUT,@VM_LINPUT,@VM_DEFOUT,@VM_EXEC1,@VM_EXEC2,@VM_STOP1,@VM_STOP2,@VM_PUSHVAREXPR,@VM_PUSHVAREXPRREF,@VM_INITCALLSPRITE,@VM_INITCALLTEXT
 @VM_NOP
 GOTO @VM_INVAL
 CASE C
 WHEN #VM_PUSHINT:@VM_PUSHINT
  ?"PUSHINT",VM_OPS[VM_PC]
  INC VM_PC
 WHEN #VM_PUSHDBL:@VM_PUSHDBL
  ?"PUSHDBL",VM_IMM#[VM_OPS[VM_PC]]
  INC VM_PC
 WHEN #VM_PUSHSTR:@VM_PUSHSTR
  ?"PUSHSTR",VM_DUMP_STR$(VM_IMM$[VM_OPS[VM_PC]])
  INC VM_PC
 WHEN #VM_BINOP:@VM_BINOP
  VAR T=VM_OPS[VM_PC]
  INC VM_PC
  ?"BINOP",TKN_STR$(T)
 WHEN #VM_PRINT:@VM_PRINT
  INC VM_PC
  ?"PRINT",VM_OPS[VM_PC-1]
 WHEN #VM_TPRINT:@VM_TPRINT
  INC VM_PC
  ?"TPRINT",VM_OPS[VM_PC-1]
 WHEN #VM_PUSHVARREF:@VM_PUSHVARREF
  ?"PUSHVARREF",VM_OPS[VM_PC]
  INC VM_PC
 WHEN #VM_PUSHLVARREF:@VM_PUSHLVARREF
  ?"PUSHLVARREF",VM_OPS[VM_PC]
  INC VM_PC
 WHEN #VM_REF:@VM_REF
  ?"REF"
 WHEN #VM_ASSIGN:@VM_ASSIGN
  ?"ASSIGN"
 WHEN #VM_BR:@VM_BR
  ?"BR",VM_DUMP_ADDR$(VM_OPS[VM_PC])
  INC VM_PC
 WHEN #VM_BRFALSE:@VM_BRFALSE
  ?"BRFALSE",VM_DUMP_ADDR$(VM_OPS[VM_PC])
  INC VM_PC
 WHEN #VM_BRTRUE:@VM_BRTRUE
  ?"BRTRUE",VM_DUMP_ADDR$(VM_OPS[VM_PC])
  INC VM_PC
 WHEN #VM_FOR:@VM_FOR
  ?"FOR",VM_DUMP_ADDR$(VM_OPS[VM_PC])
  INC VM_PC
 WHEN #VM_FORINIT:@VM_FORINIT
  ?"FORINIT",VM_DUMP_ADDR$(VM_OPS[VM_PC])
  INC VM_PC
 WHEN #VM_BROR:@VM_BROR
  ?"BROR",VM_DUMP_ADDR$(VM_OPS[VM_PC])
  INC VM_PC
 WHEN #VM_BRAND:@VM_BRAND
  ?"BRAND",VM_DUMP_ADDR$(VM_OPS[VM_PC])
  INC VM_PC
 WHEN #VM_GOTO_PLACEHOLDER:@VM_GOTO_PLACEHOLDER
  ?"GOTO",VM_IMM$[VM_OPS[VM_PC]]
  INC VM_PC
 WHEN #VM_GOSUB_PLACEHOLDER:@VM_GOSUB_PLACEHOLDER
  ?"GOSUB",VM_IMM$[VM_OPS[VM_PC]]
  INC VM_PC
 WHEN #VM_GOSUB:@VM_GOSUB
  ?"GOSUB",VM_DUMP_ADDR$(VM_OPS[VM_PC])
  INC VM_PC
 WHEN #VM_RETURN:@VM_RETURN
  ?"RETURN"
 WHEN #VM_CALLFUNC:@VM_CALLFUNC
  ?"CALLFUNC",VM_IMM$[VM_OPS[VM_PC]],VM_OPS[VM_PC+1],VM_OPS[VM_PC+2]
  INC VM_PC,3
 WHEN #VM_PUSHEMPTY:@VM_PUSHEMPTY
  INC VM_PC
  ?"PUSHEMPTY",VM_OPS[VM_PC-1]
 WHEN #VM_RETURNFUNC:@VM_RETURNFUNC
  ?"RETURNFUNC"
 WHEN #VM_PUSHEMPTYREF:@VM_PUSHEMPTYREF
  ?"PUSHEMPTYREF"
 WHEN #VM_END:@VM_END
  ?"END"
 WHEN #VM_NEWARRAY:@VM_NEWARRAY
  ?"NEWARRAY",VM_OPS[VM_PC],VM_OPS[VM_PC+1]
  INC VM_PC,2
 WHEN #VM_PUSHARYREF:@VM_PUSHARYREF
  ?"PUSHARYREF",VM_OPS[VM_PC]
  INC VM_PC,1
 WHEN #VM_INITARRAY:@VM_INITARRAY
  ?"INITARRAY",VM_OPS[VM_PC]
  INC VM_PC,1
 WHEN #VM_READ:@VM_READ
  ?"READ"
 WHEN #VM_RESTORE:@VM_RESTORE
  ?"RESTORE",VM_OPS[VM_PC]
  INC VM_PC,1
 WHEN #VM_RESTORE_PLACEHOLDER:@VM_RESTORE_PLACEHOLDER
  ?"RESTORE",VM_IMM$[VM_OPS[VM_PC]]
  INC VM_PC,1
 WHEN #VM_UNAOP:@VM_UNAOP
  ?"UNAOP",VM_OPS[VM_PC]
  INC VM_PC,1
 WHEN #VM_CALLSPRITE:@VM_CALLSPRITE
  ?"CALLSPRITE"
 WHEN #VM_CALLTEXT:@VM_CALLTEXT
  ?"CALLTEXT"
 WHEN #VM_RESTOREEXPR:@VM_RESTOREEXPR
  ?"RESTOREEXPR"
 WHEN #VM_GOTOEXPR:@VM_GOTOEXPR
  ?"GOTOEXPR"
 WHEN #VM_GOSUBEXPR:@VM_GOSUBEXPR
  ?"GOSUBEXPR"
 WHEN #VM_INC:@VM_INC
  ?"INC"
 WHEN #VM_DEC:@VM_DEC
  ?"DEC"
 WHEN #VM_POP:@VM_POP
  ?"POP",VM_OPS[VM_PC]
  INC VM_PC
 WHEN #VM_ONGOTO:@VM_ONGOTO
  VAR LEN=VM_OPS[VM_PC]
  INC VM_PC
  ?"ONGOTO",LEN
  INC VM_PC,LEN
 WHEN #VM_ONGOSUB:@VM_ONGOSUB
  LEN=VM_OPS[VM_PC]
  INC VM_PC
  ?"ONGOSUB",LEN
  INC VM_PC,LEN
 WHEN #VM_WHEN:@VM_WHEN
  ?"WHEN",VM_DUMP_ADDR$(VM_OPS[VM_PC])
  INC VM_PC
 WHEN #VM_SWAP:@VM_SWAP
  ?"SWAP"
 WHEN #VM_INPUT:@VM_INPUT
  ?"INPUT",VM_OPS[VM_PC],VM_OPS[VM_PC+1],VM_OPS[VM_PC+2]
  INC VM_PC,3
 WHEN #VM_LINPUT:@VM_LINPUT
  ?"LINPUT",VM_OPS[VM_PC]
  INC VM_PC,1
 WHEN #VM_DEFOUT:@VM_DEFOUT
  ?"DEFOUT"
 WHEN #VM_EXEC1:@VM_EXEC1
  ?"EXEC1"
 WHEN #VM_EXEC2:@VM_EXEC2
  ?"EXEC2"
 WHEN #VM_STOP1:@VM_STOP1
  ?"STOP1"
 WHEN #VM_STOP2:@VM_STOP2
  ?"STOP2"
 WHEN #VM_PUSHVAREXPR:@VM_PUSHVAREXPR
  ?"PUSHVAREXPR"
 WHEN #VM_PUSHVAREXPRREF:@VM_PUSHVAREXPRREF
  ?"PUSHVAREXPRREF"
 WHEN #VM_INITCALLSPRITE:@VM_INITCALLSPRITE
  ?"INITCALLSPRITE"
 WHEN #VM_INITCALLTEXT:@VM_INITCALLTEXT
  ?"INITCALLTEXT
 OTHERWISE:@VM_INVAL
  VM_ERROR
 ENDCASE
 VM_PC2=VM_PC
END

COMMON DEF SBSB_SPANIM * OUT *
 VAR FUNC$="SPANIM"
 IF DEFOUTC()!=0THEN
  MISSING_OUT_PARAMETER FUNC$
  RETURN
 ENDIF
 IF DEFARGC()==3||DEFARGC()==4 THEN
  IF TYPEOF(DEFARG(2))==#T_STR||TYPEOF(DEFARG(2))==#T_INTARRAY||TYPEOF(DEFARG(2))==#T_REALARRAY THEN
   IF DEFARGC()==3THEN
    SBSBANIM FUNC$,DEFARG(0),DEFARG(1),DEFARG(2)
   ELSE
    SBSBANIM FUNC$,DEFARG(0),DEFARG(1),DEFARG(2),DEFARG(3)
   ENDIF
   RETURN
  ENDIF
 ENDIF
 'COPIPE
 VAR VOF=0
 VAR A1=VOF+1
 VAR A0=VOF+0
 VAR SPNO=DEFARG(A0)
 IF TYPEOF(SPNO)!=#T_INT&&TYPEOF(SPNO)!=#T_REAL THEN
  TYPE_MISMATCH FUNC$,1
  RETURN
 ENDIF
 VAR TRGT=DEFARG(A1)
 IF TYPEOF(TRGT)!=#T_INT&&TYPEOF(TRGT)!=#T_REAL&&TYPEOF(TRGT)!=#T_STR THEN
  TYPE_MISMATCH FUNC$,2
  RETURN
 ENDIF
 VAR I
 VAR LEN=2
 IF TYPEOF(TRGT)==#VMT_STR THEN
  VAR T$=TO_UPPER$(MID$(TRGT,0,2))
  IF T$=="XY"||T$=="UV"||T$=="S"THEN
   LEN=3
  ENDIF
 ELSE
  IF TRGT==0||TRGT==3||TRGT==6||TRGT==8||TRGT==8+3||TRGT==8+6||TRGT==16||TRGT==16+3||TRGT==16+6 THEN
   LEN=3
  ENDIF
 ENDIF
 VAR CNT=DEFARGC()-2
 VAR LOOP_
 IF CNT MOD LEN==0 THEN
  LOOP_=1
  CNT=CNT DIV LEN
 ELSEIF CNT MOD LEN==1 THEN
  LOOP_=DEFARG(DEFARGC()-1)
  CNT=CNT DIV LEN
  IF TYPEOF(LOOP_)!=#T_INT&&TYPEOF(LOOP_)!=#T_REAL THEN
   TYPE_MISMATCH FUNC$,DEFARGC()
   RETURN
  ENDIF
 ELSEIF CNT MOD LEN==2 THEN
  ILLEGAL_FUNCTION_CALL FUNC$,DEFARGC()-1
  RETURN
 ENDIF
 DIM ANIM#[CNT*LEN]
 FOR I=0 TO LAST(ANIM#)
  VAR V
  V=DEFARG(I+2)
  IF TYPEOF(V)!=#T_INT&&TYPEOF(V)!=#T_REAL THEN
   TYPE_MISMATCH FUNC$
   RETURN
  ENDIF
  ANIM#[I]=V
 NEXT
 CALL FUNC$,SPNO,TRGT,ANIM#,LOOP_
 'COPIPE
END
COMMON DEF SBSB_ANIMDEF * OUT *
 VAR FUNC$="ANIMDEF"
 IF DEFOUTC()!=0THEN
  MISSING_OUT_PARAMETER FUNC$
  RETURN
 ENDIF
 IF DEFARGC()==3||DEFARGC()==4 THEN
  IF TYPEOF(DEFARG(2))==#T_STR||TYPEOF(DEFARG(2))==#T_INTARRAY||TYPEOF(DEFARG(2))==#T_REALARRAY THEN
   IF DEFARGC()==3THEN
    SBSBANIM FUNC$,DEFARG(0),DEFARG(1),DEFARG(2)
   ELSE
    SBSBANIM FUNC$,DEFARG(0),DEFARG(1),DEFARG(2),DEFARG(3)
   ENDIF
   RETURN
  ENDIF
 ENDIF
 'COPIPE
 VAR VOF=0
 VAR A1=VOF+1
 VAR A0=VOF+0
 VAR SPNO=DEFARG(A0)
 IF TYPEOF(SPNO)!=#T_INT&&TYPEOF(SPNO)!=#T_REAL THEN
  TYPE_MISMATCH FUNC$,1
  RETURN
 ENDIF
 VAR TRGT=DEFARG(A1)
 IF TYPEOF(TRGT)!=#T_INT&&TYPEOF(TRGT)!=#T_REAL&&TYPEOF(TRGT)!=#T_STR THEN
  TYPE_MISMATCH FUNC$,2
  RETURN
 ENDIF
 VAR I
 VAR LEN=2
 IF TYPEOF(TRGT)==#VMT_STR THEN
  VAR T$=TO_UPPER$(MID$(TRGT,0,2))
  IF T$=="XY"||T$=="UV"||T$=="S"THEN
   LEN=3
  ENDIF
 ELSE
  IF TRGT==0||TRGT==3||TRGT==6||TRGT==8||TRGT==8+3||TRGT==8+6||TRGT==16||TRGT==16+3||TRGT==16+6 THEN
   LEN=3
  ENDIF
 ENDIF
 VAR CNT=DEFARGC()-2
 VAR LOOP_
 IF CNT MOD LEN==0 THEN
  LOOP_=1
  CNT=CNT DIV LEN
 ELSEIF CNT MOD LEN==1 THEN
  LOOP_=DEFARG(DEFARGC()-1)
  CNT=CNT DIV LEN
  IF TYPEOF(LOOP_)!=#T_INT&&TYPEOF(LOOP_)!=#T_REAL THEN
   TYPE_MISMATCH FUNC$,DEFARGC()
   RETURN
  ENDIF
 ELSEIF CNT MOD LEN==2 THEN
  ILLEGAL_FUNCTION_CALL FUNC$,DEFARGC()-1
  RETURN
 ENDIF
 DIM ANIM#[CNT*LEN]
 FOR I=0 TO LAST(ANIM#)
  VAR V
  V=DEFARG(I+2)
  IF TYPEOF(V)!=#T_INT&&TYPEOF(V)!=#T_REAL THEN
   TYPE_MISMATCH FUNC$
   RETURN
  ENDIF
  ANIM#[I]=V
 NEXT
 CALL FUNC$,SPNO,TRGT,ANIM#,LOOP_
 'COPIPE
END
COMMON DEF SBSB_TANIM * OUT *
 VAR FUNC$="TANIM"
 IF DEFOUTC()!=0THEN
  MISSING_OUT_PARAMETER FUNC$
  RETURN
 ENDIF
 IF DEFARGC()==3||DEFARGC()==4 THEN
  IF TYPEOF(DEFARG(2))==#T_STR||TYPEOF(DEFARG(2))==#T_INTARRAY||TYPEOF(DEFARG(2))==#T_REALARRAY THEN
   IF DEFARGC()==3THEN
    SBSBANIM FUNC$,DEFARG(0),DEFARG(1),DEFARG(2)
   ELSE
    SBSBANIM FUNC$,DEFARG(0),DEFARG(1),DEFARG(2),DEFARG(3)
   ENDIF
   RETURN
  ENDIF
 ENDIF
 'COPIPE
 VAR VOF=0
 VAR A1=VOF+1
 VAR A0=VOF+0
 VAR SPNO=DEFARG(A0)
 IF TYPEOF(SPNO)!=#T_INT&&TYPEOF(SPNO)!=#T_REAL THEN
  TYPE_MISMATCH FUNC$,1
  RETURN
 ENDIF
 VAR TRGT=DEFARG(A1)
 IF TYPEOF(TRGT)!=#T_INT&&TYPEOF(TRGT)!=#T_REAL&&TYPEOF(TRGT)!=#T_STR THEN
  TYPE_MISMATCH FUNC$,2
  RETURN
 ENDIF
 VAR I
 VAR LEN=2
 IF TYPEOF(TRGT)==#VMT_STR THEN
  VAR T$=TO_UPPER$(MID$(TRGT,0,2))
  IF T$=="XY"||T$=="UV"||T$=="S"THEN
   LEN=3
  ENDIF
 ELSE
  IF TRGT==0||TRGT==3||TRGT==6||TRGT==8||TRGT==8+3||TRGT==8+6||TRGT==16||TRGT==16+3||TRGT==16+6 THEN
   LEN=3
  ENDIF
 ENDIF
 VAR CNT=DEFARGC()-2
 VAR LOOP_
 IF CNT MOD LEN==0 THEN
  LOOP_=1
  CNT=CNT DIV LEN
 ELSEIF CNT MOD LEN==1 THEN
  LOOP_=DEFARG(DEFARGC()-1)
  CNT=CNT DIV LEN
  IF TYPEOF(LOOP_)!=#T_INT&&TYPEOF(LOOP_)!=#T_REAL THEN
   TYPE_MISMATCH FUNC$,DEFARGC()
   RETURN
  ENDIF
 ELSEIF CNT MOD LEN==2 THEN
  ILLEGAL_FUNCTION_CALL FUNC$,DEFARGC()-1
  RETURN
 ENDIF
 DIM ANIM#[CNT*LEN]
 FOR I=0 TO LAST(ANIM#)
  VAR V
  V=DEFARG(I+2)
  IF TYPEOF(V)!=#T_INT&&TYPEOF(V)!=#T_REAL THEN
   TYPE_MISMATCH FUNC$
   RETURN
  ENDIF
  ANIM#[I]=V
 NEXT
 CALL FUNC$,SPNO,TRGT,ANIM#,LOOP_
 'COPIPE
END
DEF SBSBANIM *
 VAR VOF=1
 VAR A3=VOF+3
 VAR A2=VOF+2
 VAR A1=VOF+1
 VAR A0=VOF+0
 VAR FUNC$=DEFARG(0)
 IF TYPEOF(DEFARG(A2))==#T_STR THEN
  VAR LBL$=DEFARG(A2)
  VAR SPNO=DEFARG(A0)
  IF TYPEOF(SPNO)!=#T_INT&&TYPEOF(SPNO)!=#T_REAL THEN
   TYPE_MISMATCH FUNC$,1
   RETURN
  ENDIF
  VAR TRGT=DEFARG(A1)
  IF TYPEOF(TRGT)!=#T_INT&&TYPEOF(TRGT)!=#T_REAL&&TYPEOF(TRGT)!=#T_STR THEN
   TYPE_MISMATCH FUNC$,2
   RETURN
  ENDIF
  'FIXME:RANGE CHECK
  VAR LOOP_=1
  IF DEFARGC()>=4+VOF THEN
   LOOP_=DEFARG(A3)
  ENDIF
  IF TYPEOF(LOOP_)!=#T_INT&&TYPEOF(LOOP_)!=#T_REAL THEN
   TYPE_MISMATCH FUNC$,4
   RETURN
  ENDIF
  IF VM_RESTORE(LBL$) THEN RETURN
  VAR T,CNT
  VM_READ OUT T,CNT
  IF T==#VMT_DEFAULT THEN
   OUT_OF_DATA FUNC$
   RETURN
  ENDIF
  VAR I
  VAR LEN=2
  IF TYPEOF(TRGT)==#VMT_STR THEN
   VAR T$=TO_UPPER$(MID$(TRGT,0,2))
   IF T$=="XY"||T$=="UV"||T$=="S"THEN
    LEN=3
   ENDIF
  ELSE
   IF TRGT==0||TRGT==3||TRGT==6||TRGT==8||TRGT==8+3||TRGT==8+6||TRGT==16||TRGT==16+3||TRGT==16+6 THEN
    LEN=3
   ENDIF
  ENDIF
  DIM ANIM#[CNT*LEN]
  FOR I=0TO LAST(ANIM#)
   VAR V
   VM_READ OUT T,V
   IF T!=#VMT_INT&&T!=#VMT_REAL THEN
    TYPE_MISMATCH FUNC$
    RETURN
   ENDIF
   ANIM#[I]=V
  NEXT
  CALL FUNC$,SPNO,TRGT,ANIM#,LOOP_
  RETURN
 ELSEIF TYPEOF(DEFARG(A2))==#T_INTARRAY||TYPEOF(DEFARG(A2))==#T_REALARRAY THEN
  IF DEFARGC()==3+VOF THEN
   CALL FUNC$,DEFARG(VOF+0),DEFARG(VOF+1),DEFARG(VOF+2)
  ELSE
   CALL FUNC$,DEFARG(VOF+0),DEFARG(VOF+1),DEFARG(VOF+2),DEFARG(VOF+3)
  ENDIF
 ENDIF
END
COMMON DEF SBSB_BGMSETD * OUT *
 IF DEFOUTC()!=0THEN
  MISSING_OUT_PARAMETER "BGMSETD"
  RETURN
 ENDIF
 IF DEFARGC()!=2THEN
  MISSING_PARAMETER "BGMSETD"
  RETURN
 ENDIF
 VAR BGM=DEFARG(0)
 VAR LBL$=DEFARG(1)
 IF TYPEOF(BGM)!=#T_INT&&TYPEOF(BGM)!=#T_REAL THEN
  TYPE_MISMATCH "BGMSETD",1
  RETURN
 ENDIF
 IF BGM<128||BGM>255 THEN
  OUT_OF_RANGE "BGMSETD",1
  RETURN
 ENDIF
 IF TYPEOF(LBL$)!=#T_STR THEN
  TYPE_MISMATCH "BGMSETD",2
  RETURN
 ENDIF
 VAR I
 IF VM_RESTORE(LBL$) THEN RETURN
 VAR MML$=""
 VAR E=#TRUE
 LOOP
  VAR T,V
  VM_READ OUT T,V
  IF T==#VMT_DEFAULT&&E THEN
   '??????
   'BGMSETD 128,@A -> UNDEFINED LABEL(BGMSETD)
   '@A
   'END
   UNDEFINED_LABEL "BGMSETD",LBL$
   RETURN
  ENDIF
  E=#FALSE
  IF TYPEOF(V)!=#T_STR THEN
   BREAK
  ENDIF
  PUSH MML$,V
 ENDLOOP
 BGMSET BGM,MML$
END
DEF SPFUNC_CALLBACK
 SPFUNC_LIST[CALLIDX()]=#TRUE
END
DEF TFUNC_CALLBACK
 TFUNC_LIST[CALLIDX()]=#TRUE
END
DEF SBTHUNK_GET_CALLBACK N$ OUT SLOT,ADDR,ISFUNC
 VAR FOUND,FUNC,LABEL
 IF INSTR(N$,"@")!=-1THEN
  ISFUNC=#FALSE
  VM_GET_LABEL N$,2 OUT SLOT,LABEL,FOUND
  IF!FOUND THEN
   SLOT=-1
   ADDR=-1
   RETURN
  ENDIF
  ADDR=LABEL_ADDR[LABEL]
 ELSE
  ISFUNC=#TRUE
  VM_GETFUNC N$,1,1 OUT FOUND,FUNC
  IF!FOUND THEN
   SLOT=-1
   ADDR=-1
   RETURN
  ENDIF
  SLOT=FUNC_SLOT[FUNC]
  ADDR=FUNC_ADDR[FUNC]
 ENDIF
END
COMMON DEF SBSB_SPFUNC * OUT *
 IF DEFOUTC()==0THEN
  IF DEFARGC()==1 THEN
   SPFUNC DEFARG(0)
   SPVAR DEFARG(0),"SPFUNC_CALLBACK",0
  ELSEIF DEFARGC()==2 THEN
   SBTHUNK_SPFUNC$[DEFARG(0)]=DEFARG(1)
   SBTHUNK_GET_CALLBACK DEFARG(1) OUT\
     SBTHUNK_SPFUNC_SLOT[DEFARG(0)],\
     SBTHUNK_SPFUNC_ADDR[DEFARG(0)],\
     SBTHUNK_SPFUNC_ISFUNC[DEFARG(0)]
   SPFUNC DEFARG(0),"SPFUNC_CALLBACK"
   SPVAR DEFARG(0),"SPFUNC_CALLBACK",1
  ELSE
   MISSING_PARAMETER "SPFUNC"
  ENDIF
 ELSE
  MISSING_OUT_PARAMETER "SPFUNC"
 ENDIF
END
COMMON DEF SBSB_TFUNC * OUT *
 IF DEFOUTC()==0THEN
  IF DEFARGC()==1 THEN
   TFUNC DEFARG(0)
   TVAR DEFARG(0),"TFUNC_CALLBACK",0
  ELSEIF DEFARGC()==2 THEN
   SBTHUNK_TFUNC$[DEFARG(0)]=DEFARG(1)
   SBTHUNK_GET_CALLBACK DEFARG(1) OUT\
     SBTHUNK_TFUNC_SLOT[DEFARG(0)],\
     SBTHUNK_TFUNC_ADDR[DEFARG(0)],\
     SBTHUNK_TFUNC_ISFUNC[DEFARG(0)]
   TVAR DEFARG(0),"TFUNC_CALLBACK",1
   TFUNC DEFARG(0),"TFUNC_CALLBACK"
  ELSE
   MISSING_PARAMETER "TFUNC"
  ENDIF
 ELSE
  MISSING_OUT_PARAMETER "TFUNC"
 ENDIF
END
COMMON DEF SBSB_COPY * OUT *
 IF DEFOUTC()==0&&DEFARGC()>=2&&DEFARGC()<=5THEN
  VAR A1=DEFARG(0)
  VAR A2=DEFARG(1)
  IF TYPEOF(A1)>=#T_INTARRAY&&TYPEOF(A1)<=#T_STRARRAY THEN
   VAR LBL$
   VAR OFF=0
   VAR LEN=0
   VAR HAS_LEN=#FALSE
   VAR LBL_CPY=#FALSE
   'COPY ARY,@A
   'COPY ARY,OFF,@A
   'COPY ARY,@A,LEN
   'COPY ARY,OFF,@A,LEN
   IF DEFARGC()==2&&TYPEOF(A2)==#T_STR THEN
    LBL$=A2
    LEN=LEN(A1)
    HAS_LEN=#TRUE
    LBL_CPY=#TRUE
   ELSEIF DEFARGC()==3&&TYPEOF(A2)==#T_STR THEN
    LBL$=A2
    LEN=DEFARG(2)
    HAS_LEN=#TRUE
    LBL_CPY=#TRUE
   ELSEIF DEFARGC()==3&&TYPEOF(DEFARG(2))==#T_STR THEN
    LBL$=DEFARG(2)
    OFF=A2
    LEN=LEN(A1)-OFF
    HAS_LEN=#TRUE
    LBL_CPY=#TRUE
   ELSEIF DEFARGC()==4&&TYPEOF(DEFARG(2))==#T_STR THEN
    LBL$=DEFARG(2)
    OFF=A2
    LEN=DEFARG(3)
    HAS_LEN=#TRUE
    LBL_CPY=#TRUE
   ENDIF
   IF LBL_CPY THEN
    VAR I
    IF VM_RESTORE(LBL$) THEN RETURN
    FOR I=0TO LEN-1
     VAR T,V
     VM_READ OUT T,V
     IF T==#VMT_DEFAULT THEN
      OUT_OF_DATA "COPY"
      RETURN
     ENDIF
     A1[OFF+I]=V
    NEXT
    RETURN
   ENDIF
  ENDIF
  CASE DEFARGC()
  WHEN 2
   COPY DEFARG(0),DEFARG(1)
  WHEN 3
   COPY DEFARG(0),DEFARG(1),DEFARG(2)
  WHEN 4
   COPY DEFARG(0),DEFARG(1),DEFARG(2),DEFARG(3)
  WHEN 5
   COPY DEFARG(0),DEFARG(1),DEFARG(2),DEFARG(3),DEFARG(4)
  ENDCASE
 ELSEIF DEFOUTC()==1&&DEFARGC()>=1&&DEFARGC()<=3 THEN
  CASE DEFARGC()
  WHEN 1
   DEFOUT 0,COPY(DEFARG(0))
  WHEN 2
   DEFOUT 0,COPY(DEFARG(0),DEFARG(1))
  WHEN 3
   DEFOUT 0,COPY(DEFARG(0),DEFARG(1),DEFARG(2))
  ENDCASE
 ELSE
  MISSING_PARAMETER "COPY"
 ENDIF
END
COMMON DEF SBSB_SPDEF * OUT *
 IF DEFOUTC()==0&&DEFARGC()==0THEN
  SPDEF
 ELSEIF DEFOUTC()==0&&DEFARGC()>=1&&DEFARGC()<=9THEN
  VAR A1=DEFARG(0)
  IF TYPEOF(A1)==#T_STR THEN
   IF VM_RESTORE(A1) THEN RETURN
   VAR T,CNT
   VM_READ OUT T,CNT
   IF T==#VMT_DEFAULT THEN
    OUT_OF_DATA "SPDEF"
    RETURN
   ENDIF
   DIM ANIM#[CNT*7]
   VAR I
   FOR I=0TO CNT-1
    VAR J
    FOR J=0TO 6
     VM_READ OUT T,ANIM#[I*7+J]
     IF T==#VMT_DEFAULT THEN
      OUT_OF_DATA "SPDEF"
      RETURN
     ENDIF
    NEXT
   NEXT
   CASE DEFARGC()
   WHEN 1
    SPDEF ANIM#
   WHEN 2
    SPDEF ANIM#,DEFARG(1)
   WHEN 3
    SPDEF ANIM#,DEFARG(1),DEFARG(2)
   WHEN 4
    SPDEF ANIM#,DEFARG(1),DEFARG(2),DEFARG(3)
   ENDCASE
  ELSE
   CASE DEFARGC()
   WHEN 1
    SPDEF DEFARG(0)
   WHEN 2
    SPDEF DEFARG(0),DEFARG(1)
   WHEN 3
    SPDEF DEFARG(0),DEFARG(1),DEFARG(2)
   WHEN 4
    SPDEF DEFARG(0),DEFARG(1),DEFARG(2),DEFARG(3)
   WHEN 5
    SPDEF DEFARG(0),DEFARG(1),DEFARG(2),DEFARG(3),DEFARG(4)
   WHEN 6
    SPDEF DEFARG(0),DEFARG(1),DEFARG(2),DEFARG(3),DEFARG(4),DEFARG(5)
   WHEN 7
    SPDEF DEFARG(0),DEFARG(1),DEFARG(2),DEFARG(3),DEFARG(4),DEFARG(5),DEFARG(6)
   WHEN 8
    SPDEF DEFARG(0),DEFARG(1),DEFARG(2),DEFARG(3),DEFARG(4),DEFARG(5),DEFARG(6),DEFARG(7)
   WHEN 9
    SPDEF DEFARG(0),DEFARG(1),DEFARG(2),DEFARG(3),DEFARG(4),DEFARG(5),DEFARG(6),DEFARG(7),DEFARG(8)
   ENDCASE
  ENDIF
 ELSEIF DEFOUTC()>=2&&DEFOUTC()<=7&&DEFARGC()==1 THEN
  VAR O0,O1,O2,O3,O4,O5,O6
  SPDEF DEFARG(0) OUT O0,O1,O2,O3,O4,O5,O6
  DEFOUT 0,O0
  DEFOUT 1,O1
  IF DEFOUTC()==3 THEN
   DEFOUT 2,O6
  ELSEIF DEFOUTC()==4THEN
   DEFOUT 2,O2
   DEFOUT 3,O3
  ELSEIF DEFOUTC()==5THEN
   DEFOUT 2,O2
   DEFOUT 3,O3
   DEFOUT 4,O6
  ELSEIF DEFOUTC()==6THEN
   DEFOUT 2,O2
   DEFOUT 3,O3
   DEFOUT 4,O4
   DEFOUT 5,O5
  ELSEIF DEFOUTC()==7THEN
   DEFOUT 2,O2
   DEFOUT 3,O3
   DEFOUT 4,O4
   DEFOUT 5,O5
   DEFOUT 6,O6
  ENDIF
 ELSE
  MISSING_PARAMETER "SPDEF"
 ENDIF
END
'VM END




'VIRTUAL SLOT
DIM VSLOTL_LINE$[]
DIM VSLOTL_NEXT[]
DIM VSLOTL_PREV[]
VAR VSLOTL_FREE'FREELIST
DIM VSLOT[]
DIM VSLOT_CURLINE[]
DIM VSLOT_CURLINE_NO[]
DIM VSLOT_LINECNT[]
DIM VSLOT_CHRCNT[]
DIM VSLOT_EOF[]
VAR VSLOT_MAX
CONST #VSLOT_INVALSLOT=-1
VAR VSLOT_CURSLOT
DEF VSLOT_INIT
 VSLOT_CURSLOT=#VSLOT_INVALSLOT
 VSLOT_MAX=4
 VSLOT=ARRAY%(VSLOT_MAX)
 VSLOT_CURLINE=ARRAY%(VSLOT_MAX)
 VSLOT_CURLINE_NO=ARRAY%(VSLOT_MAX)
 VSLOT_LINECNT=ARRAY%(VSLOT_MAX)
 VSLOT_CHRCNT=ARRAY%(VSLOT_MAX)
 VSLOT_EOF=ARRAY%(VSLOT_MAX)
 VAR VSLOT_INIT_CAP=1024
 VSLOTL_LINE$=ARRAY$(VSLOT_INIT_CAP)
 VSLOTL_NEXT=ARRAY%(VSLOT_INIT_CAP)
 VSLOTL_PREV=ARRAY%(VSLOT_INIT_CAP)
 VAR I
 FOR I=1TO VSLOT_INIT_CAP-2
  VSLOTL_NEXT[I]=I+1
 NEXT
 VSLOTL_FREE=1
 FOR I=0TO VSLOT_MAX-1
  VSLOT_LOAD I,CHR$(10)
 NEXT
END

DEF NEW_VSLOTL()
 IF!VSLOTL_FREE THEN
  VAR LAST=LEN(VSLOTL_LINE$)
  RESIZE VSLOTL_LINE$,LEN(VSLOTL_LINE$)*2
  RESIZE VSLOTL_NEXT,LEN(VSLOTL_NEXT)*2
  RESIZE VSLOTL_PREV,LEN(VSLOTL_PREV)*2
  VAR I
  FOR I=LAST TO LEN(VSLOTL_NEXT)-2
   VSLOTL_NEXT[I]=I+1
  NEXT
  VSLOTL_FREE=LAST
 ENDIF
 VAR L=VSLOTL_FREE
 VSLOTL_FREE=VSLOTL_NEXT[VSLOTL_FREE]
 VSLOTL_NEXT[L]=0
 RETURN L
END

DEF DELETE_VSLOTL L
 VSLOTL_NEXT[L]=VSLOTL_FREE
 VSLOTL_FREE=L
 VSLOTL_PREV[L]=0
 VAR E$
 VSLOTL_LINE$[L]=E$
END

DEF VSLOT_DESTROY SLOT
 VAR S=VSLOT[SLOT]
 WHILE S
  VAR NXT=VSLOTL_NEXT[S]
  DELETE_VSLOTL S
  S=NXT
 WEND
 VSLOT[SLOT]=0
END

DEF VSLOT_DUMP SLOT
 VAR S=VSLOT[SLOT]
 VAR L
 WHILE S
  INC L
  IF S==VSLOT_CURLINE[SLOT]THEN
   ?VSLOT_CURLINE_NO[SLOT];"=>";
  ENDIF
  ?L;".";VSLOTL_LINE$[S];
  S=VSLOTL_NEXT[S]
 WEND
END

DEF VSLOT_DUMPR SLOT
 VAR S=VSLOT[SLOT]
 VAR L
 WHILE S
  INC L
  IF!VSLOTL_NEXT[S]THEN BREAK
  S=VSLOTL_NEXT[S]
 WEND
 WHILE S
  IF S==VSLOT_CURLINE[SLOT]THEN
   ?VSLOT_CURLINE_NO[SLOT];"=>";
  ENDIF
  ?L;".";VSLOTL_LINE$[S];
  S=VSLOTL_PREV[S]
  DEC L
 WEND
END


DEF VSLOT_LOAD SLOT,V$
 VAR I
 VAR LF$=CHR$(10)
 VSLOT_DESTROY SLOT
 VAR PREV=0
 VAR FRST
 VAR LINE
 VSLOT_CHRCNT[SLOT]=0
 LOOP
  IF I>=LEN(V$)THEN BREAK
  VAR NXTLF=INSTR(I,V$,LF$)
  IF NXTLF==-1 THEN
   NXTLF=LEN(V$)
  ENDIF
  VAR S$=MID$(V$,I,NXTLF-I+1)
  VAR L=NEW_VSLOTL()
  INC LINE
  INC VSLOT_CHRCNT[SLOT],LEN(S$)
  VSLOTL_LINE$[L]=S$
  IF!PREV THEN
   PREV=L
   FRST=L
  ELSE
   VSLOTL_NEXT[PREV]=L
   VSLOTL_PREV[L]=PREV
  ENDIF
  PREV=L
  I=NXTLF+1
 ENDLOOP
 VSLOT_LINECNT[SLOT]=LINE
 VSLOT[SLOT]=FRST
 VSLOT_CURLINE[SLOT]=PREV
 VSLOT_CURLINE_NO[SLOT]=LINE
 VSLOT_EOF[SLOT]=#TRUE
END

DEF VSLOT_SEEK(SLOT,DIFF)
 VSLOT_EOF[SLOT]=#FALSE
 IF DIFF==1 THEN
  IF VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]==0 THEN
   VSLOT_EOF[SLOT]=#TRUE
   RETURN 0
  ENDIF
  VSLOT_CURLINE[SLOT]=VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]
  INC VSLOT_CURLINE_NO[SLOT]
  RETURN 1
 ENDIF
 IF DIFF==-1 THEN
  IF VSLOTL_PREV[VSLOT_CURLINE[SLOT]]==0 THEN
   RETURN 0
  ENDIF
  VSLOT_CURLINE[SLOT]=VSLOTL_PREV[VSLOT_CURLINE[SLOT]]
  DEC VSLOT_CURLINE_NO[SLOT]
  RETURN 1
 ENDIF
 STOP
END
DEF VSLOT_SEEKEOF SLOT
 LOOP
  IF VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]==0 THEN
   VSLOT_EOF[SLOT]=#TRUE
   BREAK
  ENDIF
  VSLOT_CURLINE[SLOT]=VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]
  INC VSLOT_CURLINE_NO[SLOT]
 ENDLOOP
END
DEF VSLOT_GETLINE$(SLOT,LINE)
 VAR DIFF=LINE-VSLOT_CURLINE_NO[SLOT]
 VAR CL=VSLOT_CURLINE[SLOT]
 IF DIFF>0 THEN
  FOR DIFF=DIFF TO 1 STEP -1
   IF VSLOTL_NEXT[CL]==0 THEN
    BREAK
   ENDIF
   CL=VSLOTL_NEXT[CL]
  NEXT
 ELSE
  FOR DIFF=DIFF TO -1
   IF VSLOTL_PREV[CL]==0 THEN
    BREAK
   ENDIF
   CL=VSLOTL_PREV[CL]
  NEXT
 ENDIF
 RETURN VSLOTL_LINE$[CL]
END
DEF VSLOT_SEEKLINE SLOT,LINE
 VAR DIFF=LINE-VSLOT_CURLINE_NO[SLOT]
 VSLOT_EOF[SLOT]=#FALSE
 IF DIFF==0 THEN
  RETURN
 ENDIF
 IF DIFF>0 THEN
  FOR DIFF=DIFF TO 1 STEP -1
   IF VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]==0 THEN
    BREAK
   ENDIF
   VSLOT_CURLINE[SLOT]=VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]
   INC VSLOT_CURLINE_NO[SLOT]
  NEXT
 ELSE
  FOR DIFF=DIFF TO -1
   IF VSLOTL_PREV[VSLOT_CURLINE[SLOT]]==0 THEN
    BREAK
   ENDIF
   VSLOT_CURLINE[SLOT]=VSLOTL_PREV[VSLOT_CURLINE[SLOT]]
   DEC VSLOT_CURLINE_NO[SLOT]
  NEXT
 ENDIF
END

DEF VSLOT_SET SLOT,V$
 V$=V$+CHR$(10)
 VAR I
 VAR LF$=CHR$(10)
 VAR NL
 VAR MULTIPLE
 IF!VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]&&!VSLOT_EOF[SLOT]THEN
  NL=NEW_VSLOTL()
  VSLOTL_LINE$[NL]=LF$
  INC VSLOT_CHRCNT[SLOT]
  VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]=NL
  VSLOTL_PREV[NL]=VSLOT_CURLINE[SLOT]
  INC VSLOT_LINECNT[SLOT]
 ENDIF
 LOOP
  VAR NXTLF=INSTR(I,V$,LF$)
  IF NXTLF==-1 THEN
   NXTLF=LEN(V$)
  ENDIF
  VAR LINE$=MID$(V$,I,NXTLF-I+1)
  VAR L=VSLOT_CURLINE[SLOT]
  INC VSLOT_CHRCNT[SLOT],LEN(LINE$)-LEN(VSLOTL_LINE$[L])
  VSLOTL_LINE$[L]=LINE$
  I=NXTLF+1
  IF I>=LEN(V$)THEN BREAK
  INC VSLOT_CURLINE_NO[SLOT]
  INC VSLOT_LINECNT[SLOT]
  NL=NEW_VSLOTL()
  VSLOTL_PREV[NL]=L
  VSLOTL_NEXT[NL]=VSLOTL_NEXT[L]
  VSLOTL_PREV[VSLOTL_NEXT[L]]=NL
  VSLOTL_NEXT[L]=NL
  VSLOT_CURLINE[SLOT]=NL
  MULTIPLE=#TRUE
 ENDLOOP
 IF VSLOT_EOF[SLOT]THEN
  NL=NEW_VSLOTL()
  VSLOTL_PREV[NL]=L
  VSLOTL_NEXT[L]=NL
  VSLOTL_LINE$[NL]=LF$
  VSLOT_CURLINE[SLOT]=NL
  INC VSLOT_LINECNT[SLOT]
  INC VSLOT_CURLINE_NO[SLOT]
  INC VSLOT_CHRCNT[SLOT],LEN(LF$)
 ELSE
  INC VSLOT_CURLINE_NO[SLOT]
  IF VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]THEN
   VSLOT_CURLINE[SLOT]=VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]
  ENDIF
 ENDIF
END

DEF VSLOT_INS SLOT,V$,PS
 V$=V$+CHR$(10)
 VAR I
 VAR LF$=CHR$(10)
 VAR NL
 VAR INSTO=VSLOT_CURLINE[SLOT]
 IF PS THEN
  INSTO=INSTO
 ELSE
  INSTO=VSLOTL_PREV[INSTO]
 ENDIF
 IF !INSTO&&PS THEN
  INSTO=VSLOT_CURLINE[SLOT]
 ENDIF
 LOOP
  VAR NXTLF=INSTR(I,V$,LF$)
  IF NXTLF==-1 THEN
   NXTLF=LEN(V$)
  ENDIF
  VAR LINE$=MID$(V$,I,NXTLF-I+1)
  NL=NEW_VSLOTL()
  IF !INSTO THEN
   VSLOTL_PREV[NL]=INSTO
   VSLOTL_NEXT[NL]=VSLOTL_NEXT[INSTO]
   IF INSTO THEN
    VSLOTL_NEXT[INSTO]=NL
   ELSE
    VSLOTL_NEXT[NL]=VSLOT[SLOT]
    VSLOTL_PREV[VSLOT[SLOT]]=NL
    VSLOT[SLOT]=NL
   ENDIF
  ELSE
   VAR PRV=VSLOTL_PREV[INSTO]
   VAR NXT=VSLOTL_NEXT[INSTO]
   VSLOTL_NEXT[INSTO]=NL
   VSLOTL_NEXT[NL]=NXT
   VSLOTL_PREV[NL]=INSTO
   VSLOTL_PREV[NXT]=NL
  ENDIF
  INC VSLOT_CURLINE_NO[SLOT]
  IF PS THEN
   VSLOT_CURLINE[SLOT]=NL
  ELSE
   VSLOT_CURLINE[SLOT]=VSLOTL_NEXT[NL]
  ENDIF
  INSTO=NL
  INC VSLOT_LINECNT[SLOT]
  INC VSLOT_CHRCNT[SLOT],LEN(LINE$)
  VAR L=NL
  VSLOTL_LINE$[L]=LINE$
  I=NXTLF+1
  IF I>=LEN(V$)THEN BREAK
 ENDLOOP
END

DEF VSLOT_DEL SLOT,D
 IF D<0THEN
  VAR PRSV=VSLOT_EOF[SLOT]
  VSLOT_DESTROY SLOT
  VSLOT_LOAD SLOT,CHR$(10)
  VSLOT_EOF[SLOT]=PRSV
  RETURN
 ENDIF
 VAR CL=VSLOT_CURLINE[SLOT]
 VAR DELFRST
 WHILE D>0&&CL
  DEC D
  VAR NXT=VSLOTL_NEXT[CL]
  VAR PRV=VSLOTL_PREV[CL]
  DEC VSLOT_LINECNT[SLOT]
  DEC VSLOT_CHRCNT[SLOT],LEN(VSLOTL_LINE$[CL])
  VSLOTL_NEXT[PRV]=NXT
  IF NXT THEN
   VSLOTL_PREV[NXT]=PRV
  ELSE
   DEC VSLOT_CURLINE_NO[SLOT]
   NXT=PRV
  ENDIF
  VSLOT_CURLINE[SLOT]=NXT
  DELETE_VSLOTL CL
  IF CL==VSLOT[SLOT]THEN
   IF NXT THEN
    VSLOT[SLOT]=NXT
    VSLOT_CURLINE_NO[SLOT]=1
   ELSE
    DELFRST=#TRUE
   ENDIF
  ENDIF
  CL=NXT
 WEND
 IF DELFRST THEN
  PRSV=VSLOT_EOF[SLOT]
  VSLOT[SLOT]=0
  VSLOT_LOAD SLOT,CHR$(10)
  VSLOT_EOF[SLOT]=PRSV
 ENDIF
END

DEF VSLOT_PRGEDIT SLOT,LINE
 VSLOT_CURSLOT=SLOT
 IF LINE!=-1 THEN
  VSLOT_SEEKLINE SLOT,LINE
 ELSE
  VSLOT_SEEKEOF SLOT
 ENDIF
END

DEF VSLOT_PRGGET_SLOT$(SLOT,SEEKFLG)
 IF VSLOT_EOF[SLOT]THEN
  RETURN ""
 ENDIF
 VAR V$=VSLOTL_LINE$[VSLOT_CURLINE[SLOT]]
 IF SEEKFLG THEN
  VAR _=VSLOT_SEEK(SLOT,1)
 ENDIF
 RETURN V$
END
DEF VSLOT_PRGGET$(SEEKFLG)
 RETURN VSLOT_PRGGET_SLOT$(VSLOT_CURSLOT,SEEKFLG)
END

DEF VSLOT_PRGSEEK(D)
 RETURN VSLOT_SEEK(VSLOT_CURSLOT,D)
END

DEF VSLOT_PRGEDIT_OUT OUT SLOT,LINE
 SLOT=VSLOT_CURSLOT
 LINE=VSLOT_CURLINE_NO[SLOT]
END

DEF VSLOT_PRGSET L$
 VSLOT_SET VSLOT_CURSLOT,L$
END

DEF VSLOT_PRGINS L$,D
 VSLOT_INS VSLOT_CURSLOT,L$,D
END

DEF VSLOT_PRGDEL D
 VSLOT_DEL VSLOT_CURSLOT,D
END

DEF VSLOT_PRGSIZE(SLOT,TYP)
 IF TYP==0 THEN
  IF VSLOT_LINECNT[SLOT]==1&&VSLOTL_LINE$[VSLOT[SLOT]]==CHR$(10)THEN
   RETURN 0
  ENDIF
  RETURN VSLOT_LINECNT[SLOT]
 ELSEIF TYP==1THEN
  RETURN VSLOT_CHRCNT[SLOT]
 ENDIF
 RETURN 1048576-VSLOT_CHRCNT[SLOT]
END


VAR VSLOT_TEST_SLOT
DEF VSLOT_TEST_SET LINE,STR$
 VAR I
 FOR I=0TO LAST(STR$)
  IF STR$[I]=="/"THEN STR$[I]=CHR$(10)
 NEXT
 VSLOT_PRGEDIT VSLOT_TEST_SLOT,1
 VSLOT_PRGDEL -1
 VSLOT_PRGSET STR$
 VSLOT_PRGEDIT VSLOT_TEST_SLOT,LINE
 PRGEDIT VSLOT_TEST_SLOT
 PRGDEL -1
 PRGSET STR$
 PRGEDIT VSLOT_TEST_SLOT,LINE
END
VAR VSLOT_ASSERT_FAILED
DEF VSLOT_ASSERT *
 IF!DEFARG(0)THEN
  VSLOT_ASSERT_FAILED=#TRUE
  ?"Assertion failed",DEFARG(1),"SLOT ";DEFARG(2);" LINE ";DEFARG(3);" FILE ";CHR$(34);DEFARG(4);CHR$(34)
 ENDIF
END
DEF VSLOT_ASSERT_EQ L,L$,R,R$,SLOT,LINE,FILE
 IF L!=R THEN
  VSLOT_ASSERT_FAILED=#TRUE
  VAR LL$=VSLOT_TEST_ESCAPE$(L)
  VAR RR$=VSLOT_TEST_ESCAPE$(R)
  ?"Assertion failed",LL$;"!=";RR$,L$;"!=";R$,"SLOT ";SLOT;" LINE ";LINE;" FILE ";CHR$(34);FILE;CHR$(34)
 ENDIF
END
DEF VSLOT_TEST_ESCAPE$(S$)
 IF TYPEOF(S$)==#T_STR THEN
  VAR I
  VAR R$=""
  PUSH R$,CHR$(34)
  FOR I=0TO LAST(S$)
   IF ASC(S$[I])==10THEN
    PUSH R$,"\n"
   ELSEIF S$[I]=="\"THEN
    PUSH R$,"\\"
   ELSE
    PUSH R$,S$[I]
   ENDIF
  NEXT
  PUSH R$,CHR$(34)
  RETURN R$
 ELSE
  RETURN STR$(S$)
 ENDIF
END
VAR VSLOT_TEST_CNT
VAR VSLOT_TEST_SUCC_CNT
VAR VSLOT_TEST_FAILED_CNT
DEF VSLOT_CHECK
 INC VSLOT_TEST_CNT
 VSLOT_ASSERT_FAILED=#FALSE
 VAR SLOT=VSLOT_TEST_SLOT
 VAR S=VSLOT[SLOT]
 VAR L
 VAR LINES$[]
 VAR LINESR$[]
 VAR P_IS_EOF=PRGGET$(#FALSE)==""
 VAR V_IS_EOF=VSLOT_EOF[SLOT]
 VSLOT_ASSERT_EQ P_IS_EOF,"P_IS_EOF",V_IS_EOF,"V_IS_EOF",#_SLOT,#_LINE,#_FILENAME
 VAR P_LINE=PRGEDIT()
 VAR V_LINE=VSLOT_CURLINE_NO[SLOT]
 VSLOT_ASSERT_EQ P_LINE,"P_LINE",V_LINE,"V_LINE",#_SLOT,#_LINE,#_FILENAME
 VSLOT_ASSERT_EQ PRGGET$(#FALSE),"PRGGET$(#FALSE)",VSLOT_PRGGET$(#FALSE),"VSLOT_PRGGET$(#FALSE)",#_SLOT,#_LINE,#_FILENAME
 VAR HAS_CURLINE
 WHILE S
  INC L
  IF S==VSLOT_CURLINE[SLOT]THEN
   VSLOT_ASSERT_EQ VSLOT_CURLINE_NO[SLOT],"VSLOT_CURLINE_NO[SLOT]",L,"L",#_SLOT,#_LINE,#_FILENAME
   HAS_CURLINE=#TRUE
  ENDIF
  PUSH LINES$,VSLOTL_LINE$[S]
  IF!VSLOTL_NEXT[S] THEN
   BREAK
  ENDIF
  S=VSLOTL_NEXT[S]
 WEND
 VSLOT_ASSERT HAS_CURLINE,"HAS_CURLINE",#_SLOT,#_LINE,#_FILENAME
 HAS_CURLINE=#FALSE
 VAR V_LINE_CNT=L
 WHILE S
  IF S==VSLOT_CURLINE[SLOT]THEN
   VSLOT_ASSERT_EQ VSLOT_CURLINE_NO[SLOT],"VSLOT_CURLINE_NO[SLOT]",L,"L",#_SLOT,#_LINE,#_FILENAME
   HAS_CURLINE=#TRUE
  ENDIF
  UNSHIFT LINESR$,VSLOTL_LINE$[S]
  S=VSLOTL_PREV[S]
  DEC L
 WEND
 VSLOT_ASSERT HAS_CURLINE,"HAS_CURLINE",#_SLOT,#_LINE,#_FILENAME
 PRGEDIT SLOT,1
 DIM LINESP$[]
 LOOP
  VAR L$=PRGGET$()
  IF L$==""THEN BREAK
  PUSH LINESP$,L$
 ENDLOOP
 PRGEDIT SLOT,-1
 VAR P_LINE_CNT=PRGEDIT()
 VSLOT_ASSERT_EQ P_LINE_CNT,"P_LINE_CNT",V_LINE_CNT,"V_LINE_CNT",#_SLOT,#_LINE,#_FILENAME
 VSLOT_ASSERT_EQ LEN(LINES$),"LEN(LINES$)",LEN(LINESP$),"LEN(LINESP$)",#_SLOT,#_LINE,#_FILENAME
 VSLOT_ASSERT LEN(LINES$),"LEN(LINES$)",LEN(LINESR$),"LEN(LINESR$)",#_SLOT,#_LINE,#_FILENAME
 VAR I
 FOR I=0TO MIN(LAST(LINES$[I]),LAST(LINESP$),LAST(LINESR$))'P_LINE-1
  VSLOT_ASSERT_EQ LINES$[I],"LINES$[I]",LINESP$[I],"LINESP$[I]",#_SLOT,#_LINE,#_FILENAME
  VSLOT_ASSERT_EQ LINES$[I],"LINES$[I]",LINESR$[I],"LINESR$[I]",#_SLOT,#_LINE,#_FILENAME
 NEXT
 VSLOT_ASSERT_EQ PRGSIZE(VSLOT_TEST_SLOT,0),"PRGSIZE(VSLOT_TEST_SLOT,0)",VSLOT_PRGSIZE(VSLOT_TEST_SLOT,0),"VSLOT_PRGSIZE(VSLOT_TEST_SLOT,0)",#_SLOT,#_LINE,#_FILENAME
 VSLOT_ASSERT_EQ PRGSIZE(VSLOT_TEST_SLOT,1),"PRGSIZE(VSLOT_TEST_SLOT,1)",VSLOT_PRGSIZE(VSLOT_TEST_SLOT,1),"VSLOT_PRGSIZE(VSLOT_TEST_SLOT,1)",#_SLOT,#_LINE,#_FILENAME
 IF VSLOT_ASSERT_FAILED THEN
  ?FORMAT$("%15S%15S%15S","LINESP","LINES","LINESR")
  FOR I=0TO MAX(LAST(LINES$),LAST(LINESP$),LAST(LINESR$))
   IF LEN(LINESP$)>I THEN
    ?FORMAT$("%20S",VSLOT_TEST_ESCAPE$(LINESP$[I]));
   ELSE
    ?FORMAT$("%20S","XXX");
   ENDIF
   IF LEN(LINES$)>I THEN
    ?FORMAT$("%20S",VSLOT_TEST_ESCAPE$(LINES$[I]));
   ELSE
    ?FORMAT$("%20S","XXX");
   ENDIF
   IF LEN(LINESR$)>I THEN
    ?FORMAT$("%20S",VSLOT_TEST_ESCAPE$(LINESR$[I]))
   ELSE
    ?FORMAT$("%20S","XXX");
   ENDIF
  NEXT
 ENDIF
 IF VSLOT_ASSERT_FAILED THEN
  INC VSLOT_TEST_FAILED_CNT
  STOP
 ELSE
  INC VSLOT_TEST_SUCC_CNT
 ENDIF
END

DEF VSLOT_TEST_PRGINS A$,B
 PRGINS A$,B
 VSLOT_PRGINS A$,B
END
DEF VSLOT_TEST_PRGSET A$
 PRGSET A$
 VSLOT_PRGSET A$
END
DEF VSLOT_TEST_PRGDEL L
 PRGDEL L
 VSLOT_PRGDEL L
END
DEF VSLOT_TEST_PRGSEEK L
 VSLOT_ASSERT_EQ PRGSEEK(L),"PRGSEEK("+STR$(L)+")",VSLOT_PRGSEEK(L),"VSLOT_PRGSEEK("+STR$(L)+")",#_SLOT,#_LINE,#_FILENAME
END
DEF VSLOT_TEST_PRGGET L
 VSLOT_ASSERT_EQ PRGGET$(L),"PRGGET$("+STR$(L)+")",VSLOT_PRGGET$(L),"VSLOT_PRGGET$("+STR$(L)+")",#_SLOT,#_LINE,#_FILENAME
END

DEF VSLOT_TEST
 VSLOT_TEST_SLOT=3
 VAR I,J,K
 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 "+STR$(I)
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGINS "PRGINS0,"+STR$(I),0
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGINS "PRGINS1,"+STR$(I),1
  VSLOT_CHECK
 NEXT


 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGINS "PRGINS0,"+STR$(I)+CHR$(10)+"\n",0
  VSLOT_CHECK
 NEXT


 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGINS "PRGINS1,"+STR$(I)+CHR$(10)+"\n",1
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGSET "PRGSET"+STR$(I)
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGSET "PRGSET"+STR$(I)+CHR$(10)+"\n"
  VSLOT_CHECK
 NEXT


 FOR I=-1TO 2
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,""
  VSLOT_TEST_PRGSET "PRGSET"+STR$(I)+CHR$(10)+"\n"
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGSET "PRGSET"+STR$(I)+CHR$(10)+"\n1"
  VSLOT_TEST_PRGINS "PRGINS0,"+STR$(I)+CHR$(10)+"\n2",0
  VSLOT_TEST_PRGINS "PRGINS1,"+STR$(I)+CHR$(10)+"\n3",1
  VSLOT_TEST_PRGSET "PRGSET"+STR$(I)+CHR$(10)+"\n4"
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 DEL"+STR$(I)
  VSLOT_TEST_PRGDEL -1
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  FOR J=-1TO 5
   IF J==0THEN CONTINUE
   VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 DEL"+STR$(I)+","+STR$(J)
   VSLOT_TEST_PRGDEL J
   VSLOT_CHECK
  NEXT
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 SEEK"+STR$(I)
  VSLOT_TEST_PRGSEEK 1
  VSLOT_CHECK
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 SEEK"+STR$(I)
  VSLOT_TEST_PRGSEEK -1
  VSLOT_CHECK
  FOR J=0TO 5
   VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 GET0,"+STR$(I)
   FOR K=0TO J
    VSLOT_TEST_PRGGET 0
   NEXT
   VSLOT_CHECK
   VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 GET1,"+STR$(I)
   FOR K=0TO J
    VSLOT_TEST_PRGGET 1
   NEXT
   VSLOT_CHECK
  NEXT
 NEXT
 ?"(";VSLOT_TEST_SUCC_CNT;"/";VSLOT_TEST_CNT;") passed"
 STOP
END


'INTERFACES
COMMON DEF SBSB_LOAD * OUT *
 IF DEFOUTC()!=0 THEN
  MISSING_PARAMETER "LOAD"
  RETURN
 ENDIF
 IF DEFARGC()!=1&&DEFARGC()!=2 THEN
  MISSING_PARAMETER "LOAD"
  RETURN
 ENDIF
 VAR FN$=DEFARG(0)
 VAR SLOT=0
 IF TYPEOF(FN$)!=#T_STR THEN
  TYPE_MISMATCH "LOAD"
  RETURN
 ENDIF
 IF DEFARGC()==2THEN
  SLOT=DEFARG(1)
  IF TYPEOF(SLOT)!=#T_INT&&TYPEOF(SLOT)!=#T_REAL THEN
   TYPE_MISMATCH "LOAD"
   RETURN
  ENDIF
 ENDIF
 IF SLOT<0||SLOT>=VSLOT_MAX THEN
  OUT_OF_RANGE "LOAD"
  RETURN
 ENDIF
 IF INSTR(FN$,"TXT:")!=0 THEN
  FN$="TXT:"+FN$
 ENDIF
 'FIXME:VALIDATE FILENAME
 VAR V$=LOADV(FN$)
 VSLOT_LOAD SLOT,V$
END


COMMON DEF SBSB_PRGEDIT * OUT *
 IF DEFARGC()==0&&DEFOUTC()==1THEN
  VAR SLOT,LINE
  VSLOT_PRGEDIT_OUT OUT SLOT,LINE
  IF SLOT==#VSLOT_INVALSLOT THEN
   USE_PRGEDIT_BEFORE_ANY_PRG_FUNCTION "PRGEDIT"
  ELSE
   DEFOUT 0,LINE
  ENDIF
 ELSEIF DEFARGC()==0&&DEFOUTC()==2THEN
  VSLOT_PRGEDIT_OUT OUT SLOT,LINE
  IF SLOT==#VSLOT_INVALSLOT THEN
   USE_PRGEDIT_BEFORE_ANY_PRG_FUNCTION "PRGEDIT"
  ELSE
   DEFOUT 0,SLOT
   DEFOUT 0,LINE
  ENDIF
 ELSEIF DEFARGC()==1&&DEFOUTC()==0THEN
  VSLOT_PRGEDIT DEFARG(0),1'FIXME
 ELSEIF DEFARGC()==2&&DEFOUTC()==0THEN
  VSLOT_PRGEDIT DEFARG(0),DEFARG(1)
 ELSE
  MISSING_PARAMETER "PRGEDIT"
 ENDIF
END

COMMON DEF SBSB_PRGDEL * OUT *
 IF DEFARGC()==0&&DEFOUTC()==0THEN
  VSLOT_PRGDEL 1
 ELSEIF DEFARGC()==1&&DEFOUTC()==0THEN
  VSLOT_PRGDEL DEFARG(0)
 ELSE
  MISSING_PARAMETER "PRGDEL"
 ENDIF
END

COMMON DEF SBSB_PRGSET * OUT *
 IF DEFARGC()==1&&DEFOUTC()==0THEN
  VSLOT_PRGSET DEFARG(0)
 ELSE
  MISSING_PARAMETER "PRGSET"
 ENDIF
END
'REGISTER BASED
ENUM\
 #RIR_MOVINT,\
 #RIR_MOVREAL,\
 #RIR_MOVSTR,\
 #RIR_MOVEMPTY,\
 #RIR_MOVREG,\
 #RIR_ADD,\
 #RIR_SUB,\
 #RIR_MUL,\
 #RIR_DIV,\
 #RIR_DIVINT,\
 #RIR_MOD,\
 #RIR_AND,\
 #RIR_OR,\
 #RIR_XOR,\
 #RIR_EQ,\
 #RIR_NEQ,\
 #RIR_LSHIFT,\
 #RIR_RSHIFT,\
 #RIR_GREAT,\
 #RIR_LESS,\
 #RIR_GEQ,\
 #RIR_LEQ,\
 #RIR_LNOT,\
 #RIR_NOT,\
 #RIR_NEG,\
 #RIR_SETGLOBAL,\
 #RIR_SETLOCAL,\
 #RIR_SETVAR,\
 #RIR_SETINARG,\
 #RIR_SETOUTARG,\
 #RIR_GETGLOBAL,\
 #RIR_GETLOCAL,\
 #RIR_GETVAR,\
 #RIR_GETINARG,\
 #RIR_GETOUTARG,\
 #RIR_BR,\
 #RIR_BRFALSE,\
 #RIR_BRTRUE,\
 #RIR_PRINT,\
 #RIR_TPRINT,\
 #RIR_CALL,\
 #RIR_LEAVE,\
 #RIR_END,\
 #RIR_DEFFUN,\
 #RIR_FORGLOBAL,\
 #RIR_FORLOCAL,\
 #RIR_FORINARG,\
 #RIR_FOROUTARG,\
 #RIR_FORARRAY,\
 #RIR_FORVAR,\
 #RIR_NEWARRAY,\
 #RIR_SETARRAY,\
 #RIR_GETARRAY,\
 #RIR_DATAINT,\
 #RIR_DATAREAL,\
 #RIR_DATASTR,\
 #RIR_READ,\
 #RIR_GOTO,\
 #RIR_GOSUB,\
 #RIR_LABEL,\
 #RIR_RESTORE,\
 #RIR_RESTOREEXPR,\
 #RIR_INC,\
 #RIR_CALLSPRITE,\
 #RIR_CALLTEXT,\
 #RIR_BRAND,\
 #RIR_BROR,\
 #RIR_WHEN,\
 #RIR_OTHERWISE,\
 #RIR_STOP1,\
 #RIR_STOP2,\
 #RIR_EXEC1,\
 #RIR_EXEC2,\
 #RIR_RETURN,\
 #RIR_CALLSPRITEINIT,\
 #RIR_CALLTEXTINIT,\
 #RIR_CALLBACKEND,\
 #RIR_GOTOEXPR,\
 #RIR_GOSUBEXPR,\
 #RIR_ONGOTO,\
 #RIR_CLEANSTACK,\
 #RIR_SPILLVAR,\
 #RIR_FILLVAR,\
 #RIR_SPILLVAR2,\
 #RIR_FILLVAR2,\
 #RIR_SWAP,\
 #RIR_DEFOUT,\
 #RIR_INPUT,\
 #RIR_INPUTGUIDE,\
 #RIR_LINPUT,\
 #RIR_LINPUTGUIDE,\
 #RIR_EMPTYREG,\
 #RIR_DBG_TEMP_STOP,\
 #RIR_
DEF RIR_STR$(T)
 CASE T
 WHEN #RIR_MOVINT:RETURN "#RIR_MOVINT"WHEN #RIR_MOVREAL:RETURN "#RIR_MOVREAL"WHEN #RIR_MOVSTR:RETURN "#RIR_MOVSTR"WHEN #RIR_MOVEMPTY:RETURN "#RIR_MOVEMPTY"WHEN #RIR_MOVREG:RETURN "#RIR_MOVREG"WHEN #RIR_ADD:RETURN "#RIR_ADD"WHEN #RIR_SUB:RETURN "#RIR_SUB"WHEN #RIR_MUL:RETURN "#RIR_MUL"WHEN #RIR_DIV:RETURN "#RIR_DIV"WHEN #RIR_DIVINT:RETURN "#RIR_DIVINT"WHEN #RIR_MOD:RETURN "#RIR_MOD"WHEN #RIR_AND:RETURN "#RIR_AND"WHEN #RIR_OR:RETURN "#RIR_OR"WHEN #RIR_XOR:RETURN "#RIR_XOR"WHEN #RIR_EQ:RETURN "#RIR_EQ"WHEN #RIR_NEQ:RETURN "#RIR_NEQ"WHEN #RIR_LSHIFT:RETURN "#RIR_LSHIFT"WHEN #RIR_RSHIFT:RETURN "#RIR_RSHIFT"WHEN #RIR_GREAT:RETURN "#RIR_GREAT"WHEN #RIR_LESS:RETURN "#RIR_LESS"WHEN #RIR_GEQ:RETURN "#RIR_GEQ"WHEN #RIR_LEQ:RETURN "#RIR_LEQ"WHEN #RIR_LNOT:RETURN "#RIR_LNOT"WHEN #RIR_NOT:RETURN "#RIR_NOT"WHEN #RIR_NEG:RETURN "#RIR_NEG"WHEN #RIR_SETGLOBAL:RETURN "#RIR_SETGLOBAL"WHEN #RIR_SETLOCAL:RETURN "#RIR_SETLOCAL"WHEN #RIR_SETVAR:RETURN "#RIR_SETVAR"WHEN #RIR_SETINARG:RETURN "#RIR_SETINARG"WHEN #RIR_SETOUTARG:RETURN "#RIR_SETOUTARG"WHEN #RIR_GETGLOBAL:RETURN "#RIR_GETGLOBAL"WHEN #RIR_GETLOCAL:RETURN "#RIR_GETLOCAL"WHEN #RIR_GETVAR:RETURN "#RIR_GETVAR"WHEN #RIR_GETINARG:RETURN "#RIR_GETINARG"WHEN #RIR_GETOUTARG:RETURN "#RIR_GETOUTARG"WHEN #RIR_BR:RETURN "#RIR_BR"WHEN #RIR_BRFALSE:RETURN "#RIR_BRFALSE"WHEN #RIR_BRTRUE:RETURN "#RIR_BRTRUE"WHEN #RIR_PRINT:RETURN "#RIR_PRINT"WHEN #RIR_TPRINT:RETURN "#RIR_TPRINT"WHEN #RIR_CALL:RETURN "#RIR_CALL"WHEN #RIR_LEAVE:RETURN "#RIR_LEAVE"WHEN #RIR_END:RETURN "#RIR_END"WHEN #RIR_DEFFUN:RETURN "#RIR_DEFFUN"WHEN #RIR_FORGLOBAL:RETURN "#RIR_FORGLOBAL"WHEN #RIR_FORLOCAL:RETURN "#RIR_FORLOCAL"WHEN #RIR_FORINARG:RETURN "#RIR_FORINARG"WHEN #RIR_FOROUTARG:RETURN "#RIR_FOROUTARG"WHEN #RIR_NEWARRAY:RETURN "#RIR_NEWARRAY"WHEN #RIR_SETARRAY:RETURN "#RIR_SETARRAY"WHEN #RIR_GETARRAY:RETURN "#RIR_GETARRAY"WHEN #RIR_DATAINT:RETURN "#RIR_DATAINT"WHEN #RIR_DATAREAL:RETURN "#RIR_DATAREAL"WHEN #RIR_DATASTR:RETURN "#RIR_DATASTR"WHEN #RIR_READ:RETURN "#RIR_READ"WHEN #RIR_GOTO:RETURN "#RIR_GOTO"WHEN #RIR_GOSUB:RETURN "#RIR_GOSUB"WHEN #RIR_GOTOEXPR:RETURN "#RIR_GOTOEXPR"WHEN #RIR_GOSUBEXPR:RETURN "#RIR_GOSUBEXPR"WHEN #RIR_LABEL:RETURN "#RIR_LABEL"WHEN #RIR_RESTORE:RETURN "#RIR_RESTORE"WHEN #RIR_RESTOREEXPR:RETURN "#RIR_RESTOREEXPR"WHEN #RIR_INC:RETURN "#RIR_INC"WHEN #RIR_CALLSPRITE:RETURN "#RIR_CALLSPRITE"WHEN #RIR_CALLTEXT:RETURN "#RIR_CALLTEXT"WHEN #RIR_BRAND:RETURN "#RIR_BRAND"WHEN #RIR_BROR:RETURN "#RIR_BROR"WHEN #RIR_WHEN:RETURN "#RIR_WHEN"WHEN #RIR_OTHERWISE:RETURN "#RIR_OTHERWISE"
 OTHERWISE
  RETURN "#RIR_"+STR$(T)
 ENDCASE
END
DIM RIR_OPS[]
DIM RIR_IMM#[]
DIM RIR_IMM$[]
DEF INIT_RIR_CODEGEN
 RIR_OPS=ARRAY%(0)
 RIR_IMM#=ARRAY#(0)
 RIR_IMM$=ARRAY$(0)
 VM_OPS=RIR_OPS
 VM_IMM#=RIR_IMM#
 VM_IMM$=RIR_IMM$
END
DEF REMIT OP
 PUSH RIR_OPS,OP
END
DEF REMIT_IMM# IMM#
 PUSH RIR_IMM#,IMM#
 PUSH RIR_OPS,LAST(RIR_IMM#)
END
DEF REMIT_IMM$ IMM$
 PUSH RIR_IMM$,IMM$
 PUSH RIR_OPS,LAST(RIR_IMM$)
END
DEF RIR_SET ADDR,V
 RIR_OPS[ADDR]=V
END
DEF RIR_GET_ADDR()
 RETURN LAST(RIR_OPS)
END
DEF RIR_NEXT_ADDR()
 RETURN LEN(RIR_OPS)
END

DEF RIR_DUMP
 VAR I
 LOOP
  IF I>=LEN(RIR_OPS) THEN
   BREAK
  ENDIF
  ?"@0"+HEX$(I);":";
  VAR C=RIR_OPS[I]
  INC I
  CASE C
  WHEN #RIR_MOVINT
   ?"R";RIR_OPS[I];"=";RIR_OPS[I+1]
   INC I,2
  WHEN #RIR_MOVREAL
   ?"R";RIR_OPS[I];"=";RIR_IMM#[RIR_OPS[I+1]]
   INC I,2
  WHEN #RIR_MOVSTR
   ?"R";RIR_OPS[I];"=";CHR$(34);RIR_IMM$[RIR_OPS[I+1]];CHR$(34)
   INC I,2
  WHEN #RIR_ADD
  WHEN #RIR_ADD
  WHEN #RIR_SUB
  WHEN #RIR_MUL
  WHEN #RIR_DIV
  WHEN #RIR_DIVINT
  WHEN #RIR_MOD
  WHEN #RIR_AND
  WHEN #RIR_OR
  WHEN #RIR_XOR
  WHEN #RIR_EQ
  WHEN #RIR_NEQ
  WHEN #RIR_LSHIFT
  WHEN #RIR_RSHIFT
  WHEN #RIR_GREAT
  WHEN #RIR_LESS
  WHEN #RIR_GEQ
  WHEN #RIR_LEQ
   ?"R";RIR_OPS[I];"=";"R";RIR_OPS[I+1];RIR_GET_OP$(C);"R";RIR_OPS[I+2]
   INC I,3
  WHEN #RIR_GETGLOBAL
   ?"R";RIR_OPS[I];"=G0";RIR_OPS[I+1]
   INC I,2
  WHEN #RIR_GETLOCAL
   ?"R";RIR_OPS[I];"=L";RIR_OPS[I+1]
   INC I,2
  WHEN #RIR_SETGLOBAL
   ?"G0";RIR_OPS[I];"=R";RIR_OPS[I+1]
   INC I,2
  WHEN #RIR_SETLOCAL
   ?"L";RIR_OPS[I];"=R";RIR_OPS[I+1]
   INC I,2
  WHEN #RIR_PRINT
   VAR CNT=RIR_OPS[I]*2+I-1
   ?"?";
   FOR I=I+1 TO CNT STEP 2
    ?"R";RIR_OPS[I+1];
    IF RIR_OPS[I]==0 THEN
     ?",";
    ELSEIF RIR_OPS[I]==1 THEN
    ELSEIF RIR_OPS[I]==2 THEN
     ?";";
    ENDIF
   NEXT
   ?
  WHEN #RIR_BRFALSE
   ?"IF R";RIR_OPS[I];" THEN ELSE GOTO@0";HEX$(RIR_OPS[I+1])
   INC I,2
  WHEN #RIR_BRTRUE
   ?"IF R";RIR_OPS[I];" GOTO@0";HEX$(RIR_OPS[I+1])
   INC I,2
  WHEN #RIR_BR
   ?"GOTO@0";HEX$(RIR_OPS[I])
   INC I
  OTHERWISE
   STOP
  ENDCASE
 ENDLOOP
END
VAR RCMP_REG
VAR RIR_SBCODE$
VAR RIR_LINE
VAR RGEN_FAST_LARGE

DEF RGEN_EMIT_SBCODE C$
 VAR I=INSTR(C$,CHR$(10))
 WHILE I!=-1
  INC RIR_LINE
  I=INSTR(I+1,C$,CHR$(10))
 WEND
 PUSH RIR_SBCODE$,C$
END
DEF RGEN_FLUSH_SBCODE
 PRGSET RIR_SBCODE$
 IF LEN(RIR_SBCODE$)>PRGSIZE(RVM_SLOT,2)THEN
  ?LEN(RIR_SBCODE$)
  STOP
 ENDIF
 RIR_SBCODE$=""
 RIR_LINE=PRGEDIT()
END
DEF RGEN_SET_SBCODE
 PRGSET RIR_SBCODE$
 RIR_SBCODE$=""
 RIR_LINE=PRGEDIT()
END
DIM RGEN_REG_TABLE[]
DIM RGEN_REG_TABLE_TYPE[]
DIM RGEN_REG_TABLE_CONST%[]
DIM RGEN_REG_TABLE_CONST#[]
DIM RGEN_REG_TABLE_CONST$[]
DIM RGEN_REG[]
DIM RGEN_REG_TYPE[]
DIM RGEN_REG_NEXT[]
DIM RGEN_REG_USED[]
VAR RGEN_REG_FREE
ENUM #RGEN_REG_NONE,#RGEN_REG_CONST

DEF RGEN_ALLOC_CONST% REG,V
 RGEN_REG_TABLE[REG]=-2
 RGEN_REG_TABLE_TYPE[REG]=#T_INT
 RGEN_REG_TABLE_CONST%[REG]=V
END
DEF RGEN_ALLOC_CONST# REG,V
 RGEN_REG_TABLE[REG]=-2
 RGEN_REG_TABLE_TYPE[REG]=#T_REAL
 RGEN_REG_TABLE_CONST#[REG]=V
END
DEF RGEN_ALLOC_CONST$ REG,V
 RGEN_REG_TABLE[REG]=-2
 RGEN_REG_TABLE_TYPE[REG]=#T_STR
 RGEN_REG_TABLE_CONST$[REG]=V
END
DEF RGEN_ALLOC_EXPR REG,V
 RGEN_REG_TABLE[REG]=-3
 RGEN_REG_TABLE_CONST$[REG]=V
END
DEF RGEN_ALLOC_REG(REG)
 IF RGEN_REG_TABLE[REG]!=-1&&RGEN_REG_USED[RGEN_REG_TABLE[REG]] THEN RETURN RGEN_REG_TABLE[REG]
 IF RGEN_REG_FREE!=-1 THEN
  VAR L=RGEN_REG_FREE
  RGEN_REG_FREE=RGEN_REG_NEXT[RGEN_REG_FREE]
 ELSE
  PUSH RGEN_REG,0
  PUSH RGEN_REG_TYPE,0
  PUSH RGEN_REG_NEXT,-1
  PUSH RGEN_REG_USED,0
  L=LAST(RGEN_REG)
  RGEN_REG[L]=L
 ENDIF
 RGEN_REG[L]=REG
 RGEN_REG_TABLE[REG]=L
 RGEN_REG_USED[L]=#TRUE
 RETURN L
END
DEF RGEN_FREE_REG REG
 IF REG==-1THEN RETURN
 RGEN_REG_NEXT[REG]=RGEN_REG_FREE
 RGEN_REG_USED[REG]=#FALSE
 RGEN_REG_FREE=REG
 RGEN_REG_TABLE[RGEN_REG[REG]]=-99
END
ENUM #RGEN_REG_TYPE_CONST,#RGEN_REG_TYPE_REG
DEF RGEN_GET_REG_TYPE REG OUT R,R$,TYP
 IF RGEN_REG_TABLE[REG]==-1THEN
  STOP
 ELSEIF RGEN_REG_TABLE[REG]==-99THEN
  STOP "FRE
 ELSEIF RGEN_REG_TABLE[REG]==-2THEN
  IF RGEN_REG_TABLE_TYPE[REG]==#T_INT THEN
   R=-1
   R$=STR$(RGEN_REG_TABLE_CONST%[REG])
  ELSEIF RGEN_REG_TABLE_TYPE[REG]==#T_REAL THEN
   R=-1
   R$=STR$(RGEN_REG_TABLE_CONST#[REG])
  ELSEIF RGEN_REG_TABLE_TYPE[REG]==#T_STR THEN
   R=-1
   R$=CHR$(34)+RGEN_REG_TABLE_CONST$[REG]+CHR$(34)
  ENDIF
  TYP=#RGEN_REG_TYPE_CONST
 ELSEIF RGEN_REG_TABLE[REG]==-3THEN
  R=-1
  R$=RGEN_REG_TABLE_CONST$[REG]
  TYP=#RGEN_REG_TYPE_CONST
 ELSE
  R=RGEN_REG_TABLE[REG]
  R$=RGEN_REG_STR$(R)
  TYP=#RGEN_REG_TYPE_REG
 ENDIF
END
DEF RGEN_GET_REG_CONST REG OUT C
 IF RGEN_REG_TABLE[REG]==-1THEN
  STOP
 ELSEIF RGEN_REG_TABLE[REG]==-99THEN
  STOP "FRE
 ELSEIF RGEN_REG_TABLE[REG]==-2THEN
  IF RGEN_REG_TABLE_TYPE[REG]==#T_INT THEN
   C=RGEN_REG_TABLE_CONST%[REG]
  ELSEIF RGEN_REG_TABLE_TYPE[REG]==#T_REAL THEN
   C=RGEN_REG_TABLE_CONST#[REG]
  ELSEIF RGEN_REG_TABLE_TYPE[REG]==#T_STR THEN
   C=RGEN_REG_TABLE_CONST$[REG]
  ENDIF
 ELSEIF RGEN_REG_TABLE[REG]==-3THEN
 ELSE
 ENDIF
END
DEF RGEN_GET_REG REG OUT R,R$
 IF RGEN_REG_TABLE[REG]==-1THEN
  STOP
 ELSEIF RGEN_REG_TABLE[REG]==-99THEN
  STOP "FRE
 ELSEIF RGEN_REG_TABLE[REG]==-2THEN
  IF RGEN_REG_TABLE_TYPE[REG]==#T_INT THEN
   R=-1
   R$=STR$(RGEN_REG_TABLE_CONST%[REG])
  ELSEIF RGEN_REG_TABLE_TYPE[REG]==#T_REAL THEN
   R=-1
   R$=STR$(RGEN_REG_TABLE_CONST#[REG])
  ELSEIF RGEN_REG_TABLE_TYPE[REG]==#T_STR THEN
   R=-1
   R$=CHR$(34)+RGEN_REG_TABLE_CONST$[REG]+CHR$(34)
  ENDIF
 ELSEIF RGEN_REG_TABLE[REG]==-3THEN
  R=-1
  R$=RGEN_REG_TABLE_CONST$[REG]
 ELSE
  R=RGEN_REG_TABLE[REG]
  R$=RGEN_REG_STR$(R)
 ENDIF
END
DEF RGEN_REG_STR$(R)
 RETURN "R"+STR$(R)
END
DEF RGEN_GLOBAL_STR$(R)
 RETURN "G"+STR$(CMP_SLOT)+STR$(R)
END
DEF RGEN_GLOBAL_STR_SLOT$(SLOT,R)
 RETURN "G"+STR$(SLOT)+STR$(R)
END
DEF RGEN_LOCAL_STR$(R)
 RETURN "L"+STR$(R)
END
DEF RGEN_INARG_STR$(R)
 RETURN "I"+STR$(R)
END
DEF RGEN_OUTARG_STR$(R)
 RETURN "O"+STR$(R)
END
DIM RGEN_SLOT_RJMP_TABLE[]
DIM RGEN_RJMP_TABLE[]

DEF RGEN_BASE32$(R)
 RETURN HEX$(R)
 VAR TBL$="0123456789ABCDEFGHIJKLMNOPQRSTUV"
 IF!R THEN RETURN "0"
 VAR R$=" "*(LOG(R,32)+1)
 VAR I=LAST(R$)
 REPEAT
  R$[I]=TBL$[R MOD 32]
  DEC I
  R=R DIV 32
 UNTIL !R
 RETURN R$
END
DEF RGEN_LABEL$(CURRENT_PC,R)
 RETURN "@"+STR$(CMP_SLOT)+RGEN_BASE32$(R)
END
DEF RGEN_LABEL2$(SLOT,PC)
 RETURN "@"+STR$(SLOT)+RGEN_BASE32$(PC)
END
DEF RGEN_FUNC$(FUNC$)
 RETURN RGEN_FUNC_SLOT$(CMP_SLOT,FUNC$)
END
DEF RGEN_FUNC_SLOT$(CMP_SLOT,FUNC$)
 IF FUNC$[LAST(FUNC$)]=="%"THEN
  RETURN "@FI"+STR$(CMP_SLOT)+MID$(FUNC$,0,LAST(FUNC$))
 ELSEIF FUNC$[LAST(FUNC$)]=="$"THEN
  RETURN "@FS"+STR$(CMP_SLOT)+MID$(FUNC$,0,LAST(FUNC$))
 ELSEIF FUNC$[LAST(FUNC$)]=="#"THEN
  RETURN "@FR"+STR$(CMP_SLOT)+MID$(FUNC$,0,LAST(FUNC$))
 ELSE
  RETURN "@F"+STR$(CMP_SLOT)+FUNC$
 ENDIF
END
DEF RGEN_JMP_TABLE TBL
 VAR I,L=LAST(TBL)
 VAR PREFIX1$="@"+STR$(CMP_SLOT)
 VAR PREFIX$=",@"+STR$(CMP_SLOT)
 RGEN_EMIT_SBCODE "@JMP"+STR$(CMP_SLOT)
 RGEN_EMIT_SBCODE CHR$(10)
 RGEN_EMIT_SBCODE "ON VM_PC GOTO "
 FOR I=0TO L
  IF I THEN
   RGEN_EMIT_SBCODE PREFIX$+RGEN_BASE32$(TBL[I])'HEX$(TBL[I])
  ELSE
   RGEN_EMIT_SBCODE PREFIX1$+RGEN_BASE32$(TBL[I])'+HEX$(TBL[I])
  ENDIF
  IF I MOD 101==100 THEN
   RGEN_EMIT_SBCODE "\"
   RGEN_FLUSH_SBCODE
  ENDIF
 NEXT
 RGEN_EMIT_SBCODE CHR$(10)
 RGEN_EMIT_SBCODE "INTERNAL_ERROR"+CHR$(10)
END
VAR RGEN_SAVE_REGS_UNIQ
VAR RGEN_FUNC=0
DEF RGEN_GEN_SAVE_REG R$
 RGEN_EMIT_SBCODE "S "+R$+":"
END

DEF RGEN_GEN_SAVE_REG2 R$
 IF !RGEN_FAST_LARGE THEN
  RGEN_GEN_SAVE_REG R$
  RETURN
 ENDIF
 RGEN_EMIT_SBCODE\
  "ON TYPEOF("+R$+")GOTO"+\
  "@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ)+","+\
  "@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+1)+","+\
  "@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+2)+","+\
  "@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+3)+":"+\
\
  "T[P]=TYPEOF("+R$+"):I[P]=VM_ALLOC_ARRAY("+R$+"):GOTO@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+4)+":"+\
  "@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ)+":"+\
  "T[P]=0GOTO@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+4)+\
  "@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+1)+":"+\
  "T[P]=1I[P]="+R$+":GOTO@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+4)+\
  "@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+2)+":"+\
  "T[P]=2R[P]="+R$+":GOTO@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+4)+\
  "@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+3)+":"+\
  "T[P]=3S[P]="+R$+":"+\
  "@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+4)+":"+\
  "INC P"+\
  CHR$(10)
 INC RGEN_SAVE_REGS_UNIQ,5
END
DIM RGEN_SAVED_REGS[]
ENUM\
 #RVMSTK_LVAR=-5,\
 #RVMSTK_PC_I=-4,\
 #RVMSTK_SLOT=-3,\
 #RVMSTK_BP=-1,\
 #RVMSTK_FUNC=-2
DEF RGEN_GEN_SAVE_ALL_REGS EXCEPT_REGS
 VAR I,L=LAST(RGEN_REG_USED)
 IF TYPEOF(RGEN_SAVED_REGS)THEN STOP
 RGEN_SAVED_REGS=ARRAY%(0)
 FOR I=0TO L
  IF !RGEN_REG_USED[I] THEN CONTINUE
  VAR J
  FOR J=0TO LAST(EXCEPT_REGS)
   IF EXCEPT_REGS[J]==I THEN @CONTINUE
  NEXT
  VAR R$=RGEN_REG_STR$(I)
  RGEN_GEN_SAVE_REG R$
  PUSH RGEN_SAVED_REGS,I
  @CONTINUE
 NEXT
 RGEN_EMIT_SBCODE "INC P:"'FIXME
 IF 0&&RGEN_FUNC THEN
  IF FUNC_INCNT[RGEN_FUNC]==-1 THEN
   RGEN_EMIT_SBCODE "I[P]=ICNT:INC P"+CHR$(10)
  ELSE
   FOR I=0TO FUNC_INCNT[RGEN_FUNC]-1
    RGEN_GEN_SAVE_REG RGEN_INARG_STR$(I)
   NEXT
  ENDIF
  IF FUNC_OUTCNT[RGEN_FUNC]==-1 THEN
   RGEN_EMIT_SBCODE "I[P]=OCNT:INC P"+CHR$(10)
  ELSE
   FOR I=0TO FUNC_OUTCNT[RGEN_FUNC]-1
    RGEN_GEN_SAVE_REG RGEN_OUTARG_STR$(I)
   NEXT
  ENDIF
  FOR I=0TO FUNC_VARNUM[RGEN_FUNC]-1
   RGEN_GEN_SAVE_REG RGEN_LOCAL_STR$(I)
  NEXT
  RGEN_EMIT_SBCODE "I[P]=RET:INC P:I[P]=RETS:INC P:I[P]=VM_CURFUNC:INC P:I[P]=VM_BP:INC P:VM_BP=P"+CHR$(10)
 ENDIF
END
DEF RGEN_GEN_SPILLVAR JUMP
 IF RGEN_FUNC THEN
  VAR I
  IF FUNC_INCNT[RGEN_FUNC]==-1 THEN
   RGEN_EMIT_SBCODE "FOR TEMP=0TO ICNT-1S VAR("+CHR$(34)+"I"+CHR$(34)+"+STR$(TEMP)):NEXT:"
   RGEN_EMIT_SBCODE "I[P]=ICNT:INC P"+CHR$(10)
  ELSE
   FOR I=0TO FUNC_INCNT[RGEN_FUNC]-1
    RGEN_GEN_SAVE_REG2 RGEN_INARG_STR$(I)
   NEXT
  ENDIF
  IF FUNC_OUTCNT[RGEN_FUNC]==-1 THEN
   RGEN_EMIT_SBCODE "FOR TEMP=0TO OCNT-1S VAR("+CHR$(34)+"O"+CHR$(34)+"+STR$(TEMP)):NEXT:"
   RGEN_EMIT_SBCODE "I[P]=OCNT:INC P"+CHR$(10)
  ELSE
   FOR I=0TO FUNC_OUTCNT[RGEN_FUNC]-1
    RGEN_GEN_SAVE_REG2 RGEN_OUTARG_STR$(I)
   NEXT
  ENDIF
  FOR I=0TO FUNC_VARNUM[RGEN_FUNC]-1
   RGEN_GEN_SAVE_REG2 RGEN_LOCAL_STR$(I)
  NEXT
  RGEN_EMIT_SBCODE "I[P]=RET:INC P:I[P]=RETS:INC P:I[P]=VM_CURFUNC:INC P:I[P]=VM_BP:INC P:VM_BP=P"
  IF JUMP THEN RGEN_EMIT_SBCODE ":GOTO@JMP"+STR$(CMP_SLOT)+CHR$(10)
 ENDIF
END
DEF RGEN_GEN_LOAD_REG R$
 RGEN_EMIT_SBCODE R$+"=L():"
END

DEF RGEN_GEN_LOAD_REG2 R$
 IF !RGEN_FAST_LARGE THEN
  RGEN_GEN_LOAD_REG R$
  RETURN
 ENDIF
 RGEN_EMIT_SBCODE\
  "DEC P:ON T[P]GOTO"+\
  "@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ)+","+\
  "@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+1)+","+\
  "@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+2)+","+\
  "@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+3)+":"+\
\
  R$+"=VM_GETFREE_ARRAY(I[P])GOTO"+"@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+4)+":"+\
  "@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ)+":"+\
  R$+"=EMPTY:GOTO@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+4)+\
  "@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+1)+":"+\
  R$+"=I[P]GOTO@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+4)+\
  "@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+2)+":"+\
  R$+"=R[P]GOTO@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+4)+\
  "@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+3)+":"+\
  R$+"=S[P]:"+\
  "@S"+RGEN_BASE32$(RGEN_SAVE_REGS_UNIQ+4)+\
  CHR$(10)
 INC RGEN_SAVE_REGS_UNIQ,5
END
DEF RGEN_GEN_FILLVAR JMP
 IF RGEN_FUNC THEN
  RGEN_EMIT_SBCODE "P=VM_BP:DEC P:VM_BP=I[P]:DEC P:VM_CURFUNC=I[P]:DEC P:RETS=I[P]:DEC P:RET=I[P]"+CHR$(10)
 VAR I
  IF FUNC_INCNT[RGEN_FUNC]==-1 THEN
  ENDIF
  FOR I=FUNC_VARNUM[RGEN_FUNC]-1 TO 0 STEP -1
   RGEN_GEN_LOAD_REG2 RGEN_LOCAL_STR$(I)
  NEXT
  IF FUNC_OUTCNT[RGEN_FUNC]==-1 THEN
   RGEN_EMIT_SBCODE "DEC P:OCNT=I[P]"+CHR$(10)
   RGEN_EMIT_SBCODE "FOR TEMP=OCNT-1TO 0STEP -1VAR("+CHR$(34)+"O"+CHR$(34)+"+STR$(TEMP))=L():NEXT:"
  ELSE
   RGEN_EMIT_SBCODE "OCNT="+STR$(FUNC_INCNT[RGEN_FUNC])+":"
   FOR I=FUNC_OUTCNT[RGEN_FUNC]-1 TO 0 STEP -1
    RGEN_GEN_LOAD_REG2 RGEN_OUTARG_STR$(I)
   NEXT
  ENDIF
  IF FUNC_INCNT[RGEN_FUNC]==-1 THEN
   RGEN_EMIT_SBCODE "DEC P:ICNT=I[P]"+CHR$(10)
   RGEN_EMIT_SBCODE "FOR TEMP=ICNT-1TO 0STEP -1VAR("+CHR$(34)+"I"+CHR$(34)+"+STR$(TEMP))=L():NEXT:"
  ELSE
   RGEN_EMIT_SBCODE "ICNT="+STR$(FUNC_INCNT[RGEN_FUNC])+":"
   FOR I=FUNC_INCNT[RGEN_FUNC]-1 TO 0 STEP -1
    RGEN_GEN_LOAD_REG2 RGEN_INARG_STR$(I)
   NEXT
  ENDIF
  IF JMP THEN RGEN_EMIT_SBCODE "GOTO@JMP"+STR$(CMP_SLOT)
 ENDIF
END
DEF RGEN_GEN_LOAD_ALL_REGS
 VAR I,L=LAST(RGEN_SAVED_REGS)
 IF 0&&RGEN_FUNC THEN
  RGEN_EMIT_SBCODE "P=VM_BP:DEC P:VM_BP=I[P]:DEC P:VM_CURFUNC=I[P]:DEC P:RETS=I[P]:DEC P:RET=I[P]"+CHR$(10)
  FOR I=FUNC_VARNUM[RGEN_FUNC]-1 TO 0 STEP -1
   RGEN_GEN_LOAD_REG RGEN_LOCAL_STR$(I)
  NEXT
  IF FUNC_OUTCNT[RGEN_FUNC]==-1 THEN
   RGEN_EMIT_SBCODE "DEC P:OCNT=I[P]"+CHR$(10)
  ELSE
   FOR I=FUNC_OUTCNT[RGEN_FUNC]-1 TO 0 STEP -1
    RGEN_GEN_LOAD_REG RGEN_OUTARG_STR$(I)
   NEXT
  ENDIF
  IF FUNC_INCNT[RGEN_FUNC]==-1 THEN
   RGEN_EMIT_SBCODE "DEC P:ICNT=I[P]"+CHR$(10)
  ELSE
   FOR I=FUNC_INCNT[RGEN_FUNC]-1 TO 0 STEP -1
    RGEN_GEN_LOAD_REG RGEN_INARG_STR$(I)
   NEXT
  ENDIF
 ENDIF
 RGEN_EMIT_SBCODE "DEC P:"'FIXME
 FOR I=L TO 0 STEP -1
  VAR R$=RGEN_REG_STR$(RGEN_SAVED_REGS[I])
  RGEN_GEN_LOAD_REG R$
 NEXT
 RGEN_SAVED_REGS=EMPTY()
END
DEF RIR_DATA_ESCAPE$ D$ OUT R$
 R$=""
 PUSH R$,CHR$(34)
 VAR I,L=LAST(D$)
 FOR I=0TO L
  VAR C$=D$[I]
  IF ASC(C$)==34 THEN
   PUSH R$,CHR$(34)+"+CHR$(34)+"CHR$(34)
  ELSEIF ASC(C$)==10 THEN
   PUSH R$,CHR$(34)+"+CHR$(10)+"CHR$(34)
  ELSEIF ASC(C$)==13 THEN
   PUSH R$,CHR$(34)+"+CHR$(13)+"CHR$(34)
  ELSE
   PUSH R$,C$
  ENDIF
 NEXT
 PUSH R$,CHR$(34)
END
DEF RGEN_INIT_LOCAL_VAR NODE
 IF !NODE THEN RETURN
 RGEN_INIT_LOCAL_VAR GET_SPLAYN_LEFT(NODE)
 VAR V=GET_SPLAYN_VAL%(NODE)
 VAR IDX=VAR_IDX[V]
 VAR TYP=VAR_TYP[V]
 IF IDX>=0 THEN
  CASE TYP
  WHEN #VMT_INT
   RGEN_EMIT_SBCODE RGEN_LOCAL_STR$(IDX)+"=0:"
  WHEN #VMT_REAL
   RGEN_EMIT_SBCODE RGEN_LOCAL_STR$(IDX)+"=0#:"
  WHEN #VMT_STR
   RGEN_EMIT_SBCODE RGEN_LOCAL_STR$(IDX)+"=EMPTY$:"
  OTHERWISE
   RGEN_EMIT_SBCODE RGEN_LOCAL_STR$(IDX)+"=EMPTY:"
  ENDCASE
 ENDIF
 RGEN_INIT_LOCAL_VAR GET_SPLAYN_RIGHT(NODE)
END

VAR RCMP_MAX_LOCAL
VAR RCMP_MAX_INARG
VAR RCMP_MAX_OUTARG
DIM RIR_OPS_LINE[]
DIM RIR_OPS_LINE_PC[]
DIM RIR_SLOT_OPS_LINE[]
DIM RIR_SLOT_OPS_LINE_PC[]
VAR RIR_VM_STK_TYP
VAR RIR_VM_STK%
VAR RIR_VM_STK$
VAR RIR_VM_STK#
VAR RIR_VM_SP$
ENUM #RVM_RETCODE_END,\
 #RVM_RETCODE_STOP,\
 #RVM_RETCODE_STOP2,\
 #RVM_RETCODE_TRACE_BP,\
 #RVM_RETCODE_BP,\
 #RVM_RETCODE_INTERRUPT,\
 #RVM_RETCODE_EXEC1,\
 #RVM_RETCODE_EXEC2,\
 #RVM_RETCODE_ERR,\
 #RVM_RETCODE_CALLSPRITE,\
 #RVM_RETCODE_CALLTEXT,\
 #RVM_RETCODE_DBG_TEMP_STOP

DIM RVM_BREAK_POINTS[]
DIM RVM_BP[]
DIM RVM_TBP_SLOT[]
DIM RVM_SLOT_BREAK_POINTS[]
VAR RVM_GOTO_BREAK_POINT_LINE

DIM RVM_LOCAL_TYP[]
DIM RVM_LOCAL%[]
DIM RVM_LOCAL#[]
DIM RVM_LOCAL$[]
DIM RVM_INARG_TYP[]
DIM RVM_INARG%[]
DIM RVM_INARG#[]
DIM RVM_INARG$[]
DIM RVM_OUTARG_TYP[]
DIM RVM_OUTARG%[]
DIM RVM_OUTARG#[]
DIM RVM_OUTARG$[]
DIM RVM_REG_TYP[]
DIM RVM_REG%[]
DIM RVM_REG#[]
DIM RVM_REG$[]
VAR RVM_STOP_HANDLER$
VAR RGEN_INTERRUPT
DIM RVM_START_LINE_SLOT[]
DIM RVM_END_LINE_SLOT[]
DIM RVM_TEMP_STOP_ADDR[]
DEF RGEN_EMIT_BREAK_CODE PC
 IF!RGEN_INTERRUPT THEN RETURN
' RGEN_EMIT_SBCODE "IF KEYBOARD(72)THEN VM_PC="+STR$(PC)+"RETURN "+STR$(#RVM_RETCODE_INTERRUPT)+":ENDIF:"
 RGEN_EMIT_SBCODE "IF KEYBOARD(72)THEN VM_PC="+STR$(PC)+"RETURN "+STR$(#RVM_RETCODE_INTERRUPT)+":ELSE"
END
DEF RGEN_EMIT_BREAK_CODE_END PC
 IF!RGEN_INTERRUPT THEN RETURN
 RGEN_EMIT_SBCODE ":ENDIF"
END
DEF RVM_EXEC1 A1
 IF TYPEOF(A1)==#T_INT||TYPEOF(A1)==#T_REAL THEN
  RVM_EXEC A1
  RETURN
 ENDIF
 IF TYPEOF(A1)==#T_STR THEN
  SBSB_LOAD A1,VM_CURSLOT
  RVM_EXEC VM_CURSLOT
  RETURN
 ENDIF
 TYPE_MISMATCH "EXEC",1
END
DEF RVM_EXEC2 A1,A2
 SBSB_LOAD A1,A2
 RVM_EXEC A2
END
DEF RVM_FREE_SLOT SLOT
 VM_FREE_ARRAY RGEN_SLOT_RJMP_TABLE[SLOT]:RGEN_SLOT_RJMP_TABLE[SLOT]=0
 VM_FREE_ARRAY RVM_SLOT_BREAK_POINTS[SLOT]:RVM_SLOT_BREAK_POINTS[SLOT]=0
 VM_FREE_ARRAY RIR_SLOT_OPS_LINE[SLOT]:RIR_SLOT_OPS_LINE[SLOT]=0
 VM_FREE_ARRAY RIR_SLOT_OPS_LINE_PC[SLOT]:RIR_SLOT_OPS_LINE_PC[SLOT]=0
 VM_FREE_SLOT SLOT
END
DEF RVM_EXEC SLOT
 VAR RESET
 VAR IN$=GET_VSLOT$(SLOT)
 IF VM_SLOT_OPS[SLOT] THEN
  VAR I
  RESET=VM_SLOT_EXEC_ADDR[SLOT]!=-1||VM_CURSLOT==SLOT
  IF RESET THEN
   VAR L=VM_SP
   FOR I=1TO L
    VM_POP OUT ,
   NEXT
   VM_BP=0
   VM_CURFUNC=0
   VM_SP=0
  ENDIF
  RVM_FREE_SLOT SLOT
 ENDIF
 VAR OPC=VM_PC
 VAR OCURFUNC=VM_CURFUNC
 INIT_LEXER IN$
 INIT_AST
 INIT_PARSER SLOT
 VAR AST=PARSE()
 INIT_RCOMPILER SLOT
 RCOMPILE AST
' LOAD_VM_SLOT SLOT
 IF !RESET THEN
  VM_SLOT_EXEC_ADDR[SLOT]=OPC
  VM_SLOT_EXEC_FUNC[SLOT]=OCURFUNC
  VM_SLOT_EXEC_SLOT[SLOT]=VM_CURSLOT
 ENDIF
 VM_CURSLOT=SLOT
 RVM_SWITCH_SLOT VM_CURSLOT
 VM_PC=0
 VM_CURFUNC=0
 VM_PREV_PC=0
END
DEF RVM_SWITCH_SLOT SLOT
 RGEN_RJMP_TABLE=VM_GET_ARRAY(RGEN_SLOT_RJMP_TABLE[SLOT])
 RIR_OPS_LINE=VM_GET_ARRAY(RIR_SLOT_OPS_LINE[SLOT])
 RIR_OPS_LINE_PC=VM_GET_ARRAY(RIR_SLOT_OPS_LINE_PC[SLOT])
 RVM_BREAK_POINTS=VM_GET_ARRAY(RVM_SLOT_BREAK_POINTS[SLOT])
 VM_SWITCH_SLOT SLOT
END
VAR RGEN_NEXT_GEN_LINE
VAR RGEN_VAR_AREA
DEF RIR_GEN_SBCODE
 RGEN_INTERRUPT=#TRUE
 RGEN_FAST_LARGE=!#TRUE
 PRGEDIT RVM_SLOT
 RIR_OPS_LINE=ARRAY%(0)
 RIR_OPS_LINE_PC=ARRAY%(0)

 RGEN_REG_TABLE=ARRAY%(RCMP_REG+1)
 FILL RGEN_REG_TABLE,-1
 RGEN_REG_TABLE_TYPE=ARRAY%(RCMP_REG+1)
 RGEN_REG_TABLE_CONST%=ARRAY%(RCMP_REG+1)
 RGEN_REG_TABLE_CONST#=ARRAY#(RCMP_REG+1)
 RGEN_REG_TABLE_CONST$=ARRAY$(RCMP_REG+1)
 IF TYPEOF(RGEN_SLOT_RJMP_TABLE)==#T_DEFAULT THEN
  RGEN_REG=ARRAY%(0)
  RGEN_REG_TYPE=ARRAY%(0)
  RGEN_REG_NEXT=ARRAY%(0)
  RGEN_REG_USED=ARRAY%(0)
  RGEN_REG_FREE=-1
  PRGDEL -1
  RGEN_SAVE_REGS_UNIQ=0
  RGEN_EMIT_SBCODE "OPTION STRICT"+CHR$(10)
  'これだとアドレスをシュトクできない
  'DEBUGMON:KEYBOARD ^D
  'SEND STOP
  'CHKCHRでBreak onしゅとく(かんぺき)
 ' RGEN_EMIT_SBCODE "ON BREAK GOTO@BREAK"+CHR$(10)
  RGEN_EMIT_SBCODE "END"+CHR$(10)
  RGEN_EMIT_SBCODE "@BREAK"+CHR$(10)
  RGEN_EMIT_SBCODE "VAR RVM_STOP_HANDLER$"+CHR$(10)
  RGEN_EMIT_SBCODE "GOTO RVM_STOP_HANDLER$"+CHR$(10)
  RGEN_EMIT_SBCODE "END"+CHR$(10)
  RIR_VM_STK_TYP="T"
  RIR_VM_STK%="I"
  RIR_VM_STK#="R"
  RIR_VM_STK$="S"
  RIR_VM_SP$="P"
  RGEN_EMIT_SBCODE "DIM "+RIR_VM_STK_TYP+"[]"+CHR$(10)
  RGEN_EMIT_SBCODE "DIM "+RIR_VM_STK%+"[]"+CHR$(10)
  RGEN_EMIT_SBCODE "DIM "+RIR_VM_STK#+"[]"+CHR$(10)
  RGEN_EMIT_SBCODE "DIM "+RIR_VM_STK$+"[]"+CHR$(10)
  RGEN_EMIT_SBCODE "VAR VM_BP"+CHR$(10)
  RGEN_EMIT_SBCODE "VAR "+RIR_VM_SP$+CHR$(10)
  RGEN_EMIT_SBCODE "VAR EMPTY"+CHR$(10)
  RGEN_EMIT_SBCODE "VAR EMPTY$"+CHR$(10)
  RGEN_EMIT_SBCODE "VAR VM_PC"+CHR$(10)
  RGEN_EMIT_SBCODE "VAR VM_CURSLOT"+CHR$(10)
  RGEN_EMIT_SBCODE "VAR VM_CURFUNC"+CHR$(10)
  RGEN_EMIT_SBCODE "VAR VM_EXEC_ARG1"+CHR$(10)
  RGEN_EMIT_SBCODE "VAR VM_EXEC_ARG2"+CHR$(10)
  RGEN_EMIT_SBCODE "VAR VM_ERRNUM"+CHR$(10)
  RGEN_EMIT_SBCODE "VAR RET"+CHR$(10)
  RGEN_EMIT_SBCODE "VAR RETS"+CHR$(10)
  RGEN_EMIT_SBCODE "VAR ICNT"+CHR$(10)
  RGEN_EMIT_SBCODE "VAR OCNT"+CHR$(10)
  RGEN_EMIT_SBCODE "VAR ICALL$"+CHR$(10)
  RGEN_EMIT_SBCODE "VAR TEMP"+CHR$(10)
  RGEN_EMIT_SBCODE "VAR VM_STOP_MSG$"+CHR$(10)
  RGE1
  RGE2
  RGEN_EMIT_SBCODE CHR$(10)
  RGEN_EMIT_SBCODE CHR$(10)
  RGEN_EMIT_SBCODE CHR$(10)
  RGEN_EMIT_SBCODE CHR$(10)
  RGEN_EMIT_SBCODE CHR$(10)
  RGEN_EMIT_SBCODE CHR$(10)
  RGEN_EMIT_SBCODE CHR$(10)
  RGEN_EMIT_SBCODE CHR$(10)
  RGEN_EMIT_SBCODE CHR$(10)
  RGEN_EMIT_SBCODE CHR$(10)
  RGEN_FLUSH_SBCODE
  RGEN_VAR_AREA=PRGEDIT()
  RGEN_EMIT_SBCODE "DEF VM_RUN()"+CHR$(10)
  RGEN_FLUSH_SBCODE
  RVM_GOTO_BREAK_POINT_LINE=RIR_LINE-1
  RGEN_EMIT_SBCODE CHR$(10)
  RGEN_EMIT_SBCODE CHR$(10)
  RGEN_EMIT_SBCODE "ON VM_CURSLOT GOTO@JMP0,@JMP1,@JMP2,@JMP3"+CHR$(10)
  RGEN_FLUSH_SBCODE
  RCMP_MAX_LOCAL=0
  RCMP_MAX_INARG=0
  RCMP_MAX_OUTARG=0
  RGEN_SLOT_RJMP_TABLE=ARRAY%(LEN(VM_SLOT_OPS))
  RVM_SLOT_BREAK_POINTS=ARRAY%(LEN(VM_SLOT_OPS))
  RIR_SLOT_OPS_LINE=ARRAY%(LEN(VM_SLOT_OPS))
  RIR_SLOT_OPS_LINE_PC=ARRAY%(LEN(VM_SLOT_OPS))
  RVM_START_LINE_SLOT=ARRAY%(LEN(VM_SLOT_OPS))
  RVM_END_LINE_SLOT=ARRAY%(LEN(VM_SLOT_OPS))
  RVM_TEMP_STOP_ADDR=ARRAY%(LEN(VM_SLOT_OPS))
 ELSE
  VAR I
  IF RVM_START_LINE_SLOT[CMP_SLOT] THEN
   VAR OLDL=PRGEDIT()
   PRGEDIT RVM_SLOT,RVM_START_LINE_SLOT[CMP_SLOT]
   FOR I=0TO RVM_END_LINE_SLOT[CMP_SLOT]-RVM_START_LINE_SLOT[CMP_SLOT]
    PRGSET ""
   NEXT
   I=0
  ENDIF
  PRGEDIT RVM_SLOT,-1
  PRGDEL PRGEDIT()-RGEN_NEXT_GEN_LINE
  RGEN_FLUSH_SBCODE
 ENDIF
 RVM_START_LINE_SLOT[CMP_SLOT]=PRGEDIT()
 RIR_SBCODE$=""
 RGEN_RJMP_TABLE=ARRAY%(0)
 VAR TRACE=!#TRUE
 VAR PC=0,OPC=-1
 VAR J
 VAR NEED_LOAD
 VAR R1,R1$
 VAR R2,R2$
 VAR R3,R3$
 ?"COMPILE
 LOOP
  IF I>=LEN(RIR_OPS) THEN
   BREAK
  ENDIF
  IF OPC!=PC THEN
   RGEN_EMIT_SBCODE CHR$(10)
'   RGEN_EMIT_SBCODE "'"+STR$(PC)
'   RGEN_EMIT_SBCODE CHR$(10)
   PUSH RIR_OPS_LINE,RIR_LINE'PRGEDIT()
   PUSH RIR_OPS_LINE_PC,I
   RGEN_EMIT_SBCODE RGEN_LABEL$(I,I)+":"'"@"+STR$(CMP_SLOT)+HEX$(I)+":"
   OPC=PC
   PUSH RGEN_RJMP_TABLE,I
  ENDIF
  VAR C=RIR_OPS[I]
  INC I
  IF TRACE THEN ?I-1,RIR_STR$(C)
  CASE C
  WHEN #RIR_MOVINT
   RGEN_ALLOC_CONST% RIR_OPS[I],RIR_OPS[I+1]
   INC I,2
  WHEN #RIR_MOVREAL
   RGEN_ALLOC_CONST# RIR_OPS[I],RIR_IMM#[RIR_OPS[I+1]]
'   RGEN_EMIT_SBCODE RGEN_REG_STR$(R)+"="+STR$(RIR_IMM#[RIR_OPS[I+1]])'FIXME!!!!!!!ast
   INC I,2
  WHEN #RIR_MOVSTR
   RGEN_ALLOC_CONST$ RIR_OPS[I],RIR_IMM$[RIR_OPS[I+1]]
'   R=RGEN_ALLOC_REG(RIR_OPS[I])
'   RGEN_EMIT_SBCODE RGEN_REG_STR$(R)+"="+CHR$(34)+RIR_IMM$[RIR_OPS[I+1]]+CHR$(34)
   INC I,2
  WHEN #RIR_MOVEMPTY
   RGEN_ALLOC_EXPR RIR_OPS[I],"EMPTY"
   INC I
  WHEN #RIR_NEWARRAY
   VAR ARY_REG=RIR_OPS[I]:INC I
   VAR DM=RIR_OPS[I]:INC I
   VAR TYP=RIR_OPS[I]:INC I
   CASE TYP
   WHEN #T_INTARRAY
    VAR NEWARRAY$="ARRAY%("
   WHEN #T_REALARRAY
    NEWARRAY$="ARRAY#("
   WHEN #T_STRARRAY
    NEWARRAY$="ARRAY$("
   ENDCASE
   FOR J=0TO DM-1
    RGEN_GET_REG RIR_OPS[I] OUT R1,R1$
    PUSH NEWARRAY$,R1$
    IF J==DM-1 THEN
     PUSH NEWARRAY$,")"
    ELSE
     PUSH NEWARRAY$,","
    ENDIF
    RGEN_FREE_REG R1
    INC I
   NEXT
   RGEN_ALLOC_EXPR ARY_REG,NEWARRAY$
  WHEN #RIR_ADD
  WHEN #RIR_SUB
  WHEN #RIR_MUL
  WHEN #RIR_DIV
  WHEN #RIR_DIVINT
  WHEN #RIR_MOD
  WHEN #RIR_AND
  WHEN #RIR_OR
  WHEN #RIR_XOR
  WHEN #RIR_EQ
  WHEN #RIR_NEQ
  WHEN #RIR_LSHIFT
  WHEN #RIR_RSHIFT
  WHEN #RIR_GREAT
  WHEN #RIR_LESS
  WHEN #RIR_GEQ
  WHEN #RIR_LEQ
   VAR R1T,R2T,R3T
   RGEN_GET_REG_TYPE RIR_OPS[I+1] OUT R2,R2$,R2T
   RGEN_GET_REG_TYPE RIR_OPS[I+2] OUT R3,R3$,R3T
   IF R2T||R3T THEN
    R1=RGEN_ALLOC_REG(RIR_OPS[I])
    RGEN_EMIT_SBCODE RGEN_REG_STR$(R1)+"="+R2$+RIR_GET_OP$(C)+R3$
    INC PC
   ELSE 
    RGEN_ALLOC_EXPR RIR_OPS[I],"("+R2$+RIR_GET_OP$(C)+R3$+")"
   ENDIF
   RGEN_FREE_REG R2
   RGEN_FREE_REG R3
   INC I,3
  WHEN #RIR_NEG
  WHEN #RIR_NOT
  WHEN #RIR_LNOT
   RGEN_GET_REG RIR_OPS[I+1] OUT R2,R2$
   RGEN_ALLOC_EXPR RIR_OPS[I],"("+RIR_GET_OP$(C)+R2$+")"
   RGEN_FREE_REG R2
   INC I,2
  WHEN #RIR_GETGLOBAL
   RGEN_ALLOC_EXPR RIR_OPS[I],RGEN_GLOBAL_STR$(RIR_OPS[I+1])
   INC I,2
  WHEN #RIR_GETLOCAL
   RGEN_ALLOC_EXPR RIR_OPS[I],RGEN_LOCAL_STR$(RIR_OPS[I+1])
   IF TRACE THEN ?"R",RIR_OPS[I],RGEN_LOCAL_STR$(RIR_OPS[I+1])
   INC I,2
  WHEN #RIR_GETINARG
'   RGEN_ALLOC_EXPR RIR_OPS[I],RGEN_INARG_STR$(RIR_OPS[I+1])
   R1=RGEN_ALLOC_REG(RIR_OPS[I])
   RGEN_EMIT_SBCODE RGEN_REG_STR$(R1)+"="+RGEN_INARG_STR$(RIR_OPS[I+1])
   INC I,2
   INC PC
  WHEN #RIR_GETOUTARG
'   RGEN_ALLOC_EXPR RIR_OPS[I],RGEN_OUTARG_STR$(RIR_OPS[I+1])
   R1=RGEN_ALLOC_REG(RIR_OPS[I])
   RGEN_EMIT_SBCODE RGEN_REG_STR$(R1)+"="+RGEN_OUTARG_STR$(RIR_OPS[I+1])
   INC I,2
   INC PC
  WHEN #RIR_GETVAR
   RGEN_GET_REG RIR_OPS[I+1] OUT R2,R2$
   RGEN_ALLOC_EXPR RIR_OPS[I],"VAR(RVM_VAR$("+STR$(CMP_SLOT)+","+STR$(RGEN_FUNC)+","+R2$+"))"
   RGEN_FREE_REG R2
   INC I,2
  WHEN #RIR_MOVREG
   R1=RGEN_ALLOC_REG(RIR_OPS[I]):INC I
   RGEN_GET_REG RIR_OPS[I] OUT R2,R2$:INC I
   RGEN_EMIT_SBCODE RGEN_REG_STR$(R1)+"="+R2$
   INC PC
  WHEN #RIR_SETGLOBAL
   RGEN_GET_REG RIR_OPS[I+1] OUT R1,R1$
   RGEN_EMIT_SBCODE RGEN_GLOBAL_STR$(RIR_OPS[I])+"="+R1$
   RGEN_FREE_REG R1
   INC I,2
   INC PC
  WHEN #RIR_SETLOCAL
   RGEN_GET_REG RIR_OPS[I+1] OUT R1,R1$
   RGEN_EMIT_SBCODE RGEN_LOCAL_STR$(RIR_OPS[I])+"="+R1$
   RGEN_FREE_REG R1
   INC I,2
   INC PC
  WHEN #RIR_SETINARG
   RGEN_GET_REG RIR_OPS[I+1] OUT R1,R1$
   RGEN_EMIT_SBCODE RGEN_INARG_STR$(RIR_OPS[I])+"="+R1$
   RGEN_FREE_REG R1
   INC I,2
   INC PC
  WHEN #RIR_SETOUTARG
   RGEN_GET_REG RIR_OPS[I+1] OUT R1,R1$
   RGEN_EMIT_SBCODE RGEN_OUTARG_STR$(RIR_OPS[I])+"="+R1$
   RGEN_FREE_REG R1
   INC I,2
   INC PC
  WHEN #RIR_SETVAR
   RGEN_GET_REG RIR_OPS[I] OUT R1,R1$
   RGEN_GET_REG RIR_OPS[I+1] OUT R2,R2$
   RGEN_EMIT_SBCODE "VAR(RVM_VAR$("+STR$(CMP_SLOT)+","+STR$(RGEN_FUNC)+","+R1$+"))="+R2$
   RGEN_FREE_REG R1
   RGEN_FREE_REG R2
   INC I,2
   INC PC
  WHEN #RIR_PRINT
   VAR CNT=RIR_OPS[I]*2+I-1
   RGEN_EMIT_SBCODE "?"
   FOR I=I+1 TO CNT STEP 2
    RGEN_GET_REG RIR_OPS[I+1] OUT R1,R1$
    RGEN_FREE_REG R1
    RGEN_EMIT_SBCODE R1$
    IF RIR_OPS[I]==0 THEN
     RGEN_EMIT_SBCODE ","
    ELSEIF RIR_OPS[I]==1 THEN
    ELSEIF RIR_OPS[I]==2 THEN
     RGEN_EMIT_SBCODE ";"
    ENDIF
   NEXT
   INC PC
  WHEN #RIR_TPRINT
   RGEN_GET_REG RIR_OPS[I] OUT R2,R2$:INC I
   RGEN_FREE_REG R2
   CNT=RIR_OPS[I]*2+I-1
   RGEN_EMIT_SBCODE "T?"+R2$+","
   FOR I=I+1 TO CNT STEP 2
    RGEN_GET_REG RIR_OPS[I+1] OUT R1,R1$
    RGEN_FREE_REG R1
    RGEN_EMIT_SBCODE R1$
    IF RIR_OPS[I]==0 THEN
     RGEN_EMIT_SBCODE ","
    ELSEIF RIR_OPS[I]==1 THEN
    ELSEIF RIR_OPS[I]==2 THEN
     RGEN_EMIT_SBCODE ";"
    ENDIF
   NEXT
   INC PC
  WHEN #RIR_BRFALSE
   RGEN_EMIT_BREAK_CODE PC
   RGEN_GET_REG RIR_OPS[I] OUT R1,R1$
   RGEN_EMIT_SBCODE "IF "+R1$+" THEN ELSE"+RGEN_LABEL$(I,RIR_OPS[I+1])
   RGEN_EMIT_BREAK_CODE_END PC
   INC I,2
   INC PC
   RGEN_FREE_REG R1
  WHEN #RIR_BRTRUE
   RGEN_EMIT_BREAK_CODE PC
   RGEN_GET_REG RIR_OPS[I] OUT R1,R1$
   RGEN_EMIT_SBCODE "IF "+R1$+" GOTO"+RGEN_LABEL$(I,RIR_OPS[I+1])
   RGEN_EMIT_BREAK_CODE_END PC
   INC I,2
   INC PC
   RGEN_FREE_REG R1
  WHEN #RIR_BR
   IF!RGEN_INTERRUPT THEN
    RGEN_EMIT_SBCODE "GOTO"+RGEN_LABEL$(I,RIR_OPS[I])
   ELSE
    RGEN_EMIT_BREAK_CODE PC
    RGEN_EMIT_SBCODE RGEN_LABEL$(I,RIR_OPS[I])
    RGEN_EMIT_BREAK_CODE_END PC
   ENDIF
   INC I
   INC PC
  WHEN #RIR_CALL
   'FIXME:へんすうをいっかいれじすたにかく
   '?GLIL*A()
   'は
   'R0=O0
   '?(G00*R0)ではなく
   'R0=G00
   '...
   'R1=O0
   '?(R0*R1)がただしい(ごかんせいてきには)
   VAR FUNC$=RIR_IMM$[RIR_OPS[I]]
   VAR INCNT=RIR_OPS[I+1]
   VAR OUTCNT=RIR_OPS[I+2]
   RCMP_MAX_INARG=MAX(RCMP_MAX_INARG,INCNT)
   RCMP_MAX_OUTARG=MAX(RCMP_MAX_OUTARG,OUTCNT)
   VAR NATV=#FALSE
   IF CHKCALL("SBSB_"+FUNC$)THEN
    FUNC$="SBSB_"+FUNC$
    NATV=#TRUE
    RGEN_EMIT_SBCODE "VAR("+CHR$(34)+STR$(#_SLOT)+":VM_CURFUNC"+CHR$(34)+")=VM_CURFUNC:"
   ELSEIF CHKCALL("RSBSB_"+FUNC$)THEN
    FUNC$="RSBSB_"+FUNC$
    NATV=#TRUE
   ELSEIF CHKCALL(NOT_USED_SLOT$+FUNC$)THEN
    NATV=#TRUE
   ENDIF
   IF NATV THEN
    IF FUNC$=="DIM"&&OUTCNT==1THEN
     R1=RGEN_ALLOC_REG(RIR_OPS[I+3+INCNT])
     RGEN_EMIT_SBCODE RGEN_REG_STR$(R1)
     RGEN_EMIT_SBCODE "=DIM("
    ELSE
     RGEN_EMIT_SBCODE FUNC$
    ENDIF
    FOR J=INCNT-1 TO 0 STEP -1
     RGEN_GET_REG RIR_OPS[I+3+J] OUT R1,R1$
     IF TRACE THEN ?R1$,
     RGEN_FREE_REG R1
     IF J!=INCNT-1 THEN
      RGEN_EMIT_SBCODE ","
     ELSE
      RGEN_EMIT_SBCODE " "
     ENDIF
     RGEN_EMIT_SBCODE R1$
    NEXT
    IF FUNC$=="DIM"&&OUTCNT==1THEN
      RGEN_EMIT_SBCODE ")"
    ELSE
     FOR J=OUTCNT-1TO 0 STEP -1
      IF J==OUTCNT-1 THEN
       RGEN_EMIT_SBCODE " OUT "
      ELSE
       RGEN_EMIT_SBCODE ","
      ENDIF
      R1=RGEN_ALLOC_REG(RIR_OPS[I+3+J+INCNT])
      RGEN_EMIT_SBCODE RGEN_REG_STR$(R1)
      IF TRACE THEN ?RGEN_REG_STR$(R1),
     NEXT
     IF TRACE THEN ?
    ENDIF
    INC I,3+INCNT+OUTCNT
    INC PC
    CONTINUE
   ENDIF
   'FIXME
   DIM EXCEPT_REGS=ARRAY%(0)
   FOR J=0TO INCNT-1
    RGEN_GET_REG_TYPE RIR_OPS[I+3+J] OUT R1,R1$,R1T
    IF R1T==#RGEN_REG_TYPE_REG THEN
     PUSH EXCEPT_REGS,R1
    ENDIF
   NEXT
   RGEN_GEN_SAVE_ALL_REGS EXCEPT_REGS

   IF RGEN_FUNC THEN
    RGEN_EMIT_SBCODE "VM_PC="+STR$(PC+1)
    RGEN_EMIT_SBCODE ":GOTO@SPILL_"+MID$(RGEN_FUNC$(FUNC_NAME$[RGEN_FUNC]),1,&H7FFFFFFF)
    INC PC
    RGEN_EMIT_SBCODE CHR$(10)
    PUSH RIR_OPS_LINE,RIR_LINE'PRGEDIT()
    PUSH RIR_OPS_LINE_PC,I
    RGEN_EMIT_SBCODE RGEN_LABEL$(I,I)+":"'"@"+STR$(CMP_SLOT)+HEX$(I)+":"
    OPC=PC
    PUSH RGEN_RJMP_TABLE,I
   ENDIF

   FOR J=0TO INCNT-1
    RGEN_GET_REG RIR_OPS[I+3+J] OUT R1,R1$
    RGEN_FREE_REG R1
    RGEN_EMIT_SBCODE RGEN_INARG_STR$(J)+"="+R1$+":"
   NEXT
   FOR J=0TO OUTCNT-1
    RGEN_EMIT_SBCODE RGEN_OUTARG_STR$(J)+"=EMPTY:"
   NEXT
   IF FUNC$=="CALL"THEN
    RGEN_EMIT_SBCODE "ICALL$="+RGEN_INARG_STR$(INCNT-1)+":"
    RGEN_EMIT_SBCODE "ICNT="+STR$(INCNT-1)+":"
   ELSE
    RGEN_EMIT_SBCODE "ICNT="+STR$(INCNT)+":"
   ENDIF
   RGEN_EMIT_SBCODE "OCNT="+STR$(OUTCNT)+":"
   RGEN_EMIT_SBCODE "RETS="+STR$(CMP_SLOT)+":"
   RGEN_EMIT_SBCODE "RET="+STR$(PC+1)+":"
   RGEN_EMIT_SBCODE "GOTO"+RGEN_FUNC$(FUNC$)
   VAR K=I
   INC I,3+INCNT+OUTCNT
   INC PC
  WHEN #RIR_CLEANSTACK
   INC PC
   IF NATV THEN CONTINUE
'   'FIXME
'   RGEN_EMIT_SBCODE CHR$(10)
'   PUSH RIR_OPS_LINE,RIR_LINE
'   PUSH RIR_OPS_LINE_PC,I
'   RGEN_EMIT_SBCODE "@"+STR$(CMP_SLOT)+HEX$(I)+":"
   'FIXME
   RGEN_GEN_LOAD_ALL_REGS
'   OPC=PC
'   PUSH RGEN_RJMP_TABLE,I
  WHEN #RIR_DEFFUN
   FOR J=0TO LAST(RGEN_REG_USED)
    IF !RGEN_REG_USED[J] THEN CONTINUE
    ?"LEAKED! R";J
    STOP
   NEXT
   VAR FUNC=RIR_OPS[I]
   FUNC_ADDR[FUNC]=PC
   RCMP_MAX_LOCAL=MAX(RCMP_MAX_LOCAL,FUNC_VARNUM[FUNC])
   RCMP_MAX_INARG=MAX(RCMP_MAX_INARG,FUNC_INCNT[FUNC])
   RCMP_MAX_OUTARG=MAX(RCMP_MAX_OUTARG,FUNC_OUTCNT[FUNC])
   INC I,1
   IF FUNC THEN
    VAR MAX_SLOT=3
    IF FUNC_COMMON[FUNC]THEN
     FOR J=0TO MAX_SLOT
      RGEN_EMIT_SBCODE "@F"+STR$(J)+FUNC_NAME$[FUNC]+":"
     NEXT
    ELSE
     RGEN_EMIT_SBCODE RGEN_FUNC$(FUNC_NAME$[FUNC])+":"
    ENDIF
    IF FUNC_INCNT[FUNC]!=-1&&FUNC_OUTCNT[FUNC]!=-1THEN
     RGEN_EMIT_SBCODE "IF ICNT!="+STR$(FUNC_INCNT[FUNC])+"||OCNT!="+STR$(FUNC_OUTCNT[FUNC])+"THEN VM_PC="+STR$(PC)+":VM_ERRNUM=0:RETURN "+STR$(#RVM_RETCODE_ERR)+":ENDIF:"
    ELSEIF FUNC_INCNT[FUNC]==-1&&FUNC_OUTCNT[FUNC]!=-1 THEN
     RGEN_EMIT_SBCODE "IF OCNT!="+STR$(FUNC_OUTCNT[FUNC])+"THEN VM_PC="+STR$(PC)+":VM_ERRNUM=0:RETURN "+STR$(#RVM_RETCODE_ERR)+":ENDIF:"
    ELSEIF FUNC_INCNT[FUNC]!=-1&&FUNC_OUTCNT[FUNC]==-1 THEN
     RGEN_EMIT_SBCODE "IF ICNT!="+STR$(FUNC_OUTCNT[FUNC])+"THEN VM_PC="+STR$(PC)+":VM_ERRNUM=0:RETURN "+STR$(#RVM_RETCODE_ERR)+":ENDIF:"
    ENDIF
    RGEN_INIT_LOCAL_VAR GET_SPLAY_ROOT(FUNC_VARTBL[FUNC])
   ENDIF
   RGEN_EMIT_SBCODE "VM_CURFUNC="+STR$(FUNC)
   RGEN_FUNC=FUNC
   INC PC
  WHEN #RIR_SPILLVAR
   IF RGEN_FUNC THEN
'    RGEN_EMIT_SBCODE "VM_PC="+STR$(PC)
'    RGEN_EMIT_SBCODE ":GOTO@SPILL_"+MID$(RGEN_FUNC$(FUNC_NAME$[RGEN_FUNC]),1,&H7FFFFFFF)
'    INC PC
   ENDIF
   INC PC
  WHEN #RIR_FILLVAR
   RGEN_EMIT_SBCODE "VM_CURFUNC="+STR$(RGEN_FUNC)+":"
   FOR J=0TO OUTCNT-1
    R1=RGEN_ALLOC_REG(RIR_OPS[K+3+J+INCNT])
    RGEN_EMIT_SBCODE RGEN_REG_STR$(R1)+"="+RGEN_OUTARG_STR$(J)+":"
   NEXT
   IF RGEN_FUNC THEN
    RGEN_EMIT_SBCODE "VM_PC="+STR$(PC+1)
    RGEN_EMIT_SBCODE ":GOTO@FILL_"+MID$(RGEN_FUNC$(FUNC_NAME$[RGEN_FUNC]),1,&H7FFFFFFF)
   ENDIF
   INC PC
  WHEN #RIR_SPILLVAR2
   RGEN_EMIT_SBCODE "@SPILL_"+MID$(RGEN_FUNC$(FUNC_NAME$[RGEN_FUNC]),1,&H7FFFFFFF)+":"
   RGEN_GEN_SPILLVAR #TRUE
   INC PC
  WHEN #RIR_FILLVAR2
   RGEN_EMIT_SBCODE "@FILL_"+MID$(RGEN_FUNC$(FUNC_NAME$[RGEN_FUNC]),1,&H7FFFFFFF)+":"
   RGEN_GEN_FILLVAR #TRUE
   INC PC
  WHEN #RIR_LEAVE
   RGEN_EMIT_SBCODE "IF "+RIR_VM_SP$+"&&"+RIR_VM_STK_TYP+"["+RIR_VM_SP$+"-1]=="+STR$(#VMT_SUBROUTINE)+"THEN "
   RGEN_EMIT_SBCODE "DEC "+RIR_VM_SP$+":"
   RGEN_EMIT_SBCODE RIR_VM_STK_TYP+"["+RIR_VM_SP$+"]=0:"
   RGEN_EMIT_SBCODE "VM_PC="+RIR_VM_STK%+"["+RIR_VM_SP$+"]:"
   RGEN_EMIT_SBCODE "DEC "+RIR_VM_SP$+":"
   RGEN_EMIT_SBCODE "VM_CURSLOT="+RIR_VM_STK%+"["+RIR_VM_SP$+"]:"
   RGEN_EMIT_SBCODE RIR_VM_STK_TYP+"["+RIR_VM_SP$+"]=0:"
   RGEN_EMIT_SBCODE "ON VM_CURSLOT GOTO@JMP0,@JMP1,@JMP2,@JMP3:ELSE "
   INC PC
   RGEN_EMIT_SBCODE "VM_PC=RET:VM_CURSLOT=RETS:ON RETS GOTO@JMP0,@JMP1,@JMP2,@JMP3:ENDIF
  WHEN #RIR_END
   RGEN_EMIT_SBCODE "VM_PC="+STR$(PC)+":RETURN "+STR$(#RVM_RETCODE_END)
   INC PC
  WHEN #RIR_DBG_TEMP_STOP
   RGEN_EMIT_SBCODE "VM_PC="+STR$(PC)+":RETURN "+STR$(#RVM_RETCODE_DBG_TEMP_STOP)
   RVM_TEMP_STOP_ADDR[CMP_SLOT]=PC
   INC PC
  WHEN #RIR_FORGLOBAL
  WHEN #RIR_FORLOCAL
  WHEN #RIR_FORINARG
  WHEN #RIR_FOROUTARG
  WHEN #RIR_FORARRAY
   VAR IDX=RIR_OPS[I]:INC I
   VAR TO_REG=RIR_OPS[I]:INC I
   VAR STEP_REG=RIR_OPS[I]:INC I
   VAR INIT=RIR_OPS[I]:INC I
   VAR BRKADDR=RIR_OPS[I]:INC I
   RGEN_GET_REG STEP_REG OUT R1,R1$
   RGEN_GET_REG TO_REG OUT R2,R2$
   IF C==#RIR_FORGLOBAL THEN
    VAR VS$=RGEN_GLOBAL_STR$(IDX)
   ELSEIF C==#RIR_FORLOCAL THEN
    VS$=RGEN_LOCAL_STR$(IDX)
   ELSEIF C==#RIR_FORINARG THEN
    VS$=RGEN_INARG_STR$(IDX)
   ELSEIF C==#RIR_FOROUTARG THEN
    VS$=RGEN_OUTARG_STR$(IDX)
   ELSEIF C==#RIR_FORARRAY THEN
    DM=RIR_OPS[I]:INC I
    RGEN_GET_REG IDX OUT R3,R3$
    'TODO:はいれつアクセスのサクゲン
    VS$=R3$+"["
    FOR J=0TO DM-1
     RGEN_GET_REG RIR_OPS[I] OUT R3,R3$:INC I
     IF J THEN PUSH VS$,","
     PUSH VS$,R3$
    NEXT
    PUSH VS$,"]"
   ENDIF
   IF RGEN_INTERRUPT THEN
    RGEN_EMIT_BREAK_CODE PC
    RGEN_EMIT_SBCODE " "
   ENDIF
   VAR STEP_CONST
   RGEN_GET_REG_CONST STEP_REG OUT STEP_CONST
   VAR CONST_STEP=TYPEOF(STEP_CONST)==#T_INT||TYPEOF(STEP_CONST)==#T_REAL
   IF CONST_STEP THEN
    IF !INIT THEN
     RGEN_EMIT_SBCODE "INC "+VS$+","+R1$
     IF STEP_CONST>0 THEN
      RGEN_EMIT_SBCODE ":IF "+VS$+"<="+R2$+" THEN "+RGEN_LABEL$(PC,BRKADDR)
     ELSEIF STEP_CONST<0 THEN
      RGEN_EMIT_SBCODE ":IF "+VS$+">="+R2$+" THEN "+RGEN_LABEL$(PC,BRKADDR)
     ELSE
      RGEN_EMIT_SBCODE ":GOTO"+RGEN_LABEL$(PC,BRKADDR)
     ENDIF
    ELSE
     IF STEP_CONST>0 THEN
      RGEN_EMIT_SBCODE "IF "+VS$+">"+R2$+" THEN "+RGEN_LABEL$(PC,BRKADDR)
     ELSEIF STEP_CONST<0 THEN
      RGEN_EMIT_SBCODE "IF "+VS$+"<"+R2$+" THEN "+RGEN_LABEL$(PC,BRKADDR)
     ELSE
      RGEN_EMIT_SBCODE "GOTO"+RGEN_LABEL$(PC,BRKADDR)
     ENDIF
    ENDIF
   ELSEIF !INIT THEN
    RGEN_EMIT_SBCODE "INC "+VS$+","+R1$
    RGEN_EMIT_SBCODE ":IF "+R1$+">0 THEN"
    RGEN_EMIT_SBCODE ":IF "+VS$+"<="+R2$+" THEN "+RGEN_LABEL$(PC,BRKADDR)
    RGEN_EMIT_SBCODE ":ENDIF:ELSEIF "+R1$+"<0 THEN"
    RGEN_EMIT_SBCODE ":IF "+VS$+">="+R2$+" THEN "+RGEN_LABEL$(PC,BRKADDR)
    RGEN_EMIT_SBCODE ":ENDIF:ELSE"+RGEN_LABEL$(PC,BRKADDR)
    RGEN_EMIT_SBCODE ":ENDIF"
   ELSE
    RGEN_EMIT_SBCODE "IF "+R1$+">0 THEN"
    RGEN_EMIT_SBCODE ":IF "+VS$+">"+R2$+" THEN "+RGEN_LABEL$(PC,BRKADDR)
    RGEN_EMIT_SBCODE ":ENDIF:ELSEIF "+R1$+"<0 THEN"
    RGEN_EMIT_SBCODE ":IF "+VS$+"<"+R2$+" THEN "+RGEN_LABEL$(PC,BRKADDR)
    RGEN_EMIT_SBCODE ":ENDIF:ELSE"+RGEN_LABEL$(PC,BRKADDR)
    RGEN_EMIT_SBCODE ":ENDIF"
   ENDIF
   RGEN_FREE_REG R1
   RGEN_FREE_REG R2
   INC PC
  WHEN #RIR_SETARRAY
   RIR_GEN_ARRAY I OUT I
   RGEN_GET_REG RIR_OPS[I] OUT R1,R1$:INC I
   RGEN_EMIT_SBCODE "="+R1$
   RGEN_FREE_REG R1
   INC PC
  WHEN #RIR_GETARRAY
   VAR EXPR$=""
   VAR EXPR=#FALSE
   R1=RIR_OPS[I]:INC I
   RGEN_GET_REG_TYPE RIR_OPS[I] OUT R2,R2$,R2T:INC I
   RGEN_FREE_REG R2
   DM=RIR_OPS[I]:INC I
   PUSH EXPR$,R2$+"["
   EXPR=EXPR||R2T
   FOR J=0TO DM-1
    RGEN_GET_REG_TYPE RIR_OPS[I] OUT R3,R3$,R3T:INC I
    IF J THEN PUSH EXPR$,","
    PUSH EXPR$,R3$
    RGEN_FREE_REG R3
    EXPR=EXPR||R3T
   NEXT
   PUSH EXPR$,"]"
   IF EXPR THEN
    R1=RGEN_ALLOC_REG(R1)
    RGEN_EMIT_SBCODE RGEN_REG_STR$(R1)+"="+EXPR$
    INC PC
   ELSE 
    RGEN_ALLOC_EXPR R1,"("+EXPR$+")"
   ENDIF
  WHEN #RIR_DATAINT
'   ADD_DATA RIR_OPS[I]
'   RGEN_EMIT_SBCODE "DATA "+STR$(RIR_OPS[I])+":"
   INC I
  WHEN #RIR_DATASTR
'   ADD_DATA RIR_IMM$[RIR_OPS[I]]
'   RGEN_EMIT_SBCODE "DATA "+RIR_DATA_ESCAPE$(RIR_IMM$[RIR_OPS[I]])+":"
   INC I
  WHEN #RIR_DATAREAL
'   ADD_DATA RIR_IMM%[RIR_OPS[I]]
'   RGEN_EMIT_SBCODE "DATA "+MID$(FORMAT$("%.97F",RIR_IMM#[RIR_OPS[I]]),0,97)+":"
   INC I
  WHEN #RIR_READ
   R1=RGEN_ALLOC_REG(RIR_OPS[I])
'   RGEN_EMIT_SBCODE "READ "+RGEN_REG_STR$(R1)
   RGEN_EMIT_SBCODE "RVM_READ OUT "+RGEN_REG_STR$(R1)
   INC I
   INC PC
  WHEN #RIR_LABEL
   VAR LABEL$=RIR_IMM$[RIR_OPS[I]]:INC I
   IF RGEN_FUNC THEN
    RGEN_EMIT_SBCODE "@K"+STR$(CMP_SLOT)+STR$(RGEN_FUNC)+"_"+MID$(LABEL$,1,&H7FFFFFFF)+":"
   ELSE
    RGEN_EMIT_SBCODE "@L"+STR$(CMP_SLOT)+MID$(LABEL$,1,&H7FFFFFFF)+":"
   ENDIF
   VAR LABEL=RIR_OPS[I]:INC I
   LABEL_ADDR[LABEL]=PC
   INC PC
  WHEN #RIR_RESTORE
   LABEL$=RIR_IMM$[RIR_OPS[I]]:INC I
   VAR FOUND,DATA_ADDR
   IF RGEN_FUNC THEN
    SPLAY_GET% FUNC_LBLTBL[RGEN_FUNC],LABEL$ OUT FOUND,DATA_ADDR
    IF !FOUND THEN
     SPLAY_GET% CMP_GLBLTBL,LABEL$ OUT FOUND,DATA_ADDR
    ENDIF
'    RGEN_EMIT_SBCODE "RESTORE@K"+STR$(CMP_SLOT)+STR$(RGEN_FUNC)+"_"+MID$(LABEL$,1,&H7FFFFFFF)
   ELSE
    SPLAY_GET% CMP_GLBLTBL,LABEL$ OUT FOUND,DATA_ADDR
'   RGEN_EMIT_SBCODE "RESTORE@L"+STR$(CMP_SLOT)+MID$(LABEL$,1,&H7FFFFFFF)
   ENDIF
   IF !FOUND THEN STOP
   RGEN_EMIT_SBCODE "RVM_RESTORE_ADDR "+STR$(CMP_SLOT)+","+STR$(LABEL_DATA_ADDR[DATA_ADDR])
   INC PC
  WHEN #RIR_GOTO
   LABEL$=RIR_IMM$[RIR_OPS[I]]:INC I
   IF RGEN_FUNC THEN
    RGEN_EMIT_SBCODE "GOTO@K"+STR$(CMP_SLOT)+STR$(RGEN_FUNC)+"_"+MID$(LABEL$,1,&H7FFFFFFF)
   ELSE
    RGEN_EMIT_SBCODE "GOTO@L"+STR$(CMP_SLOT)+MID$(LABEL$,1,&H7FFFFFFF)
   ENDIF
   INC PC
  WHEN #RIR_RESTOREEXPR
   RGEN_GET_REG RIR_OPS[I] OUT R1,R1$:INC I
   RGEN_FREE_REG R1
   RGEN_EMIT_SBCODE "RVM_RESTORE "+R1$+","+STR$(RGEN_FUNC)
   INC PC
  WHEN #RIR_GOTOEXPR
   RGEN_GET_REG RIR_OPS[I] OUT R1,R1$:INC I
   RGEN_FREE_REG R1
   RGEN_EMIT_SBCODE "TEMP=RVMINSTR_GOTOEXPR("+R1$+")"
   RGEN_EMIT_SBCODE "IF TEMP THEN RETURN "+STR$(#RVM_RETCODE_TRACE_BP)+":ENDIF"
   RGEN_EMIT_SBCODE ":ON VM_CURSLOT GOTO@JMP0,@JMP1,@JMP2,@JMP3"
   INC PC
  WHEN #RIR_GOSUBEXPR
   RGEN_GET_REG RIR_OPS[I] OUT R1,R1$:INC I
   RGEN_FREE_REG R1
   RGEN_EMIT_SBCODE "VM_PC="+STR$(PC)
   RGEN_EMIT_SBCODE "TEMP=RVMINSTR_GOSUBEXPR("+R1$+")"
   RGEN_EMIT_SBCODE "IF TEMP THEN RETURN "+STR$(#RVM_RETCODE_TRACE_BP)+":ENDIF"
   RGEN_EMIT_SBCODE ":ON VM_CURSLOT GOTO@JMP0,@JMP1,@JMP2,@JMP3"
   INC PC
  WHEN #RIR_INC
   VAR DECREMENT=RIR_OPS[I]:INC I
   VAR DIFF_REG=RIR_OPS[I]:INC I
   RGEN_GET_REG DIFF_REG OUT R1,R1$
   IF DECREMENT THEN
    RGEN_EMIT_SBCODE "DEC "
   ELSE
    RGEN_EMIT_SBCODE "INC "
   ENDIF
   RIR_GEN_REF_CODE I OUT I
   RGEN_EMIT_SBCODE ","+R1$
   RGEN_FREE_REG R1
   INC PC
  WHEN #RIR_SWAP
   RGEN_EMIT_SBCODE "SWAP "
   RIR_GEN_REF_CODE I OUT I
   RGEN_EMIT_SBCODE ","
   RIR_GEN_REF_CODE I OUT I
   INC PC
  WHEN #RIR_CALLSPRITEINIT
   RGEN_EMIT_SBCODE "VMINSTR_INITCALLSPRITE:"
   RGEN_GEN_SAVE_ALL_REGS ARRAY%(0)
   RGEN_GEN_SPILLVAR #FALSE
   INC PC
  WHEN #RIR_CALLSPRITE
   RGEN_EMIT_SBCODE "VM_PC="+STR$(PC)
   RGEN_EMIT_SBCODE "RETURN "+STR$(#RVM_RETCODE_CALLSPRITE)
   INC PC
  WHEN #RIR_CALLTEXTINIT
   RGEN_EMIT_SBCODE "VMINSTR_INITCALLTEXT:"
   RGEN_GEN_SAVE_ALL_REGS ARRAY%(0)
   RGEN_GEN_SPILLVAR #FALSE
   INC PC
  WHEN #RIR_CALLTEXT
   RGEN_EMIT_SBCODE "VM_PC="+STR$(PC)
   RGEN_EMIT_SBCODE "RETURN "+STR$(#RVM_RETCODE_CALLTEXT)
   INC PC
  WHEN #RIR_CALLBACKEND
   RGEN_EMIT_SBCODE "VM_CURFUNC="+STR$(RGEN_FUNC)+":"
   RGEN_GEN_FILLVAR #FALSE
   RGEN_GEN_LOAD_ALL_REGS
   INC PC
  WHEN #RIR_BRAND
   VAR COND_R1,COND_R1$
   RGEN_GET_REG RIR_OPS[I] OUT COND_R1,COND_R1$:INC I
   VAR BOOL=RIR_OPS[I]:INC I
   VAR JMP$=RGEN_LABEL$(I,RIR_OPS[I]):INC I
   BOOL=RGEN_ALLOC_REG(BOOL)
   RGEN_EMIT_SBCODE "IF "+COND_R1$+" THEN "+RGEN_REG_STR$(BOOL)+"=1 ELSE "+RGEN_REG_STR$(BOOL)+"=0:GOTO"+JMP$
   RGEN_FREE_REG COND_R1
   INC PC
  WHEN #RIR_BROR
   RGEN_GET_REG RIR_OPS[I] OUT COND_R1,COND_R1$:INC I
   BOOL=RIR_OPS[I]:INC I
   JMP$=RGEN_LABEL$(I,RIR_OPS[I]):INC I
   BOOL=RGEN_ALLOC_REG(BOOL)
   RGEN_EMIT_SBCODE "IF "+COND_R1$+" THEN "+RGEN_REG_STR$(BOOL)+"=1:GOTO"+JMP$+" ELSE "+RGEN_REG_STR$(BOOL)+"=0"
   RGEN_FREE_REG COND_R1
   INC PC
  WHEN #RIR_WHEN'FIXME:ふくすうかいひょうかされる
   VAR CASE_R,CASE_R$
   RGEN_GET_REG RIR_OPS[I] OUT CASE_R,CASE_R$:INC I
   VAR WHEN_R,WHEN_R$
   RGEN_GET_REG RIR_OPS[I] OUT WHEN_R,WHEN_R$:INC I
   RGEN_FREE_REG WHEN_R
   JMP$=RGEN_LABEL$(I,RIR_OPS[I]):INC I
   RGEN_EMIT_SBCODE "IF "+CASE_R$+"=="+WHEN_R$+" THEN "+JMP$
   INC PC
  WHEN #RIR_OTHERWISE
   RGEN_GET_REG RIR_OPS[I] OUT CASE_R,CASE_R$:INC I
   JMP$=RGEN_LABEL$(I,RIR_OPS[I]):INC I
   RGEN_FREE_REG CASE_R
   RGEN_EMIT_SBCODE "GOTO"+JMP$
   INC PC
  WHEN #RIR_STOP1
   RGEN_EMIT_SBCODE "VM_CURSLOT="+STR$(CMP_SLOT)
   RGEN_EMIT_SBCODE ":VM_PC="+STR$(PC)
   RGEN_EMIT_SBCODE ":RETURN "+STR$(#RVM_RETCODE_STOP)
   INC PC
  WHEN #RIR_STOP2
   RGEN_GET_REG RIR_OPS[I] OUT R1,R1$:INC I
   RGEN_EMIT_SBCODE "VM_CURSLOT="+STR$(CMP_SLOT)
   RGEN_EMIT_SBCODE ":VM_PC="+STR$(PC)
   RGEN_EMIT_SBCODE ":VM_STOP_MSG$="+R1$
   RGEN_EMIT_SBCODE ":RETURN "+STR$(#RVM_RETCODE_STOP2)
   INC PC
  WHEN #RIR_EXEC1
   RGEN_GET_REG RIR_OPS[I] OUT R1,R1$:INC I
   RGEN_EMIT_SBCODE "VM_PC="+STR$(PC+1)
   RGEN_EMIT_SBCODE ":VM_CURSLOT="+STR$(CMP_SLOT)
   RGEN_EMIT_SBCODE ":VM_EXEC_ARG1="+R1$
   RGEN_EMIT_SBCODE ":RETURN "+STR$(#RVM_RETCODE_EXEC1)
   INC PC
  WHEN #RIR_EXEC2
   RGEN_GET_REG RIR_OPS[I] OUT R1,R1$:INC I
   RGEN_GET_REG RIR_OPS[I] OUT R2,R2$:INC I
   RGEN_EMIT_SBCODE "VM_PC="+STR$(PC+1)
   RGEN_EMIT_SBCODE ":VM_CURSLOT="+STR$(CMP_SLOT)
   RGEN_EMIT_SBCODE ":VM_EXEC_ARG2="+R2$
   RGEN_EMIT_SBCODE ":VM_EXEC_ARG1="+R1$
   RGEN_EMIT_SBCODE ":RETURN "+STR$(#RVM_RETCODE_EXEC2)
   INC PC
  WHEN #RIR_GOSUB
   LABEL$=RIR_IMM$[RIR_OPS[I]]:INC I
   RGEN_EMIT_SBCODE RIR_VM_STK%+"["+RIR_VM_SP$+"]="+STR$(CMP_SLOT)+":"
   RGEN_EMIT_SBCODE RIR_VM_STK_TYP+"["+RIR_VM_SP$+"]="+STR$(#VMT_SUBROUTINE)+":"
   RGEN_EMIT_SBCODE "INC "+RIR_VM_SP$+":"
   RGEN_EMIT_SBCODE RIR_VM_STK%+"["+RIR_VM_SP$+"]="+STR$(PC+1)+":"
   RGEN_EMIT_SBCODE RIR_VM_STK_TYP+"["+RIR_VM_SP$+"]="+STR$(#VMT_SUBROUTINE)+":"
   RGEN_EMIT_SBCODE "INC "+RIR_VM_SP$+":"
   IF RGEN_FUNC THEN
    RGEN_EMIT_SBCODE "GOTO@K"+STR$(CMP_SLOT)+STR$(RGEN_FUNC)+"_"+MID$(LABEL$,1,&H7FFFFFFF)
   ELSE
    RGEN_EMIT_SBCODE "GOTO@L"+STR$(CMP_SLOT)+MID$(LABEL$,1,&H7FFFFFFF)
   ENDIF
   INC PC
  WHEN #RIR_RETURN
   RGEN_EMIT_SBCODE "DEC "+RIR_VM_SP$+":"
   RGEN_EMIT_SBCODE "IF "+RIR_VM_STK_TYP+"["+RIR_VM_SP$+"]!="+STR$(#VMT_SUBROUTINE)+"THEN VM_PC="+STR$(PC)+":VM_ERRNUM=0:RETURN "+STR$(#RVM_RETCODE_ERR)+":ENDIF:"'FIXME ERRCODE
   RGEN_EMIT_SBCODE "VM_PC="+RIR_VM_STK%+"["+RIR_VM_SP$+"]:"
   RGEN_EMIT_SBCODE RIR_VM_STK_TYP+"["+RIR_VM_SP$+"]=0:"
   RGEN_EMIT_SBCODE "DEC "+RIR_VM_SP$+":"
   RGEN_EMIT_SBCODE "VM_CURSLOT="+RIR_VM_STK%+"["+RIR_VM_SP$+"]:"
   RGEN_EMIT_SBCODE RIR_VM_STK_TYP+"["+RIR_VM_SP$+"]=0:"
   RGEN_EMIT_SBCODE "ON VM_CURSLOT GOTO@JMP0,@JMP1,@JMP2,@JMP3"
   INC PC
  WHEN #RIR_ONGOTO
   RGEN_GET_REG RIR_OPS[I] OUT R1,R1$:INC I
   RGEN_FREE_REG R1
   VAR IS_GOSUB=RIR_OPS[I]:INC I
   CNT=RIR_OPS[I]:INC I
   IF IS_GOSUB THEN
    RGEN_EMIT_SBCODE "TEMP="+R1$+":"
    R1$="TEMP"
    RGEN_EMIT_SBCODE "IF TEMP>=0&&TEMP<"+STR$(CNT)+"THEN "
    RGEN_EMIT_SBCODE RIR_VM_STK%+"["+RIR_VM_SP$+"]="+STR$(CMP_SLOT)+":"
    RGEN_EMIT_SBCODE RIR_VM_STK_TYP+"["+RIR_VM_SP$+"]="+STR$(#VMT_SUBROUTINE)+":"
    RGEN_EMIT_SBCODE "INC "+RIR_VM_SP$+":"
    RGEN_EMIT_SBCODE RIR_VM_STK%+"["+RIR_VM_SP$+"]="+STR$(PC+1)+":"
    RGEN_EMIT_SBCODE RIR_VM_STK_TYP+"["+RIR_VM_SP$+"]="+STR$(#VMT_SUBROUTINE)+":"
    RGEN_EMIT_SBCODE "INC "+RIR_VM_SP$+":"
   ENDIF
   RGEN_EMIT_SBCODE "ON "+R1$+" GOTO"
   FOR J=0TO CNT-1
    LABEL$=RIR_IMM$[RIR_OPS[J+I]]
    IF J THEN
     RGEN_EMIT_SBCODE ","
    ENDIF
    IF RGEN_FUNC THEN
     RGEN_EMIT_SBCODE "@K"+STR$(CMP_SLOT)+STR$(RGEN_FUNC)+"_"+MID$(LABEL$,1,&H7FFFFFFF)
    ELSE
     RGEN_EMIT_SBCODE "@L"+STR$(CMP_SLOT)+MID$(LABEL$,1,&H7FFFFFFF)
    ENDIF
   NEXT
   INC I,CNT
   INC PC
  WHEN #RIR_DEFOUT
   IF !RGEN_FUNC THEN ERRRRRRRRRRRRRRRRR
   RGEN_GET_REG RIR_OPS[I] OUT R1,R1$:INC I
   RGEN_GET_REG RIR_OPS[I] OUT R2,R2$:INC I
   RGEN_FREE_REG R1
   RGEN_FREE_REG R2
   RGEN_EMIT_SBCODE "TEMP="+R1$+":IF OCNT<=TEMP THEN "
   RGEN_EMIT_SBCODE "VM_PC="+STR$(PC)+":VM_ERRNUM=0:RETURN "+STR$(#RVM_RETCODE_ERR)+":ENDIF:"'FIXME ERRCODE
   RGEN_EMIT_SBCODE "VAR("+CHR$(34)+"O"+CHR$(34)+"+STR$(OCNT-1-TEMP))"+"="+R2$
   INC PC
  WHEN #RIR_INPUTGUIDE
   VAR SEMI=RIR_OPS[I]:INC I
   CNT=RIR_OPS[I]:INC I
   RGEN_GET_REG RIR_OPS[I] OUT R1,R1$:INC I
   RGEN_EMIT_SBCODE "INPUT "+R1$
   IF SEMI THEN
    RGEN_EMIT_SBCODE ";"
   ELSE
    RGEN_EMIT_SBCODE ","
   ENDIF
   FOR J=0TO CNT-1
    IF J THEN RGEN_EMIT_SBCODE ","
    RIR_GEN_REF_CODE I OUT I
   NEXT
   INC PC
  WHEN #RIR_INPUT
   RGEN_EMIT_SBCODE "INPUT "
   SEMI=RIR_OPS[I]:INC I
   CNT=RIR_OPS[I]:INC I
   FOR J=0TO CNT-1
    IF J THEN RGEN_EMIT_SBCODE ","
    RIR_GEN_REF_CODE I OUT I
   NEXT
   INC PC
  WHEN #RIR_LINPUT
   R1=RGEN_ALLOC_REG(RIR_OPS[I]):INC I
   RGEN_EMIT_SBCODE "LINPUT "+RGEN_REG_STR$(R1)
   INC PC
  WHEN #RIR_LINPUTGUIDE
   RGEN_GET_REG RIR_OPS[I] OUT R1,R1$:INC I
   R2=RGEN_ALLOC_REG(RIR_OPS[I]):INC I
   RGEN_EMIT_SBCODE "LINPUT "+R1$+";"+RGEN_REG_STR$(R2)
   INC PC
  WHEN #RIR_EMPTYREG
    RGEN_GET_REG RIR_OPS[I] OUT R1,R1$
   RGEN_FREE_REG R1:INC I
  OTHERWISE
   STOP
  ENDCASE
 ENDLOOP
 RGEN_EMIT_SBCODE CHR$(10)
 RGEN_JMP_TABLE RGEN_RJMP_TABLE
 RGEN_EMIT_SBCODE CHR$(10)
 RGEN_FLUSH_SBCODE
 RGEN_NEXT_GEN_LINE=RIR_LINE
 RVM_END_LINE_SLOT[CMP_SLOT]=RIR_LINE
 RGEN_EMIT_SBCODE "RETURN"+CHR$(10)
 RGEN_EMIT_SBCODE "@F0CALL"+CHR$(10)
 RGEN_EMIT_SBCODE "@F1CALL"+CHR$(10)
 RGEN_EMIT_SBCODE "@F2CALL"+CHR$(10)
 RGEN_EMIT_SBCODE "@F3CALL"+CHR$(10)
 RGEN_EMIT_SBCODE "RVM_ICALL ICALL$,ICNT,OCNT OUT VM_CURSLOT,VM_PC,TEMP"+CHR$(10)+\
                  "IF TEMP THEN RETURN "+STR$(#RVM_RETCODE_TRACE_BP)+CHR$(10)+\
                  "ON VM_CURSLOT GOTO@JMP0,@JMP1,@JMP2,@JMP3"+CHR$(10)+\
                  ""
 RGEN_EMIT_SBCODE "END:DEF B:END"+CHR$(10)
 RGEN_FLUSH_SBCODE
 PRGEDIT RVM_SLOT,RGEN_VAR_AREA-5
 LOAD_VM_SLOT CMP_SLOT
 RGEN_SLOT_RJMP_TABLE[CMP_SLOT]=VM_ALLOC_ARRAY(RGEN_RJMP_TABLE)
 RVM_BREAK_POINTS=ARRAY%(LEN(RGEN_RJMP_TABLE))
 RVM_SLOT_BREAK_POINTS[CMP_SLOT]=VM_ALLOC_ARRAY(RVM_BREAK_POINTS)
 RIR_SLOT_OPS_LINE[CMP_SLOT]=VM_ALLOC_ARRAY(RIR_OPS_LINE)
 RIR_SLOT_OPS_LINE_PC[CMP_SLOT]=VM_ALLOC_ARRAY(RIR_OPS_LINE_PC)
 CNT=0
 FOR I=0TO LAST(VM_SLOT_GVAR_TYP)
  IF!VM_SLOT_GVAR_TYP[I] THEN CONTINUE
  VAR ARY=VM_GET_ARRAY(VM_SLOT_GVAR_TYP[I])
  FOR J=0TO LAST(ARY)
   IF !CNT THEN
    RGEN_EMIT_SBCODE "VAR "+RGEN_GLOBAL_STR_SLOT$(I,J)
   ELSE
    RGEN_EMIT_SBCODE ","+RGEN_GLOBAL_STR_SLOT$(I,J)
   ENDIF
   INC CNT
  NEXT
 NEXT
 RGEN_SET_SBCODE
 FOR I=0TO RCMP_MAX_LOCAL-1
  IF !I THEN
   RGEN_EMIT_SBCODE "VAR "+RGEN_LOCAL_STR$(I)
  ELSE
   RGEN_EMIT_SBCODE ","+RGEN_LOCAL_STR$(I)
  ENDIF
 NEXT
 IF TYPEOF(RVM_LOCAL_TYP)==#T_DEFAULT THEN
  RVM_LOCAL_TYP=ARRAY%(RCMP_MAX_LOCAL)
  RVM_LOCAL%=ARRAY%(RCMP_MAX_LOCAL)
  RVM_LOCAL#=ARRAY#(RCMP_MAX_LOCAL)
  RVM_LOCAL$=ARRAY$(RCMP_MAX_LOCAL)
  RVM_INARG_TYP=ARRAY%(RCMP_MAX_INARG)
  RVM_INARG%=ARRAY%(RCMP_MAX_INARG)
  RVM_INARG#=ARRAY#(RCMP_MAX_INARG)
  RVM_INARG$=ARRAY$(RCMP_MAX_INARG)
  RVM_OUTARG_TYP=ARRAY%(RCMP_MAX_OUTARG)
  RVM_OUTARG%=ARRAY%(RCMP_MAX_OUTARG)
  RVM_OUTARG#=ARRAY#(RCMP_MAX_OUTARG)
  RVM_OUTARG$=ARRAY$(RCMP_MAX_OUTARG)
  RVM_REG_TYP=ARRAY%(LEN(RGEN_REG))
  RVM_REG%=ARRAY%(LEN(RGEN_REG))
  RVM_REG#=ARRAY#(LEN(RGEN_REG))
  RVM_REG$=ARRAY$(LEN(RGEN_REG))
 ELSE
  RESIZE RVM_LOCAL_TYP,RCMP_MAX_LOCAL
  RESIZE RVM_LOCAL%,RCMP_MAX_LOCAL
  RESIZE RVM_LOCAL#,RCMP_MAX_LOCAL
  RESIZE RVM_LOCAL$,RCMP_MAX_LOCAL
  RESIZE RVM_INARG_TYP,RCMP_MAX_INARG
  RESIZE RVM_INARG%,RCMP_MAX_INARG
  RESIZE RVM_INARG#,RCMP_MAX_INARG
  RESIZE RVM_INARG$,RCMP_MAX_INARG
  RESIZE RVM_OUTARG_TYP,RCMP_MAX_OUTARG
  RESIZE RVM_OUTARG%,RCMP_MAX_OUTARG
  RESIZE RVM_OUTARG#,RCMP_MAX_OUTARG
  RESIZE RVM_OUTARG$,RCMP_MAX_OUTARG
  RESIZE RVM_REG_TYP,LEN(RGEN_REG)
  RESIZE RVM_REG%,LEN(RGEN_REG)
  RESIZE RVM_REG#,LEN(RGEN_REG)
  RESIZE RVM_REG$,LEN(RGEN_REG)
 ENDIF

 RGEN_SET_SBCODE
 FOR I=0TO RCMP_MAX_INARG-1
  IF !I THEN
   RGEN_EMIT_SBCODE "VAR "+RGEN_INARG_STR$(I)
  ELSE
   RGEN_EMIT_SBCODE ","+RGEN_INARG_STR$(I)
  ENDIF
 NEXT
 RGEN_SET_SBCODE
 FOR I=0TO RCMP_MAX_OUTARG-1
  IF !I THEN
   RGEN_EMIT_SBCODE "VAR "+RGEN_OUTARG_STR$(I)
  ELSE
   RGEN_EMIT_SBCODE ","+RGEN_OUTARG_STR$(I)
  ENDIF
 NEXT
 RGEN_SET_SBCODE
 FOR I=0TO LAST(RGEN_REG)
  IF !I THEN
   RGEN_EMIT_SBCODE "VAR "+RGEN_REG_STR$(I)
  ELSE
   RGEN_EMIT_SBCODE ","+RGEN_REG_STR$(I)
  ENDIF
 NEXT
 RGEN_SET_SBCODE
 RVM_SWITCH_SLOT CMP_SLOT
 RVM_BP=ARRAY%(0)
 RVM_TBP_SLOT=ARRAY%(0)
END

DEF RGE2
 RGEN_EMIT_SBCODE\
  "DEF S A:ON TYPEOF(A)GOTO"+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ)+","+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+1)+","+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+2)+","+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+3)+\
  ":T[P]=TYPEOF(A):I[P]=VM_ALLOC_ARRAY(A):GOTO@S"+STR$(RGEN_SAVE_REGS_UNIQ+4)+":"+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ)+":"+\
  "T[P]=0GOTO@S"+STR$(RGEN_SAVE_REGS_UNIQ+4)+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+1)+":"+\
  "T[P]=1I[P]=A:GOTO@S"+STR$(RGEN_SAVE_REGS_UNIQ+4)+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+2)+":"+\
  "T[P]=2R[P]=A:GOTO@S"+STR$(RGEN_SAVE_REGS_UNIQ+4)+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+3)+":"+\
  "T[P]=3S[P]=A:GOTO@S"+STR$(RGEN_SAVE_REGS_UNIQ+4)+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+4)+":"+\
  "INC P"+\
  CHR$(10)
 RGEN_EMIT_SBCODE "END"+CHR$(10)
 INC RGEN_SAVE_REGS_UNIQ,4
END
DEF RGE1
 RGEN_EMIT_SBCODE\
  "DEF L():DEC P:ON T[P]GOTO"+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ)+","+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+1)+","+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+2)+","+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+3)+":"+\
\
  "RETURN VM_GETFREE_ARRAY(I[P]):@S"+STR$(RGEN_SAVE_REGS_UNIQ)+":"+\
  "RETURN EMPTY"+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+1)+":"+\
  "RETURN I[P]"+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+2)+":"+\
  "RETURN R[P]"+\
  "@S"+STR$(RGEN_SAVE_REGS_UNIQ+3)+":"+\
  "RETURN S[P]"+\
  CHR$(10)
 RGEN_EMIT_SBCODE "END"+CHR$(10)
 INC RGEN_SAVE_REGS_UNIQ,4
END
ENUM\
 #RIR_REF_GLOBAL,\
 #RIR_REF_LOCAL,\
 #RIR_REF_INARG,\
 #RIR_REF_OUTARG,\
 #RIR_REF_ARRAY,\
 #RIR_REF_VAR
DEF RIR_GEN_REF_CODE II OUT I
 I=II
 VAR IDX=RIR_OPS[I]:INC I
 CASE IDX
 WHEN #RIR_REF_GLOBAL
  RIR_GEN_GLOBAL I OUT I
 WHEN #RIR_REF_LOCAL
  RIR_GEN_LOCAL I OUT I
 WHEN #RIR_REF_INARG
  RIR_GEN_INARG I OUT I
 WHEN #RIR_REF_OUTARG
  RIR_GEN_OUTARG I OUT I
 WHEN #RIR_REF_ARRAY
  RIR_GEN_ARRAY I OUT I
 WHEN #RIR_REF_VAR
  RIR_GEN_VAR I OUT I
 OTHERWISE
  STOP
 ENDCASE
END
DEF RIR_GEN_GLOBAL II OUT I
 I=II
 VAR IDX=RIR_OPS[I]:INC I
 RGEN_EMIT_SBCODE RGEN_GLOBAL_STR$(IDX)
END
DEF RIR_GEN_LOCAL II OUT I
 I=II
 VAR IDX=RIR_OPS[I]:INC I
 RGEN_EMIT_SBCODE RGEN_LOCAL_STR$(IDX)
END
DEF RIR_GEN_INARG II OUT I
 I=II
 VAR IDX=RIR_OPS[I]:INC I
 RGEN_EMIT_SBCODE RGEN_INARG_STR$(IDX)
END
DEF RIR_GEN_OUTARG II OUT I
 I=II
 VAR IDX=RIR_OPS[I]:INC I
 RGEN_EMIT_SBCODE RGEN_OUTARG_STR$(IDX)
END
DEF RIR_GEN_ARRAY II OUT I
 I=II
 VAR ARY_R,ARY_R$
 VAR IND_R,IND_R$
 RGEN_GET_REG RIR_OPS[I] OUT ARY_R,ARY_R$:INC I
 VAR DM=RIR_OPS[I]:INC I
 RGEN_EMIT_SBCODE ARY_R$+"["
 VAR J
 FOR J=0TO DM-1
  RGEN_GET_REG RIR_OPS[I] OUT IND_R,IND_R$:INC I
  IF J THEN
   RGEN_EMIT_SBCODE ","+IND_R$
  ELSE
   RGEN_EMIT_SBCODE IND_R$
  ENDIF
  RGEN_FREE_REG IND_R
 NEXT
 RGEN_EMIT_SBCODE "]
 RGEN_FREE_REG ARY_R
END
DEF RIR_GEN_VAR II OUT I
 I=II
 VAR VAR_R,VAR_R$
 RGEN_GET_REG RIR_OPS[I] OUT VAR_R,VAR_R$:INC I
 RGEN_FREE_REG VAR_R
 RGEN_EMIT_SBCODE "VAR(RVM_VAR$("+STR$(CMP_SLOT)+","+STR$(RGEN_FUNC)+","+VAR_R$+"))"
END
DEF RIR_GET_OP$(OP)
 CASE OP
 WHEN #RIR_ADD
  RETURN "+"
 WHEN #RIR_SUB
  RETURN "-"
 WHEN #RIR_MUL
  RETURN "*"
 WHEN #RIR_DIV
  RETURN "/"
 WHEN #RIR_DIVINT
  RETURN " DIV "
 WHEN #RIR_MOD
  RETURN " MOD "
 WHEN #RIR_AND
  RETURN " AND "
 WHEN #RIR_OR
  RETURN " OR "
 WHEN #RIR_XOR
  RETURN " XOR "
 WHEN #RIR_EQ
  RETURN "=="
 WHEN #RIR_NEQ
  RETURN "!="
 WHEN #RIR_LSHIFT
  RETURN "<<"
 WHEN #RIR_RSHIFT
  RETURN ">>"
 WHEN #RIR_GREAT
  RETURN "<"
 WHEN #RIR_LESS
  RETURN ">"
 WHEN #RIR_GEQ
  RETURN "<="
 WHEN #RIR_LEQ
  RETURN ">="
 WHEN #RIR_NEG
  RETURN "-"
 WHEN #RIR_NOT
  RETURN "NOT "
 WHEN #RIR_LNOT
  RETURN "!"
 ENDCASE
END
VAR RCMP_STRICT
VAR RCMP_DEFINT
DEF INIT_RCOMPILER SLOT
 RCMP_STRICT=#FALSE
 RCMP_DEFINT=#FALSE
 RCMP_REG=0
 INIT_COMPILER SLOT
 INIT_RIR_CODEGEN
END
DEF RCOMPILE AST
 RCOMPILE_STATEMENTS AST
 REMIT #RIR_END
 REMIT #RIR_DBG_TEMP_STOP
 RIR_GEN_SBCODE
 VM_TYPE$="R"
' RIR_DUMP
END
DEF RCOMPILE_STATEMENTS A
 VAR I
 CASE AST_TYP[A]
 WHEN #AST_STATEMENTS
  I=AST_NEXT[AST_LEFT[A]]
  WHILE I
   IF!I THEN BREAK
   RCOMPILE_STATEMENT AST_LEFT[I]
   I=AST_NEXT[I]
  WEND
 OTHERWISE
  RCOMPILE_ERROR
 ENDCASE
END
DEF RCOMPILE_STATEMENT A
 IF AST_TYP[A]!=#AST_DEF&&AST_TYP[A]!=#AST_LABEL THEN
  VMDBG_ADD_SRC_INFO2 AST_LINE[A],AST_POS[A],AST_LINE_END[A],AST_POS_END[A],RIR_NEXT_ADDR()
 ENDIF
 CASE AST_TYP[A]
 WHEN #AST_PRINT
  RCOMPILE_PRINT A
 WHEN #AST_ASSIGN
  RCOMPILE_ASSIGN A
 WHEN #AST_IF
  RCOMPILE_IF A
 WHEN #AST_FOR
  RCOMPILE_FOR A
 WHEN #AST_BREAK
  RCOMPILE_BREAK
 WHEN #AST_CONTINUE
  RCOMPILE_CONTINUE
 WHEN #AST_WHILE
  RCOMPILE_WHILE A
 WHEN #AST_REPEAT
  RCOMPILE_REPEAT A
 WHEN #AST_LOOP
  RCOMPILE_LOOP A
 WHEN #AST_LABEL
  RCOMPILE_LABEL A
 WHEN #AST_GOTO
  RCOMPILE_GOTO A
 WHEN #AST_GOSUB
  RCOMPILE_GOSUB A
 WHEN #AST_GOTOEXPR
  RCOMPILE_GOTOEXPR A
 WHEN #AST_GOSUBEXPR
  RCOMPILE_GOSUBEXPR A
 WHEN #AST_ONGOTO
 WHEN #AST_ONGOSUB
  RCOMPILE_ONGOTO A
 WHEN #AST_ONBREAKGOTO
  RCOMPILE_ONBREAKGOTO A
 WHEN #AST_ONBREAKGOTOEXPR
  RCOMPILE_ONBREAKGOTOEXPR A
 WHEN #AST_RETURN
  RCOMPILE_RETURN A
 WHEN #AST_CALLFUNC
  VAR VOID
  RCOMPILE_CALLFUNC A OUT VOID
 WHEN #AST_DEF
  RCOMPILE_DEF A
 WHEN #AST_RETURNFUNC
  RCOMPILE_RETURNFUNC A
 WHEN #AST_DEFVAR
  RCOMPILE_DEFVAR A
 WHEN #AST_END
  REMIT #RIR_END
 WHEN #AST_OPTIONSTRICT
  RCMP_STRICT=#TRUE
 WHEN #AST_OPTIONDEFINT
  RCMP_DEFINT=#TRUE
 WHEN #AST_DATA
'  RCOMPILE_DATA A
  COMPILE_DATA A
 WHEN #AST_CONST
  COMPILE_CONST A
 WHEN #AST_ENUM
  COMPILE_ENUM A
 WHEN #AST_READ
  RCOMPILE_READ A
 WHEN #AST_RESTORE
  RCOMPILE_RESTORE A
 WHEN #AST_RESTOREEXPR
  RCOMPILE_RESTOREEXPR A
 WHEN #AST_CALLSPRITE
  REMIT #RIR_CALLSPRITEINIT
  REMIT #RIR_CALLSPRITE
  REMIT #RIR_CALLBACKEND
 WHEN #AST_CALLTEXT
  REMIT #RIR_CALLTEXTINIT
  REMIT #RIR_CALLTEXT
  REMIT #RIR_CALLBACKEND
 WHEN #AST_TPRINT
  RCOMPILE_TPRINT A
 WHEN #AST_INC
 WHEN #AST_DEC
  RCOMPILE_INC A
 WHEN #AST_CASE
  RCOMPILE_CASE A
 WHEN #AST_SWAP
  RCOMPILE_SWAP A
 WHEN #AST_INPUT
  RCOMPILE_INPUT A
 WHEN #AST_LINPUT
  RCOMPILE_LINPUT A
 WHEN #AST_DEFOUT
  RCOMPILE_DEFOUT A
 WHEN #AST_EXEC
  RCOMPILE_EXEC A
 WHEN #AST_STOP
  RCOMPILE_STOP A
 OTHERWISE
  ?AST_STR$(AST_TYP[A])
  RCOMPILE_ERROR
 ENDCASE
END


DEF RCOMPILE_INPUT A
 'RIGHT TO LEFT
 DIM EXPR%[0]
 VAR RTL=#FALSE
 IF RTL THEN
  VAR I=AST_PREV[AST_A2[A]]
  WHILE I!=AST_A2[A]
   PUSH EXPR%,AST_A1[I]
   I=AST_PREV[I]
  WEND
 ELSE
  I=AST_NEXT[AST_A2[A]]
  WHILE I
   PUSH EXPR%,AST_A1[I]
   I=AST_NEXT[I]
  WEND
 ENDIF
 IF AST_A1[A]THEN
  VAR GUIDE=RCOMPILE_EXPR(AST_A1[A])
  'A3:SEMICOLON
  RCOMPILE_REF EXPR%,#RIR_INPUTGUIDE,AST_A3[A],LEN(EXPR%),GUIDE
 ELSE
  RCOMPILE_REF EXPR%,#RIR_INPUT,AST_A3[A],LEN(EXPR%)
 ENDIF
END
DEF RCOMPILE_LINPUT A
 IF AST_A1[A]THEN
  VAR GUIDE=RCOMPILE_EXPR(AST_A1[A])
  VAR REG=RCOMPILE_ADDREG()
  REMIT #RIR_LINPUTGUIDE
  REMIT GUIDE
  REMIT REG
 ELSE
  REG=RCOMPILE_ADDREG()
  REMIT #RIR_LINPUT
  REMIT REG
 ENDIF
 RCOMPILE_ASSIGN_REG AST_A2[A],REG
END

DEF RCOMPILE_DEFOUT A
 'RIGHT TO LEFT
 VAR R=RCOMPILE_EXPR(AST_A2[A])
 VAR L=RCOMPILE_EXPR(AST_A1[A])
 REMIT #RIR_DEFOUT
 REMIT L
 REMIT R
END

DEF RCOMPILE_ONBREAKGOTO A
END
DEF RCOMPILE_ONGOTO A
 VAR REG=RCOMPILE_EXPR(AST_A1[A])
 VAR I=AST_NEXT[AST_A2[A]]
 REMIT #RIR_ONGOTO
 REMIT REG
 REMIT AST_TYP[A]==#AST_ONGOSUB
 REMIT -1
 VAR CNTA=RIR_GET_ADDR()
 VAR CNT
 WHILE I
  REMIT_IMM$ AST$[I]
  INC CNT
  I=AST_NEXT[I]
 WEND
 RIR_SET CNTA,CNT
END
DEF RCOMPILE_GOTOEXPR A
 VAR REG=RCOMPILE_EXPR(AST_LEFT[A])
 REMIT #RIR_GOTOEXPR
 REMIT REG
END
DEF RCOMPILE_GOSUBEXPR A
 VAR REG=RCOMPILE_EXPR(AST_LEFT[A])
 REMIT #RIR_GOSUBEXPR
 REMIT REG
END

DEF RCOMPILE_RETURN A
 REMIT #RIR_RETURN
END
DEF RCOMPILE_STOP A
 IF AST_A1[A]THEN
  VAR REG=RCOMPILE_EXPR(AST_A1[A])
  REMIT #RIR_STOP2
  REMIT REG
 ELSE
  REMIT #RIR_STOP1
 ENDIF
END
DEF RCOMPILE_EXEC A
 'RIGHT TO LEFT
 IF AST_A2[A]THEN
  VAR A2=RCOMPILE_EXPR(AST_A2[A])
  VAR A1=RCOMPILE_EXPR(AST_A1[A])
  REMIT #RIR_EXEC2
  REMIT A1
  REMIT A2
 ELSE
  A1=RCOMPILE_EXPR(AST_A1[A])
  REMIT #RIR_EXEC1
  REMIT A1
 ENDIF
END
DEF RCOMPILE_RESTORE A
 IF LEN(AST$[A])THEN
  REMIT #RIR_RESTORE
  REMIT_IMM$ AST$[A]
 ELSE
  'CURRENT SLOT??FIXME
  TYPE_MISMATCH
 ENDIF
END
DEF RCOMPILE_RESTOREEXPR A
 VAR REG=RCOMPILE_EXPR(AST_LEFT[A])
 REMIT #RIR_RESTOREEXPR
 REMIT REG
END
DEF RCOMPILE_LABEL A
 VAR L=DEFINE_LABEL2(AST$[A])
 REMIT #RIR_LABEL
 REMIT_IMM$ AST$[A]
 REMIT L
END

DEF RCOMPILE_GOTO A
 REMIT #RIR_GOTO
 REMIT_IMM$ AST$[A]
END
DEF RCOMPILE_GOSUB A
 REMIT #RIR_GOSUB
 REMIT_IMM$ AST$[A]
END

DEF RCOMPILE_READ A
 VAR I=AST_NEXT[AST_A1[A]]
 WHILE I
  VAR REG=RCOMPILE_ADDREG()
  REMIT #RIR_READ
  REMIT REG
  RCOMPILE_ASSIGN_REG AST_A1[I],REG
  ' BAD:READ->EVAL REFEXPR->ASSIGN
  'GOOD:EVAL REFEXPR->READ->ASSIGN
  I=AST_NEXT[I]
 WEND
END
DEF RCOMPILE_DATA A
 COMPILE_DATA A
 RETURN
 VAR I=AST_NEXT[AST_A1[A]]
 WHILE I
  VAR EXPR=FOLD_CONSTEXPR(AST_A1[I])
  CASE AST_TYP[EXPR]
  WHEN #AST_IMM_INT
   REMIT #RIR_DATAINT
   REMIT AST%[EXPR]
  WHEN #AST_IMM_DBL
   REMIT #RIR_DATAREAL
   REMIT_IMM# AST#[EXPR]
  WHEN #AST_IMM_STR
   REMIT #RIR_DATASTR
   REMIT_IMM$ AST$[EXPR]
  OTHERWISE
   SYNTAX_ERROR "DATA"
  ENDCASE
  I=AST_NEXT[I]
 WEND
END
DEF RCOMPILE_ARRAY_INDEX_EXPR A OUT REGS
 VAR I=AST_PREV[A]
 REGS=ARRAY%(0)
 WHILE I!=A
  UNSHIFT REGS,RCOMPILE_EXPR(AST_A1[I])
  I=AST_PREV[I]
 WEND
END

DEF RCOMPILE_INITARRAY LOCAL,IDX,A
 VAR I=AST_PREV[A]
 VAR IND=AST_GET_ITEM_COUNT(A)
 WHILE I!=A
  DEC IND
  IF LOCAL THEN
   REMIT #RIR_GETLOCAL
  ELSE
   REMIT #RIR_GETGLOBAL
  ENDIF
  VAR ARY_REG=RCOMPILE_ADDREG()
  REMIT ARY_REG
  REMIT IDX
  VAR IND_REG=RCOMPILE_ADDREG()
  REMIT #RIR_MOVINT
  REMIT IND_REG
  REMIT IND
  VAR REG=RCOMPILE_EXPR(AST_A1[I])
  REMIT #RIR_SETARRAY
  REMIT ARY_REG
  REMIT 1
  REMIT IND_REG
  REMIT REG
  I=AST_PREV[I]
 WEND
END
DEF RCOMPILE_DEFVAR A
 'A1:LIST
  '$:NAME
  'A1:INIT EXPR
  'A2:ARRAY DIM
  'A3:ARRAY INIT LIST 
 'LEFT TO RIGHT
 VAR I=AST_NEXT[AST_A1[A]]
 WHILE I
  VAR NAME$=AST$[I]
  VAR IDX,LOCAL,ARY
  IF AST_A2[I] THEN
   ARY=#TRUE
  ELSE
   ARY=#FALSE
  ENDIF
  DEFINE_VAR NAME$,ARY OUT IDX,LOCAL
  IF AST_A1[I] THEN
   VAR REG=RCOMPILE_EXPR(AST_A1[I])
   'FIXME:EXTRACT FUNCTION
   IF LOCAL THEN
    REMIT #RIR_SETLOCAL
   ELSE
    REMIT #RIR_SETGLOBAL
   ENDIF
   REMIT IDX
   REMIT REG
  ELSEIF ARY THEN
   'RIGHT TO LEFT
   VAR DM=RCOMPILE_ARRAY_INDEX_EXPR(AST_A2[I])
   IF LEN(DM)==0THEN
    REG=RCOMPILE_ADDREG()
    REMIT #RIR_MOVINT
    REMIT REG
    REMIT AST_GET_ITEM_COUNT(AST_A3[I])
    PUSH DM,REG
   ENDIF
   VAR ARY_REG=RCOMPILE_ADDREG()
   REMIT #RIR_NEWARRAY
   REMIT ARY_REG
   REMIT LEN(DM)
   REMIT DETER_VAR_TYPE(NAME$,#TRUE)
   VAR J
   FOR J=0TO LAST(DM)
    REMIT DM[J]
   NEXT
   IF LOCAL THEN
    REMIT #RIR_SETLOCAL
   ELSE
    REMIT #RIR_SETGLOBAL
   ENDIF
   REMIT IDX
   REMIT ARY_REG
   IF AST_A3[I]THEN
    'RIGHT TO LEFT
    RCOMPILE_INITARRAY LOCAL,IDX,AST_A3[I]
   ENDIF
  ENDIF
  I=AST_NEXT[I]
 WEND
END
DEF RCOMPILE_ASSIGN A
 VAR L=AST_LEFT[A]
 CASE AST_TYP[L]
 WHEN #AST_VAR
 WHEN #AST_BINOP
 WHEN #AST_VAREXPR
  VAR REG=RCOMPILE_EXPR(AST_RIGHT[A])
  RCOMPILE_ASSIGN_REG L,REG
 OTHERWISE
  STOP
 ENDCASE
END
DEF RCOMPILE_ASSIGN_REG A,REG
 VAR L=A
 CASE AST_TYP[L]
 WHEN #AST_VAR
  VAR IDX,LC
  GET_VAR_INDEX AST$[L] OUT IDX,LC
  IF LC THEN
   IF IDX<0 THEN
    IF IDX>=-FUNC_INCNT[CMP_CURFUNC] THEN'FIXME VAARGS
     REMIT #RIR_SETINARG
     IDX=-IDX-1
    ELSE
     REMIT #RIR_SETOUTARG
     IDX=-IDX-FUNC_INCNT[CMP_CURFUNC]-1
    ENDIF
   ELSE
    REMIT #RIR_SETLOCAL
   ENDIF
  ELSE
   REMIT #RIR_SETGLOBAL
  ENDIF
  REMIT IDX
  REMIT REG
 WHEN #AST_BINOP
  VAR TYP=AST%[A]
  IF TYP!=#TKN_LB THEN
   SYNTAX_ERROR "EXPECTED '['"
   RETURN
  ENDIF
  VAR DM=RCOMPILE_ARRAY_INDEX_EXPR(AST_RIGHT[A])
  VAR ARY_REG=RCOMPILE_EXPR(AST_LEFT[A])
  REMIT #RIR_SETARRAY
  REMIT ARY_REG
  REMIT LEN(DM)
  VAR I
  FOR I=0TO LAST(DM)
   REMIT DM[I]
  NEXT
  REMIT REG
 WHEN #AST_EMPTYEXPR
  REMIT #RIR_EMPTYREG
  REMIT REG
  RETURN
 WHEN #AST_VAREXPR
  VAR VAR_REG=RCOMPILE_EXPR(AST_LEFT[A])
  REMIT #RIR_SETVAR
  REMIT VAR_REG
  REMIT REG
 OTHERWISE
  STOP
 ENDCASE
END
DEF RCOMPILE_CALLFUNCEXPR A OUT REG
 RCOMPILE_CALLFUNC A OUT REG
END
DEF RCOMPILE_CALLFUNC A OUT OUT0_REG
 'A1:IN ARGS
 'A2:OUT ARGS
 'FIXME:SAVE REGS
 VAR FN$=AST$[A]
 VAR INCNT=0
 VAR I
 VAR OUTCNT
 IF AST_TYP[A]==#AST_CALLFUNC THEN
  OUTCNT=AST_GET_ITEM_COUNT(AST_A2[A])
 ELSE
  OUTCNT=1
 ENDIF
 I=AST_PREV[AST_A1[A]]
 DIM REGS%[0]
 WHILE I!=AST_A1[A]
  VAR REG=RCOMPILE_EXPR(AST_A1[I])
  PUSH REGS%,REG
  I=AST_PREV[I]
  INC INCNT
 WEND
' IF !CHKCALL(NOT_USED_SLOT$+FN$) THEN
' REMIT #RIR_SPILLVAR
' ENDIF
 REMIT #RIR_CALL
 REMIT_IMM$ FN$
 REMIT INCNT
 REMIT OUTCNT
 FOR I=0TO LAST(REGS%)
  REMIT REGS%[I]
 NEXT
 DIM OUTREGS%[OUTCNT]
 VAR AD=RIR_NEXT_ADDR()
 FOR I=0TO OUTCNT-1
  OUTREGS%[I]=RCOMPILE_ADDREG()
  IF I==0 THEN OUT0_REG=OUTREGS%[I]
  REMIT OUTREGS%[I]
 NEXT
 IF !CHKCALL(NOT_USED_SLOT$+FN$) THEN
  REMIT #RIR_FILLVAR
  REMIT #RIR_CLEANSTACK
 ENDIF

 IF AST_TYP[A]==#AST_CALLFUNC THEN
  I=AST_PREV[AST_A2[A]]
  VAR J
  WHILE I!=AST_A2[A]
'   VAR RR=RCOMPILE_ADDREG()
'   RIR_SET AD+J,RR
'   REMIT #RIR_MOVREG
'   REMIT RR
'   REMIT OUTREGS%[J]
   RCOMPILE_ASSIGN_REG AST_A1[I],OUTREGS%[J]
   INC J
   I=AST_PREV[I]
  WEND
' ELSE
'  OUT0_REG=RCOMPILE_ADDREG()
'  REMIT #RIR_MOVREG
'  REMIT OUT0_REG
'  REMIT OUTREGS%[0]
 ENDIF
END
DEF RCOMPILE_IF A
 VAR COND_REG=RCOMPILE_EXPR(AST_A1[A])
 REMIT #RIR_BRFALSE
 REMIT COND_REG
 REMIT &H7FFFFFFF
 VAR ENDIF_POS=AST_A5[A]
 VAR ADDR_ELSE=RIR_GET_ADDR()
 RCOMPILE_STATEMENTS AST_A2[A]
 IF AST_A4[A]||AST_A3[A]THEN
  IF ENDIF_POS THEN
   VMDBG_ADD_SRC_INFO2 AST_LINE[ENDIF_POS],AST_POS[ENDIF_POS],AST_LINE_END[ENDIF_POS],AST_POS_END[ENDIF_POS],RIR_NEXT_ADDR()
  ENDIF
  REMIT #RIR_BR
  REMIT &H7FFFFFFF
  VAR ADDR_ENDIF=RIR_GET_ADDR()
 ENDIF
 RIR_SET ADDR_ELSE,RIR_NEXT_ADDR()
 IF AST_A3[A]THEN'ELSEIF
  DIM BRLIST=ARRAY%(0)
  VAR I=AST_NEXT[AST_A3[A]]
  WHILE I
   VMDBG_ADD_SRC_INFO2 AST_LINE[I],AST_POS[I],AST_LINE_END[I],AST_POS_END[I],RIR_NEXT_ADDR()
   VAR COND_ELSEIF=RCOMPILE_EXPR(AST_A1[I])
   REMIT #RIR_BRFALSE
   REMIT COND_ELSEIF
   REMIT &H7FFFFFFF
   VAR ADDR_AFTER_ELSEIF=RIR_GET_ADDR()
   RCOMPILE_STATEMENTS AST_A2[I]
   I=AST_NEXT[I]
   IF ENDIF_POS THEN
    VMDBG_ADD_SRC_INFO2 AST_LINE[ENDIF_POS],AST_POS[ENDIF_POS],AST_LINE_END[ENDIF_POS],AST_POS_END[ENDIF_POS],RIR_NEXT_ADDR()
   ENDIF
   REMIT #RIR_BR
   REMIT &H7FFFFFFF
   PUSH BRLIST,RIR_GET_ADDR()
   RIR_SET ADDR_AFTER_ELSEIF,RIR_NEXT_ADDR()
  WEND
 ENDIF
 IF AST_A4[A]THEN'ELSE
  RCOMPILE_STATEMENTS AST_A4[A]
 ENDIF
 IF AST_A4[A]||AST_A3[A]THEN
  RIR_SET ADDR_ENDIF,RIR_NEXT_ADDR()
 ENDIF
 IF AST_A3[A]THEN'ELSEIF
  FOR I=0TO LAST(BRLIST)
   RIR_SET BRLIST[I],RIR_NEXT_ADDR()
  NEXT
 ENDIF
END
DEF RCOMPILE_ADDREG()
 INC RCMP_REG
 RETURN RCMP_REG
END
DEF RCOMPILE_EXPR A OUT REG
 VAR LEFT_R,RIGHT_R
 CASE AST_TYP[A]
 WHEN #AST_BINOP
  VAR TYP=AST%[A]
  IF TYP==#TKN_LAND THEN
   REG=RCOMPILE_ADDREG()
   LEFT_R=RCOMPILE_EXPR(AST_LEFT[A])
   REMIT #RIR_BRAND
   REMIT LEFT_R
   REMIT REG
   REMIT &H7FFFFFFF
   VAR BR1=RIR_GET_ADDR()
   RIGHT_R=RCOMPILE_EXPR(AST_RIGHT[A])
   REMIT #RIR_BRAND
   REMIT RIGHT_R
   REMIT REG
   REMIT &H7FFFFFFF
   VAR BR2=RIR_GET_ADDR()
   RIR_SET BR1,RIR_NEXT_ADDR()
   RIR_SET BR2,RIR_NEXT_ADDR()
  ELSEIF TYP==#TKN_LOR THEN
   REG=RCOMPILE_ADDREG()
   LEFT_R=RCOMPILE_EXPR(AST_LEFT[A])
   REMIT #RIR_BROR
   REMIT LEFT_R
   REMIT REG
   REMIT &H7FFFFFFF
   BR1=RIR_GET_ADDR()
   RIGHT_R=RCOMPILE_EXPR(AST_RIGHT[A])
   REMIT #RIR_BROR
   REMIT RIGHT_R
   REMIT REG
   REMIT &H7FFFFFFF
   BR2=RIR_GET_ADDR()
   RIR_SET BR1,RIR_NEXT_ADDR()
   RIR_SET BR2,RIR_NEXT_ADDR()
  ELSEIF TYP==#TKN_LB THEN
   VAR IND_REGS=RCOMPILE_ARRAY_INDEX_EXPR(AST_RIGHT[A])
   VAR ARY_REG=RCOMPILE_EXPR(AST_LEFT[A])
   REMIT #RIR_GETARRAY
   REG=RCOMPILE_ADDREG()
   REMIT REG
   VAR I
   REMIT ARY_REG
   REMIT LEN(IND_REGS)
   FOR I=0TO LAST(IND_REGS)
    REMIT IND_REGS[I]
   NEXT
  ELSE
   RIGHT_R=RCOMPILE_EXPR(AST_RIGHT[A])
   LEFT_R=RCOMPILE_EXPR(AST_LEFT[A])
   VAR OP
   CASE TYP
   WHEN #TKN_PLUS
    OP=#RIR_ADD
   WHEN #TKN_MINUS
    OP=#RIR_SUB
   WHEN #TKN_MUL
    OP=#RIR_MUL
   WHEN #TKN_DIV
    OP=#RIR_DIV
   WHEN #TKN_DIVINT
    OP=#RIR_DIVINT
   WHEN #TKN_MOD
    OP=#RIR_MOD
   WHEN #TKN_AND
    OP=#RIR_AND
   WHEN #TKN_OR
    OP=#RIR_OR
   WHEN #TKN_XOR
    OP=#RIR_XOR
   WHEN #TKN_EQ
    OP=#RIR_EQ
   WHEN #TKN_NEQ
    OP=#RIR_NEQ
   WHEN #TKN_LSHIFT
    OP=#RIR_LSHIFT
   WHEN #TKN_RSHIFT
    OP=#RIR_RSHIFT
   WHEN #TKN_GREAT
    OP=#RIR_GREAT
   WHEN #TKN_LESS
    OP=#RIR_LESS
   WHEN #TKN_GEQ
    OP=#RIR_GEQ
   WHEN #TKN_LEQ
    OP=#RIR_LEQ
   OTHERWISE
    STOP
   ENDCASE
    REMIT OP
    REG=RCOMPILE_ADDREG()
    REMIT REG
    REMIT LEFT_R
    REMIT RIGHT_R
  ENDIF
 WHEN #AST_IMM_INT
  REMIT #RIR_MOVINT
  REG=RCOMPILE_ADDREG()
  REMIT REG
  REMIT AST%[A]
 WHEN #AST_IMM_DBL
  REMIT #RIR_MOVREAL
  REG=RCOMPILE_ADDREG()
  REMIT REG
  REMIT_IMM# AST#[A]
 WHEN #AST_IMM_STR
  REMIT #RIR_MOVSTR
  REG=RCOMPILE_ADDREG()
  REMIT REG
  REMIT_IMM$ AST$[A]
 WHEN #AST_VAR
  VAR IDX,LC
  GET_VAR_INDEX AST$[A] OUT IDX,LC
  IF LC THEN
   IF IDX<0 THEN
    IF IDX>=-FUNC_INCNT[CMP_CURFUNC] THEN'FIXME VAARGS
     REMIT #RIR_GETINARG
     IDX=-IDX-1
    ELSE
     REMIT #RIR_GETOUTARG
     IDX=-IDX-FUNC_INCNT[CMP_CURFUNC]-1
    ENDIF
   ELSE
    REMIT #RIR_GETLOCAL
   ENDIF
  ELSE
   REMIT #RIR_GETGLOBAL
  ENDIF
  REG=RCOMPILE_ADDREG()
  REMIT REG
  REMIT IDX
 WHEN #AST_CALLFUNCEXPR
  REG=RCOMPILE_CALLFUNCEXPR(A)
 WHEN #AST_CONSTVAR
  REG=RCOMPILE_EXPR(FOLD_CONSTEXPR(A))
 WHEN #AST_UNAOP
  LEFT_R=RCOMPILE_EXPR(AST_LEFT[A])
  CASE AST%[A]
  WHEN #TKN_MINUS
   REMIT #RIR_NEG
  WHEN #TKN_NOT
   REMIT #RIR_NOT
  WHEN #TKN_LNOT
   REMIT #RIR_LNOT
  OTHERWISE
   STOP
  ENDCASE
  REG=RCOMPILE_ADDREG()
  REMIT REG
  REMIT LEFT_R
 WHEN #AST_EMPTYEXPR
  REMIT #RIR_MOVEMPTY
  REG=RCOMPILE_ADDREG()
  REMIT REG
 WHEN #AST_VAREXPR
  LEFT_R=RCOMPILE_EXPR(AST_LEFT[A])
  REMIT #RIR_GETVAR
  REG=RCOMPILE_ADDREG()
  REMIT REG
  REMIT LEFT_R
 OTHERWISE
  ?AST_STR$(AST_TYP[A])
  COMPILE_ERROR
 ENDCASE
END
DEF RCOMPILE_TPRINT A
 VAR I=AST_NEXT[AST_LEFT[A]]
 IF !I THEN
  TYPE_MISMATCH'FIXME:RUNTIME ERROR
 ENDIF
 VAR TREG=RCOMPILE_EXPR(AST_LEFT[I])
 I=AST_NEXT[I]
 VAR CNT
 DIM ARGS=ARRAY%(0)
 WHILE I
  IF!I THEN BREAK
  VAR REG=RCOMPILE_EXPR(AST_LEFT[I])
  CASE AST_TYP[I]
  WHEN #AST_PRINT_EXPR_COMMA
   PUSH ARGS,0
  WHEN #AST_PRINT_EXPR_NEWLINE
   PUSH ARGS,1
  WHEN #AST_PRINT_EXPR_SEMI
   PUSH ARGS,2
  ENDCASE
   PUSH ARGS,REG
  I=AST_NEXT[I]
  INC CNT
 WEND
 REMIT #RIR_TPRINT
 REMIT TREG
 REMIT LEN(ARGS) DIV 2
 FOR I=0TO LAST(ARGS)
  REMIT ARGS[I]
 NEXT
END
DEF RCOMPILE_PRINT A
 VAR I=AST_NEXT[AST_LEFT[A]]
 VAR CNT
 DIM ARGS=ARRAY%(0)
 WHILE I
  IF!I THEN BREAK
  VAR REG=RCOMPILE_EXPR(AST_LEFT[I])
  CASE AST_TYP[I]
  WHEN #AST_PRINT_EXPR_COMMA
   PUSH ARGS,0
  WHEN #AST_PRINT_EXPR_NEWLINE
   PUSH ARGS,1
  WHEN #AST_PRINT_EXPR_SEMI
   PUSH ARGS,2
  ENDCASE
   PUSH ARGS,REG
  I=AST_NEXT[I]
  INC CNT
 WEND
 REMIT #RIR_PRINT
 REMIT LEN(ARGS) DIV 2
 FOR I=0TO LAST(ARGS)
  REMIT ARGS[I]
 NEXT
END

DEF RCOMPILE_DEF A
 '$:NAME
 'A1:IN LIST
 'A2:OUT LIST
 'A3:STATEMENTS
 'A4:HAS RETURN VALUE
 REMIT #RIR_BR
 REMIT &H7FFFFFFF
 VAR SKIP=RIR_GET_ADDR()
 VAR FN$=AST$[A]
 VAR INCNT
 VAR I
 VAR OUTCNT
 VAR CMN
 INCNT=AST_GET_ITEM_COUNT(AST_A1[A])
 OUTCNT=AST_GET_ITEM_COUNT(AST_A2[A])
 IF AST_A4[A]AND #AST_DEF_A4_HAS_RET_VAL THEN
  INC OUTCNT
 ENDIF
 IF AST_A4[A]AND #AST_DEF_A4_OUT_VAARGS THEN
  OUTCNT=-1
 ENDIF
 IF AST_A4[A]AND #AST_DEF_A4_IN_VAARGS THEN
  INCNT=-1
 ENDIF
 IF AST_A4[A]AND #AST_DEF_A4_COMMON_DEF THEN
  CMN=#TRUE
 ENDIF
 VMDBG_ADD_SRC_INFO2 AST_LINE[A],AST_POS[A],AST_LINE_END[A],AST_POS_END[A],RIR_NEXT_ADDR()
 CMP_CURFUNC=DEFINE_FUNC(FN$,RIR_NEXT_ADDR(),INCNT,OUTCNT,CMN)
 REMIT #RIR_DEFFUN
 REMIT CMP_CURFUNC
 I=AST_NEXT[AST_A1[A]]
 VAR IDX=-INCNT
 WHILE I
  DEFINE_LOCAL_VAR CMP_CURFUNC,AST$[I],IDX
  INC IDX
  I=AST_NEXT[I]
 WEND
 IF INCNT==-1 THEN
  IDX=-1
 ELSE
  IDX=-INCNT-1
 ENDIF
 I=AST_PREV[AST_A2[A]]
 WHILE I!=AST_A2[A]
  DEFINE_LOCAL_VAR CMP_CURFUNC,AST$[I],IDX
  I=AST_PREV[I]
  DEC IDX
 WEND
 RCOMPILE_STATEMENTS AST_A3[A]
 REMIT #RIR_FILLVAR2
 REMIT #RIR_SPILLVAR2
 RIR_SET SKIP,RIR_NEXT_ADDR()
 CMP_CURFUNC=0
 REMIT #RIR_DEFFUN
 REMIT CMP_CURFUNC
END

DEF RCOMPILE_RETURNFUNC A
 VAR EXPR=AST_LEFT[A]
 IF EXPR THEN
  VAR REG=RCOMPILE_EXPR(EXPR)
  REMIT #RIR_SETOUTARG
  REMIT 0
  REMIT REG
 ENDIF
 REMIT #RIR_LEAVE
END

DEF RCOMPILE_FOR_VAR(INDEX,TOEXPR,STEPEXPR,INIT)

 IF STEPEXPR THEN
  VAR STEP_REG=RCOMPILE_EXPR(STEPEXPR)
 ELSE
  STEP_REG=RCOMPILE_ADDREG()
  REMIT #RIR_MOVINT
  REMIT STEP_REG
  REMIT 1
 ENDIF
 VAR TO_REG=RCOMPILE_EXPR(TOEXPR)
 CASE AST_TYP[INDEX]
 WHEN #AST_VAR
  VAR IDX,LC
  GET_VAR_INDEX AST$[INDEX] OUT IDX,LC
  IF LC THEN
   IF IDX<0 THEN
    IF IDX>=-FUNC_INCNT[CMP_CURFUNC] THEN'FIXME VAARGS
     REMIT #RIR_FORINARG
     IDX=-IDX-1
    ELSE
     REMIT #RIR_FOROUTARG
     IDX=-IDX-FUNC_INCNT[CMP_CURFUNC]-1
    ENDIF
   ELSE
    REMIT #RIR_FORLOCAL
   ENDIF
  ELSE
   REMIT #RIR_FORGLOBAL
  ENDIF
  REMIT IDX
  REMIT TO_REG
  REMIT STEP_REG
  REMIT INIT
  REMIT &H7FFFFFFF
  RETURN RIR_GET_ADDR()
 WHEN #AST_BINOP
  VAR TYP=AST%[INDEX]
  IF TYP!=#TKN_LB THEN
   SYNTAX_ERROR "EXPECTED '['"
   RETURN
  ENDIF
  VAR DM=RCOMPILE_ARRAY_INDEX_EXPR(AST_RIGHT[INDEX])
  VAR ARY_REG=RCOMPILE_EXPR(AST_LEFT[INDEX])
  REMIT #RIR_FORARRAY
  REMIT ARY_REG
  REMIT TO_REG
  REMIT STEP_REG
  REMIT INIT
  REMIT &H7FFFFFFF
  VAR AD=RIR_GET_ADDR()
  REMIT LEN(DM)
  VAR J
  FOR J=0TO LAST(DM)
   REMIT DM[J]
  NEXT
  RETURN AD
 OTHERWISE
  STOP
 ENDCASE
END

DEF RCOMPILE_FOR A
 'A1:INDEXREFEXPR
 'A2:INITEXPR
 'A3:TOEXPR
 'A4:STEPEXPR
 'A5:STATEMENTS
 VAR INDEXREF=AST_A1[A]
 VAR INITEXPR=AST_A2[A]
 VAR TOEXPR=AST_A3[A]
 VAR STEPEXPR=AST_A4[A]
 VAR STATEMENTS=AST_A5[A]
 RCOMPILE_ASSIGN_REG INDEXREF,RCOMPILE_EXPR(INITEXPR)
 '0-GLOBAL 1-LOCAL 2IN 3OUT
 VAR BRKADDR=RCOMPILE_FOR_VAR(INDEXREF,TOEXPR,STEPEXPR,#TRUE)
 VAR LOOPADDR=RIR_NEXT_ADDR()
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  RCOMPILE_STATEMENTS STATEMENTS
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   RIR_SET CMP_CONTINUE[I],RIR_NEXT_ADDR()
  NEXT
  VMDBG_ADD_SRC_INFO2 AST_LINE[A],AST_POS[A],AST_LINE_END[A],AST_POS_END[A],RIR_NEXT_ADDR()
  VAR BRKADDR2=RCOMPILE_FOR_VAR(INDEXREF,TOEXPR,STEPEXPR,#FALSE)
  RIR_SET BRKADDR,RIR_NEXT_ADDR()
  RIR_SET BRKADDR2,LOOPADDR
  FOR I=0TO LAST(CMP_BREAK)
   RIR_SET CMP_BREAK[I],RIR_NEXT_ADDR()
  NEXT
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF RCOMPILE_WHILE A
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  REMIT #RIR_BR
  REMIT &H7FFFFFFF
  VAR BRL=RIR_GET_ADDR()
  VAR BEGINADDR=RIR_NEXT_ADDR()
  RCOMPILE_STATEMENTS AST_A2[A]
  RIR_SET BRL,RIR_NEXT_ADDR()
  VAR CONTADDR=RIR_NEXT_ADDR()
  VAR REG=RCOMPILE_EXPR(AST_A1[A])
  REMIT #RIR_BRTRUE
  REMIT REG
  REMIT BEGINADDR
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   RIR_SET CMP_CONTINUE[I],CONTADDR
  NEXT
  FOR I=0TO LAST(CMP_BREAK)
   RIR_SET CMP_BREAK[I],RIR_NEXT_ADDR()
  NEXT
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF RCOMPILE_REPEAT A
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  VAR LOOPADDR=RIR_NEXT_ADDR()
  RCOMPILE_STATEMENTS AST_A2[A]
  VAR CONTADDR=RIR_NEXT_ADDR()
  VMDBG_ADD_SRC_INFO2 AST_LINE[A],AST_POS[A],AST_LINE_END[A],AST_POS_END[A],RIR_NEXT_ADDR()
  VAR COND_REG=RCOMPILE_EXPR(AST_A1[A])
  REMIT #RIR_BRFALSE
  REMIT COND_REG
  REMIT LOOPADDR
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   RIR_SET CMP_CONTINUE[I],CONTADDR
  NEXT
  FOR I=0TO LAST(CMP_BREAK)
   RIR_SET CMP_BREAK[I],RIR_NEXT_ADDR()
  NEXT
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF RCOMPILE_LOOP A
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  VAR CONTADDR=RIR_NEXT_ADDR()
  RCOMPILE_STATEMENTS AST_A2[A]
  VMDBG_ADD_SRC_INFO2 AST_LINE[A],AST_POS[A],AST_LINE_END[A],AST_POS_END[A],RIR_NEXT_ADDR()
  REMIT #RIR_BR
  REMIT CONTADDR
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   RIR_SET CMP_CONTINUE[I],CONTADDR
  NEXT
  FOR I=0TO LAST(CMP_BREAK)
   RIR_SET CMP_BREAK[I],RIR_NEXT_ADDR()
  NEXT
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END

DEF RCOMPILE_CONTINUE
 IF TYPEOF(CMP_CONTINUE)!=#T_INTARRAY THEN
  SYNTAX_ERROR
  RETURN
 ENDIF
 REMIT #RIR_BR
 REMIT &H7FFFFFFF
 PUSH CMP_CONTINUE,RIR_GET_ADDR()
END
DEF RCOMPILE_BREAK
 IF TYPEOF(CMP_CONTINUE)!=#T_INTARRAY THEN
  SYNTAX_ERROR
  RETURN
 ENDIF
 REMIT #RIR_BR
 REMIT &H7FFFFFFF
 PUSH CMP_BREAK,RIR_GET_ADDR()
END

DEF RCOMPILE_INC A
 'RIGHT TO LEFT
 IF AST_RIGHT[A] THEN
  VAR REG=RCOMPILE_EXPR(AST_RIGHT[A])
 ELSE
  REG=RCOMPILE_ADDREG()
  REMIT #RIR_MOVINT
  REMIT REG
  REMIT 1
 ENDIF
 IF AST_TYP[A]!=#AST_INC THEN
  RCOMPILE_REF 1,AST_LEFT[A],#RIR_INC,#TRUE,REG
 ELSE
  RCOMPILE_REF 1,AST_LEFT[A],#RIR_INC,#FALSE,REG
 ENDIF
END
DEF RCOMPILE_SWAP A
 'RIGHT TO LEFT
 RCOMPILE_REF 2,AST_RIGHT[A],AST_LEFT[A],#RIR_SWAP
END
DEF RCOMPILE_REF *
 VAR I,J
 VAR CNT=DEFARG(0)
 IF TYPEOF(CNT)==#T_INTARRAY THEN
  VAR ARY=#TRUE
  CNT=LEN(DEFARG(0))
 ENDIF
 DIM BUF%[0]
 FOR I=1 TO CNT
  IF ARY THEN
   VAR A=DEFARG(0)[I-1]
  ELSE
   A=DEFARG(I)
  ENDIF
  CASE AST_TYP[A]
  WHEN #AST_VAR
   VAR IDX,LC
   GET_VAR_INDEX AST$[A] OUT IDX,LC
   IF LC THEN
    IF IDX<0 THEN
     IF IDX>=-FUNC_INCNT[CMP_CURFUNC] THEN'FIXME VAARGS
      PUSH BUF%,#RIR_REF_INARG
      IDX=-IDX-1
     ELSE
      PUSH BUF%,#RIR_REF_OUTARG
      IDX=-IDX-FUNC_INCNT[CMP_CURFUNC]-1
     ENDIF
    ELSE
     PUSH BUF%,#RIR_REF_LOCAL
    ENDIF
   ELSE
    PUSH BUF%,#RIR_REF_GLOBAL
   ENDIF
   PUSH BUF%,IDX
  WHEN #AST_BINOP
   VAR TYP=AST%[A]
   IF TYP!=#TKN_LB THEN
    SYNTAX_ERROR "EXPECTED '['"
    RETURN
   ENDIF
   VAR DM=RCOMPILE_ARRAY_INDEX_EXPR(AST_RIGHT[A])
   VAR ARY_REG=RCOMPILE_EXPR(AST_LEFT[A])
   PUSH BUF%,#RIR_REF_ARRAY
   PUSH BUF%,ARY_REG
   PUSH BUF%,LEN(DM)
   FOR J=0TO LAST(DM)
    PUSH BUF%,DM[J]
   NEXT
  WHEN #AST_VAREXPR
   VAR VAR_REG=RCOMPILE_EXPR(AST_LEFT[A])
   PUSH BUF%,#RIR_REF_VAR
   PUSH BUF%,VAR_REG
  OTHERWISE
   STOP
  ENDCASE
 NEXT
 IF ARY THEN
  FOR I=1 TO DEFARGC()-1
   REMIT DEFARG(I)
  NEXT
 ELSE
  FOR I=1+CNT TO DEFARGC()-1
   REMIT DEFARG(I)
  NEXT
 ENDIF
 FOR I=0TO LAST(BUF%)
  REMIT BUF%[I]
 NEXT
END


DEF RCOMPILE_CASE A
 VAR CASE_REG=RCOMPILE_EXPR(AST_A1[A])
 VAR I
 I=AST_NEXT[AST_A2[A]]
 VAR LBL
 DIM BRLIST=ARRAY%(0)
 DIM ENDCASELIST=ARRAY%(0)
 VAR EXPR,STMTS
 VAR HAS_OTHERWISE
 WHILE I
  EXPR=AST_A1[I]
  STMTS=AST_A2[I]
  VMDBG_ADD_SRC_INFO2 AST_LINE[I],AST_POS[I],AST_LINE_END[I],AST_POS_END[I],RIR_NEXT_ADDR()
  IF EXPR THEN
   VAR WHEN_REG=RCOMPILE_EXPR(EXPR)
   REMIT #RIR_WHEN
   REMIT CASE_REG
   REMIT WHEN_REG
   REMIT &H7FFFFFFF
   PUSH BRLIST,RIR_GET_ADDR()
  ELSE
   HAS_OTHERWISE=#TRUE
   REMIT #RIR_OTHERWISE
   REMIT CASE_REG
   REMIT &H7FFFFFFF
   PUSH BRLIST,RIR_GET_ADDR()
  ENDIF
  I=AST_NEXT[I]
 WEND
 IF !HAS_OTHERWISE THEN
  REMIT #RIR_OTHERWISE
  REMIT CASE_REG
  REMIT &H7FFFFFFF
  PUSH ENDCASELIST,RIR_GET_ADDR()
 ENDIF
 I=AST_NEXT[AST_A2[A]]
 VAR J
 WHILE I
  EXPR=AST_A1[I]
  STMTS=AST_A2[I]
  RIR_SET BRLIST[J],RIR_NEXT_ADDR()
  IF EXPR THEN
   IF !AST_IS_EMPTY_STMTS(STMTS)THEN
    RCOMPILE_STATEMENTS STMTS
    REMIT #RIR_BR
    REMIT &H7FFFFFFF
    PUSH ENDCASELIST,RIR_GET_ADDR()
   ENDIF
  ELSE
   RCOMPILE_STATEMENTS STMTS
  ENDIF
  INC J
  I=AST_NEXT[I]
 WEND
 FOR I=0TO LAST(ENDCASELIST)
  RIR_SET ENDCASELIST[I],RIR_NEXT_ADDR()
 NEXT
END

DEF VMDBG_SET_STOP_HANDLER HNDLR$
 RVM_STOP_HANDLER$=HNDLR$
END
VAR RVM_RETS
VAR RVM_RET
VAR RVM_ICNT
VAR RVM_OCNT
DEF RVM_LOAD
 VM_STK_TYP=VAR(RVM_SLOT$+""+RIR_VM_STK_TYP)
 VM_STK%=VAR(RVM_SLOT$+""+RIR_VM_STK%)
 VM_STK#=VAR(RVM_SLOT$+""+RIR_VM_STK#)
 VM_STK$=VAR(RVM_SLOT$+""+RIR_VM_STK$)
 VM_SP=VAR(RVM_SLOT$+"P")
 VM_BP=VAR(RVM_SLOT$+"VM_BP")
 VM_CURSLOT=VAR(RVM_SLOT$+"VM_CURSLOT")
 RVM_SWITCH_SLOT VM_CURSLOT
 VM_CURFUNC=VAR(RVM_SLOT$+"VM_CURFUNC")
 VM_PC=RGEN_RJMP_TABLE[VAR(RVM_SLOT$+"VM_PC")]
 RVM_RETS=VAR(RVM_SLOT$+"RETS")
 RVM_RET=VAR(RVM_SLOT$+"RET")
 RVM_ICNT=VAR(RVM_SLOT$+"ICNT")
 RVM_OCNT=VAR(RVM_SLOT$+"OCNT")
 RVM_STOP_HANDLER$=VAR(RVM_SLOT$+"RVM_STOP_HANDLER$")
 VAR SLOT
 FOR SLOT=0TO LAST(VM_SLOT_OPS)
  IF!VM_SLOT_GVAR_TYP[SLOT] THEN CONTINUE
  VAR TYP=VM_GET_ARRAY(VM_SLOT_GVAR_TYP[SLOT])
  VAR V%=VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT])
  VAR V#=VM_GET_ARRAY(VM_SLOT_GVAR#[SLOT])
  VAR V$=VM_GET_ARRAY(VM_SLOT_GVAR$[SLOT])
  VAR PREFIX$=RVM_SLOT$+"G"+STR$(SLOT)
  RVM_LOAD_SEQ TYP,V%,V#,V$,PREFIX$
 NEXT
 RVM_LOAD_SEQ RVM_LOCAL_TYP,RVM_LOCAL%,RVM_LOCAL#,RVM_LOCAL$,RVM_SLOT$+"L"
 RVM_LOAD_SEQ RVM_INARG_TYP,RVM_INARG%,RVM_INARG#,RVM_INARG$,RVM_SLOT$+"I"
 RVM_LOAD_SEQ RVM_OUTARG_TYP,RVM_OUTARG%,RVM_OUTARG#,RVM_OUTARG$,RVM_SLOT$+"O"
 RVM_LOAD_SEQ RVM_REG_TYP,RVM_REG%,RVM_REG#,RVM_REG$,RVM_SLOT$+"R"
END
DEF RVM_LOAD_SEQ TYP,V%,V#,V$,PREFIX$
 VAR I
 FOR I=0TO LAST(TYP)
  CASE TYP[I]
  WHEN #VMT_INTARRAY
  WHEN #VMT_REALARRAY
  WHEN #VMT_STRARRAY
   VM_FREE_ARRAY V%[I]
  ENDCASE
  VAR V=VAR(PREFIX$+STR$(I))
  CASE TYPEOF(V)
  WHEN #T_DEFAULT
   TYP[I]=#VMT_DEFAULT
  WHEN #T_INT
   TYP[I]=#VMT_INT
   V%[I]=V
  WHEN #T_REAL
   TYP[I]=#VMT_REAL
   V#[I]=V
  WHEN #VMT_STR
   TYP[I]=#VMT_STR
   V$[I]=V
  WHEN #VMT_INTARRAY
   TYP[I]=#VMT_INTARRAY
   V%[I]=VM_ALLOC_ARRAY(V)
  WHEN #VMT_REALARRAY
   TYP[I]=#VMT_INTARRAY
   V%[I]=VM_ALLOC_ARRAY(V)
  WHEN #VMT_STRARRAY
   TYP[I]=#VMT_INTARRAY
   V%[I]=VM_ALLOC_ARRAY(V)
  ENDCASE
 NEXT
END
DEF RVM_SAVE
 VAR(RVM_SLOT$+RIR_VM_STK_TYP)=VM_STK_TYP
 VAR(RVM_SLOT$+RIR_VM_STK%)=VM_STK%
 VAR(RVM_SLOT$+RIR_VM_STK#)=VM_STK#
 VAR(RVM_SLOT$+RIR_VM_STK$)=VM_STK$
 VAR(RVM_SLOT$+"P")=VM_SP
 VAR(RVM_SLOT$+"VM_BP")=VM_BP
 VAR(RVM_SLOT$+"VM_CURSLOT")=VM_CURSLOT
 VAR(RVM_SLOT$+"VM_CURFUNC")=VM_CURFUNC
 VAR(RVM_SLOT$+"VM_PC")=VMDBG_BINSEARCH(RIR_OPS_LINE_PC,VM_PC)
 VAR(RVM_SLOT$+"EMPTY")=EMPTY()
 VAR(RVM_SLOT$+"RET")=RVM_RET
 VAR(RVM_SLOT$+"RETS")=RVM_RETS
 VAR(RVM_SLOT$+"ICNT")=RVM_ICNT
 VAR(RVM_SLOT$+"OCNT")=RVM_OCNT
 VAR(RVM_SLOT$+"RVM_STOP_HANDLER$")=RVM_STOP_HANDLER$
 VAR I,SLOT
 FOR SLOT=0TO LAST(VM_SLOT_OPS)
  IF!VM_SLOT_GVAR_TYP[SLOT] THEN CONTINUE
  VAR TYP=VM_GET_ARRAY(VM_SLOT_GVAR_TYP[SLOT])
  VAR V%=VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT])
  VAR V#=VM_GET_ARRAY(VM_SLOT_GVAR#[SLOT])
  VAR V$=VM_GET_ARRAY(VM_SLOT_GVAR$[SLOT])
  VAR PREFIX$=RVM_SLOT$+"G"+STR$(SLOT)
  RVM_SAVE_SEQ TYP,V%,V#,V$,PREFIX$
 NEXT
 RVM_SAVE_SEQ RVM_LOCAL_TYP,RVM_LOCAL%,RVM_LOCAL#,RVM_LOCAL$,RVM_SLOT$+"L"
 RVM_SAVE_SEQ RVM_INARG_TYP,RVM_INARG%,RVM_INARG#,RVM_INARG$,RVM_SLOT$+"I"
 RVM_SAVE_SEQ RVM_OUTARG_TYP,RVM_OUTARG%,RVM_OUTARG#,RVM_OUTARG$,RVM_SLOT$+"O"
 RVM_SAVE_SEQ RVM_REG_TYP,RVM_REG%,RVM_REG#,RVM_REG$,RVM_SLOT$+"R"
END
DEF RVM_SAVE_SEQ TYP,V%,V#,V$,PREFIX$
 VAR I
 FOR I=0TO LAST(TYP)
  CASE TYP[I]
  WHEN #VMT_DEFAULT
   VAR(PREFIX$+STR$(I))=EMPTY()
  WHEN #VMT_INT
   VAR(PREFIX$+STR$(I))=V%[I]
  WHEN #VMT_REAL
   VAR(PREFIX$+STR$(I))=V#[I]
  WHEN #VMT_STR
   VAR(PREFIX$+STR$(I))=V$[I]
  WHEN #VMT_INTARRAY
  WHEN #VMT_REALARRAY
  WHEN #VMT_STRARRAY
   VAR(PREFIX$+STR$(I))=VM_GET_ARRAY(V%[I])
  ENDCASE
 NEXT
END
CONST #RVM_GET_NEXT_INSTR_ADDR_LEAVE=-1000
DEF RVM_GET_NEXT_INSTR_ADDR PC,NXT,STEPIN OUT I
 I=PC
 VAR J
 REPEAT
  @CONTINUE
  VAR OI=I
  IF LEN(RIR_OPS)<=I THEN RETURN
  VAR C=RIR_OPS[I]
'  ?RIR_STR$(C),I
  INC I
  CASE C
  WHEN #RIR_MOVINT
  WHEN #RIR_MOVREAL
  WHEN #RIR_MOVSTR
   INC I,2
  WHEN #RIR_MOVEMPTY
   INC I
  WHEN #RIR_NEWARRAY
   INC I
   VAR DM=RIR_OPS[I]:INC I
   INC I
   INC I,DM
  WHEN #RIR_ADD
  WHEN #RIR_SUB
  WHEN #RIR_MUL
  WHEN #RIR_DIV
  WHEN #RIR_DIVINT
  WHEN #RIR_MOD
  WHEN #RIR_AND
  WHEN #RIR_OR
  WHEN #RIR_XOR
  WHEN #RIR_EQ
  WHEN #RIR_NEQ
  WHEN #RIR_LSHIFT
  WHEN #RIR_RSHIFT
  WHEN #RIR_GREAT
  WHEN #RIR_LESS
  WHEN #RIR_GEQ
  WHEN #RIR_LEQ
   INC I,3
  WHEN #RIR_NEG
  WHEN #RIR_NOT
  WHEN #RIR_LNOT
  WHEN #RIR_GETGLOBAL
  WHEN #RIR_GETLOCAL
  WHEN #RIR_GETINARG
  WHEN #RIR_GETOUTARG
  WHEN #RIR_GETVAR
  WHEN #RIR_MOVREG
  WHEN #RIR_SETGLOBAL
  WHEN #RIR_SETLOCAL
  WHEN #RIR_SETINARG
  WHEN #RIR_SETOUTARG
  WHEN #RIR_SETVAR
   INC I,2
  WHEN #RIR_PRINT
   VAR CNT=RIR_OPS[I]*2+I-1
   FOR I=I+1 TO CNT STEP 2
   NEXT
  WHEN #RIR_TPRINT
   INC I
   CNT=RIR_OPS[I]*2+I-1
   FOR I=I+1 TO CNT STEP 2
   NEXT
  WHEN #RIR_BRFALSE
   INC I
   PUSH NXT,RIR_OPS[I]:INC I
  WHEN #RIR_BRTRUE
   INC I
   PUSH NXT,RIR_OPS[I]:INC I
  WHEN #RIR_BR
   I=RIR_OPS[I]
  WHEN #RIR_CALL
   VAR FUNC$=RIR_IMM$[RIR_OPS[I]]
   VAR INCNT=RIR_OPS[I+1]
   VAR OUTCNT=RIR_OPS[I+2]
   INC I,3+INCNT+OUTCNT
   IF CHKCALL(NOT_USED_SLOT$+FUNC$)||CHKCALL("SBSB_"+FUNC$)||CHKCALL("RSBSB_"+FUNC$) THEN
   ELSE
    IF STEPIN THEN
     I=-OI-1
'     I=#RVM_GET_NEXT_INSTR_ADDR_LEAVE
    ENDIF
   ENDIF
  WHEN #RIR_DEFFUN
   INC I,1
  WHEN #RIR_LEAVE
   I=-OI-1'#RVM_GET_NEXT_INSTR_ADDR_LEAVE
'   RGEN_EMIT_SBCODE "VM_PC=RET:ON RETS GOTO@JMP0,@JMP1,@JMP2,@JMP3
  WHEN #RIR_END
   CONTINUE
  WHEN #RIR_FORGLOBAL
  WHEN #RIR_FORLOCAL
  WHEN #RIR_FORINARG
  WHEN #RIR_FOROUTARG
   INC I,4
   PUSH NXT,RIR_OPS[I]:INC I
  WHEN #RIR_FORARRAY
   INC I,4
   PUSH NXT,RIR_OPS[I]:INC I
   DM=RIR_OPS[I]:INC I
   INC I,DM
  WHEN #RIR_SETARRAY
   INC I
   DM=RIR_OPS[I]:INC I
   INC I,DM
   INC I
  WHEN #RIR_GETARRAY
   INC I,2
   DM=RIR_OPS[I]:INC I
   INC I,DM
  WHEN #RIR_DATAINT
  WHEN #RIR_DATASTR
  WHEN #RIR_DATAREAL
  WHEN #RIR_READ
  WHEN #RIR_RESTORE
   INC I
  WHEN #RIR_LABEL
   INC I,2
   GOTO@CONTINUE
  WHEN #RIR_GOSUB
  WHEN #RIR_GOTO
   VAR LABEL$=RIR_IMM$[RIR_OPS[I]]:INC I
   VAR SLOT,LABEL,FOUND
   VM_GET_LABEL LABEL$,0 OUT SLOT,LABEL,FOUND
   I=RGEN_RJMP_TABLE[LABEL_ADDR[LABEL]]
  WHEN #RIR_RESTOREEXPR
   INC I
  WHEN #RIR_INC
   INC I,2
   RIR_NEXT_REF_CODE I OUT I
  WHEN #RIR_BRAND
  WHEN #RIR_BROR
  WHEN #RIR_WHEN
   INC I,2
   PUSH NXT,RIR_OPS[I]:INC I
  WHEN #RIR_OTHERWISE
   INC I
   PUSH NXT,RIR_OPS[I]:INC I
  WHEN #RIR_STOP1
   BREAK
  WHEN #RIR_STOP2
   INC I
  WHEN #RIR_EXEC1
   INC I
  WHEN #RIR_EXEC2
   INC I,2
   STOP
  WHEN #RIR_RETURN
   I=-OI-1'#RVM_GET_NEXT_INSTR_ADDR_LEAVE
  WHEN #RIR_CALLSPRITEINIT
  WHEN #RIR_CALLTEXTINIT
  WHEN #RIR_CALLSPRITE
  WHEN #RIR_CALLTEXT
  WHEN #RIR_CALLBACKEND
   BREAK
  WHEN #RIR_GOTOEXPR
  WHEN #RIR_GOSUBEXPR
   INC I
  WHEN #RIR_ONGOTO
   STOP
  WHEN #RIR_CLEANSTACK
  WHEN #RIR_SPILLVAR
  WHEN #RIR_FILLVAR
  WHEN #RIR_SPILLVAR2
  WHEN #RIR_FILLVAR2
   GOTO@CONTINUE
  WHEN #RIR_DEFOUT
   INC I,2
  
  WHEN #RIR_INPUTGUIDE
   INC I
   CNT=RIR_OPS[I]:INC I
   INC I
   FOR J=0TO CNT-1
    RIR_NEXT_REF_CODE I OUT I
   NEXT
  WHEN #RIR_INPUT
   INC I
   CNT=RIR_OPS[I]:INC I
   FOR J=0TO CNT-1
    RIR_GEN_REF_CODE I OUT I
   NEXT
  WHEN #RIR_LINPUT
   INC I
  WHEN #RIR_LINPUTGUIDE
   INC I,2
  WHEN #RIR_EMPTYREG
   INC I
  WHEN #RIR_SWAP
   RIR_NEXT_REF_CODE I OUT I
   RIR_NEXT_REF_CODE I OUT I
  OTHERWISE
   STOP
  ENDCASE
 UNTIL 1
END

DEF RIR_NEXT_REF_CODE II OUT I
 I=II
 VAR IDX=RIR_OPS[I]:INC I
 CASE IDX
 WHEN #RIR_REF_GLOBAL
 WHEN #RIR_REF_LOCAL
 WHEN #RIR_REF_INARG
 WHEN #RIR_REF_OUTARG
  INC I
 WHEN #RIR_REF_ARRAY
  RIR_NEXT_ARRAY I OUT I
 WHEN #RIR_REF_VAR
  INC I
 OTHERWISE
  STOP
 ENDCASE
END
DEF RIR_NEXT_ARRAY II OUT I
 I=II
 INC I
 VAR DM=RIR_OPS[I]:INC I
 INC I,DM
END
ENUM\
 #RVM_BP_NONE,\
 #RVM_BP_BP,\
 #RVM_BP_TRACE

DEF RVM_SET_TRACE_BREAK_POINTS
 VAR I=VM_PC
 VAR OLINE,OLINE_POS
 VMDBG_GET_LINE VM_CURSLOT,I OUT OLINE,OLINE_POS
 VAR NXT=ARRAY%(0)
 VAR LPC=VMDBG_BINSEARCH(RIR_OPS_LINE_PC,I)
 LOOP
  IF RIR_OPS[I]==#RIR_LEAVE THEN
   IF VM_SP&&VM_STK_TYP[VM_SP-1]==#VMT_SUBROUTINE THEN
    RVMDBG_SET_BP_LPC VM_STK%[VM_SP-2],VM_STK%[VM_SP-1],#RVM_BP_TRACE
   ENDIF
   RVMDBG_SET_BP_LPC RVM_RETS,RVM_RET,#RVM_BP_TRACE
   RETURN
  ELSEIF RIR_OPS[I]==#RIR_RETURN THEN
   RVMDBG_SET_BP_LPC VM_STK%[VM_SP-2],VM_STK%[VM_SP-1],#RVM_BP_TRACE
   RETURN
  ELSEIF RIR_OPS[I]==#RIR_CALL THEN
   IF !VMDBG_TRACE_STEPIN THEN BREAK
   VAR FUNC$=RIR_IMM$[RIR_OPS[I+1]]
   VAR INCNT=RIR_OPS[I+2]
   VAR OUTCNT=RIR_OPS[I+3]
   VAR FOUND,FUNC
   VM_GETFUNC FUNC$,INCNT,OUTCNT OUT FOUND,FUNC
   IF FOUND THEN
    VAR SLOT=FUNC_SLOT[FUNC]
    VAR ADDR=FUNC_ADDR[FUNC]+1'SKIP #RIR_DEFFUN <FUNC>
    RVMDBG_SET_BP_LPC SLOT,ADDR,#RVM_BP_TRACE
    RETURN
   ENDIF
   IF FUNC$=="CALL"THEN RETURN
   BREAK
  ENDIF
  RVM_GET_NEXT_INSTR_ADDR I,NXT,VMDBG_TRACE_STEPIN OUT I
  IF I<0 THEN
   I=-I-1
  ENDIF
  IF LPC!=VMDBG_BINSEARCH(RIR_OPS_LINE_PC,I)THEN BREAK
 ENDLOOP
 I=VM_PC
 RVM_SET_TRACE_BREAK_POINTS2 I,OLINE,OLINE_POS,VMDBG_BINSEARCH(RIR_OPS_LINE_PC,I),ARRAY%(0),VMDBG_TRACE_STEPIN
END
DEF RVM_SET_TRACE_BREAK_POINTS_CHECK_SEARCH(SEARCH_LIST,PC)
 VAR I,L=LAST(SEARCH_LIST)
 FOR I=0TO L
  IF SEARCH_LIST[I]==PC THEN RETURN #TRUE
 NEXT
 RETURN #FALSE
END
DEF RVM_SET_TRACE_BREAK_POINTS2 I,OLINE,OLINE_POS,OL,SEARCH_LIST,STEPIN
 VAR LINE,LINE_POS
 LOOP
  DIM NXT=ARRAY%(0)
  VAR OI=I
  RVM_GET_NEXT_INSTR_ADDR I,NXT,STEPIN OUT I
  IF I<0 THEN
   I=-I-1
   RVMDBG_SET_BP_PC VM_CURSLOT,I,#RVM_BP_TRACE
   BREAK
  ENDIF
  VAR J
  FOR J=0TO LAST(NXT)
   IF RVM_SET_TRACE_BREAK_POINTS_CHECK_SEARCH(SEARCH_LIST,NXT[J]) THEN
    CONTINUE
   ENDIF
   PUSH SEARCH_LIST,NXT[J]
   VMDBG_GET_LINE VM_CURSLOT,NXT[J] OUT LINE,LINE_POS
   IF (OLINE!=LINE||LINE_POS!=OLINE_POS)&&VMDBG_BINSEARCH(RIR_OPS_LINE_PC,NXT[J])!=OL THEN
    RVMDBG_SET_BP_PC VM_CURSLOT,NXT[J],#RVM_BP_TRACE
    BREAK
   ENDIF
   RVM_SET_TRACE_BREAK_POINTS2 NXT[J],OLINE,OLINE_POS,OL,SEARCH_LIST,STEPIN
  NEXT
  IF RVM_SET_TRACE_BREAK_POINTS_CHECK_SEARCH(SEARCH_LIST,I) THEN
   BREAK
  ENDIF
  PUSH SEARCH_LIST,I
  VMDBG_GET_LINE VM_CURSLOT,I OUT LINE,LINE_POS
  IF (OLINE!=LINE||LINE_POS!=OLINE_POS)&&VMDBG_BINSEARCH(RIR_OPS_LINE_PC,I)!=OL THEN
   RVMDBG_SET_BP_PC VM_CURSLOT,I,#RVM_BP_TRACE
   BREAK
  ENDIF
 ENDLOOP
END
VAR RVM_BP_STOP
VAR RVM_BP_SLOT
VAR RVM_BP_ADDR

VAR RVM_RETCODE
VAR RVMDBG_TRACE_FUNC
VAR RVMDBG_TRACE_BP
DEF RVM_CALLSPRITE
 RVM_CALLXXX SPFUNC_LIST,SBTHUNK_SPFUNC$,SBTHUNK_SPFUNC_SLOT,SBTHUNK_SPFUNC_ADDR,SBTHUNK_SPFUNC_ISFUNC
END
DEF RVM_GOSUBCALLBACK L$
 '2:GLOBAL ONLY
 VAR SLOT,LABEL,FOUND
 VM_CURFUNC=0
 VAR(RVM_SLOT$+"VM_CURFUNC")=0
 VM_GET_LABEL L$,2 OUT SLOT,LABEL,FOUND
 IF !FOUND THEN
  UNDEFIND_LABEL L$
  RETURN
 ENDIF
 VM_STK%[VAR(RVM_SLOT$+RIR_VM_SP$)]=VAR(RVM_SLOT$+"VM_CURSLOT")
 VM_STK_TYP[VAR(RVM_SLOT$+RIR_VM_SP$)]=#VMT_SUBROUTINE
 INC VAR(RVM_SLOT$+RIR_VM_SP$)
 VM_STK%[VAR(RVM_SLOT$+RIR_VM_SP$)]=VAR(RVM_SLOT$+"VM_PC")
 VM_STK_TYP[VAR(RVM_SLOT$+RIR_VM_SP$)]=#VMT_SUBROUTINE
 INC VAR(RVM_SLOT$+RIR_VM_SP$)
 VAR(RVM_SLOT$+"VM_PC")=LABEL_ADDR[LABEL]
 VAR(RVM_SLOT$+"VM_CURSLOT")=SLOT
END
DEF RVM_CALLBACK F$,SLOT,ADDR,IS_FUNC
 IF SLOT==-1 THEN
  VM_CURSLOT=VAR(RVM_SLOT$+"VM_CURSLOT")
  VM_PC=VAR(RVM_SLOT$+"VM_PC")
  IF INSTR(F$,"@")!=-1THEN
   RVM_GOSUBCALLBACK F$
  ELSE
   VAR(RVM_SLOT$+"RETS")=VM_CURSLOT
   VAR(RVM_SLOT$+"RET")=VAR(RVM_SLOT$+"VM_PC")
   RVM_CALL F$,0,0 OUT VAR(RVM_SLOT$+"VM_CURSLOT"),VAR(RVM_SLOT$+"VM_PC")
   RVM_SWITCH_SLOT VAR(RVM_SLOT$+"VM_CURSLOT")
  ENDIF
 ELSEIF IS_FUNC THEN
  VAR OLDS=VAR(RVM_SLOT$+"VM_CURSLOT")
  VAR(RVM_SLOT$+"RETS")=OLDS
  VAR(RVM_SLOT$+"RET")=VAR(RVM_SLOT$+"VM_PC")
  VAR(RVM_SLOT$+"VM_CURSLOT")=SLOT
  VAR(RVM_SLOT$+"VM_PC")=ADDR
  VAR(RVM_SLOT$+"ICNT")=0
  VAR(RVM_SLOT$+"OCNT")=0
  IF OLDS!=SLOT THEN
   RVM_SWITCH_SLOT SLOT
  ENDIF
 ELSE
  OLDS=VAR(RVM_SLOT$+"VM_CURSLOT")
  VAR SP$=RVM_SLOT$+RIR_VM_SP$
  VAR SP=VAR(SP$)
  VM_STK_TYP[SP]=#VMT_SUBROUTINE
  VM_STK%[SP]=OLDS
  INC SP
  VM_STK%[SP]=VAR(RVM_SLOT$+"VM_PC")
  VM_STK_TYP[SP]=#VMT_SUBROUTINE
  VAR(SP$)=SP+1
  VAR(RVM_SLOT$+"VM_CURFUNC")=0
  VM_CURFUNC=0
  VAR(RVM_SLOT$+"VM_PC")=ADDR
  VAR(RVM_SLOT$+"VM_CURSLOT")=SLOT
  IF OLDS!=SLOT THEN
   RVM_SWITCH_SLOT SLOT
  ENDIF
 ENDIF
END
DEF RVM_CALLXXX LIST,FUNC$,SLOT,ADDR,ISFUNC
 @P
 INC VM_CALLIDX
 LOOP
  IF VM_CALLIDX>=LEN(LIST) THEN
   INC VAR(RVM_SLOT$+"VM_PC")
   RETURN
  ENDIF
  IF!LIST[VM_CALLIDX] THEN
   INC VM_CALLIDX
  ELSE
   BREAK
  ENDIF
 ENDLOOP
 IF LIST[VM_CALLIDX]THEN
  IF LEN(LIST)==4 THEN
   IF!TVAR(VM_CALLIDX,"TFUNC_CALLBACK")THEN @P
  ELSE
   IF!SPVAR(VM_CALLIDX,"SPFUNC_CALLBACK")THEN @P
  ENDIF
  RVM_CALLBACK FUNC$[VM_CALLIDX],SLOT[VM_CALLIDX],ADDR[VM_CALLIDX],ISFUNC[VM_CALLIDX]
 ENDIF
END
DEF RVM_CALLTEXT
 RVM_CALLXXX TFUNC_LIST,SBTHUNK_TFUNC$,SBTHUNK_TFUNC_SLOT,SBTHUNK_TFUNC_ADDR,SBTHUNK_TFUNC_ISFUNC
END
VAR RVM_BP_DISABLED
DEF RVM_RUN
 IF VMDBG_TRACE THEN
  'PCのツギのアドレスにBPをセッテイする
  RIR_OPS=VM_OPS
  RIR_IMM#=VM_IMM#
  RIR_IMM$=VM_IMM$
  RVM_SET_TRACE_BREAK_POINTS
  RVMDBG_TRACE_FUNC=VM_CURFUNC
  RVMDBG_TRACE_BP=VM_BP
 ENDIF
 @RE_EXEC
 PRGEDIT_FASTSEEK RVM_SLOT,RVM_GOTO_BREAK_POINT_LINE
 IF !RVM_BP_STOP THEN
  PRGSET ""
 ELSE
  IF!RVM_BREAK_POINTS[VMDBG_BINSEARCH(RIR_OPS_LINE_PC,RVM_BP_ADDR)] THEN
   PRGSET "GOTO"+RGEN_LABEL2$(RVM_BP_SLOT,RVM_BP_ADDR)'"GOTO@"+STR$(RVM_BP_SLOT)+HEX$(RVM_BP_ADDR)
  ELSE
   PRGSET "GOTO@BP_"+STR$(RVM_BP_SLOT)+HEX$(RVM_BP_ADDR)
  ENDIF
 ENDIF
 EXEC RVM_SLOT
 RVM_SAVE
 @RET_EXEC
 VM_RUNNING=#TRUE
 RVM_RETCODE=CALL(RVM_SLOT$+"VM_RUN")
' ON BREAK GOTO ""
 IF RVM_RETCODE==#RVM_RETCODE_CALLSPRITE THEN
  RVM_CALLSPRITE
  GOTO @RET_EXEC
 ELSEIF RVM_RETCODE==#RVM_RETCODE_CALLTEXT THEN
  RVM_CALLTEXT
  GOTO @RET_EXEC
 ELSEIF RVM_RETCODE==#RVM_RETCODE_TRACE_BP THEN
  IF VMDBG_TRACE&&!VMDBG_TRACE_STEPIN THEN
   IF RVMDBG_TRACE_BP<VAR(RVM_SLOT$+"VM_BP") THEN
    RVM_LOAD
    RVM_BP_STOP=#TRUE
    RVM_BP_SLOT=VM_CURSLOT
    RVM_BP_ADDR=VM_PC
    GOTO@RE_EXEC
   ENDIF
  ENDIF
 ENDIF
 RVM_LOAD
 VM_STOP=#FALSE
 IF RVM_RETCODE==#RVM_RETCODE_BP THEN
  RVM_BP_STOP=#TRUE
  RVM_BP_SLOT=VM_CURSLOT
  RVM_BP_ADDR=VM_PC
  IF RVM_BP_DISABLED THEN
   GOTO@RE_EXEC
  ENDIF
 ELSE
  IF RVM_RETCODE==#RVM_RETCODE_END THEN
   IF VM_SLOT_EXEC_SLOT[VM_CURSLOT]!=-1THEN
    VAR OS=VM_CURSLOT
    VM_PC=VM_SLOT_EXEC_ADDR[OS]
    VM_CURSLOT=VM_SLOT_EXEC_SLOT[OS]
    VM_CURFUNC=VM_SLOT_EXEC_FUNC[OS]
    RVM_SWITCH_SLOT VM_CURSLOT
    VM_SLOT_EXEC_FUNC[OS]=-1
    VM_SLOT_EXEC_ADDR[OS]=-1
    VM_SLOT_EXEC_SLOT[OS]=-1
    RVM_SAVE
    GOTO @RET_EXEC
   ENDIF
   VM_RUNNING=#FALSE
  ELSEIF RVM_RETCODE==#RVM_RETCODE_STOP THEN
   VM_STOP=#TRUE
   VM_STOP_MSG$=""
   VM_RAISE_ERR1 "Break on "+VM_GET_CURLOC$()+CHR$(10)+""
   VM_CONTINUABLE=#TRUE
   INC VM_PC
  ENDIF
  RVM_BP_STOP=#FALSE
 ENDIF
 IF RVM_RETCODE==#RVM_RETCODE_EXEC1 THEN
  RVM_EXEC1 VAR(RVM_SLOT$+"VM_EXEC_ARG1")
  GOTO@RE_EXEC
 ELSEIF RVM_RETCODE==#RVM_RETCODE_EXEC2 THEN
  RVM_EXEC2 VAR(RVM_SLOT$+"VM_EXEC_ARG1"),VAR(RVM_SLOT$+"VM_EXEC_ARG2")
  GOTO@RE_EXEC
 ENDIF
 VAR S,L,I$,LP,I
 VMDBG_GET OUT S,L,LP
 FOR I=0TO LAST(RVM_BP)
  RVMDBG_SET_BP_PC RVM_TBP_SLOT[I],RVM_BP[I],#RVM_BP_NONE
 NEXT
 RESIZE RVM_BP,0
END
DEF RVMDBG_GET_FUNC_ADDR FUNC OUT ADDR
 ADDR=RGEN_RJMP_TABLE[FUNC_ADDR[FUNC]]
END
DEF RVMDBG_GET_LABEL_ADDR FUNC OUT ADDR
 ADDR=RGEN_RJMP_TABLE[LABEL_ADDR[FUNC]]
END

'@0000:@F0AAA:@F1AAAA:VM_CURFUNC=?"hoge"
DEF RVMDBG_FIND_COLON(L$)
 VAR COLON=INSTR(L$,":")
 IF COLON==-1 THEN RETURN 0
 LOOP
  IF MID$(L$,COLON+1,1)=="@"THEN
   VAR NXT=INSTR(COLON+1,L$,":")
   IF NXT==-1 THEN RETURN COLON
   COLON=NXT
   CONTINUE
  ENDIF
  BREAK
 ENDLOOP
 RETURN COLON
END
DEF PRGEDIT_FASTSEEK SLOT,L
 VAR PSLOT,PREV_LINE
 PRGEDIT OUT PSLOT,PREV_LINE
 IF PSLOT==SLOT&&L>=2000 THEN
  IF L-PREV_LINE>0THEN
   VAR I
   VAR DIFF=L-PREV_LINE
   FOR I=1TO DIFF
    PRGSEEK
   NEXT
  ELSEIF L-PREV_LINE<0THEN
   DIFF=PREV_LINE-L
   FOR I=1TO DIFF
    PRGSEEK -1
   NEXT
  ENDIF
  IF PRGEDIT()!=L THEN STOP
 ELSE
  PRGEDIT SLOT,L
 ENDIF
END
DEF RVMDBG_REMOVE_BP_LPC SLOT,LPC
 VAR L=RIR_OPS_LINE[LPC]
 PRGEDIT_FASTSEEK RVM_SLOT,L
 VAR L$=PRGGET$(0)
 L$=MID$(L$,0,LEN(L$)-1)
 VAR COLON=RVMDBG_FIND_COLON(L$)
 VAR PC=RGEN_RJMP_TABLE[LPC]
 VAR BPLBL$="@BP_"+STR$(SLOT)+HEX$(PC)
 VAR BPLBL=INSTR(L$,BPLBL$)
 IF BPLBL==-1 THEN RETURN
 L$=MID$(L$,0,COLON)+MID$(L$,BPLBL+LEN(BPLBL$),&H7FFFFFFF)
 PRGSET L$
END
DEF RVMDBG_SET_BP_PC SLOT,PC,TYP
 VAR PC_2=VMDBG_BINSEARCH(RIR_OPS_LINE_PC,PC)
 RVMDBG_SET_BP_LPC SLOT,PC_2,TYP
END
DEF RVMDBG_CONT LINE
 RVM_LOAD
 VM_PC=RGEN_RJMP_TABLE[VMDBG_BINSEARCH(RIR_OPS_LINE,LINE)]
 RVM_SAVE
 RVM_RUN
END
DEF RVMDBG_SET_BP_LPC SLOT,PC_2,TYP
 VAR L=RIR_OPS_LINE[PC_2]
 VAR OLD_TYP=RVM_BREAK_POINTS[PC_2]
 IF OLD_TYP==TYP THEN
  RETURN
 ENDIF
 IF OLD_TYP==#RVM_BP_BP&&TYP==#RVM_BP_TRACE THEN
  RETURN
 ENDIF
 IF OLD_TYP THEN
  RVMDBG_REMOVE_BP_LPC SLOT,PC_2
 ENDIF
 PRGEDIT_FASTSEEK RVM_SLOT,L
 VAR L$=PRGGET$(0)
 L$=MID$(L$,0,LEN(L$)-1)
 VAR PC=RGEN_RJMP_TABLE[PC_2]
 VAR BPLBL=INSTR(L$,"@BP_"+STR$(SLOT)+HEX$(PC))
 VAR COLON=RVMDBG_FIND_COLON(L$)
 RVM_BREAK_POINTS[PC_2]=TYP
 VAR RET=#RVM_RETCODE_BP
 IF OLD_TYP!=#RVM_BP_BP&&TYP==#RVM_BP_TRACE THEN
  RET=#RVM_RETCODE_TRACE_BP
  PUSH RVM_BP,PC
  PUSH RVM_TBP_SLOT,SLOT
 ELSEIF TYP==#RVM_BP_NONE THEN
  RVMDBG_REMOVE_BP_LPC SLOT,PC_2
  RETURN
 ENDIF
 IF BPLBL!=-1 THEN STOP:RETURN
' RVM_BP[PC]=#TRUE
' L$=MID$(L$,0,COLON)+":IF VM_BP0["+STR$(PC)+"]THEN VM_PC="+STR$(PC)+"RETURN "+STR$(#RVM_RETCODE_TRACE_BP)+":ENDIF"+MID$(L$,COLON,&H7FFFFFFF)
 L$=MID$(L$,0,COLON)+":VM_CURSLOT="+STR$(SLOT)+":VM_PC="+STR$(PC_2)+"RETURN "+STR$(RET)+"@BP_"+STR$(SLOT)+HEX$(PC)+MID$(L$,COLON,&H7FFFFFFF)
 PRGSET L$
END
DEF RVMDBG_TOGGLE_BP SLOT,PC
 VAR PC_2=VMDBG_BINSEARCH(RIR_OPS_LINE_PC,PC)
 IF RVM_BREAK_POINTS[PC_2]==#RVM_BP_BP THEN
  RVMDBG_SET_BP_PC SLOT,PC,#RVM_BP_NONE
 ELSE
  RVMDBG_SET_BP_PC SLOT,PC,#RVM_BP_BP
 ENDIF
END
DEF RVMDBG_TOGGLE_BP_LIST SLOT,PC_LIST
 VAR I
 DIM LIST%[]
 FOR I=0TO LAST(PC_LIST)
  VAR PC_2=VMDBG_BINSEARCH(RIR_OPS_LINE_PC,PC_LIST[I])
  IF RVM_SET_TRACE_BREAK_POINTS_CHECK_SEARCH(LIST%,PC_2)THEN CONTINUE
  PUSH LIST%,PC_2
  RVMDBG_TOGGLE_BP SLOT,PC_LIST[I]
 NEXT
END
ENUM\
 #RVMDBG_FRAME_GLOBAL,\
 #RVMDBG_FRAME_SUBROUTINE,\
 #RVMDBG_FRAME_LOCAL_REGS,\
 #RVMDBG_FRAME_LOCAL
DEF RVMDBG_HAS_BP(SLOT,PC)
 VAR PC_2=VMDBG_BINSEARCH(RIR_OPS_LINE_PC,PC)
 RETURN RVM_BREAK_POINTS[PC_2]==#RVM_BP_BP
END
DEF RVMDBG_GET(I,TYP,V%,V#,V$)
 CASE TYP[I]
 WHEN #VMT_DEFAULT
  RETURN EMPTY()
 WHEN #VMT_INT
  RETURN V%[I]
 WHEN #VMT_REAL
  RETURN V#[I]
 WHEN #VMT_STR
  RETURN V$[I]
 WHEN #VMT_INTARRAY
 WHEN #VMT_REALARRAY
 WHEN #VMT_STRARRAY
  RETURN VM_GET_ARRAY(V%[I])
 OTHERWISE
  STOP
 ENDCASE
END

DEF RVMDBG_SET I,TYP,V%,V#,V$,V
 CASE TYP[I]
 WHEN #VMT_STR
  VAR N$
  V$[I]=N$
 WHEN #VMT_INTARRAY
 WHEN #VMT_REALARRAY
 WHEN #VMT_STRARRAY
  VM_FREE_ARRAY V%[I]
 ENDCASE
 TYP[I]=TYPEOF(V)
 CASE TYPEOF(V)
 WHEN #T_DEFAULT
  RETURN
 WHEN #T_INT
  V%[I]=V
 WHEN #T_REAL
  V#[I]=V
 WHEN #T_STR
  V$[I]=V
 WHEN #T_INTARRAY
 WHEN #T_REALARRAY
 WHEN #T_STRARRAY
  V%[I]=VM_ALLOC_ARRAY(V)
 OTHERWISE
  STOP
 ENDCASE
END

DEF RVMDBG_GET_VAR_LIST FUNC,BP OUT VNAME$[],VIDX[]
 VNAME$=ARRAY$(0)
 VIDX=ARRAY%(0)
 VMDBG_ENUM_VAR_LIST VNAME$,VIDX,GET_SPLAY_ROOT(FUNC_VARTBL[FUNC])
 IF BP==VM_BP&&FUNC THEN
  RETURN
 ENDIF
END
DEF RVMDBG_GET_VAR FUNC,BP,VIDX OUT V
 VAR I,TYP,V%,V#,V$
 RVMDBG_GET_VAR_ARY FUNC,BP,VIDX OUT I,TYP,V%,V#,V$
 V=RVMDBG_GET(I,TYP,V%,V#,V$)
END

DEF RVMDBG_SET_VAR FUNC,BP,VIDX,V
 VAR I,TYP,V%,V#,V$
 RVMDBG_GET_VAR_ARY FUNC,BP,VIDX OUT I,TYP,V%,V#,V$
 RVMDBG_SET I,TYP,V%,V#,V$,V
END
DEF RVMDBG_GET_VAR_ARY FUNC,BP,VIDX OUT I,TYP,V%,V#,V$
 IF BP==-1&&FUNC THEN
  IF VIDX<0 THEN
   IF VIDX>=-FUNC_INCNT[FUNC] THEN'FIXME VAARGS
    I=-VIDX-1
    TYP=RVM_INARG_TYP
    V%=RVM_INARG%
    V#=RVM_INARG#
    V$=RVM_INARG$
   ELSE
    I=-VIDX-FUNC_INCNT[FUNC]-1
    TYP=RVM_OUTARG_TYP
    V%=RVM_OUTARG%
    V#=RVM_OUTARG#
    V$=RVM_OUTARG$
   ENDIF
  ELSE
   I=VIDX
   TYP=RVM_LOCAL_TYP
   V%=RVM_LOCAL%
   V#=RVM_LOCAL#
   V$=RVM_LOCAL$
  ENDIF
  RETURN
 ENDIF
 TYP=VM_STK_TYP
 V%=VM_STK%
 V#=VM_STK#
 V$=VM_STK$
 IF VIDX<0 THEN
  IF VIDX>=-FUNC_INCNT[FUNC] THEN'FIXME VAARGS
   VIDX=FUNC_VARNUM[FUNC]-VIDX-1
  ELSE
   VIDX=FUNC_VARNUM[FUNC]+FUNC_INCNT[FUNC]-VIDX-FUNC_INCNT[FUNC]-1
  ENDIF
 ENDIF
 I=BP-VIDX+#RVMSTK_LVAR
END
DEF RVMDBG_FIND_FRAME FRAME_NO OUT FUNC,BP,SLOT,PC
 IF FRAME_NO==0 THEN
  FUNC=VM_CURFUNC
  BP=-1
  SLOT=VM_CURSLOT
  PC=VM_PC
  RETURN
 ENDIF
 VAR SLOTS,LINE,INFO$,INFO,BP_LIST,PC_LIST
 RVM_BACKTRACE_INTRNL #TRUE,FRAME_NO OUT SLOTS,LINE,INFO$,INFO,BP_LIST,PC_LIST
 BP=BP_LIST[FRAME_NO]
 VAR BP2=BP_LIST[FRAME_NO-1]
 IF BP2>0 THEN
  SLOT=VM_STK%[BP2+#RVMSTK_SLOT]
  PC=RGEN_RJMP_TABLE[VM_STK%[BP2+#RVMSTK_PC_I]]
 ELSE
  SLOT=RVM_RETS
  PC=RGEN_RJMP_TABLE[RVM_RET]
 ENDIF
 IF INFO[FRAME_NO]==#RVMDBG_FRAME_SUBROUTINE THEN
  PC=PC_LIST[FRAME_NO]
 ENDIF
 IF BP THEN
  FUNC=VM_STK%[BP+#RVMSTK_FUNC]
  IF FRAME_NO==1 THEN
   
  ENDIF
  RETURN
 ENDIF
 FUNC=0
END
DEF RVM_BACKTRACE INCLUDE_SUB OUT SLOT,LINE,INFO$
 RVM_BACKTRACE_INTRNL INCLUDE_SUB,-1 OUT SLOT,LINE,INFO$,,,
END
DEF RVM_BACKTRACE_INTRNL INCLUDE_SUB,FRAME_NO OUT SLOT,LINE,INFO$,INFO,BPS,PC_LIST
 VAR I,BP=VM_BP
 SLOT=ARRAY%(0)
 LINE=ARRAY%(0)
 INFO$=ARRAY$(0)
 INFO=ARRAY%(0)
 BPS=ARRAY%(0)
 PC_LIST=ARRAY%(0)
 VAR FUNC=VM_CURFUNC
 VAR A,S,L
 IF !VM_CURFUNC&&!BP THEN
  VMDBG_GET OUT S,L,
  PUSH LINE,L
  PUSH SLOT,S
  PUSH INFO$,""
  PUSH INFO,#RVMDBG_FRAME_GLOBAL
  PUSH BPS,0
  PUSH PC_LIST,VM_PC
  FOR I=VM_SP TO 0 STEP -1
   IF INCLUDE_SUB&&VM_STK_TYP[I]==#VMT_SUBROUTINE&&I>=1 THEN
    A=RGEN_RJMP_TABLE[VM_STK%[I]]
    DEC I
    S=VM_STK%[I]
    VMDBG_GET_LINE S,A OUT L,
    PUSH LINE,L
    PUSH SLOT,S
    PUSH INFO$,""
    PUSH INFO,#RVMDBG_FRAME_SUBROUTINE
    PUSH BPS,BP
    PUSH PC_LIST,A
   ENDIF
  NEXT
  RETURN
 ENDIF
 FUNC=0
 IF VM_CURFUNC&&BP THEN
  VMDBG_GET OUT S,L,
  PUSH LINE,L
  PUSH SLOT,S
  PUSH INFO$,FUNC_NAME$[VM_CURFUNC]
  PUSH INFO,#RVMDBG_FRAME_LOCAL_REGS
  PUSH BPS,-1
  PUSH PC_LIST,VM_PC
  VMDBG_GET_LINE RVM_RETS,RGEN_RJMP_TABLE[RVM_RET] OUT L,
  IF BP THEN
   PUSH LINE,L
   PUSH SLOT,RVM_RETS
'    PUSH INFO$,FUNC_NAME$[VM_STK%[BP+#RVMSTK_FUNC]]
  ENDIF
 ELSEIF VM_CURFUNC THEN
  VMDBG_GET OUT S,L,
  PUSH LINE,L
  PUSH SLOT,S
  PUSH INFO$,FUNC_NAME$[VM_CURFUNC]
  PUSH INFO,#RVMDBG_FRAME_LOCAL_REGS
  PUSH BPS,0
  PUSH PC_LIST,VM_PC
  VMDBG_GET_LINE RVM_RETS,RGEN_RJMP_TABLE[RVM_RET] OUT L,
  PUSH LINE,L
  PUSH SLOT,RVM_RETS
  PUSH INFO$,""
  PUSH INFO,#RVMDBG_FRAME_GLOBAL
  PUSH BPS,0
  PUSH PC_LIST,RGEN_RJMP_TABLE[RVM_RET]
  FOR I=VM_SP TO 0 STEP -1
   IF INCLUDE_SUB&&VM_STK_TYP[I]==#VMT_SUBROUTINE&&I>0 THEN
    A=RGEN_RJMP_TABLE[VM_STK%[I]]
    DEC I
    S=VM_STK%[I]
    VMDBG_GET_LINE S,A OUT L,
    PUSH LINE,L
    PUSH SLOT,S
    PUSH INFO$,""
    PUSH INFO,#RVMDBG_FRAME_SUBROUTINE
    PUSH BPS,BP
    PUSH PC_LIST,A
   ENDIF
  NEXT
  RETURN
 ENDIF
 FOR I=VM_SP TO 0 STEP -1
  IF I==BP&&I THEN
   A=RGEN_RJMP_TABLE[VM_STK%[I+#RVMSTK_PC_I]]
   S=VM_STK%[I+#RVMSTK_SLOT]
   PUSH BPS,BP
   BP=VM_STK%[I+#RVMSTK_BP]
   VMDBG_GET_LINE S,A OUT L,
   PUSH PC_LIST,A
   PUSH LINE,L
   PUSH SLOT,S
   FUNC=VM_STK%[I+#RVMSTK_FUNC]
   PUSH INFO$,FUNC_NAME$[FUNC]
   PUSH INFO,#RVMDBG_FRAME_LOCAL
  ELSEIF INCLUDE_SUB&&VM_STK_TYP[I]==#VMT_SUBROUTINE THEN
   A=RGEN_RJMP_TABLE[VM_STK%[I]]
   DEC I
   S=VM_STK%[I]
   VMDBG_GET_LINE S,A OUT L,
   PUSH PC_LIST,A
   PUSH LINE,L
   PUSH SLOT,S
   PUSH INFO$,""
   PUSH INFO,#RVMDBG_FRAME_SUBROUTINE
   PUSH BPS,BP
  ENDIF
 NEXT
 PUSH INFO$,""
 PUSH INFO,#RVMDBG_FRAME_LOCAL
 PUSH BPS,BP
 IF !VM_BP THEN
  VMDBG_GET_LINE VM_CURSLOT,VM_PC OUT L,
  PUSH LINE,L
  PUSH SLOT,VM_CURSLOT
  PUSH INFO$,""
  PUSH INFO,#RVMDBG_FRAME_GLOBAL
  PUSH BPS,0
  PUSH PC_LIST,VM_PC
 ENDIF
END
DEF RVMDBG_CALL_FUNC * OUT *
 VAR F$=DEFARG(0)
 VAR ICNT=DEFARGC()-1
 VAR OCNT=DEFOUTC()
 VAR SLOT,ADDR
 VAR OPC=VM_PC
 VAR OSLOT=VM_CURSLOT
 VAR OFUNC=VM_CURFUNC
 RVM_CALL F$,ICNT,OCNT OUT SLOT,ADDR
 RVM_RETS=VM_CURSLOT
 RVM_RET=RVM_TEMP_STOP_ADDR[VM_CURSLOT]
 RVM_ICNT=ICNT
 RVM_OCNT=OCNT
 VM_PC=RGEN_RJMP_TABLE[ADDR]
 VM_CURSLOT=SLOT
 VAR I
 VAR NOT_LOADED=#FALSE
 FOR I=0TO LAST(RVM_LOCAL_TYP)
  IF!CHKVAR(RVM_SLOT$+"L"+STR$(I))THEN
   NOT_LOADED=#TRUE
   BREAK
  ENDIF
  VM_PUSH VAR(RVM_SLOT$+"L"+STR$(I))
 NEXT
 FOR I=0TO LAST(RVM_INARG_TYP)
  IF!CHKVAR(RVM_SLOT$+"L"+STR$(I))THEN
   NOT_LOADED=#TRUE
   BREAK
  ENDIF
  VM_PUSH VAR(RVM_SLOT$+"I"+STR$(I))
 NEXT
 FOR I=0TO LAST(RVM_OUTARG_TYP)
  IF!CHKVAR(RVM_SLOT$+"L"+STR$(I))THEN
   NOT_LOADED=#TRUE
   BREAK
  ENDIF
  VM_PUSH VAR(RVM_SLOT$+"O"+STR$(I))
 NEXT
 VAR OLDDISA=!!RVM_BP_DISABLED
 RVM_BP_DISABLED=#TRUE
 RVM_RUN
 FOR I=0TO OCNT-1
  DEFOUT I,VAR(RVM_SLOT$+"O"+STR$(I))
 NEXT
 IF!NOT_LOADED THEN
  FOR I=LAST(RVM_OUTARG_TYP)TO 0 STEP -1
   VM_POP OUT ,VAR(RVM_SLOT$+"O"+STR$(I))
  NEXT
  FOR I=LAST(RVM_INARG_TYP)TO 0 STEP -1
   VM_POP OUT ,VAR(RVM_SLOT$+"I"+STR$(I))
  NEXT
  FOR I=LAST(RVM_LOCAL_TYP)TO 0 STEP -1
   VM_POP OUT ,VAR(RVM_SLOT$+"L"+STR$(I))
  NEXT
 ENDIF
 RVM_BP_DISABLED=OLDDISA
 VM_CURSLOT=OSLOT
 VM_PC=OPC
 VM_CURFUNC=OFUNC
 RVM_SAVE
END
DEF RVM_CALL ICALL$,ICNT,OCNT OUT SLOT,ADDR
 VAR FOUND,FUNC
 VM_GETFUNC ICALL$,ICNT,OCNT OUT FOUND,FUNC
 IF!FOUND THEN
  STOP
 ENDIF
 SLOT=FUNC_SLOT[FUNC]
 ADDR=FUNC_ADDR[FUNC]
END
COMMON DEF RVM_ICALL ICALL$,ICNT,OCNT OUT SLOT,ADDR,BP
 VAR FOUND,FUNC
 VM_GETFUNC ICALL$,ICNT,OCNT OUT FOUND,FUNC
 IF!FOUND THEN
  STOP
 ENDIF
 IF VMDBG_TRACE&&VMDBG_TRACE_STEPIN THEN
  BP=#TRUE
 ELSE
  BP=#FALSE
 ENDIF
 SLOT=FUNC_SLOT[FUNC]
 ADDR=FUNC_ADDR[FUNC]
END


COMMON DEF RVM_READ OUT V
 VAR TYP=VM_DATA_TYP[VM_DATA_IDX]
 CASE TYP
 WHEN #VMT_INT
  V=VM_DATA%[VM_DATA_IDX]
 WHEN #VMT_REAL
  V=VM_DATA#[VM_DATA_IDX]
 WHEN #VMT_STR
  V=VM_DATA$[VM_DATA_IDX]+""
 OTHERWISE
  INTERNAL_VM_ERROR
 ENDCASE
 INC VM_DATA_IDX
END
COMMON DEF RVM_RESTORE_ADDR SLOT,A
 IF SLOT!=VM_CURDATASLOT THEN
  VM_CURDATASLOT=SLOT
  VM_SWITCH_SLOT_DATA VM_CURDATASLOT
 ENDIF
 VM_DATA_IDX=A
END
COMMON DEF RVM_RESTORE LABEL$,FUNC
 VM_CURFUNC=FUNC
 VAR SLOT,ADDR,FOUND
 VM_GET_LABEL_DATA_ADDR LABEL$ OUT SLOT,ADDR,FOUND
 IF!FOUND THEN
  STOP
  RETURN
 ENDIF
 IF SLOT!=VM_CURDATASLOT THEN
  VM_CURDATASLOT=SLOT
  VM_SWITCH_SLOT_DATA VM_CURDATASLOT
 ENDIF
 VM_DATA_IDX=ADDR
END
COMMON DEF RVMINSTR_GOTOEXPR LABEL$ OUT BP
 VM_CURFUNC=VAR(RVM_SLOT$+"VM_CURFUNC")
 VM_CURSLOT=VAR(RVM_SLOT$+"VM_CURSLOT")
 IF VMDBG_TRACE THEN
  BP=#TRUE
 ELSE
  BP=#FALSE
 ENDIF
 'IRANAI?
 RVM_SWITCH_SLOT VM_CURSLOT
 VAR SLOT,ADDR,FOUND
 VM_GET_LABEL_ADDR LABEL$ OUT SLOT,ADDR,FOUND
 IF !FOUND THEN
  ADDR=-1
  STOP
  SLOT=VM_CURSLOT
 ENDIF
 VAR(RVM_SLOT$+"VM_PC")=ADDR
 VAR(RVM_SLOT$+"VM_CURSLOT")=SLOT
 RVM_SWITCH_SLOT VM_CURSLOT
END
COMMON DEF RVMINSTR_GOSUBEXPR LABEL$ OUT BP
 VM_STK%[VAR(RVM_SLOT$+RIR_VM_SP$)]=VAR(RVM_SLOT$+"VM_CURSLOT")
 VM_STK_TYP[VAR(RVM_SLOT$+RIR_VM_SP$)]=#VMT_SUBROUTINE
 INC VAR(RVM_SLOT$+RIR_VM_SP$)
 VM_STK%[VAR(RVM_SLOT$+RIR_VM_SP$)]=VAR(RVM_SLOT$+"VM_PC")+1
 VM_STK_TYP[VAR(RVM_SLOT$+RIR_VM_SP$)]=#VMT_SUBROUTINE
 INC VAR(RVM_SLOT$+RIR_VM_SP$)
 RVMINSTR_GOTOEXPR LABEL$ OUT BP
END

COMMON DEF RVM_VAR$(SLOT,FUNC,NAME$)
 VM_CURFUNC=FUNC
 VM_CURSLOT=SLOT
 VAR LOCAL,IDX,FOUND
 VM_CHKVAR NAME$ OUT SLOT,LOCAL,IDX,FOUND
 IF!FOUND THEN
  UNDEFINED_VARIABLE NAME$
  RETURN ""
 ENDIF
 ?"IDX",IDX,NAME$,LOCAL
 IF!LOCAL THEN
  RETURN "G"+STR$(SLOT)+STR$(IDX)
 ELSEIF IDX>=0 THEN
  RETURN "L"+STR$(IDX)
 ELSEIF IDX>=-FUNC_INCNT[FUNC] THEN'FIXME VAARGS
  RETURN "I"+STR$(-IDX-1)
 ELSE
  RETURN "O"+STR$(-IDX-FUNC_INCNT[FUNC]-1)
 ENDIF
END

COMMON DEF RSBSB_DEFARGC()
 RETURN VAR(RVM_SLOT$+"ICNT")
END
COMMON DEF RSBSB_DEFOUTC()
 RETURN VAR(RVM_SLOT$+"OCNT")
END
COMMON DEF RSBSB_DEFARG(N)
 VAR AC=RSBSB_DEFARGC()
 IF VAR(RVM_SLOT$+"VM_CURFUNC")==0THEN ERRRRRRRRRRR
 IF AC<=N||N<0THEN
  ERRRRRRRRR
 ENDIF
 RETURN VAR(RVM_SLOT$+"I"+STR$(AC-1-N))
END








'UTIL

DIM SPLAYN_LEFT[]
DIM SPLAYN_RIGHT[]
DIM SPLAYN_PARENT[]
DIM SPLAYN_KEY$[]
DIM SPLAYN_VAL$[]
DIM SPLAYN_VAL%[]
DIM SPLAYN_VAL#[]
DIM SPLAY_ROOT[]
VAR SPLAY_INIT
VAR SPLAY_FREE
VAR SPLAYN_FREE

DEF INIT_SPLAY
 VAR S=1
 SPLAYN_LEFT=ARRAY%(S)
 SPLAYN_RIGHT=ARRAY%(S)
 SPLAYN_PARENT=ARRAY%(S)
 SPLAYN_KEY$=ARRAY$(S)
 SPLAYN_VAL$=ARRAY$(S)
 SPLAYN_VAL#=ARRAY%(S)
 SPLAYN_VAL%=ARRAY%(S)
 SPLAY_ROOT=ARRAY%(S)
 SPLAY_INIT=#TRUE
 SPLAY_FREE=0
 SPLAYN_FREE=0
END

DEF NEW_SPLAY_TREE()
 IF!SPLAY_INIT THEN
  INIT_SPLAY
 ENDIF
 IF SPLAY_FREE THEN
  VAR L=SPLAY_FREE
  SPLAY_FREE=SPLAY_ROOT[SPLAY_FREE]
  SPLAY_ROOT[L]=0
  RETURN L
 ENDIF
 PUSH SPLAY_ROOT,0
 RETURN LAST(SPLAY_ROOT)
END
DEF DELETE_SPLAY_NODE NODE
 IF!NODE THEN RETURN
 DELETE_SPLAY_NODE SPLAYN_LEFT[NODE]
 DELETE_SPLAY_NODE SPLAYN_RIGHT[NODE]
 SPLAYN_VAL%[NODE]=SPLAYN_FREE
 VAR N$
 SPLAYN_KEY$[NODE]=N$
 SPLAYN_VAL$[NODE]=N$
 SPLAYN_VAL#[NODE]=0
 SPLAYN_LEFT[NODE]=0
 SPLAYN_RIGHT[NODE]=0
 SPLAYN_PARENT[NODE]=0
 SPLAYN_FREE=NODE
END
DEF DELETE_SPLAY_TREE TREE
 IF !TREE THEN RETURN
 DELETE_SPLAY_NODE SPLAY_ROOT[TREE]
 SPLAY_ROOT[TREE]=SPLAY_FREE
 SPLAY_FREE=TREE
END
DEF NEW_SPLAYN(K$)
 VAR E$
 IF SPLAYN_FREE THEN
  VAR L=SPLAYN_FREE
  SPLAYN_FREE=SPLAYN_VAL%[SPLAYN_FREE]
  SPLAYN_KEY$[L]=K$
  SPLAYN_VAL%[L]=0
  RETURN L
 ENDIF
 PUSH SPLAYN_LEFT,0
 PUSH SPLAYN_RIGHT,0
 PUSH SPLAYN_PARENT,0
 PUSH SPLAYN_KEY$,K$
 PUSH SPLAYN_VAL$,E$
 PUSH SPLAYN_VAL%,0
 PUSH SPLAYN_VAL#,0
 RETURN LAST(SPLAYN_LEFT)
END
DEF NEW_SPLAYN%(K$,V%)
 VAR S=NEW_SPLAYN(K$)
 SPLAYN_VAL%[S]=V%
 RETURN S
END
DEF NEW_SPLAYN#(K$,V#)
 VAR S=NEW_SPLAYN(K$)
 SPLAYN_VAL#[S]=V#
 RETURN S
END
DEF NEW_SPLAYN$(K$,V$)
 VAR S=NEW_SPLAYN(K$)
 SPLAYN_VAL$[S]=V$
 RETURN S
END

DEF SPLAY_LEFT_ROTATE S,X
 VAR Y=SPLAYN_RIGHT[X]
 IF Y THEN
  SPLAYN_RIGHT[X]=SPLAYN_LEFT[Y]
  IF SPLAYN_LEFT[Y] THEN
   SPLAYN_PARENT[SPLAYN_LEFT[Y]]=X
  ENDIF
  SPLAYN_PARENT[Y]=SPLAYN_PARENT[X]
 ENDIF
 IF !SPLAYN_PARENT[X] THEN
  SPLAY_ROOT[S]=Y
 ELSEIF X==SPLAYN_LEFT[SPLAYN_PARENT[X]] THEN
  SPLAYN_LEFT[SPLAYN_PARENT[X]]=Y
 ELSE
  SPLAYN_RIGHT[SPLAYN_PARENT[X]]=Y
 ENDIF
 IF Y THEN
  SPLAYN_LEFT[Y]=X
 ENDIF
 SPLAYN_PARENT[X]=Y
END

DEF SPLAY_RIGHT_ROTATE S,X
 VAR Y=SPLAYN_LEFT[X]
 IF Y THEN
  SPLAYN_LEFT[X]=SPLAYN_RIGHT[Y]
  IF SPLAYN_RIGHT[Y]THEN
   SPLAYN_PARENT[SPLAYN_RIGHT[Y]]=X
  ENDIF
  SPLAYN_PARENT[Y]=SPLAYN_PARENT[X]
 ENDIF
 IF !SPLAYN_PARENT[X]THEN
  SPLAY_ROOT[S]=Y
 ELSEIF X==SPLAYN_LEFT[SPLAYN_PARENT[X]]THEN
  SPLAYN_LEFT[SPLAYN_PARENT[X]]=Y
 ELSE
  SPLAYN_RIGHT[SPLAYN_PARENT[X]]=Y
 ENDIF
 IF Y THEN
  SPLAYN_RIGHT[Y]=X
 ENDIF
 SPLAYN_PARENT[X]=Y
END

DEF SPLAY S,X
 WHILE SPLAYN_PARENT[X]
  VAR P=SPLAYN_PARENT[X]
  IF !SPLAYN_PARENT[P]THEN
   IF SPLAYN_LEFT[P]==X THEN
    SPLAY_RIGHT_ROTATE S,P
   ELSE
    SPLAY_LEFT_ROTATE S,P
   ENDIF
  ELSEIF SPLAYN_LEFT[P]==X&&SPLAYN_LEFT[SPLAYN_PARENT[P]]==P THEN
   SPLAY_RIGHT_ROTATE S,SPLAYN_PARENT[P]
   SPLAY_RIGHT_ROTATE S,SPLAYN_PARENT[X]
  ELSEIF SPLAYN_RIGHT[P]==X&&SPLAYN_RIGHT[SPLAYN_PARENT[P]]==P THEN
   SPLAY_LEFT_ROTATE S,SPLAYN_PARENT[P]
   SPLAY_LEFT_ROTATE S,SPLAYN_PARENT[X]
  ELSEIF SPLAYN_LEFT[P]==X&&SPLAYN_RIGHT[SPLAYN_PARENT[P]]==P THEN
   SPLAY_RIGHT_ROTATE S,P
   SPLAY_LEFT_ROTATE S,SPLAYN_PARENT[X]
  ELSE
   SPLAY_LEFT_ROTATE S,P
   SPLAY_RIGHT_ROTATE S,SPLAYN_PARENT[X]
  ENDIF
 WEND
END
DEF SPLAY_REPLACE S,U,V
 IF !SPLAYN_PARENT[U]THEN
  SPLAY_ROOT[S]=V
 ELSEIF U==SPLAYN_LEFT[SPLAYN_PARENT[U]]THEN
  SPLAYN_LEFT[SPLAYN_PARENT[U]]=V
 ELSE
  SPLAYN_RIGHT[SPLAYN_PARENT[U]]=V
 ENDIF
 IF V THEN
  SPLAYN_PARENT[V]=SPLAYN_PARENT[U]
 ENDIF
END

DEF SPLAY_SUBTREE_MIN(S,U)
 WHILE SPLAYN_LEFT[U]
  U=SPLAYN_LEFT[U]
 WEND
 RETURN U
END
DEF SPLAY_SUBTREE_MAX(S,U)
 WHILE SPLAYN_RIGHT[U]
  U=SPLAYN_RIGHT[U]
 WEND
 RETURN U
END

DEF SPLAY_INSERT% S,KEY$,VALUE%
 SPLAY_INSERT S,KEY$,VALUE%,#T_INT
END
DEF SPLAY_INSERT$ S,KEY$,VALUE$
 SPLAY_INSERT S,KEY$,VALUE$,#T_STR
END
DEF SPLAY_INSERT# S,KEY$,VALUE#
 SPLAY_INSERT S,KEY$,VALUE#,#T_REAL
END

DEF SPLAY_INSERT S,KEY$,VALUE,T
 VAR Z=SPLAY_ROOT[S]
 VAR P
 WHILE Z
  P=Z
  IF SPLAYN_KEY$[Z]<KEY$THEN
   Z=SPLAYN_RIGHT[Z]
  ELSE
   Z=SPLAYN_LEFT[Z]
  ENDIF
 WEND
 CASE T
 WHEN #T_INT
  Z=NEW_SPLAYN%(KEY$,VALUE)
 WHEN #T_STR
  Z=NEW_SPLAYN$(KEY$,VALUE)
 WHEN #T_REAL
  Z=NEW_SPLAYN#(KEY$,VALUE)
 ENDCASE
 SPLAYN_PARENT[Z]=P
 IF !P THEN
  SPLAY_ROOT[S]=Z
 ELSEIF SPLAYN_KEY$[P]<SPLAYN_KEY$[Z]THEN
  SPLAYN_RIGHT[P]=Z
 ELSE
  SPLAYN_LEFT[P]=Z
 ENDIF
 SPLAY S,Z
END

DEF SPLAY_FIND(S,KEY$)
 VAR Z=SPLAY_ROOT[S]
 WHILE Z
  IF SPLAYN_KEY$[Z]<KEY$THEN
   Z=SPLAYN_RIGHT[Z]
  ELSEIF SPLAYN_KEY$[Z]==KEY$THEN
   RETURN Z
  ELSE
   Z=SPLAYN_LEFT[Z]
  ENDIF
 WEND
 RETURN 0
END

DEF SPLAY_GET% S,KEY$ OUT FOUND,VALUE%
 VAR N=SPLAY_FIND(S,KEY$)
 IF !N THEN
  FOUND=#FALSE
  VALUE%=0
  RETURN
 ENDIF
 FOUND=#TRUE
 VALUE%=SPLAYN_VAL%[N]
END
DEF SPLAY_GET# S,KEY$ OUT FOUND,VALUE#
 VAR N=SPLAY_FIND(S,KEY$)
 IF !N THEN
  FOUND=#FALSE
  VALUE#=0E0
  RETURN
 ENDIF
 FOUND=#TRUE
 VALUE#=SPLAYN_VAL#[N]
END
DEF SPLAY_GET$ S,KEY$ OUT FOUND,VALUE$
 VAR N=SPLAY_FIND(S,KEY$)
 IF !N THEN
  FOUND=#FALSE
  VALUE$=""
  RETURN
 ENDIF
 FOUND=#TRUE
 VALUE$=SPLAYN_VAL$[N]
END

DEF SPLAY_ERASE S,KEY$
 VAR Z=SPLAY_FIND(S,KEY$)
 IF !Z THEN
  RETURN
 ENDIF
 SPLAY S,Z
 IF !SPLAYN_LEFT[Z]THEN
  SPLAY_REPLACE S,Z,SPLAYN_RIGHT[Z]
 ELSEIF !SPLAYN_RIGHT[Z]THEN
  SPLAY_REPLACE S,Z,SPLAYN_LEFT[Z]
 ELSE
  VAR Y=SPLAY_SUBTREE_MIN(S,SPLAYN_RIGHT[Z])
  IF SPLAYN_PARENT[Y]!=Z THEN
   SPLAY_REPLACE S,Y,SPLAYN_RIGHT[Y]
   SPLAYN_RIGHT[Y]=SPLAYN_RIGHT[Z]
   SPLAYN_PARENT[SPLAYN_RIGHT[Y]]=Y
  ENDIF
  SPLAY_REPLACE S,Z,Y
  SPLAYN_LEFT[Y]=SPLAYN_LEFT[Z]
  SPLAYN_PARENT[SPLAYN_LEFT[Y]]=Y
 ENDIF
 'DELETE Z
END

DEF SPLAY_TEST
 VAR T=NEW_SPLAY_TREE()
 SPLAY_INSERT T,"K","V1"
 SPLAY_INSERT T,"K2","V2"
 SPLAY_INSERT T,"K3","V3"
 VAR F
 SPLAY_GET T,"K" OUT ,F
 ?F
 SPLAY_GET T,"K2" OUT ,F
 ?F
 SPLAY_GET T,"K3" OUT ,F
 ?F
 SPLAY_ERASE T,"K2"
 SPLAY_GET T,"K" OUT ,F
 ?F
 SPLAY_GET T,"K2" OUT ,F
 ?F
 SPLAY_GET T,"K3" OUT ,F
 ?F
 SPLAY_ERASE T,"K3"
 SPLAY_ERASE T,"K"
 SPLAY_GET T,"K" OUT ,F
 ?F
 SPLAY_GET T,"K2" OUT ,F
 ?F
 SPLAY_GET T,"K3" OUT ,F
 ?F

 VAR I
 VAR O=50000
 DIM LST1=ARRAY$(0)
 DIM LST2=ARRAY$(0)
 FOR I=0TO O-1
  PUSH LST1,STR$(I)
  PUSH LST2,STR$(I)
 NEXT
 FOR I=0TO O*10
  SWAP LST1[RND(O)],LST1[RND(O)]
  SWAP LST2[RND(O)],LST2[RND(O)]
 NEXT
 PERFBEGIN 0
 FOR I=0TO O-1
  SPLAY_INSERT T,LST1[I],"a"
 NEXT
 ?PERFEND(0)/O
 PERFBEGIN 0
 FOR I=0TO O-1
  SPLAY_GET T,LST2[I] OUT ,
 NEXT
 ?PERFEND(0)/O
 PERFBEGIN 0
 FOR I=0TO O-1
  SPVAR #GSPRITE,LST1[I],"a"
 NEXT
 ?PERFEND(0)/O
 PERFBEGIN 0
 VAR A$
 FOR I=0TO O-1
  SPVAR #GSPRITE,LST2[I] OUT A$
 NEXT
 ?PERFEND(0)/O
END

DEF GET_SPLAY_ROOT(S)
 RETURN SPLAY_ROOT[S]
END
DEF GET_SPLAYN_LEFT(S)
 RETURN SPLAYN_LEFT[S]
END
DEF GET_SPLAYN_RIGHT(S)
 RETURN SPLAYN_RIGHT[S]
END
DEF GET_SPLAYN_VAL%(S)
 RETURN SPLAYN_VAL%[S]
END
DEF GET_SPLAYN_VAL#(S)
 RETURN SPLAYN_VAL#[S]
END
DEF GET_SPLAYN_VAL$(S)
 RETURN SPLAYN_VAL$[S]
END
DEF GET_SPLAYN_KEY$(S)
 RETURN SPLAYN_KEY$[S]
END

DIM NULLARRAY[0]
DIM SBARY[0]
VAR SBARYMAX
VAR SBARYFREE
DEF OTX_INIT_SBARRAY
 SBARYMAX=1024'256
 SBARY=ARRAY%(SBARYMAX)
 VAR I
 FOR I=0TO SBARYMAX-2
  SBARY[I]=I+1
 NEXT
 SBARY[SBARYMAX-1]=-1
 SBARYFREE=1
 NULLARRAY=ARRAY%(0)
END
COMMON DEF AllocSBArray()
 VAR A=SBARYFREE
 IF A==-1THEN RETURN -1
 SBARYFREE=SBARY[A]
 RETURN A
END
COMMON DEF FreeSBArray A
 IF!A THEN RETURN
 SBARY[A]=SBARYFREE
 SBARYFREE=A
 VAR("_"+HEX$(A))=EMPTY()
END
COMMON DEF GetSBArray(A)
 RETURN VAR("_"+HEX$(A))
END
COMMON DEF SetSBArray A,ARY
 VAR("_"+HEX$(A))=ARY
END
DIM _0[0],_1[0],_2[0],_3[0],_4[0],_5[0],_6[0],_7[0],_8[0],_9[0],_A[0],_B[0],_C[0],_D[0],_E[0],_F[0],_10[0],_11[0],_12[0],_13[0],_14[0],_15[0],_16[0],_17[0],_18[0],_19[0],_1A[0],_1B[0],_1C[0],_1D[0],_1E[0],_1F[0],_20[0],_21[0],_22[0],_23[0],_24[0],_25[0],_26[0],_27[0],_28[0],_29[0],_2A[0],_2B[0],_2C[0],_2D[0],_2E[0],_2F[0],_30[0],_31[0],_32[0],_33[0],_34[0],_35[0],_36[0],_37[0],_38[0],_39[0],_3A[0],_3B[0],_3C[0],_3D[0],_3E[0],_3F[0],_40[0],_41[0],_42[0],_43[0],_44[0],_45[0],_46[0],_47[0],_48[0],_49[0],_4A[0],_4B[0],_4C[0],_4D[0],_4E[0],_4F[0],_50[0],_51[0],_52[0],_53[0],_54[0],_55[0],_56[0],_57[0],_58[0],_59[0],_5A[0],_5B[0],_5C[0],_5D[0],_5E[0],_5F[0],_60[0],_61[0],_62[0],_63[0],_64[0],_65[0],_66[0],_67[0],_68[0],_69[0],_6A[0],_6B[0],_6C[0],_6D[0],_6E[0],_6F[0],_70[0],_71[0],_72[0],_73[0],_74[0],_75[0],_76[0],_77[0],_78[0],_79[0],_7A[0],_7B[0],_7C[0],_7D[0],_7E[0],_7F[0],_80[0],_81[0],_82[0],_83[0],_84[0],_85[0],_86[0],_87[0],_88[0],_89[0],_8A[0],_8B[0],_8C[0],_8D[0],_8E[0],_8F[0],_90[0],_91[0],_92[0],_93[0],_94[0],_95[0],_96[0],_97[0],_98[0],_99[0],_9A[0],_9B[0],_9C[0],_9D[0],_9E[0],_9F[0],_A0[0],_A1[0],_A2[0],_A3[0],_A4[0],_A5[0],_A6[0],_A7[0],_A8[0],_A9[0],_AA[0],_AB[0],_AC[0],_AD[0],_AE[0],_AF[0],_B0[0],_B1[0],_B2[0],_B3[0],_B4[0],_B5[0],_B6[0],_B7[0],_B8[0],_B9[0],_BA[0],_BB[0],_BC[0],_BD[0],_BE[0],_BF[0],_C0[0],_C1[0],_C2[0],_C3[0],_C4[0],_C5[0],_C6[0],_C7[0],_C8[0],_C9[0],_CA[0],_CB[0],_CC[0],_CD[0],_CE[0],_CF[0],_D0[0],_D1[0],_D2[0],_D3[0],_D4[0],_D5[0],_D6[0],_D7[0],_D8[0],_D9[0],_DA[0],_DB[0],_DC[0],_DD[0],_DE[0],_DF[0],_E0[0],_E1[0],_E2[0],_E3[0],_E4[0],_E5[0],_E6[0],_E7[0],_E8[0],_E9[0],_EA[0],_EB[0],_EC[0],_ED[0],_EE[0],_EF[0],_F0[0],_F1[0],_F2[0],_F3[0],_F4[0],_F5[0],_F6[0],_F7[0],_F8[0],_F9[0],_FA[0],_FB[0],_FC[0],_FD[0],_FE[0],_FF[0],_100[0],_101[0],_102[0],_103[0],_104[0],_105[0],_106[0],_107[0],_108[0],_109[0],_10A[0],_10B[0],_10C[0],_10D[0],_10E[0],_10F[0],_110[0],_111[0],_112[0],_113[0],_114[0],_115[0],_116[0],_117[0],_118[0],_119[0],_11A[0],_11B[0],_11C[0],_11D[0],_11E[0],_11F[0],_120[0],_121[0],_122[0],_123[0],_124[0],_125[0],_126[0],_127[0],_128[0],_129[0],_12A[0],_12B[0],_12C[0],_12D[0],_12E[0],_12F[0],_130[0],_131[0],_132[0],_133[0],_134[0],_135[0],_136[0],_137[0],_138[0],_139[0],_13A[0],_13B[0],_13C[0],_13D[0],_13E[0],_13F[0],_140[0],_141[0],_142[0],_143[0],_144[0],_145[0],_146[0],_147[0],_148[0],_149[0],_14A[0],_14B[0],_14C[0],_14D[0],_14E[0],_14F[0],_150[0],_151[0],_152[0],_153[0],_154[0],_155[0],_156[0],_157[0],_158[0],_159[0],_15A[0],_15B[0],_15C[0],_15D[0],_15E[0],_15F[0],_160[0],_161[0],_162[0],_163[0],_164[0],_165[0],_166[0],_167[0],_168[0],_169[0],_16A[0],_16B[0],_16C[0],_16D[0],_16E[0],_16F[0],_170[0],_171[0],_172[0],_173[0],_174[0],_175[0],_176[0],_177[0],_178[0],_179[0],_17A[0],_17B[0],_17C[0],_17D[0],_17E[0],_17F[0],_180[0],_181[0],_182[0],_183[0],_184[0],_185[0],_186[0],_187[0],_188[0],_189[0],_18A[0],_18B[0],_18C[0],_18D[0],_18E[0],_18F[0],_190[0],_191[0],_192[0],_193[0],_194[0],_195[0],_196[0],_197[0],_198[0],_199[0],_19A[0],_19B[0],_19C[0],_19D[0],_19E[0],_19F[0],_1A0[0],_1A1[0],_1A2[0],_1A3[0],_1A4[0],_1A5[0],_1A6[0],_1A7[0],_1A8[0],_1A9[0],_1AA[0],_1AB[0],_1AC[0],_1AD[0],_1AE[0],_1AF[0],_1B0[0],_1B1[0],_1B2[0],_1B3[0],_1B4[0],_1B5[0],_1B6[0],_1B7[0],_1B8[0],_1B9[0],_1BA[0],_1BB[0],_1BC[0],_1BD[0],_1BE[0],_1BF[0],_1C0[0],_1C1[0],_1C2[0],_1C3[0],_1C4[0],_1C5[0],_1C6[0],_1C7[0],_1C8[0],_1C9[0],_1CA[0],_1CB[0],_1CC[0],_1CD[0],_1CE[0],_1CF[0],_1D0[0],_1D1[0],_1D2[0],_1D3[0],_1D4[0],_1D5[0],_1D6[0],_1D7[0],_1D8[0],_1D9[0],_1DA[0],_1DB[0],_1DC[0],_1DD[0],_1DE[0],_1DF[0],_1E0[0],_1E1[0],_1E2[0],_1E3[0],_1E4[0],_1E5[0],_1E6[0],_1E7[0],_1E8[0],_1E9[0],_1EA[0],_1EB[0],_1EC[0],_1ED[0],_1EE[0],_1EF[0],_1F0[0],_1F1[0],_1F2[0],_1F3[0],_1F4[0],_1F5[0],_1F6[0],_1F7[0],_1F8[0],_1F9[0],_1FA[0],_1FB[0],_1FC[0],_1FD[0],_1FE[0],_1FF[0],_200[0],_201[0],_202[0],_203[0],_204[0],_205[0],_206[0],_207[0],_208[0],_209[0],_20A[0],_20B[0],_20C[0],_20D[0],_20E[0],_20F[0],_210[0],_211[0],_212[0],_213[0],_214[0],_215[0],_216[0],_217[0],_218[0],_219[0],_21A[0],_21B[0],_21C[0],_21D[0],_21E[0],_21F[0],_220[0],_221[0],_222[0],_223[0],_224[0],_225[0],_226[0],_227[0],_228[0],_229[0],_22A[0],_22B[0],_22C[0],_22D[0],_22E[0],_22F[0],_230[0],_231[0],_232[0],_233[0],_234[0],_235[0],_236[0],_237[0],_238[0],_239[0],_23A[0],_23B[0],_23C[0],_23D[0],_23E[0],_23F[0],_240[0],_241[0],_242[0],_243[0],_244[0],_245[0],_246[0],_247[0],_248[0],_249[0],_24A[0],_24B[0],_24C[0],_24D[0],_24E[0],_24F[0],_250[0],_251[0],_252[0],_253[0],_254[0],_255[0],_256[0],_257[0],_258[0],_259[0],_25A[0],_25B[0],_25C[0],_25D[0],_25E[0],_25F[0],_260[0],_261[0],_262[0],_263[0],_264[0],_265[0],_266[0],_267[0],_268[0],_269[0],_26A[0],_26B[0],_26C[0],_26D[0],_26E[0],_26F[0],_270[0],_271[0],_272[0],_273[0],_274[0],_275[0],_276[0],_277[0],_278[0],_279[0],_27A[0],_27B[0],_27C[0],_27D[0],_27E[0],_27F[0],_280[0],_281[0],_282[0],_283[0],_284[0],_285[0],_286[0],_287[0],_288[0],_289[0],_28A[0],_28B[0],_28C[0],_28D[0],_28E[0],_28F[0],_290[0],_291[0],_292[0],_293[0],_294[0],_295[0],_296[0],_297[0],_298[0],_299[0],_29A[0],_29B[0],_29C[0],_29D[0],_29E[0],_29F[0],_2A0[0],_2A1[0],_2A2[0],_2A3[0],_2A4[0],_2A5[0],_2A6[0],_2A7[0],_2A8[0],_2A9[0],_2AA[0],_2AB[0],_2AC[0],_2AD[0],_2AE[0],_2AF[0],_2B0[0],_2B1[0],_2B2[0],_2B3[0],_2B4[0],_2B5[0],_2B6[0],_2B7[0],_2B8[0],_2B9[0],_2BA[0],_2BB[0],_2BC[0],_2BD[0],_2BE[0],_2BF[0],_2C0[0],_2C1[0],_2C2[0],_2C3[0],_2C4[0],_2C5[0],_2C6[0],_2C7[0],_2C8[0],_2C9[0],_2CA[0],_2CB[0],_2CC[0],_2CD[0],_2CE[0],_2CF[0],_2D0[0],_2D1[0],_2D2[0],_2D3[0],_2D4[0],_2D5[0],_2D6[0],_2D7[0],_2D8[0],_2D9[0],_2DA[0],_2DB[0],_2DC[0],_2DD[0],_2DE[0],_2DF[0],_2E0[0],_2E1[0],_2E2[0],_2E3[0],_2E4[0],_2E5[0],_2E6[0],_2E7[0],_2E8[0],_2E9[0],_2EA[0],_2EB[0],_2EC[0],_2ED[0],_2EE[0],_2EF[0],_2F0[0],_2F1[0],_2F2[0],_2F3[0],_2F4[0],_2F5[0],_2F6[0],_2F7[0],_2F8[0],_2F9[0],_2FA[0],_2FB[0],_2FC[0],_2FD[0],_2FE[0],_2FF[0],_300[0],_301[0],_302[0],_303[0],_304[0],_305[0],_306[0],_307[0],_308[0],_309[0],_30A[0],_30B[0],_30C[0],_30D[0],_30E[0],_30F[0],_310[0],_311[0],_312[0],_313[0],_314[0],_315[0],_316[0],_317[0],_318[0],_319[0],_31A[0],_31B[0],_31C[0],_31D[0],_31E[0],_31F[0],_320[0],_321[0],_322[0],_323[0],_324[0],_325[0],_326[0],_327[0],_328[0],_329[0],_32A[0],_32B[0],_32C[0],_32D[0],_32E[0],_32F[0],_330[0],_331[0],_332[0],_333[0],_334[0],_335[0],_336[0],_337[0],_338[0],_339[0],_33A[0],_33B[0],_33C[0],_33D[0],_33E[0],_33F[0],_340[0],_341[0],_342[0],_343[0],_344[0],_345[0],_346[0],_347[0],_348[0],_349[0],_34A[0],_34B[0],_34C[0],_34D[0],_34E[0],_34F[0],_350[0],_351[0],_352[0],_353[0],_354[0],_355[0],_356[0],_357[0],_358[0],_359[0],_35A[0],_35B[0],_35C[0],_35D[0],_35E[0],_35F[0],_360[0],_361[0],_362[0],_363[0],_364[0],_365[0],_366[0],_367[0],_368[0],_369[0],_36A[0],_36B[0],_36C[0],_36D[0],_36E[0],_36F[0],_370[0],_371[0],_372[0],_373[0],_374[0],_375[0],_376[0],_377[0],_378[0],_379[0],_37A[0],_37B[0],_37C[0],_37D[0],_37E[0],_37F[0],_380[0],_381[0],_382[0],_383[0],_384[0],_385[0],_386[0],_387[0],_388[0],_389[0],_38A[0],_38B[0],_38C[0],_38D[0],_38E[0],_38F[0],_390[0],_391[0],_392[0],_393[0],_394[0],_395[0],_396[0],_397[0],_398[0],_399[0],_39A[0],_39B[0],_39C[0],_39D[0],_39E[0],_39F[0],_3A0[0],_3A1[0],_3A2[0],_3A3[0],_3A4[0],_3A5[0],_3A6[0],_3A7[0],_3A8[0],_3A9[0],_3AA[0],_3AB[0],_3AC[0],_3AD[0],_3AE[0],_3AF[0],_3B0[0],_3B1[0],_3B2[0],_3B3[0],_3B4[0],_3B5[0],_3B6[0],_3B7[0],_3B8[0],_3B9[0],_3BA[0],_3BB[0],_3BC[0],_3BD[0],_3BE[0],_3BF[0],_3C0[0],_3C1[0],_3C2[0],_3C3[0],_3C4[0],_3C5[0],_3C6[0],_3C7[0],_3C8[0],_3C9[0],_3CA[0],_3CB[0],_3CC[0],_3CD[0],_3CE[0],_3CF[0],_3D0[0],_3D1[0],_3D2[0],_3D3[0],_3D4[0],_3D5[0],_3D6[0],_3D7[0],_3D8[0],_3D9[0],_3DA[0],_3DB[0],_3DC[0],_3DD[0],_3DE[0],_3DF[0],_3E0[0],_3E1[0],_3E2[0],_3E3[0],_3E4[0],_3E5[0],_3E6[0],_3E7[0],_3E8[0],_3E9[0],_3EA[0],_3EB[0],_3EC[0],_3ED[0],_3EE[0],_3EF[0],_3F0[0],_3F1[0],_3F2[0],_3F3[0],_3F4[0],_3F5[0],_3F6[0],_3F7[0],_3F8[0],_3F9[0],_3FA[0],_3FB[0],_3FC[0],_3FD[0],_3FE[0],_3FF[0],_400[0]

'UTIL END
'OTYA FONT LIBRARY 1.00

'使い方
'
' VAR FONT
' INIT_FONT
' LOAD_FONT "NOTOSANS.FONT" OUT FONT
' GPUTCHR_FONT FONT,0,0,#FALSE,"Hello World",#C_WHITE
'


'INIT_FONT
'初期化する

'LOAD_FONT NAME% OUT FONT_DAT%
'ファイル名を指定してフォント読み込み
'IN
' NAME$:ファイル名
'OUT
' FONT_DAT%:フォントデータ

'GPUTCHR_FONT FONT_DAT%,X%,Y%,USE_BASE%,STR$,COL%
'フォントをつかって文字列を描画する
'プチコン4の制約によりCOL%の透明度は無視される
'IN
' FONT_DAT%:フォントデータ
' X%       :X
' Y%       :Y
' USE_BASE%:#TRUEの時ベースラインをY%の基準にする
' STR$     :描画する文字列
' COL%     :色

'GPUTCHR_FONT_NCLIP FONT_DAT%,X%,Y%,USE_BASE%,STR$,COL%
'フォントをつかって文字列を描画する
'プチコン4の制約によりCOL%の透明度とGCLIPは無視される
'IN
' FONT_DAT%:フォントデータ
' X%       :X
' Y%       :Y
' USE_BASE%:#TRUEの時ベースラインをY%の基準にする
' STR$     :描画する文字列
' COL%     :色

'FONT_GET_LINE_HEIGHT FONT_DAT% OUT HEIGHT%
'そのフォントの行の高さを取得する
'IN
' FONT_DAT%:フォントデータ
'OUT
' HEIGHT%  :行の高さ

'FONT_CALC_WIDTH FONT_DAT%,STR$ OUT WIDTH%
'文字列の幅を計算する
'IN
' FONT_DAT%:フォントデータ
' STR$     :幅をはかる文字列
'OUT
' WIDTH%   :計算された文字列の幅

'GENERATE_GRPF FONT_DAT%,YOFFSET%,FULL_WIDTH_CHAR%
'フォントからGRPFを生成する
' FONT_DAT%       :フォントデータ
' YOFFSET%        :フォントのY座標を微調整する
' FULL_WIDTH_CHAR%:#TRUEならば全角英数を使う



'OPTION STRICT
DEF BINREADN ARY%,OFS%,CNT% OUT V%,OFSO%
 VAR I%=0
 V%=0
 FOR I%=0TO CNT%-1
  VAR T%=ARY%[OFS% DIV 4]>>(OFS% MOD 4*8)AND 255
  INC V%,T%<<(I%*8)
  INC OFS%
 NEXT
 OFSO%=OFS%
END
DEF BINREAD ARY%,OFS%,FMT$ OUT *
 VAR I%,TMP%
 FOR I%=0TO LAST(FMT$)
  VAR F$=FMT$[I%]
  CASE F$
  '16-BIT SIGNED INTEGER
  WHEN "s"
   BINREADN ARY%,OFS%,2 OUT TMP%,OFS%
   DEFOUT I%+1,TMP%<<16>>16
  '16-BIT UNSIGNED INTEGER
  WHEN "S"
   BINREADN ARY%,OFS%,2 OUT TMP%,OFS%
   DEFOUT I%+1,TMP%
  '32-BIT SIGNED INTEGER
  WHEN "I"
   BINREADN ARY%,OFS%,4 OUT TMP%,OFS%
   DEFOUT I%+1,TMP%
  '8-BIT UNSIGNED INTEGER
  WHEN "B"
   BINREADN ARY%,OFS%,1 OUT TMP%,OFS%
   DEFOUT I%+1,TMP%
  '8-BIT SIGNED INTEGER
  WHEN "b"
   BINREADN ARY%,OFS%,1 OUT TMP%,OFS%
   DEFOUT I%+1,TMP%<<24>>24
  'NULL-TERMINATED ASCII STRING
  WHEN "N"
   VAR TMP$=""
   LOOP
    VAR C%
    BINREADN ARY%,OFS%,1 OUT C%,OFS%
    IF C%==0 THEN BREAK
    PUSH TMP$,CHR$(C%)
   ENDLOOP
   DEFOUT I%+1,TMP$
  ENDCASE
 NEXT
 DEFOUT 0,OFS%
END

ENUM\
     #FONTTBL_F,\
     #FONTTBL_X,\
     #FONTTBL_Y,\
     #FONTTBL_W,\
     #FONTTBL_H,\
     #FONTTBL_XOFF,\
     #FONTTBL_YOFF,\
     #FONTTBL_XADV,\
     #FONTTBL_PAGE,\
     #FONTTBL_CHNL,\
     #FONTTBL_SIZE
ENUM\
     #FONTTBL_INDEX_LAST=65536,\
     #FONTTBL_LEN
ENUM\
     #FONTTBL_L_LINE_H,\
     #FONTTBL_L_BASE,\
     #FONTTBL_L_SCALE_W,\
     #FONTTBL_L_SCALE_H,\
     #FONTTBL_L_PAGES,\
     #FONTTBL_L_BITFIELD_COMMON,\
     \
     #FONTTBL_L_TEXH
DIM FONT_ALPHA_PAL%[]
DIM FONT_PAL%[]
'INIT_FONT
'初期化する
COMMON DEF INIT_FONT
 VAR I%
 FONT_ALPHA_PAL%=ARRAY%(256)
 FOR I%=0TO 255
  FONT_ALPHA_PAL%[I%]=I%<<24
 NEXT
 FONT_PAL%=ARRAY%(256)
END


'GENERATE_GRPF FONT_DAT%,YOFFSET%,FULL_WIDTH_CHAR%
'フォントからGRPFをせいせいする
' FONT_DAT%       :フォントデータ
' YOFFSET%        :フォントのYざひょうをびちょうせいする
' FULL_WIDTH_CHAR%:#TRUEならばぜんかくえいすうをつかう
COMMON DEF GENERATE_GRPF FONT_DAT%,YOFFSET%,FULL_WIDTH_CHAR%
 FILL FONT_PAL%,&HFFFFFF
 ARYOP #AOPADD,FONT_PAL%,FONT_PAL%,FONT_ALPHA_PAL%
 VAR I%
 VAR TBL_I%=LEN(FONT_DAT%)-#FONTTBL_LEN*#FONTTBL_SIZE
 VAR GT%=GTARGET()
 VAR GCX1%,GCY1%,GCX2%,GCY2%
 GCLIP OUT GCX1%,GCY1%,GCX2%,GCY2%
 VAR LAST%=TBL_I%+#FONTTBL_INDEX_LAST*#FONTTBL_SIZE
 VAR BASE%=FONT_DAT%[LAST%+#FONTTBL_L_BASE]
 VAR LH%=FONT_DAT%[LAST%+#FONTTBL_L_LINE_H]
 VAR W%=FONT_DAT%[LAST%+#FONTTBL_L_SCALE_W]
 VAR H%=FONT_DAT%[LAST%+#FONTTBL_L_TEXH]
 VAR WORK_GP%=1
 DIM WORK%[]
 GSAVE WORK_GP%,0,0,16,16,WORK%
 VAR BY%=LH%-BASE%
 FOR I%=0TO 65535
  VAR X%,Y%
  IF !FULL_WIDTH_CHAR% THEN
   'Fullwidth
   IF I%>=&HFF01&&I%<=&HFF5ETHEN
    CONTINUE
   ENDIF
  ENDIF
  IF I%>=&HE800&&I%<=&HF7FF THEN CONTINUE
  VAR T%=TBL_I%+I%*#FONTTBL_SIZE
  FONTINFO I%,16 OUT X%,Y%
  IF X%==1008&&Y%==1184||!FONT_DAT%[T%+#FONTTBL_F] THEN
   CONTINUE
  ENDIF
  VAR P%=FONT_DAT%[T%+#FONTTBL_PAGE]
  VAR FX%=FONT_DAT%[T%+#FONTTBL_X]
  VAR FY%=FONT_DAT%[T%+#FONTTBL_Y]
  VAR FW%=FONT_DAT%[T%+#FONTTBL_W]
  VAR FH%=FONT_DAT%[T%+#FONTTBL_H]
  VAR XOFF%=FONT_DAT%[T%+#FONTTBL_XOFF]
  VAR YOFF%=FONT_DAT%[T%+#FONTTBL_YOFF]
  IF YOFF%+FH%>16THEN
   'YOFF%=-FH%+16
  ENDIF
  DEC YOFF%,BY%+YOFFSET%'-1
  VAR XADV%=FONT_DAT%[T%+#FONTTBL_XADV]
  GTARGET WORK_GP%
  GCLIP 0,0,FW%-1,FH%-1
  GLOAD -FX%,-FY%,W%,H%,FONT_DAT%,FONT_PAL%,#G_NORMAL
  GTARGET #GRPF
  GCLIP X%,Y%,X%+15,Y%+15
  GFILL X%,Y%,X%+15,Y%+15,0
  GCOPY WORK_GP%,0,0,FW%-1,FH%-1,X%+XOFF%+(16-XADV%)DIV 2,Y%+YOFF%,#G_NORMAL
 NEXT
 GTARGET WORK_GP%
 GLOAD 0,0,16,16,WORK%,#G_NORMAL
 GTARGET GT%
 GCLIP GCX1%,GCY1%,GCX2%,GCY2%
END

'LOAD_FONT NAME$ OUT FONT_DAT%[]
'ファイル名を指定してフォント読み込み
'IN
' NAME$:ファイル名
'OUT
' FONT_DAT%:フォントデータ
COMMON DEF LOAD_FONT NAME$ OUT FONT_DAT%[]
 FONT_DAT%=LOADV("DAT:"+NAME$)
END
'インチキをしてファイルのおおきさをさくげん(とうめいどを256/LEVEL%だんかいにしてあっしゅくりつをあげる)
COMMON DEF COMPRESS_FONT_DATA FONT_DAT%[],LEVEL%
 VAR TBL_I%=LEN(FONT_DAT%)-#FONTTBL_LEN*#FONTTBL_SIZE
 VAR LAST%=TBL_I%+#FONTTBL_INDEX_LAST*#FONTTBL_SIZE
 VAR W%=FONT_DAT%[LAST%+#FONTTBL_L_SCALE_W]
 VAR H%=FONT_DAT%[LAST%+#FONTTBL_L_TEXH]
 VAR I%
 FOR I%=0TO W%*H%-1
  IF FONT_DAT%[I%]==255 THEN CONTINUE
  FONT_DAT%[I%]=FONT_DAT%[I%] DIV LEVEL%*LEVEL%
 NEXT
END
'フォント画像の大きさを縮小してフォント情報をくっつけて一つの配列にまとめる
DEF REDUCE_FONT_DATA FONT_DAT%[],FONT_TBL%[]
 VAR I%
 VAR PAGES%=FONT_TBL%[#FONTTBL_INDEX_LAST,#FONTTBL_L_PAGES]
 VAR W%=FONT_TBL%[#FONTTBL_INDEX_LAST,#FONTTBL_L_SCALE_W]
 VAR H%=FONT_TBL%[#FONTTBL_INDEX_LAST,#FONTTBL_L_SCALE_H]
 VAR LAST_Y%=0
 FOR I%=0TO 65535
  VAR P%=FONT_TBL%[I%,#FONTTBL_PAGE]
  VAR FY%=FONT_TBL%[I%,#FONTTBL_Y]+P%*H%
  FONT_TBL%[I%,#FONTTBL_Y]=FY%
  IF P%!=PAGES%-1 THEN CONTINUE
  VAR FH%=FONT_TBL%[I%,#FONTTBL_H]
  LAST_Y%=MAX(LAST_Y%,FY%+FH%-1)
 NEXT
 ?LEN(FONT_DAT%) DIV W%;"->";LAST_Y%
 RESIZE FONT_DAT%,LAST_Y%*W%
 FONT_TBL%[#FONTTBL_INDEX_LAST,#FONTTBL_L_TEXH]=LAST_Y%
 COPY FONT_DAT%,LEN(FONT_DAT%),FONT_TBL%
END
'[&HAABBCCDD]->[AA,BB,CC,DD]
COMMON DEF GENERATE_FONT FNAME$ OUT FONT_DAT%[]
 VAR FONT_TBL%[]
 GEN_FONTTBL LOADV("DAT:"+FNAME$) OUT FONT_TBL%
 VAR I%
 VAR PAGES%=FONT_TBL%[#FONTTBL_INDEX_LAST,#FONTTBL_L_PAGES]
 VAR W%=FONT_TBL%[#FONTTBL_INDEX_LAST,#FONTTBL_L_SCALE_W]
 VAR H%=FONT_TBL%[#FONTTBL_INDEX_LAST,#FONTTBL_L_SCALE_H]
 FONT_TBL%[#FONTTBL_INDEX_LAST,#FONTTBL_L_TEXH]=H%*PAGES%
 FONT_DAT%=ARRAY%(W%*H%*PAGES%)
 VAR J%=0
 FOR I%=0TO PAGES%-1
  VAR G%=LOADV("DAT:"+FNAME$+"_"+STR$(I%))
  VAR X%,Y%
  VAR K%=0
  LOOP
   FOR Y%=I%*H% TO ((I%+1)*H%)-1
    FOR X%=0TO W% DIV 4-1
     VAR A1%,A2%,A3%,A4%
     RGB G%[K%] OUT A4%,A3%,A2%,A1%
     INC K%
     FONT_DAT%[J%]=A1%
     INC J%
     FONT_DAT%[J%]=A2%
     INC J%
     FONT_DAT%[J%]=A3%
     INC J%
     FONT_DAT%[J%]=A4%
     INC J%
    NEXT
   NEXT
   IF LEN(G%)==K% THEN BREAK
   INC I%
  ENDLOOP
 NEXT
 REDUCE_FONT_DATA FONT_DAT%,FONT_TBL%
END


'FONT_GET_LINE_HEIGHT FONT_DAT% OUT HEIGHT%
'そのフォントの行の高さを取得する
'IN
' FONT_DAT%:フォントデータ
'OUT
' HEIGHT%  :行の高さ
COMMON DEF FONT_GET_LINE_HEIGHT FONT_DAT% OUT HEIGHT%
 VAR TBL_I%=LEN(FONT_DAT%)-#FONTTBL_LEN*#FONTTBL_SIZE
 HEIGHT%=FONT_DAT%[TBL_I%+#FONTTBL_INDEX_LAST*#FONTTBL_SIZE+#FONTTBL_L_LINE_H]
END
'FONT_CALC_WIDTH FONT_DAT%,STR$ OUT WIDTH%
'文字列の幅を計算する
'IN
' FONT_DAT%:フォントデータ
' STR$     :幅をはかる文字列
'OUT
' WIDTH%   :計算された文字列の幅
COMMON DEF FONT_CALC_WIDTH FONT_DAT%,STR$ OUT WIDTH%
 VAR I%,L%=LAST(STR$)
 VAR TBL_I%=LEN(FONT_DAT%)-#FONTTBL_LEN*#FONTTBL_SIZE
 VAR LAST%=TBL_I%+#FONTTBL_INDEX_LAST*#FONTTBL_SIZE
 WIDTH%=0
 FOR I%=0TO L%
  VAR A%=ASC(STR$[I%])
  VAR T%=TBL_I%+A%*#FONTTBL_SIZE
  INC WIDTH%,FONT_DAT%[T%+#FONTTBL_XADV]
 NEXT
 RETURN WIDTH%
END
'GPUTCHR_FONT FONT_DAT%,X%,Y%,USE_BASE%,STR$,COL%
'フォントをつかって文字列を描画する
'プチコン4の制約によりCOL%の透明度は無視される
'IN
' FONT_DAT%:フォントデータ
' X%       :X
' Y%       :Y
' USE_BASE%:#TRUEの時ベースラインをY%の基準にする
' STR$     :描画する文字列
' COL%     :色
COMMON DEF GPUTCHR_FONT FONT_DAT%,X%,Y%,USE_BASE%,STR$,COL%
 VAR I%,L%=LAST(STR$),GCX1%,GCY1%,GCX2%,GCY2%
 DEC Y%,2
 FILL FONT_PAL%,COL% AND &HFFFFFF
 ARYOP #AOPADD,FONT_PAL%,FONT_PAL%,FONT_ALPHA_PAL%
 GCLIP OUT GCX1%,GCY1%,GCX2%,GCY2%
 VAR TBL_I%=LEN(FONT_DAT%)-#FONTTBL_LEN*#FONTTBL_SIZE
 VAR LAST%=TBL_I%+#FONTTBL_INDEX_LAST*#FONTTBL_SIZE
 VAR W%=FONT_DAT%[LAST%+#FONTTBL_L_SCALE_W]
 VAR H%=FONT_DAT%[LAST%+#FONTTBL_L_TEXH]
 IF USE_BASE% THEN
  DEC Y%,FONT_DAT%[LAST%+#FONTTBL_L_BASE]
 ENDIF
 FOR I%=0TO L%
  VAR A%=ASC(STR$[I%])
  VAR T%=TBL_I%+A%*#FONTTBL_SIZE
  VAR FX%=FONT_DAT%[T%+#FONTTBL_X]
  VAR FY%=FONT_DAT%[T%+#FONTTBL_Y]
  VAR FW%=FONT_DAT%[T%+#FONTTBL_W]
  VAR FH%=FONT_DAT%[T%+#FONTTBL_H]
  VAR XOFF%=FONT_DAT%[T%+#FONTTBL_XOFF]+X%
  VAR YOFF%=FONT_DAT%[T%+#FONTTBL_YOFF]+Y%
  X%=X%+FONT_DAT%[T%+#FONTTBL_XADV]
  'clipping
  IF GCX1%>=XOFF%+FW% ||\
     GCX2%<XOFF% ||\
     GCY1%>=YOFF%+FH% ||\
     GCY2%<YOFF% THEN CONTINUE
  GCLIP MAX(GCX1%,XOFF%),MAX(GCY1%,YOFF%),MIN(FW%+XOFF%-1,GCX2%),MIN(FH%+YOFF%-1,GCY2%)
  GLOAD XOFF%-FX%,YOFF%-FY%,W%,H%,FONT_DAT%,FONT_PAL%,#G_ALPHA2
 NEXT
 GCLIP GCX1%,GCY1%,GCX2%,GCY2%
END
COMMON DEF GPUTCHR_FONT_W FONT_DAT%,X%,Y%,USE_BASE%,STR$,COL% OUT TEXT_W%
 VAR I%,L%=LAST(STR$),GCX1%,GCY1%,GCX2%,GCY2%
 DEC Y%,2
 FILL FONT_PAL%,COL% AND &HFFFFFF
 ARYOP #AOPADD,FONT_PAL%,FONT_PAL%,FONT_ALPHA_PAL%
 GCLIP OUT GCX1%,GCY1%,GCX2%,GCY2%
 VAR TBL_I%=LEN(FONT_DAT%)-#FONTTBL_LEN*#FONTTBL_SIZE
 VAR LAST%=TBL_I%+#FONTTBL_INDEX_LAST*#FONTTBL_SIZE
 VAR W%=FONT_DAT%[LAST%+#FONTTBL_L_SCALE_W]
 VAR H%=FONT_DAT%[LAST%+#FONTTBL_L_TEXH]
 IF USE_BASE% THEN
  DEC Y%,FONT_DAT%[LAST%+#FONTTBL_L_BASE]
 ENDIF
 VAR SX%=X%
 FOR I%=0TO L%
  VAR A%=ASC(STR$[I%])
  VAR T%=TBL_I%+A%*#FONTTBL_SIZE
  VAR FX%=FONT_DAT%[T%+#FONTTBL_X]
  VAR FY%=FONT_DAT%[T%+#FONTTBL_Y]
  VAR FW%=FONT_DAT%[T%+#FONTTBL_W]
  VAR FH%=FONT_DAT%[T%+#FONTTBL_H]
  VAR XOFF%=FONT_DAT%[T%+#FONTTBL_XOFF]+X%
  VAR YOFF%=FONT_DAT%[T%+#FONTTBL_YOFF]+Y%
  X%=X%+FONT_DAT%[T%+#FONTTBL_XADV]
  'clipping
  IF GCX1%>=XOFF%+FW% ||\
     GCX2%<XOFF% ||\
     GCY1%>=YOFF%+FH% ||\
     GCY2%<YOFF% THEN CONTINUE
  GCLIP MAX(GCX1%,XOFF%),MAX(GCY1%,YOFF%),MIN(FW%+XOFF%-1,GCX2%),MIN(FH%+YOFF%-1,GCY2%)
  GLOAD XOFF%-FX%,YOFF%-FY%,W%,H%,FONT_DAT%,FONT_PAL%,#G_ALPHA2
 NEXT
 GCLIP GCX1%,GCY1%,GCX2%,GCY2%
 TEXT_W%=X%-SX%
END
'GPUTCHR_FONT_NCLIP FONT_DAT%,X%,Y%,USE_BASE%,STR$,COL%
'フォントをつかって文字列を描画する
'プチコン4の制約によりCOL%の透明度とGCLIPは無視される
'IN
' FONT_DAT%:フォントデータ
' X%       :X
' Y%       :Y
' USE_BASE%:#TRUEの時ベースラインをY%の基準にする
' STR$     :描画する文字列
' COL%     :色
COMMON DEF GPUTCHR_FONT_NCLIP FONT_DAT%,X%,Y%,USE_BASE%,STR$,COL%
 VAR I%,L%=LAST(STR$),GCX1%,GCY1%,GCX2%,GCY2%
 FILL FONT_PAL%,COL% AND &HFFFFFF
 ARYOP #AOPADD,FONT_PAL%,FONT_PAL%,FONT_ALPHA_PAL%
 GCLIP OUT GCX1%,GCY1%,GCX2%,GCY2%
 VAR TBL_I%=LEN(FONT_DAT%)-#FONTTBL_LEN*#FONTTBL_SIZE
 VAR LAST%=TBL_I%+#FONTTBL_INDEX_LAST*#FONTTBL_SIZE
 VAR W%=FONT_DAT%[LAST%+#FONTTBL_L_SCALE_W]
 VAR H%=FONT_DAT%[LAST%+#FONTTBL_L_TEXH]
 IF USE_BASE% THEN
  DEC Y%,FONT_DAT%[LAST%+#FONTTBL_L_BASE]
 ENDIF
 FOR I%=0TO L%
  VAR T%=TBL_I%+ASC(STR$[I%])*#FONTTBL_SIZE
  VAR XOFF%=FONT_DAT%[T%+#FONTTBL_XOFF]+X%
  VAR YOFF%=FONT_DAT%[T%+#FONTTBL_YOFF]+Y%
  GCLIP XOFF%,YOFF%,FONT_DAT%[T%+#FONTTBL_W]+XOFF%-1,FONT_DAT%[T%+#FONTTBL_H]+YOFF%-1
  GLOAD XOFF%-FONT_DAT%[T%+#FONTTBL_X],YOFF%-FONT_DAT%[T%+#FONTTBL_Y],W%,H%,FONT_DAT%,FONT_PAL%,#G_ALPHA2
  X%=X%+FONT_DAT%[T%+#FONTTBL_XADV]
 NEXT
 GCLIP GCX1%,GCY1%,GCX2%,GCY2%
END

'BMFファイルからフォント情報配列を生成
DEF GEN_FONTTBL FILE%[] OUT O_TBL%
 DIM TABLE%[#FONTTBL_LEN,#FONTTBL_SIZE]
 VAR OFS%=0
 VAR MAGIC_B%,MAGIC_M%,MAGIC_F%
 VAR VER%
 VAR BLOCK_TYPE_IDEN%
 VAR BLOCK_LEN%
 VAR FONTSIZE%,BITFIELD%,CHARSET%,STRETCHH%,AA%,PADDINGUP%,PADDINGRIGHT%,PADDINGDOWN%,PADDINGLEFT%,SPACINGHORIZ%,SPACINGVERT%,OUTLINE%,FONTNAME$
 BINREAD FILE%,OFS%,"BBBB" OUT OFS%,MAGIC_B%,MAGIC_M%,MAGIC_F%,VER%
 CONST\
       #BMF_BLOCK_INFO=1,\
       #BMF_BLOCK_COMMON=2,\
       #BMF_BLOCK_PAGES=3,\
       #BMF_BLOCK_CHARS=4,\
       #BMF_BLOCK_KERNING_PARTS=5
 LOOP
  IF OFS% DIV 4>=LEN(FILE%)-1THEN BREAK
  BINREAD FILE%,OFS%,"B" OUT OFS%,BLOCK_TYPE_IDEN%
  BINREAD FILE%,OFS%,"I" OUT OFS%,BLOCK_LEN%
  VAR OLD_OFS%=OFS%
  CASE BLOCK_TYPE_IDEN%
  WHEN #BMF_BLOCK_INFO
   BINREAD FILE%,OFS%,"sBBSBBBBBBBBN" OUT OFS%,FONTSIZE%,BITFIELD%,CHARSET%,STRETCHH%,AA%,PADDINGUP%,PADDINGRIGHT%,PADDINGDOWN%,PADDINGLEFT%,SPACINGHORIZ%,SPACINGVERT%,OUTLINE%,FONTNAME$
  WHEN #BMF_BLOCK_COMMON
   VAR lineHeight%
   VAR base%
   VAR scaleW%
   VAR scaleH%
   VAR pages%
   VAR bitFieldCommon%
   VAR alphaChnl%
   VAR redChnl%
   VAR greenChnl%
   VAR blueChnl%
   BINREAD FILE%,OFS%,"SSSSSBSSSS" OUT OFS%,lineHeight%,base%,scaleW%,\
                                       scaleH%,pages%,bitFieldCommon%,\
                                       alphaChnl%,redChnl%,greenChnl%,\
                                       blueChnl%
   TABLE%[#FONTTBL_INDEX_LAST,#FONTTBL_L_LINE_H]=lineHeight%
   TABLE%[#FONTTBL_INDEX_LAST,#FONTTBL_L_BASE]=base%
   TABLE%[#FONTTBL_INDEX_LAST,#FONTTBL_L_SCALE_W]=scaleW%
   TABLE%[#FONTTBL_INDEX_LAST,#FONTTBL_L_SCALE_H]=scaleH%
   TABLE%[#FONTTBL_INDEX_LAST,#FONTTBL_L_PAGES]=pages%
   TABLE%[#FONTTBL_INDEX_LAST,#FONTTBL_L_BITFIELD_COMMON]=bitFieldCommon%
  WHEN #BMF_BLOCK_PAGES
   LOOP
    VAR PAGE$
    BINREAD FILE%,OFS%,"N" OUT OFS%,PAGE$
    IF OFS%>=OLD_OFS%+BLOCK_LEN% THEN BREAK
   ENDLOOP
  WHEN #BMF_BLOCK_CHARS
   LOOP
    VAR ID%,X%,Y%,WIDTH%,HEIGHT%,X_OFF%,Y_OFF%,X_ADV%,PAGE%,CHNL%
    BINREAD FILE%,OFS%,"ISSSSsssBB" OUT\
            OFS%,ID%,X%,Y%,WIDTH%,HEIGHT%,X_OFF%,Y_OFF%,X_ADV%,PAGE%,CHNL%
    TABLE%[ID%,#FONTTBL_F]=1
    TABLE%[ID%,#FONTTBL_X]=X%
    TABLE%[ID%,#FONTTBL_Y]=Y%
    TABLE%[ID%,#FONTTBL_W]=WIDTH%
    TABLE%[ID%,#FONTTBL_H]=HEIGHT%
    TABLE%[ID%,#FONTTBL_XOFF]=X_OFF%
    TABLE%[ID%,#FONTTBL_YOFF]=Y_OFF%
    TABLE%[ID%,#FONTTBL_XADV]=X_ADV%
    TABLE%[ID%,#FONTTBL_PAGE]=PAGE%
    TABLE%[ID%,#FONTTBL_CHNL]=CHNL%
    IF OFS%>=OLD_OFS%+BLOCK_LEN% THEN BREAK
   ENDLOOP
  WHEN #BMF_BLOCK_KERNING_PARTS
   '''
  ENDCASE
  IF OFS%!=OLD_OFS%+BLOCK_LEN% THEN
   '?"INVALID FMT",BLOCK_TYPE_IDEN%,#_SLOT,#_LINE,#_FILENAME
  ENDIF
  OFS%=OLD_OFS%+BLOCK_LEN%
 ENDLOOP
 O_TBL%=TABLE%
END

DEF FONT_BASE91_ENCODE(DAT%[])
 VAR I%,L%=LAST(DAT%)
 VAR Q%
 VAR NB%
 VAR R$=""
 VAR T$=""
 FOR I%=0TO 90
  PUSH T$,CHR$(35+I%)
 NEXT
 FOR I%=0TO L%
  Q%=Q% OR (DAT%[I%]<<NB%)
  INC NB%,8
  IF NB%>13 THEN
   VAR V%=Q% AND 8191
   IF V%>88THEN
    Q%=Q%>>13
    DEC NB%,13
   ELSE
    V%=Q% AND 16383
    Q%=Q%>>14
    DEC NB%,14
   ENDIF
   PUSH R$,T$[V% MOD 91]
   PUSH R$,T$[V% DIV 91]
  ENDIF
 NEXT
 IF NB% THEN
  PUSH R$,T$[Q% MOD 91]
  IF NB%>7||Q%>90THEN
   PUSH R$,T$[Q% DIV 91]
  ENDIF
 ENDIF
 RETURN R$
END
DEF FONT_BASE91_DECODE(DAT$)
 VAR I%,L%=LAST(DAT$)
 DIM T%[256]
 FILL T%,-1
 FOR I%=0TO 90
  T%[35+I%]=I%
 NEXT
 DIM R%[0]
 VAR V%=-1,Q%,NB%
 FOR I%=0TO L%
  VAR D%=T%[ASC(DAT$[I%])]
  IF D%==-1 THEN CONTINUE
  IF V%==-1THEN
   V%=D%
  ELSE
   INC V%,D%*91
   Q%=Q% OR V%<<NB%
   IF (V% AND 8191)>88 THEN
    INC NB%,13
   ELSE
    INC NB%,14
   ENDIF
   REPEAT
    PUSH R%,Q% AND 255
    Q%=Q%>>8
    DEC NB%,8
   UNTIL NB%<=8
   V%=-1
  ENDIF
 NEXT
 IF V%!=-1 THEN
  PUSH R%,(Q% OR (V%<<NB%)) AND 255
 ENDIF
 RETURN R%
END
DEF FONT_TO_STR(FONT_DAT%)
 VAR TBL_I%=LEN(FONT_DAT%)-#FONTTBL_LEN*#FONTTBL_SIZE
 VAR LAST%=TBL_I%+#FONTTBL_INDEX_LAST*#FONTTBL_SIZE
 VAR W%=FONT_DAT%[LAST%+#FONTTBL_L_SCALE_W]
 VAR H%=FONT_DAT%[LAST%+#FONTTBL_L_TEXH]
 VAR I%,J%
 DIM RESULT_META%[]
 VAR PACKED%
 
 VAR T%=LAST%
 FOR J%=0TO #FONTTBL_SIZE-1
  PUSH RESULT_META%,FONT_DAT%[T%+J%] AND 255
  PUSH RESULT_META%,FONT_DAT%[T%+J%]>>16
 NEXT
 FOR I%=0 TO 65535
  T%=TBL_I%+I%*#FONTTBL_SIZE
  IF !FONT_DAT%[T%+#FONTTBL_F] THEN
   CONTINUE
  ENDIF
  FOR J%=0TO #FONTTBL_SIZE-1
   PUSH RESULT_META%,FONT_DAT%[T%+J%] AND 255
   PUSH RESULT_META%,FONT_DAT%[T%+J%]>>16
  NEXT
 NEXT
 VAR SM$=FONT_BASE91_ENCODE(RESULT_META%)
 VAR NM%=FONT_BASE91_DECODE(SM$)
 STOP
 PACKED%=0
 VAR LEVEL%
 DIM RESULT%[]
 FOR I%=0TO W%*H%-1
  IF 0&&FONT_DAT%[I%] DIV 16==0THEN
   'RLE
   VAR L%=I%+15
   VAR RLE%=0
   FOR I%=I% TO L%
    IF FONT_DAT%[I%] DIV 16!=0THEN
     BREAK
    ENDIF
    INC RLE%
   NEXT
   DEC I%
   IF PACKED% MOD 2==0THEN
    PUSH RESULT%,0 OR (RLE%<<4)
   ELSE
    INC RESULT%[LAST(RESULT%)],(FONT_DAT%[I%] DIV 16)<<4
    PUSH RESULT%,RLE%<<4
   ENDIF
   INC PACKED%,2
   CONTINUE
  ENDIF
  IF PACKED% MOD 2==0THEN
   PUSH RESULT%,FONT_DAT%[I%] DIV 16
  ELSE
   INC RESULT%[LAST(RESULT%)],(FONT_DAT%[I%] DIV 16)<<4
  ENDIF
  INC PACKED%
 NEXT
 VAR S$=FONT_BASE91_ENCODE(RESULT%)
 VAR N%=FONT_BASE91_DECODE(S$)
 STOP
END

