OPTION STRICT
MAIN
DEF GET_SLOT$(N)
 PRGEDIT N
 VAR S$=""
 VAR I,L=PRGSIZE()
 FOR I=1TO L
  PUSH S$,PRGGET$()
 NEXT
 RETURN S$
END
DEF MAIN
 VAR IN$=GET_SLOT$(1)'"PRINT 1+2-8*12"'*8"
 INIT_LEXER IN$
 LEX_NEXT OUT ,
 LEX_NEXT OUT ,
 LEX_NEXT OUT ,
 LEX_NEXT OUT ,
 LEX_NEXT OUT ,
 LEX_NEXT OUT ,
 LEX_NEXT OUT ,
 ?IN$
 INIT_VM
 INIT_LEXER IN$
 PARSE
 VM_RUN
END
VAR LEXER_IN$
VAR LEXER_I
VAR LEXER_VAL
ENUM\
 #TKN_NONE,\
 #TKN_NUM,\
 #TKN_STR,\
 #TKN_PRINT,\
 #TKN_DEF,\
 #TKN_RETURN,\
 #TKN_IDEN,\
 #TKN_PLUS,\
 #TKN_MINUS,\
 #TKN_MUL,\
 #TKN_DIV,\
 #TKN_DIVINT,\
 #TKN_COMMA,\
 #TKN_LP,\
 #TKN_RP,\
 #TKN_LB,\
 #TKN_RB,\
 #TKN_SEMI,\
 #TKN_COL,\
 #TKN_NEWLINE,\
 #TKN_EOF,\
 #TKN_MOD,\
 #TKN_LSHIFT,\
 #TKN_RSHIFT,\
 #TKN_EQ,\
 #TKN_NEQ,\
 #TKN_LESS,\
 #TKN_LEQ,\
 #TKN_GREAT,\
 #TKN_GEQ,\
 #TKN_AND,\
 #TKN_OR,\
 #TKN_XOR,\
 #TKN_LAND,\
 #TKN_LOR,\
 #TKN_,\
 #TKN_LAST
DEF TKN_STR$(T)
 CASE T
 WHEN #TKN_NONE:RETURN "#TKN_NONE"
 WHEN #TKN_NUM:RETURN "#TKN_NUM"
 WHEN #TKN_STR:RETURN "#TKN_STR"
 WHEN #TKN_PRINT:RETURN "#TKN_PRINT"
 WHEN #TKN_DEF:RETURN "#TKN_DEF"
 WHEN #TKN_RETURN:RETURN "#TKN_RETURN"
 WHEN #TKN_IDEN:RETURN "#TKN_IDEN"
 WHEN #TKN_PLUS:RETURN "#TKN_PLUS"
 WHEN #TKN_MINUS:RETURN "#TKN_MINUS"
 WHEN #TKN_MUL:RETURN "#TKN_MUL"
 WHEN #TKN_DIV:RETURN "#TKN_DIV"
 WHEN #TKN_DIVINT:RETURN "#TKN_DIVINT"
 WHEN #TKN_COMMA:RETURN "#TKN_COMMA"
 WHEN #TKN_LP:RETURN "#TKN_LP"
 WHEN #TKN_RP:RETURN "#TKN_RP"
 WHEN #TKN_LB:RETURN "#TKN_LB"
 WHEN #TKN_RB:RETURN "#TKN_RB"
 WHEN #TKN_SEMI:RETURN "#TKN_SEMI"
 WHEN #TKN_COL:RETURN "#TKN_COL"
 WHEN #TKN_NEWLINE:RETURN "#TKN_NEWLINE"
 WHEN #TKN_:RETURN "#TKN_"
 WHEN #TKN_:RETURN "#TKN_"
 WHEN #TKN_:RETURN "#TKN_"
 WHEN #TKN_EOF:RETURN "#TKN_EOF"
 OTHERWISE
  RETURN STR$(T)
 ENDCASE
END
VAR LEXER_TKN
VAR LEXER_EOF
DEF INIT_LEXER IN$
 LEXER_I=0
 LEXER_EOF=#FALSE
 LEXER_IN$=IN$
END
DEF EMPTY OUT A
 RETURN A
END
DEF IS_NUM(C)
 RETURN C>=48&&C<=57
END
DEF IS_ALPHA(C)
 RETURN (C>=65&&C<=90)||(C>=97&&C<=122)
END
DEF TO_UPPER$(S$)
 VAR I
 VAR NS$=COPY(S$)
 FOR I=0TO LAST(S$)
  VAR C=ASC(S$[I])
  IF C>=97&&C<=122THEN
   NS$[I]=CHR$(C-97+65)
  ENDIF
 NEXT
 RETURN NS$
END
DEF LEX_CUR OUT T,V
 T=LEXER_TKN
 V=LEXER_VAL
END
DEF LEX_NEXT OUT T,V
 LEX_NEXT_IMPL
 LEX_CUR OUT T,V
 '?TKN_STR$(T)
 '??V
END
DEF LEX_NEXT_IMPL
 VAR C$,C
 LEXER_TKN=#TKN_NONE
 LEXER_VAL=EMPTY()
 FOR LEXER_I=LEXER_I TO LAST(LEXER_IN$)
  C$=LEXER_IN$[LEXER_I]
  C=ASC(C$)
  IF C==13||C==10THEN
   LEXER_TKN=#TKN_NEWLINE
   CONTINUE
  ENDIF
  IF C==32||C==9THEN
   CONTINUE
  ENDIF
  BREAK
 NEXT
 IF LEXER_I>=LEN(LEXER_IN$)THEN
  LEXER_TKN=#TKN_EOF
  RETURN
 ENDIF
 CASE C$
 WHEN "+"
  INC LEXER_I
  LEXER_TKN=#TKN_PLUS
 WHEN "-"
  INC LEXER_I
  LEXER_TKN=#TKN_MINUS
 WHEN "*"
  INC LEXER_I
  LEXER_TKN=#TKN_MUL
 WHEN "/"
  INC LEXER_I
  LEXER_TKN=#TKN_DIV
 WHEN ","
  INC LEXER_I
  LEXER_TKN=#TKN_COMMA
 WHEN "("
  INC LEXER_I
  LEXER_TKN=#TKN_LP
 WHEN ")"
  INC LEXER_I
  LEXER_TKN=#TKN_RP
 WHEN "["
  INC LEXER_I
  LEXER_TKN=#TKN_LB
 WHEN "]"
  INC LEXER_I
  LEXER_TKN=#TKN_RB
 WHEN ";"
  INC LEXER_I
  LEXER_TKN=#TKN_SEMI
 WHEN ":"
  INC LEXER_I
  LEXER_TKN=#TKN_COL
 WHEN "?"
  INC LEXER_I
  LEXER_TKN=#TKN_PRINT
 ENDCASE
 IF LEXER_TKN!=#TKN_NONE THEN
  RETURN
 ENDIF
 VAR SI=LEXER_I
 IF IS_NUM(C) THEN
  'n.nEn
  VAR HAS_POINT,HAS_EXP
  FOR LEXER_I=LEXER_I TO LAST(LEXER_IN$)
   C$=LEXER_IN$[LEXER_I]
   C=ASC(C$)
   IF!HAS_EXP&&!HAS_POINT&&C$=="."THEN
    HAS_POINT=#TRUE
    CONTINUE
   ENDIF
   IF !HAS_EXP&&C$=="E"||C$=="e"THEN
    HAS_EXP=#TRUE
    CONTINUE
   ENDIF
   IF IS_NUM(C)THEN
    CONTINUE
   ENDIF
   BREAK
  NEXT
  LEXER_TKN=#TKN_NUM
  LEXER_VAL=VAL(MID$(LEXER_IN$,SI,LEXER_I-SI))
  RETURN
 ELSEIF IS_ALPHA(C)||C$=="_"THEN
  FOR LEXER_I=LEXER_I TO LAST(LEXER_IN$)
   C$=LEXER_IN$[LEXER_I]
   C=ASC(C$)
   IF IS_ALPHA(C)||C$=="_"||IS_NUM(C)THEN
    CONTINUE
   ENDIF
   BREAK
  NEXT
  LEXER_VAL=MID$(LEXER_IN$,SI,LEXER_I-SI)
  LEXER_TKN=LEX_RECOG_IDEN(LEXER_VAL)
  RETURN
 ENDIF
 ?"Synt
 STOP
END
DEF LEX_RECOG_IDEN(V)
 CASE TO_UPPER$(V)
 WHEN "PRINT"
  RETURN #TKN_PRINT
 WHEN "DIV"
  RETURN #TKN_DIVINT
 OTHERWISE
  RETURN #TKN_IDEN
 ENDCASE
END

ENUM\
 #VMT_DEFAULT,\
 #VMT_INT,\
 #VMT_REAL,\
 #VMT_STR,\
 #VMT_LAST
ENUM\
 #VM_NOP,\
 #VM_PUSHINT,\
 #VM_PUSHDBL,\
 #VM_PUSHSTR,\
 #VM_BINOP,\
 #VM_PRINT_E,\
 #VM_PRINT,\
 #VM_PRINT_COMMA,\
 #VM_PRINT_SEMI,\
 #VM_,\
 #VM_LAST



DEF PARSE
 LOOP
  VAR T,V
  LEX_NEXT OUT T,V
  IF T==#TKN_EOF THEN RETURN
  PARSE_STATEMENT
 ENDLOOP
END
DEF PARSE_STATEMENT
 VAR T,V
 LEX_CUR OUT T,V
 CASE T
 WHEN #TKN_PRINT
  PARSE_PRINT
 WHEN #TKN_EOF
 WHEN #TKN_NEWLINE
  RETURN
 OTHERWISE
  SYNTAX_ERROR
 ENDCASE
END
DEF IS_EXPR_TKN(T)
 CASE T
 WHEN #TKN_NUM
 WHEN #TKN_STR
 WHEN #TKN_IDEN
 WHEN #TKN_LP
 WHEN #TKN_MINUS
  RETURN #TRUE
 ENDCASE
 RETURN #FALSE
END
DEF PARSE_PRINT
 VAR T,V
 LEX_NEXT OUT T,V
 IF !IS_EXPR_TKN(T)THEN
  ?"PRINT_E"
   EMIT_PRINT_E
  RETURN
 ENDIF
 WHILE 1
  PARSE_EXPR
  LEX_CUR OUT T,V
  IF T==#TKN_COMMA THEN
   ?"PRINT_COMMA"
   EMIT_PRINT_COMMA
  ELSEIF T==#TKN_SEMI THEN
   ?"PRINT_SEMI"
   EMIT_PRINT_SEMI
  ELSE
   ?"PRINT"
   EMIT_PRINT
  ENDIF
  LEX_NEXT OUT T,V
  IF !IS_EXPR_TKN(T)THEN
   RETURN
  ENDIF
 WEND
END
DEF PARSE_TERM
 VAR T,V
 LEX_CUR OUT T,V
 CASE T
 WHEN #TKN_MINUS
  PARSE_TERM
  ?"MINUS UNARY"
 'FIXME:EXPND CONST EXPR
 WHEN #TKN_NUM
  ?"IMM",V
  IF TYPEOF(V)==#T_INT THEN
   EMIT_PUSHINT V
  ELSEIF TYPEOF(V)==#T_REAL THEN
   EMIT_PUSHDBL V
  ELSE
   STOP
  ENDIF
 WHEN #TKN_STR
  ?"IMM",V
  EMIT_PUSHSTR V
 OTHERWISE
  SYNTAX_ERROR
 ENDCASE
 LEX_NEXT OUT T,V
END
ENUM\
 #OPRANK_NOTANOP,\
 #OPRANK_MIN,\
 #OPRANK_PARENT,\
 #OPRANK_MUL,\
 #OPRANK_PLUS,\
 #OPRANK_SHIFT,\
 #OPRANK_EQ,\
 #OPRANK_BIT,\
 #OPRANK_LOG,\
 #OPRANK_MAX
DEF GET_OP_RANK(T)
 CASE T
 WHEN #TKN_LP
 WHEN #TKN_LB
  RETURN #OPRANK_PARENT
 WHEN #TKN_MUL
 WHEN #TKN_DIV
 WHEN #TKN_DIVINT
 WHEN #TKN_MOD
  RETURN #OPRANK_MUL
 WHEN #TKN_PLUS
 WHEN #TKN_MINUS
  RETURN #OPRANK_PLUS
 WHEN #TKN_LSHIFT
 WHEN #TKN_RSHIFT
  RETURN #OPRANK_SHIFT
 WHEN #TKN_EQ
 WHEN #TKN_NEQ
 WHEN #TKN_LESS
 WHEN #TKN_LEQ
 WHEN #TKN_GREAT
 WHEN #TKN_GEQ
  RETURN #OPRANK_EQ
 WHEN #TKN_AND
 WHEN #TKN_OR
 WHEN #TKN_XOR
  RETURN #OPRANK_BIT
 WHEN #TKN_LAND
 WHEN #TKN_LOR
  RETURN #OPRANK_LOG
 ENDCASE
 RETURN #OPRANK_NOTANOP
END
DEF PARSE_EXPR2
 VAR T,V
 PARSE_TERM
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_MUL||T==#TKN_DIV||T==#TKN_DIVINT THEN
   LEX_NEXT OUT ,
   PARSE_TERM
   ?"BINARY OP",TKN_STR$(T)
   EMIT_BINOP T
   CONTINUE
  ENDIF
  BREAK
 ENDLOOP
END
DEF PARSE_EXPR
 PARSE_EXPR0 #OPRANK_MAX
END
DEF PARSE_EXPR0 RANK
 IF RANK==#OPRANK_MIN THEN
  PARSE_TERM
  RETURN
 ENDIF
 VAR T,V
 PARSE_EXPR0 RANK-1
 LOOP
  LEX_CUR OUT T,V
  IF GET_OP_RANK(T)==RANK THEN
   LEX_NEXT OUT ,
   PARSE_EXPR0 RANK-1
   ?"BINARY OP",TKN_STR$(T)
   EMIT_BINOP T
   CONTINUE
  ENDIF
  BREAK
 ENDLOOP
END
DEF PARSE_EXPR1
 VAR T,V
 PARSE_EXPR2
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_PLUS||T==#TKN_MINUS THEN
   LEX_NEXT OUT ,
   PARSE_EXPR2
   ?"BINARY OP",TKN_STR$(T)
   EMIT_BINOP T
   CONTINUE
  ENDIF
  BREAK
 ENDLOOP
END
DIM VM_OPS[]
DIM VM_IMM#[]
DIM VM_IMM$[]

DIM VM_STK_TYP[]
DIM VM_STK%[]
DIM VM_STK#[]
DIM VM_STK$[]
VAR VM_STK_SIZE
VAR VM_SP
VAR VM_BP
DEF INIT_VM
 VM_OPS=ARRAY%(0)
 VM_IMM#=ARRAY#(0)
 VM_IMM$=ARRAY$(0)
 VM_STK_SIZE=65536
 VM_STK_TYP=ARRAY%(VM_STK_SIZE)
 VM_STK%=ARRAY%(VM_STK_SIZE)
 VM_STK#=ARRAY#(VM_STK_SIZE)
 VM_STK$=ARRAY$(VM_STK_SIZE)
END
DEF EMIT_PUSHINT V
 PUSH VM_OPS,#VM_PUSHINT
 PUSH VM_OPS,V
END
DEF VM_ADDIMMDBL(V#)
 PUSH VM_IMM#,V#
 RETURN LAST(VM_IMM#)
END
DEF VM_ADDIMMSTR(V$)
 PUSH VM_IMM$,V$
 RETURN LAST(VM_IMM$)
END
DEF EMIT_PUSHDBL V#
 PUSH VM_OPS,#VM_PUSHDBL
 PUSH VM_OPS,VM_ADDIMMDBL(V#)
END
DEF EMIT_PUSHSTR V$
 PUSH VM_OPS,#VM_PUSHSTR
 PUSH VM_OPS,VM_ADDIMMSTR(V$)
END
DEF EMIT_BINOP TYP
 PUSH VM_OPS,#VM_BINOP
 PUSH VM_OPS,TYP
END
DEF EMIT_PRINT
 PUSH VM_OPS,#VM_PRINT
END
DEF EMIT_PRINT_E
 PUSH VM_OPS,#VM_PRINT_E
END
DEF EMIT_PRINT_COMMA
 PUSH VM_OPS,#VM_PRINT_COMMA
END
DEF EMIT_PRINT_SEMI
 PUSH VM_OPS,#VM_PRINT_COMMA
END
DEF VM_PUSHINT V%
 VM_STK_TYP[VM_SP]=#VMT_INT
 VM_STK%[VM_SP]=V%
 INC VM_SP
END
DEF VM_PUSHDBL V#
 VM_STK_TYP[VM_SP]=#VMT_REAL
 VM_STK#[VM_SP]=V#
 INC VM_SP
END
DEF VM_PUSHSTR V$
 VM_STK_TYP[VM_SP]=#VMT_STR
 VM_STK$[VM_SP]=V$
 INC VM_SP
END
DEF VM_PUSH V
 CASE TYPEOF(V)
 WHEN #T_INT
  VM_STK_TYP[VM_SP]=#VMT_INT
  VM_STK%[VM_SP]=V
 WHEN #T_REAL
  VM_STK_TYP[VM_SP]=#VMT_REAL
  VM_STK#[VM_SP]=V
 WHEN #T_STR
  VM_STK_TYP[VM_SP]=#VMT_STR
  VM_STK$[VM_SP]=V
 OTHERWISE
  STOP
 ENDCASE
 INC VM_SP
END
DEF VM_POP OUT T,V
 DEC VM_SP
 T=VM_STK_TYP[VM_SP]
 CASE T
 WHEN #VMT_INT
  V=VM_STK%[VM_SP]
 WHEN #VMT_REAL
  V=VM_STK#[VM_SP]
 WHEN #VMT_STR
  V=VM_STK$[VM_SP]
 OTHERWISE
  STOP
 ENDCASE
END
DEF VM_BINOP T
 VAR LT,LV
 VAR RT,RV
 VM_POP OUT RT,RV
 VM_POP OUT LT,LV
 CASE T
 WHEN #TKN_PLUS
  VM_PUSH LV+RV
 WHEN #TKN_MINUS
  VM_PUSH LV-RV
 WHEN #TKN_MUL
  VM_PUSH LV*RV
 WHEN #TKN_DIV
  VM_PUSH LV/RV
 WHEN #TKN_DIVINT
  VM_PUSH LV DIV RV
 OTHERWISE
  STOP
 ENDCASE
END
DEF VM_PRINT_E
 ?
END

DEF VM_PRINT
 VAR V
 VM_POP OUT ,V
 ?V
END
DEF VM_PRINT_COMMA
 VAR V
 VM_POP OUT ,V
 ?V,
END
DEF VM_PRINT_SEMI
 VAR V
 VM_POP OUT ,V
 ?V;
END
DEF VM_RUN
 VAR PC
 LOOP
  IF LEN(VM_OPS)<=PC THEN BREAK
  VAR C=VM_OPS[PC]
  INC PC
  CASE C
  WHEN #VM_PUSHINT
   VM_PUSHINT VM_OPS[PC]
   INC PC
  WHEN #VM_PUSHDBL
   VM_PUSHDBL VM_IMM#[VM_OPS[PC]]
   INC PC
  WHEN #VM_PUSHSTR
   VM_PUSHDBL COPY(VM_IMM$[VM_OPS[PC]])
   INC PC
  WHEN #VM_BINOP
   VAR T=VM_OPS[PC]
   INC PC
   VM_BINOP T
  WHEN #VM_PRINT_E
   VM_PRINT_E
  WHEN #VM_PRINT
   VM_PRINT
  WHEN #VM_PRINT_COMMA
   VM_PRINT_COMMA
  WHEN #VM_PRINT_SEMI
   VM_PRINT_SEMI
  ENDCASE
 ENDLOOP
END
