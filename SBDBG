OPTION STRICT
OPTION DEFINT
'SPLAY_TEST
'END
VAR TRACE=#FALSE

'VSLOT_INIT
'VSLOT_TEST
MAIN
END
DEF GET_SLOT$(N)
 PRGEDIT N
 VAR S$=""
 VAR I,L=PRGSIZE(N)
 FOR I=1TO L
  PUSH S$,PRGGET$()
 NEXT
 RETURN S$
END
DEF GET_VSLOT$(N)
 VSLOT_PRGEDIT N,0
 VAR S$=""
 VAR I,L=VSLOT_PRGSIZE(N,0)
 FOR I=1TO L
  PUSH S$,VSLOT_PRGGET$(#TRUE)
 NEXT
 RETURN S$
END
DEF SET_VSLOT N,V$
 VSLOT_PRGEDIT N,1
 VSLOT_PRGDEL -1
 VSLOT_PRGSET V$
END
DEF SET_SLOT N,V$
 PRGEDIT N,1
 PRGDEL -1
 PRGSET V$
END
DEF MAIN
 VAR SW,SH,TS,TS2
 ACLS
 XSCREEN OUT SW,SH
 IF SW!=1280||SH!=720THEN
  XSCREEN 1280,720
 ENDIF
 TSCREEN OUT TS,TS2,,
 IF TS!=16||TS2!=16THEN
  TSCREEN 16
 ENDIF
 VSLOT_INIT
 VAR IN$=GET_SLOT$(1)
 SET_VSLOT 0,IN$
 LOGO
 REPL_MAIN
END
DEF LOGO
 ?"PetitComputer フ゜チコン ver4.0.2
 ?"SMILEBASIC for SMILEBASIC ";FREEMEM();" bytes free"
 ?
 ?"READY"
END
VAR LEXER_IN$
VAR LEXER_I
VAR LEXER_LINE
VAR LEXER_LINE_POS
VAR LEXER_VAL
ENUM\
 #TKN_NONE,\
 #TKN_NUM,\
 #TKN_STR,\
 #TKN_PRINT,\
 #TKN_DEF,\
 #TKN_RETURN,\
 #TKN_IDEN,\
 #TKN_PLUS,\
 #TKN_MINUS,\
 #TKN_MUL,\
 #TKN_DIV,\
 #TKN_DIVINT,\
 #TKN_COMMA,\
 #TKN_LP,\
 #TKN_RP,\
 #TKN_LB,\
 #TKN_RB,\
 #TKN_SEMI,\
 #TKN_COL,\
 #TKN_NEWLINE,\
 #TKN_EOF,\
 #TKN_MOD,\
 #TKN_LSHIFT,\
 #TKN_RSHIFT,\
 #TKN_EQ,\
 #TKN_NEQ,\
 #TKN_LESS,\
 #TKN_LEQ,\
 #TKN_GREAT,\
 #TKN_GEQ,\
 #TKN_AND,\
 #TKN_OR,\
 #TKN_XOR,\
 #TKN_LAND,\
 #TKN_LOR,\
 #TKN_ASSIGN,\
 #TKN_NOT,\
 #TKN_LNOT,\
 #TKN_OUT,\
 #TKN_CALL,\
 #TKN_VAR,\
 #TKN_IF,\
 #TKN_THEN,\
 #TKN_ENDIF,\
 #TKN_ELSE,\
 #TKN_ELSEIF,\
 #TKN_FOR,\
 #TKN_NEXT,\
 #TKN_GOTO,\
 #TKN_GOSUB,\
 #TKN_BREAK,\
 #TKN_CONTINUE,\
 #TKN_WHILE,\
 #TKN_WEND,\
 #TKN_REPEAT,\
 #TKN_UNTIL,\
 #TKN_LOOP,\
 #TKN_ENDLOOP,\
 #TKN_LABEL,\
 #TKN_ON,\
 #TKN_DATA,\
 #TKN_RESTORE,\
 #TKN_CONST,\
 #TKN_ENUM,\
 #TKN_CONSTVAR,\
 #TKN_END,\
 #TKN_TPRINT,\
 #TKN_READ,\
 #TKN_INC,\
 #TKN_DEC,\
 #TKN_CASE,\
 #TKN_WHEN,\
 #TKN_OTHERWISE,\
 #TKN_ENDCASE,\
 #TKN_SWAP,\
 #TKN_COMMON,\
 #TKN_DEFOUT,\
 #TKN_INPUT,\
 #TKN_LINPUT,\
 #TKN_EXEC,\
 #TKN_INSPECT,\
 #TKN_,\
 #TKN_LAST
DEF TKN_STR$(T)
 CASE T
 WHEN #TKN_NONE:RETURN "#TKN_NONE"WHEN #TKN_NUM:RETURN "#TKN_NUM"WHEN #TKN_STR:RETURN "#TKN_STR"WHEN #TKN_PRINT:RETURN "#TKN_PRINT"WHEN #TKN_DEF:RETURN "#TKN_DEF"WHEN #TKN_RETURN:RETURN "#TKN_RETURN"WHEN #TKN_IDEN:RETURN "#TKN_IDEN"WHEN #TKN_PLUS:RETURN "#TKN_PLUS"WHEN #TKN_MINUS:RETURN "#TKN_MINUS"WHEN #TKN_MUL:RETURN "#TKN_MUL"WHEN #TKN_DIV:RETURN "#TKN_DIV"WHEN #TKN_DIVINT:RETURN "#TKN_DIVINT"WHEN #TKN_COMMA:RETURN "#TKN_COMMA"WHEN #TKN_LP:RETURN "#TKN_LP"WHEN #TKN_RP:RETURN "#TKN_RP"WHEN #TKN_LB:RETURN "#TKN_LB"WHEN #TKN_RB:RETURN "#TKN_RB"WHEN #TKN_SEMI:RETURN "#TKN_SEMI"WHEN #TKN_COL:RETURN "#TKN_COL"WHEN #TKN_NEWLINE:RETURN "#TKN_NEWLINE"WHEN #TKN_EOF:RETURN "#TKN_EOF"WHEN #TKN_MOD:RETURN "#TKN_MOD"WHEN #TKN_LSHIFT:RETURN "#TKN_LSHIFT"WHEN #TKN_RSHIFT:RETURN "#TKN_RSHIFT"WHEN #TKN_EQ:RETURN "#TKN_EQ"WHEN #TKN_NEQ:RETURN "#TKN_NEQ"WHEN #TKN_LESS:RETURN "#TKN_LESS"WHEN #TKN_LEQ:RETURN "#TKN_LEQ"WHEN #TKN_GREAT:RETURN "#TKN_GREAT"WHEN #TKN_GEQ:RETURN "#TKN_GEQ"WHEN #TKN_AND:RETURN "#TKN_AND"WHEN #TKN_OR:RETURN "#TKN_OR"WHEN #TKN_XOR:RETURN "#TKN_XOR"WHEN #TKN_LAND:RETURN "#TKN_LAND"WHEN #TKN_LOR:RETURN "#TKN_LOR"WHEN #TKN_ASSIGN:RETURN "#TKN_ASSIGN"WHEN #TKN_NOT:RETURN "#TKN_NOT"WHEN #TKN_LNOT:RETURN "#TKN_LNOT"WHEN #TKN_OUT:RETURN "#TKN_OUT"WHEN #TKN_CALL:RETURN "#TKN_CALL"WHEN #TKN_VAR:RETURN "#TKN_VAR"WHEN #TKN_IF:RETURN "#TKN_IF"WHEN #TKN_THEN:RETURN "#TKN_THEN"WHEN #TKN_ENDIF:RETURN "#TKN_ENDIF"WHEN #TKN_ELSE:RETURN "#TKN_ELSE"WHEN #TKN_ELSEIF:RETURN "#TKN_ELSEIF"WHEN #TKN_FOR:RETURN "#TKN_FOR"WHEN #TKN_NEXT:RETURN "#TKN_NEXT"WHEN #TKN_GOTO:RETURN "#TKN_GOTO"WHEN #TKN_GOSUB:RETURN "#TKN_GOSUB"WHEN #TKN_BREAK:RETURN "#TKN_BREAK"WHEN #TKN_CONTINUE:RETURN "#TKN_CONTINUE"WHEN #TKN_WHILE:RETURN "#TKN_WHILE"WHEN #TKN_WEND:RETURN "#TKN_WEND"WHEN #TKN_REPEAT:RETURN "#TKN_REPEAT"WHEN #TKN_UNTIL:RETURN "#TKN_UNTIL"WHEN #TKN_LOOP:RETURN "#TKN_LOOP"WHEN #TKN_ENDLOOP:RETURN "#TKN_ENDLOOP"WHEN #TKN_LABEL:RETURN "#TKN_LABEL"WHEN #TKN_ON:RETURN "#TKN_ON"WHEN #TKN_DATA:RETURN "#TKN_DATA"WHEN #TKN_RESTORE:RETURN "#TKN_RESTORE"WHEN #TKN_CONST:RETURN "#TKN_CONST"WHEN #TKN_ENUM:RETURN "#TKN_ENUM"WHEN #TKN_CONSTVAR:RETURN "#TKN_CONSTVAR"WHEN #TKN_END:RETURN "#TKN_END"WHEN #TKN_TPRINT:RETURN "#TKN_TPRINT"WHEN #TKN_READ:RETURN "#TKN_READ"WHEN #TKN_INC:RETURN "#TKN_INC"WHEN #TKN_DEC:RETURN "#TKN_DEC"WHEN #TKN_CASE:RETURN "#TKN_CASE"WHEN #TKN_WHEN:RETURN "#TKN_WHEN"WHEN #TKN_OTHERWISE:RETURN "#TKN_OTHERWISE"WHEN #TKN_ENDCASE:RETURN "#TKN_ENDCASE"WHEN #TKN_SWAP:RETURN "#TKN_SWAP"WHEN #TKN_COMMON:RETURN "#TKN_COMMON"WHEN #TKN_DEFOUT:RETURN "#TKN_DEFOUT"WHEN #TKN_INPUT:RETURN "#TKN_INPUT"WHEN #TKN_LINPUT:RETURN "#TKN_LINPUT"WHEN #TKN_EXEC:RETURN "#TKN_EXEC"WHEN #TKN_:RETURN "#TKN_"WHEN #TKN_LAST:RETURN "#TKN_LAST"
 OTHERWISE
  RETURN STR$(T)
 ENDCASE
END
DEF REPL_MAIN
 INIT_VM
 VAR AST
 LOOP
  VAR D$
  LINPUT D$
  INIT_LEXER D$
  VAR T,V
  LEX_NEXT OUT T,V
  IF T==#TKN_IDEN&&V=="RUN"THEN
   LEX_NEXT OUT T,V
   VAR SLOT=0
   IF T==#TKN_EOF THEN
   ELSEIF T==#TKN_NUM THEN
    SLOT=V
   ELSE
    ILLEGAL_FUNCTION_CALL
    CONTINUE
   ENDIF
   VM_RESET
   VAR IN$=GET_VSLOT$(SLOT)
   INIT_LEXER IN$
   INIT_AST
   INIT_PARSER
   AST=PARSE()
   INIT_COMPILER SLOT
   INIT_VM
   COMPILE AST
   LOAD_VM_SLOT SLOT
   VM_RUN_SLOT SLOT
   VM_RUN
  ELSEIF T==#TKN_IDEN&&V=="CONT"THEN
   VM_CONT
  ELSE
   INIT_LEXER D$
   INIT_AST
   INIT_PARSER
   AST=PARSE()
   INIT_COMPILER_REPL
   COMPILE AST
   LOAD_VM_SLOT_REPL
   VM_RUN
  ENDIF
  IF VM_IS_STOPPED()THEN
   ?VM_LASTERR$()
  ENDIF
  ?"OK"
 ENDLOOP
END
VAR LEXER_TKN
VAR LEXER_EOF
DEF INIT_LEXER IN$
 LEXER_I=0
 LEXER_EOF=#FALSE
 LEXER_IN$=IN$
 LEXER_LINE=1
 LEXER_LINE_POS=0
END
DEF EMPTY OUT A
 RETURN A
END
DEF IS_NUM(C)
 RETURN C>=48&&C<=57
END
DEF IS_ALPHA(C)
 RETURN (C>=65&&C<=90)||(C>=97&&C<=122)
END
DEF TO_UPPER$(S$)
 VAR I
 VAR NS$=COPY(S$)
 FOR I=0TO LAST(S$)
  VAR C=ASC(S$[I])
  IF C>=97&&C<=122THEN
   NS$[I]=CHR$(C-97+65)
  ENDIF
 NEXT
 RETURN NS$
END
DEF LEX_CUR OUT T,V
 T=LEXER_TKN
 V=LEXER_VAL
END
DEF LEX_NEXT OUT T,V
 LEX_NEXT_IMPL
 LEX_CUR OUT T,V
 IF TRACE THEN
  ?TKN_STR$(T)
  ??V
 ENDIF
END
DEF LEX_SAVE OUT I,T,V,L,P
 I=LEXER_I
 T=LEXER_TKN
 V=LEXER_VAL
 L=LEXER_LINE
 P=LEXER_LINE_POS
END
DEF LEX_LOAD I,T,V,L,P
 LEXER_I=I
 LEXER_TKN=T
 LEXER_VAL=V
 LEXER_LINE=L
 LEXER_LINE_POS=P
END
DEF IS_VARSUFFIX(C$)
 CASE C$
 WHEN "$":WHEN "#":WHEN "%":RETURN #TRUE
 OTHERWISE RETURN #FALSE
 ENDCASE
END
DEF LEX_NEXT_IMPL
 @LOOP
 VAR C$,C
 LEXER_TKN=#TKN_NONE
 LEXER_VAL=EMPTY()
 FOR LEXER_I=LEXER_I TO LAST(LEXER_IN$)
  C$=LEXER_IN$[LEXER_I]
  C=ASC(C$)
  IF C==13||C==10THEN
   LEXER_TKN=#TKN_NEWLINE
   IF C==10THEN
    INC LEXER_LINE
    LEXER_LINE_POS=LEXER_I+1
   ENDIF
   CONTINUE
  ENDIF
  IF C==32||C==9THEN
   CONTINUE
  ENDIF
  BREAK
 NEXT
 IF LEXER_I>=LEN(LEXER_IN$)THEN
  LEXER_TKN=#TKN_EOF
  RETURN
 ENDIF
 IF LEXER_TKN!=#TKN_NONE THEN
  RETURN
 ENDIF
  VAR N$=MID$(LEXER_IN$,LEXER_I+1,1)
 VAR SI=LEXER_I
 CASE C$
 WHEN "+"
  INC LEXER_I
  LEXER_TKN=#TKN_PLUS
 WHEN "-"
  INC LEXER_I
  LEXER_TKN=#TKN_MINUS
 WHEN "*"
  INC LEXER_I
  LEXER_TKN=#TKN_MUL
 WHEN "/"
  INC LEXER_I
  LEXER_TKN=#TKN_DIV
 WHEN ","
  INC LEXER_I
  LEXER_TKN=#TKN_COMMA
 WHEN "("
  INC LEXER_I
  LEXER_TKN=#TKN_LP
 WHEN ")"
  INC LEXER_I
  LEXER_TKN=#TKN_RP
 WHEN "["
  INC LEXER_I
  LEXER_TKN=#TKN_LB
 WHEN "]"
  INC LEXER_I
  LEXER_TKN=#TKN_RB
 WHEN ";"
  INC LEXER_I
  LEXER_TKN=#TKN_SEMI
 WHEN ":"
  INC LEXER_I
  LEXER_TKN=#TKN_COL
 WHEN "T"
  IF N$=="?"THEN
   INC LEXER_I,2
   LEXER_TKN=#TKN_TPRINT
  ENDIF
 WHEN "?"
  INC LEXER_I
  IF N$=="?"THEN
   INC LEXER_I
   LEXER_TKN=#TKN_INSPECT
  ELSE
   LEXER_TKN=#TKN_PRINT
  ENDIF
 WHEN "!"
  INC LEXER_I
  IF N$=="="THEN
   INC LEXER_I
   LEXER_TKN=#TKN_NEQ
  ELSE
   LEXER_TKN=#TKN_LNOT
  ENDIF
 WHEN "="
  INC LEXER_I
  IF N$=="="THEN
   INC LEXER_I
   LEXER_TKN=#TKN_EQ
  ELSE
   LEXER_TKN=#TKN_ASSIGN
  ENDIF
 WHEN "<"
  INC LEXER_I
  IF N$=="="THEN
   INC LEXER_I
   LEXER_TKN=#TKN_GEQ
  ELSEIF N$=="<"THEN
   INC LEXER_I
   LEXER_TKN=#TKN_LSHIFT
  ELSE
   LEXER_TKN=#TKN_GREAT
  ENDIF
 WHEN ">"
  INC LEXER_I
  IF N$=="="THEN
   INC LEXER_I
   LEXER_TKN=#TKN_LEQ
  ELSEIF N$==">"THEN
   INC LEXER_I
   LEXER_TKN=#TKN_RSHIFT
  ELSE
   LEXER_TKN=#TKN_LESS
  ENDIF
 WHEN "&"
  IF N$=="&"THEN
   INC LEXER_I,2
   LEXER_TKN=#TKN_LAND
  ELSEIF N$=="H"||N$=="h"THEN
   FOR LEXER_I=LEXER_I+2 TO LAST(LEXER_IN$)
    C$=LEXER_IN$[LEXER_I]
    C=ASC(C$)
    IF IS_NUM(C)||(C$>="A"&&C$<="F")||(C$>="a"&&C$<="f")THEN
     CONTINUE
    ENDIF
    BREAK
   NEXT
   LEXER_TKN=#TKN_NUM
   LEXER_VAL=VAL(MID$(LEXER_IN$,SI,LEXER_I-SI))
   RETURN
  ELSEIF N$=="B"||N$=="b"THEN
   FOR LEXER_I=LEXER_I+2 TO LAST(LEXER_IN$)
    C$=LEXER_IN$[LEXER_I]
    IF C$>="0"&&C$<="1"THEN
     CONTINUE
    ENDIF
    BREAK
   NEXT
   LEXER_TKN=#TKN_NUM
   LEXER_VAL=VAL(MID$(LEXER_IN$,SI,LEXER_I-SI))
   RETURN
  ENDIF
 WHEN "|"
  IF N$=="|"THEN
   INC LEXER_I,2
   LEXER_TKN=#TKN_LOR
  ENDIF
 ENDCASE
 IF LEXER_TKN!=#TKN_NONE THEN
  RETURN
 ENDIF
 IF IS_NUM(C) THEN
  'n.nEn
  VAR HAS_POINT,HAS_EXP
  FOR LEXER_I=LEXER_I TO LAST(LEXER_IN$)
   C$=LEXER_IN$[LEXER_I]
   C=ASC(C$)
   IF!HAS_EXP&&!HAS_POINT&&C$=="."THEN
    HAS_POINT=#TRUE
    CONTINUE
   ENDIF
   IF !HAS_EXP&&C$=="E"||C$=="e"THEN
    HAS_EXP=#TRUE
    CONTINUE
   ENDIF
   IF IS_NUM(C)THEN
    CONTINUE
   ENDIF
   BREAK
  NEXT
  LEXER_TKN=#TKN_NUM
  LEXER_VAL=VAL(MID$(LEXER_IN$,SI,LEXER_I-SI))
  RETURN
 ELSEIF C$=="#"||C$=="@"||IS_ALPHA(C)||C$=="_"THEN
  VAR ISLBL=C$=="@"
  VAR ISCNST=C$=="#"
  VAR ADD1=ISLBL||ISCNST
  FOR LEXER_I=LEXER_I+ADD1 TO LAST(LEXER_IN$)
   C$=LEXER_IN$[LEXER_I]
   C=ASC(C$)
   IF IS_ALPHA(C)||C$=="_"||IS_NUM(C)THEN
    CONTINUE
   ENDIF
   BREAK
  NEXT
  IF !ISLBL&&IS_VARSUFFIX(MID$(LEXER_IN$,LEXER_I,1))THEN
   INC LEXER_I
  ENDIF
  LEXER_VAL=MID$(LEXER_IN$,SI,LEXER_I-SI)
  LEXER_VAL=TO_UPPER$(LEXER_VAL)
  IF ISLBL THEN
   LEXER_TKN=#TKN_LABEL
  ELSEIF ISCNST THEN
   LEXER_TKN=#TKN_CONSTVAR
  ELSE
   LEXER_TKN=LEX_RECOG_IDEN(LEXER_VAL)
  ENDIF
  RETURN
 ELSEIF C==34 THEN'STRING
  LEXER_VAL=""
  FOR LEXER_I=LEXER_I+1 TO LAST(LEXER_IN$)
   C$=LEXER_IN$[LEXER_I]
   C=ASC(C$)
   IF C==34||C==10||C==13 THEN
    IF C==34 THEN INC LEXER_I
    BREAK
   ENDIF
   PUSH LEXER_VAL,C$
  NEXT
  LEXER_TKN=#TKN_STR
  RETURN
 ELSEIF C$=="'"THEN
  FOR LEXER_I=LEXER_I+1 TO LAST(LEXER_IN$)
   C$=LEXER_IN$[LEXER_I]
   C=ASC(C$)
   IF C==10 THEN BREAK
   IF C==13 THEN BREAK
  NEXT
  GOTO @LOOP
 ELSEIF C$=="\"THEN
  IF ASC(N$)==10||ASC(N$)==13 THEN
   IF ASC(N$)==10 THEN
    INC LEXER_LINE
   ENDIF
   LEXER_LINE_POS=LEXER_I+2
   INC LEXER_I,2
   GOTO @LOOP
  ENDIF
 ENDIF
 ?"Synt
 STOP
END
DEF LEX_RECOG_IDEN(V)
 CASE V
 WHEN "PRINT"
  RETURN #TKN_PRINT
 WHEN "DIV"
  RETURN #TKN_DIVINT
 WHEN "MOD"
  RETURN #TKN_MOD
 WHEN "AND"
  RETURN #TKN_AND
 WHEN "OR"
  RETURN #TKN_OR
 WHEN "XOR"
  RETURN #TKN_XOR
 WHEN "NOT"
  RETURN #TKN_NOT
 WHEN "OUT"
  RETURN #TKN_OUT
 WHEN "CALL"
  RETURN #TKN_CALL
 WHEN "DIM"
 WHEN "VAR"
  RETURN #TKN_VAR
 WHEN "IF"
  RETURN #TKN_IF
 WHEN "THEN"
  RETURN #TKN_THEN
 WHEN "ENDIF"
  RETURN #TKN_ENDIF
 WHEN "ELSE"
  RETURN #TKN_ELSE
 WHEN "ELSEIF"
  RETURN #TKN_ELSEIF
 WHEN "FOR"
  RETURN #TKN_FOR
 WHEN "NEXT"
  RETURN #TKN_NEXT
 WHEN "GOTO"
  RETURN #TKN_GOTO
 WHEN "GOSUB"
  RETURN #TKN_GOSUB
 WHEN "BREAK"
  RETURN #TKN_BREAK
 WHEN "CONTINUE"
  RETURN #TKN_CONTINUE
 WHEN "REPEAT"
  RETURN #TKN_REPEAT
 WHEN "UNTIL"
  RETURN #TKN_UNTIL
 WHEN "WHILE"
  RETURN #TKN_WHILE
 WHEN "WEND"
  RETURN #TKN_WEND
 WHEN "REPEAT"
  RETURN #TKN_REPEAT
 WHEN "UNTIL"
  RETURN #TKN_UNTIL
 WHEN "LOOP"
  RETURN #TKN_LOOP
 WHEN "ENDLOOP"
  RETURN #TKN_ENDLOOP
 WHEN "RETURN"
  RETURN #TKN_RETURN
 WHEN "DATA"
  RETURN #TKN_DATA
 WHEN "RESTORE"
  RETURN #TKN_RESTORE
 WHEN "CONST"
  RETURN #TKN_CONST
 WHEN "ENUM"
  RETURN #TKN_ENUM
 WHEN "DEF"
  RETURN #TKN_DEF
 WHEN "END"
  RETURN #TKN_END
 WHEN "TPRINT"
  RETURN #TKN_TPRINT
 WHEN "READ"
  RETURN #TKN_READ
 WHEN "INC"
  RETURN #TKN_INC
 WHEN "DEC"
  RETURN #TKN_DEC
 WHEN "ON"
  RETURN #TKN_ON
 WHEN "CASE"
  RETURN #TKN_CASE
 WHEN "WHEN"
  RETURN #TKN_WHEN
 WHEN "OTHERWISE"
  RETURN #TKN_OTHERWISE
 WHEN "ENDCASE"
  RETURN #TKN_ENDCASE
 WHEN "SWAP"
  RETURN #TKN_SWAP
 WHEN "COMMON"
  RETURN #TKN_COMMON
 WHEN "DEFOUT"
  RETURN #TKN_DEFOUT
 WHEN "INPUT"
  RETURN #TKN_INPUT
 WHEN "LINPUT"
  RETURN #TKN_LINPUT
 WHEN "EXEC"
  RETURN #TKN_EXEC
 OTHERWISE
  RETURN #TKN_IDEN
 ENDCASE
END



DIM AST_TYP[]
DIM AST%[]
DIM AST#[]
DIM AST$[]
DIM AST_LEFT[]
DIM AST_RIGHT[]
DIM AST_NEXT[]
DIM AST_PREV[]
DIM AST_A1[]
DIM AST_A2[]
DIM AST_A3[]
DIM AST_A4[]
DIM AST_A5[]
DIM AST_LINE[]
DIM AST_POS[]
DEF INIT_AST
 VAR S=1
 AST_TYP=ARRAY%(S)
 AST%=ARRAY%(S)
 AST#=ARRAY#(S)
 AST$=ARRAY$(S)
 AST_LEFT=ARRAY%(S)
 AST_NEXT=ARRAY%(S)
 AST_RIGHT=ARRAY%(S)
 AST_PREV=ARRAY%(S)
 AST_A1=ARRAY%(S)
 AST_A2=ARRAY%(S)
 AST_A3=ARRAY%(S)
 AST_A4=ARRAY%(S)
 AST_A5=ARRAY%(S)
 AST_LINE=ARRAY%(S)
 AST_POS=ARRAY%(S)
END

'BINOP:AST%-TKN
ENUM\
 #AST_ITEM,\
 #AST_BINOP,\
 #AST_UNAOP,\
 #AST_PRINT,\
 #AST_IMM_INT,\
 #AST_IMM_DBL,\
 #AST_IMM_STR,\
 #AST_STATEMENTS,\
 #AST_PRINT_EXPR_NEWLINE,\
 #AST_PRINT_EXPR_COMMA,\
 #AST_PRINT_EXPR_SEMI,\
 #AST_ASSIGN,\
 #AST_VAR,\
 #AST_IF,\
 #AST_FOR,\
 #AST_BREAK,\
 #AST_CONTINUE,\
 #AST_WHILE,\
 #AST_REPEAT,\
 #AST_LOOP,\
 #AST_LABEL,\
 #AST_GOTO,\
 #AST_GOSUB,\
 #AST_GOTOEXPR,\
 #AST_GOSUBEXPR,\
 #AST_ONGOTO,\
 #AST_ONGOSUB,\
 #AST_ONBREAKGOTO,\
 #AST_ONBREAKGOTOEXPR,\
 #AST_RETURN,\
 #AST_RETURNFUNC,\
 #AST_CALLFUNC,\
 #AST_CALLFUNCEXPR,\
 #AST_OPTIONSTRICT,\
 #AST_OPTIONDEFINT,\
 #AST_RESTORE,\
 #AST_RESTOREEXPR,\
 #AST_DATA,\
 #AST_CONST,\
 #AST_ENUM,\
 #AST_CONSTVAR,\
 #AST_CALLSPRITE,\
 #AST_CALLTEXT,\
 #AST_ARRAYEXPR,\
 #AST_DEF,\
 #AST_END,\
 #AST_TPRINT,\
 #AST_EMPTYEXPR,\
 #AST_DEFVAR,\
 #AST_READ,\
 #AST_DEC,\
 #AST_INC,\
 #AST_CASE,\
 #AST_SWAP,\
 #AST_INPUT,\
 #AST_LINPUT,\
 #AST_DEFOUT,\
 #AST_EXEC,\
 #AST_STOP,\
 #AST_,\
 #AST_LAST
DEF AST_STR$(TYP)
 CASE TYP
WHEN #AST_ITEM:RETURN "#AST_ITEM"WHEN #AST_BINOP:RETURN "#AST_BINOP"WHEN #AST_UNAOP:RETURN "#AST_UNAOP"WHEN #AST_PRINT:RETURN "#AST_PRINT"WHEN #AST_IMM_INT:RETURN "#AST_IMM_INT"WHEN #AST_IMM_DBL:RETURN "#AST_IMM_DBL"WHEN #AST_IMM_STR:RETURN "#AST_IMM_STR"WHEN #AST_STATEMENTS:RETURN "#AST_STATEMENTS"WHEN #AST_PRINT_EXPR_NEWLINE:RETURN "#AST_PRINT_EXPR_NEWLINE"WHEN #AST_PRINT_EXPR_COMMA:RETURN "#AST_PRINT_EXPR_COMMA"WHEN #AST_PRINT_EXPR_SEMI:RETURN "#AST_PRINT_EXPR_SEMI"WHEN #AST_ASSIGN:RETURN "#AST_ASSIGN"WHEN #AST_VAR:RETURN "#AST_VAR"WHEN #AST_IF:RETURN "#AST_IF"WHEN #AST_FOR:RETURN "#AST_FOR"WHEN #AST_BREAK:RETURN "#AST_BREAK"WHEN #AST_CONTINUE:RETURN "#AST_CONTINUE"WHEN #AST_WHILE:RETURN "#AST_WHILE"WHEN #AST_REPEAT:RETURN "#AST_REPEAT"WHEN #AST_LOOP:RETURN "#AST_LOOP"WHEN #AST_LABEL:RETURN "#AST_LABEL"WHEN #AST_GOTO:RETURN "#AST_GOTO"WHEN #AST_GOSUB:RETURN "#AST_GOSUB"WHEN #AST_GOTOEXPR:RETURN "#AST_GOTOEXPR"WHEN #AST_GOSUBEXPR:RETURN "#AST_GOSUBEXPR"WHEN #AST_ONGOTO:RETURN "#AST_ONGOTO"WHEN #AST_ONGOSUB:RETURN "#AST_ONGOSUB"WHEN #AST_ONBREAKGOTO:RETURN "#AST_ONBREAKGOTO"WHEN #AST_ONBREAKGOTOEXPR:RETURN "#AST_ONBREAKGOTOEXPR"WHEN #AST_RETURN:RETURN "#AST_RETURN"WHEN #AST_RETURNFUNC:RETURN "#AST_RETURNFUNC"WHEN #AST_CALLFUNC:RETURN "#AST_CALLFUNC"WHEN #AST_CALLFUNCEXPR:RETURN "#AST_CALLFUNCEXPR"WHEN #AST_OPTIONSTRICT:RETURN "#AST_OPTIONSTRICT"WHEN #AST_OPTIONDEFINT:RETURN "#AST_OPTIONDEFINT"WHEN #AST_RESTORE:RETURN "#AST_RESTORE"WHEN #AST_RESTOREEXPR:RETURN "#AST_RESTOREEXPR"WHEN #AST_DATA:RETURN "#AST_DATA"WHEN #AST_CONST:RETURN "#AST_CONST"WHEN #AST_ENUM:RETURN "#AST_ENUM"WHEN #AST_CONSTVAR:RETURN "#AST_CONSTVAR"WHEN #AST_CALLSPRITE:RETURN "#AST_CALLSPRITE"WHEN #AST_CALLTEXT:RETURN "#AST_CALLTEXT"WHEN #AST_ARRAYEXPR:RETURN "#AST_ARRAYEXPR"WHEN #AST_DEF:RETURN "#AST_DEF"WHEN #AST_END:RETURN "#AST_END"WHEN #AST_TPRINT:RETURN "#AST_TPRINT"WHEN #AST_EMPTYEXPR:RETURN "#AST_EMPTYEXPR"WHEN #AST_DEFVAR:RETURN "#AST_DEFVAR"WHEN #AST_READ:RETURN "#AST_READ"WHEN #AST_DEC:RETURN "#AST_DEC"WHEN #AST_INC:RETURN "#AST_INC"WHEN #AST_:RETURN "#AST_"
 OTHERWISE
  RETURN "#AST"+STR$(TYP)
 ENDCASE
END
DEF NEW_AST(TYP)
 PUSH AST_TYP,TYP
 VAR E$
 PUSH AST%,0
 PUSH AST#,0
 PUSH AST$,E$
 PUSH AST_LEFT,0
 PUSH AST_RIGHT,0
 PUSH AST_NEXT,0
 PUSH AST_PREV,0
 PUSH AST_A1,0
 PUSH AST_A2,0
 PUSH AST_A3,0
 PUSH AST_A4,0
 PUSH AST_A5,0
 PUSH AST_LINE,LEXER_LINE
 PUSH AST_POS,LEXER_I-LEXER_LINE_POS
 RETURN LAST(AST_TYP)
END

DEF NEW_AST_LR(TYP,L,R)
 VAR A=NEW_AST(TYP)
 AST_LEFT[A]=L
 AST_RIGHT[A]=R
 RETURN A
END

DEF NEW_AST_APPEND(TYP,PREV)
 VAR A=NEW_AST(TYP)
 AST_PREV[A]=PREV
 AST_NEXT[PREV]=LAST(AST_TYP)
 RETURN LAST(AST_TYP)
END

DEF NEW_AST_INT(TYP,V%)
 VAR A=NEW_AST(TYP)
 AST%[A]=V%
 RETURN A
END

DEF NEW_AST_DBL(TYP,V#)
 VAR A=NEW_AST(TYP)
 AST#[A]=V#
 RETURN A
END
DEF NEW_AST_STR(TYP,V$)
 VAR A=NEW_AST(TYP)
 AST$[A]=V$
 RETURN A
END

DEF NEW_AST_IMM(V)
 VAR A
 CASE TYPEOF(V)
 WHEN #T_INT
  A=NEW_AST_INT(#AST_IMM_INT,V)
 WHEN #T_REAL
  A=NEW_AST_DBL(#AST_IMM_DBL,V)
 WHEN #T_STR
  A=NEW_AST_STR(#AST_IMM_STR,V)
 OTHERWISE
  STOP
 ENDCASE
 RETURN A
END
VAR AST_DUMPAST_END
DEF AST_IND IND
 VAR Y,H
 LOCATE OUT ,Y
 TSCREEN OUT ,,,H
 IF 0&&Y>=H-2 THEN
  LOOP
   VAR K$=INKEY$()
   IF LEN(K$)THEN
    IF K$=="A" THEN
     AST_DUMPAST_END=#TRUE
     BREAK
    ENDIF
    CLS
    BREAK
   ENDIF
   VSYNC
  ENDLOOP
 ENDIF
 ?" "*IND;
END
DEF DUMP_AST A,IND
 IF IND==0 THEN AST_DUMPAST_END=#FALSE
 IF!A THEN RETURN
 IF AST_DUMPAST_END THEN RETURN
 VAR I,J
 CASE AST_TYP[A]
 WHEN #AST_STATEMENTS
  AST_IND IND:?"STATEMENTS"
  I=AST_NEXT[AST_LEFT[A]]
  WHILE I
   IF!I THEN BREAK
   DUMP_AST AST_LEFT[I],IND+1
   I=AST_NEXT[I]
  WEND
 WHEN #AST_TPRINT
 WHEN #AST_PRINT
  VAR P$="PRINT"
  IF AST_TYP[A]==#AST_TPRINT THEN P$="TPRINT"
  AST_IND IND:?P$
  INC IND
  I=AST_NEXT[AST_LEFT[A]]
  WHILE I
   IF!I THEN BREAK
   CASE AST_TYP[I]
   WHEN #AST_PRINT_EXPR_COMMA
    AST_IND IND:?P$;" COMMA"
   WHEN #AST_PRINT_EXPR_NEWLINE
    AST_IND IND:?P$;" NEWLINE"
   WHEN #AST_PRINT_EXPR_SEMI
    AST_IND IND:?P$;" SEMI"
   ENDCASE
   DUMP_AST AST_LEFT[I],IND+1
   I=AST_NEXT[I]
  WEND
 WHEN #AST_IF
  AST_IND IND:?"IF"
  INC IND
  AST_IND IND:?"IF EXPR"
  DUMP_AST AST_A1[A],IND+1
  AST_IND IND:?"IF THEN STATEMENTS"
  DUMP_AST AST_A2[A],IND+1
  IF AST_A3[A] THEN
   I=AST_NEXT[AST_A3[A]]
   WHILE I
    AST_IND IND:?"IF ELSEIF EXPR[";J;"]"
    DUMP_AST AST_A1[I],IND+1
    AST_IND IND:?"IF ELSEIF STATEMENTS[";J;"]"
    DUMP_AST AST_A2[I],IND+1
    INC J
    I=AST_NEXT[I]
   WEND
  ENDIF
  AST_IND IND:?"IF ELSE STATEMENTS"
  DUMP_AST AST_A4[A],IND+1
 WHEN #AST_ASSIGN
  AST_IND IND:?"ASSIGN"
  DUMP_AST AST_LEFT[A],IND+1
  DUMP_AST AST_RIGHT[A],IND+1
 WHEN #AST_FOR
  AST_IND IND:?"FOR"
  DUMP_AST AST_A1[A],IND+1
  DUMP_AST AST_A2[A],IND+1
  DUMP_AST AST_A3[A],IND+1
  DUMP_AST AST_A4[A],IND+1
  DUMP_AST AST_A5[A],IND+1
 WHEN #AST_BINOP
  AST_IND IND:?"BINOP ";TKN_STR$(AST%[A])
  DUMP_AST AST_LEFT[A],IND+1
  DUMP_AST AST_RIGHT[A],IND+1
 WHEN #AST_UNAOP
  AST_IND IND:?"UNAOP ";TKN_STR$(AST%[A])
  DUMP_AST AST_LEFT[A],IND+1
 WHEN #AST_IMM_INT
  AST_IND IND:?"INT ";AST%[A]
 WHEN #AST_IMM_DBL
  AST_IND IND:?"DOUBLE ";AST#[A]
 WHEN #AST_IMM_STR
  AST_IND IND:?"STR ";AST$[A]
 WHEN #AST_VAR
  AST_IND IND:?"VAR ";AST$[A]
 WHEN #AST_CONSTVAR
  AST_IND IND:?"CONST ";AST$[A]
 WHEN #AST_EMPTYEXPR
  AST_IND IND:?"EMPTYEXPR"
 WHEN #AST_DEF
 '$:NAME
 'A1:IN LIST
 'A2:OUT LIST
 'A3:STATEMENTS
 'A4:HAS RETURN VALUE
  IF AST_A4[A] THEN
   AST_IND IND:?"DEF(";AST$[A];")"
  ELSE
   AST_IND IND:?"DEF ";AST$[A]
  ENDIF
  AST_IND IND:?"DEF ARGS(IN)"
  I=AST_NEXT[AST_A1[A]]
  WHILE I
   AST_IND IND+1:?AST$[I]
   INC J
   I=AST_NEXT[I]
  WEND
  AST_IND IND:?"DEF ARGS(OUT)"
  I=AST_NEXT[AST_A2[A]]
  WHILE I
   AST_IND IND+1:?AST$[I]
   INC J
   I=AST_NEXT[I]
  WEND
  AST_IND IND:?"DEF STATEMENTS"
  DUMP_AST AST_A3[A],IND+1
 WHEN #AST_CALLFUNC
  I=AST_NEXT[AST_A1[A]]
  AST_IND IND:?"CALLFUNC ";AST$[A]
  INC IND
  AST_IND IND:?"CALLFUNC ARGS(IN)"
  WHILE I
   DUMP_AST AST_A1[I],IND+1
   INC J
   I=AST_NEXT[I]
  WEND
  I=AST_NEXT[AST_A2[A]]
  AST_IND IND:?"CALLFUNC ARGS(OUT)"
  WHILE I
   DUMP_AST AST_A1[I],IND+1
   INC J
   I=AST_NEXT[I]
  WEND
 WHEN #AST_CALLFUNCEXPR
  I=AST_NEXT[AST_A1[A]]
  AST_IND IND:?"CALLFUNCEXPR ";AST$[A]
  WHILE I
   DUMP_AST AST_A1[I],IND+1
   INC J
   I=AST_NEXT[I]
  WEND
 WHEN #AST_LABEL
  AST_IND IND:?"LABEL ";AST$[A]
 WHEN #AST_DATA
  I=AST_NEXT[AST_A1[A]]
  AST_IND IND:?"DATA"
  WHILE I
   DUMP_AST AST_A1[I],IND+1
   INC J
   I=AST_NEXT[I]
  WEND
 WHEN #AST_RETURN
  AST_IND IND:?"RETURN FROM SUBROUTINE"
 WHEN #AST_RETURNFUNC
  AST_IND IND:?"RETURN FROM FUNCTION"
  DUMP_AST AST_LEFT[A],IND+1
 WHEN #AST_OPTIONSTRICT
  AST_IND IND:?"OPTION STRICT"
 WHEN #AST_OPTIONDEFINT
  AST_IND IND:?"OPTION DEFINT"
 WHEN #AST_END
  AST_IND IND:?"END"
 WHEN #AST_CALLSPRITE
  AST_IND IND:?"CALL SPRITE"
 WHEN #AST_CALLTEXT
  AST_IND IND:?"CALL TEXT"
 WHEN #AST_DEFVAR
  AST_IND IND:?"VAR DEFINITION"
  I=AST_NEXT[AST_A1[A]]
  INC IND
  WHILE I
   AST_IND IND:?"VAR DEFINITION ";AST$[I]
   DUMP_AST AST_A1[I],IND+1
   IF AST_A2[I] THEN
    AST_IND IND:?"ARRAY DIMENSIONS ";AST$[I]
    J=AST_NEXT[AST_A2[I]]
    WHILE J
     DUMP_AST AST_A1[J],IND+2
     J=AST_NEXT[J]
    WEND
   ENDIF
   IF AST_A3[I]THEN
    AST_IND IND:?"ARRAY INITIALIZER ";AST$[I]
    J=AST_NEXT[AST_A3[I]]
    WHILE J
     DUMP_AST AST_A1[J],IND+2
     J=AST_NEXT[J]
    WEND
   ENDIF
   I=AST_NEXT[I]
  WEND
 WHEN #AST_CONST
  I=AST_NEXT[AST_A1[A]]
  INC IND
  WHILE I
   AST_IND IND:?"CONSTANT DEFINITION ";AST$[I]
   DUMP_AST AST_A1[I],IND+1
   I=AST_NEXT[I]
  WEND
 WHEN #AST_ENUM
  I=AST_NEXT[AST_A1[A]]
  INC IND
  WHILE I
   AST_IND IND:?"ENUM DEFINITION ";AST$[I]
   DUMP_AST AST_A1[I],IND+1
   I=AST_NEXT[I]
  WEND
 WHEN #AST_WHILE
  AST_IND IND:?"WHILE"
  DUMP_AST AST_A1[A],IND+1
  DUMP_AST AST_A2[A],IND+1
 OTHERWISE
  AST_IND IND:?AST_STR$(AST_TYP[A])
 ENDCASE
END

VAR PARSER_RETURN_EXPR
VAR PARSER_IN_FUNC
VAR PARSER_HAS_ERR
DEF INIT_PARSER
 PARSER_RETURN_EXPR=#FALSE
 PARSER_IN_FUNC=#FALSE
 PARSER_HAS_ERR=#FALSE
END
DEF PARSE()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LEX_NEXT OUT T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_EOF THEN RETURN ROOT
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_STATEMENT()
 LOOP
  VAR T
  LEX_CUR OUT T,
  CASE T
  WHEN #TKN_TPRINT
   RETURN PARSE_PRINT(#TRUE)
  WHEN #TKN_PRINT
   RETURN PARSE_PRINT(#FALSE)
  WHEN #TKN_IDEN
   RETURN PARSE_IDEN()
  WHEN #TKN_IF
   RETURN PARSE_IF()
  WHEN #TKN_FOR
   RETURN PARSE_FOR()
  WHEN #TKN_BREAK
   LEX_NEXT OUT ,
   RETURN NEW_AST(#AST_BREAK)
  WHEN #TKN_CONTINUE
   LEX_NEXT OUT ,
   RETURN NEW_AST(#AST_CONTINUE)
  WHEN #TKN_REPEAT
   RETURN PARSE_REPEAT()
  WHEN #TKN_WHILE
   RETURN PARSE_WHILE()
  WHEN #TKN_LOOP
   RETURN PARSE_LOOP()
  WHEN #TKN_LABEL
   RETURN PARSE_LABEL()
  WHEN #TKN_GOTO
   RETURN PARSE_GOTO()
  WHEN #TKN_GOSUB
   RETURN PARSE_GOSUB()
  WHEN #TKN_ON
   RETURN PARSE_ON()
  WHEN #TKN_RETURN
   RETURN PARSE_RETURN()
  WHEN #TKN_DATA
   RETURN PARSE_DATA()
  WHEN #TKN_RESTORE
   RETURN PARSE_RESTORE()
  WHEN #TKN_VAR
  WHEN #TKN_CONST
  WHEN #TKN_ENUM
   RETURN PARSE_VAR()
  WHEN #TKN_INSPECT
   LEX_NEXT OUT ,
   RETURN PARSE_CALLFUNC("INSPECT",#FALSE)
  WHEN #TKN_CALL
   RETURN PARSE_CALL()
  WHEN #TKN_EXEC
   RETURN PARSE_EXEC()
  WHEN #TKN_DEFOUT
   RETURN PARSE_DEFOUT()
  WHEN #TKN_COMMON
  WHEN #TKN_DEF
   RETURN PARSE_DEF()
  WHEN #TKN_END
   RETURN PARSE_END()
  WHEN #TKN_READ
   RETURN PARSE_READ()
  WHEN #TKN_DEC
  WHEN #TKN_INC
   RETURN PARSE_INC()
  WHEN #TKN_CASE
   RETURN PARSE_CASE()
  WHEN #TKN_SWAP
   RETURN PARSE_SWAP()
  WHEN #TKN_INPUT
   RETURN PARSE_INPUT()
  WHEN #TKN_LINPUT
   RETURN PARSE_LINPUT()
  ENDCASE
  PARSER_SYNTAX_ERROR "(STATEMENT)"
  LEX_NEXT OUT ,
 ENDLOOP
END
DEF PARSE_DEFOUT()
 VAR AST=NEW_AST(#AST_DEFOUT)
 IF!PARSER_IN_FUNC THEN
  CANT_USE_OUTSIDE_DEF "DEFOUT"
 ENDIF
 VAR T,V
 LEX_NEXT OUT ,
 AST_A1[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T!=#TKN_COMMA THEN
  PARSER_SYNTAX_ERROR "EXPECTED ','"
  RETURN AST
 ENDIF
 LEX_NEXT OUT ,
 AST_A2[AST]=PARSE_EXPR()
 RETURN AST
END
DEF PARSE_EXEC()
 VAR AST=NEW_AST(#AST_EXEC)
 VAR T,V
 LEX_NEXT OUT ,
 AST_A1[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T!=#TKN_COMMA THEN
  RETURN AST
 ENDIF
 LEX_NEXT OUT ,
 AST_A2[AST]=PARSE_EXPR()
 RETURN AST
END
DEF PARSE_INPUT()
 VAR AST=NEW_AST(#AST_INPUT)
 VAR T,V
 LEX_NEXT OUT ,
 VAR GUIDE_EXPR=PARSE_EXPR()
 AST_A1[AST]=GUIDE_EXPR
 LEX_CUR OUT T,V
 VAR ITEM=NEW_AST(#AST_ITEM)
 VAR P=ITEM
 VAR FIRST=ITEM
 AST_A2[AST]=ITEM
 IF T==#TKN_SEMI THEN
  AST_A3[AST]=#TRUE
 ELSEIF T==#TKN_COMMA THEN
  AST_A3[AST]=#FALSE
  IF AST_TYP[GUIDE_EXPR]==#AST_IMM_STR THEN
   AST_A1[AST]=0
   ITEM=NEW_AST(#AST_ITEM)
   AST_NEXT[P]=ITEM
   AST_PREV[ITEM]=P
   P=ITEM
   AST_A1[ITEM]=GUIDE_EXPR
  ENDIF
 ELSE
  PARSER_SYNTAX_ERROR "EXPECTED ';' or ','"
  RETURN AST
 ENDIF
 LOOP
  LEX_NEXT OUT ,
  VAR EXPR=PARSE_EXPR()
  ITEM=NEW_AST(#AST_ITEM)
  AST_NEXT[P]=ITEM
  AST_PREV[ITEM]=P
  P=ITEM
  AST_A1[ITEM]=EXPR
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN
   BREAK
  ENDIF
 ENDLOOP
 AST_PREV[FIRST]=P
 RETURN AST
END
DEF PARSE_LINPUT()
 VAR AST=NEW_AST(#AST_LINPUT)
 LEX_NEXT OUT ,
 VAR EXPR=PARSE_EXPR()
 VAR T,V
 LEX_CUR OUT T,V
 IF T==#TKN_SEMI THEN
  LEX_NEXT OUT ,
  AST_A1[AST]=EXPR
  AST_A2[AST]=PARSE_EXPR()
 ELSE
  AST_A1[AST]=EXPR
 ENDIF
 RETURN AST
END
DEF PARSE_SWAP()
 VAR AST=NEW_AST(#AST_SWAP)
 LEX_NEXT OUT ,
 AST_LEFT[AST]=PARSE_EXPR()
 VAR T,V
 LEX_CUR OUT T,V
 IF T!=#TKN_COMMA THEN
  PARSER_SYNTAX_ERROR "EXPECTED ','"
  RETURN AST
 ENDIF
 LEX_NEXT OUT ,
 AST_RIGHT[AST]=PARSE_EXPR()
 RETURN AST
END
DEF PARSE_CASE()
 VAR AST=NEW_AST(#AST_CASE)
 VAR T,V
 LEX_NEXT OUT ,
 AST_A1[AST]=PARSE_EXPR()
 VAR ITEM=NEW_AST(#AST_ITEM)
 VAR P=ITEM
 AST_A2[AST]=ITEM
 VAR HAS_OTHERWISE
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_COL||T==#TKN_NEWLINE THEN
   LEX_NEXT OUT ,
   CONTINUE
  ENDIF
  IF T==#TKN_WHEN THEN
   IF HAS_OTHERWISE THEN
    PARSER_SYNTAX_ERROR "EXPECTED 'ENDCASE', ':' or '\n'"
   ENDIF
   LEX_NEXT OUT ,
   ITEM=NEW_AST(#AST_ITEM)
   AST_NEXT[P]=ITEM
   P=ITEM
   AST_A1[ITEM]=PARSE_EXPR()
   AST_A2[ITEM]=PARSE_WHEN_STATEMENTS()
  ELSEIF T==#TKN_OTHERWISE THEN
   LEX_NEXT OUT ,
   HAS_OTHERWISE=#TRUE
   ITEM=NEW_AST(#AST_ITEM)
   AST_NEXT[P]=ITEM
   P=ITEM
   AST_A2[ITEM]=PARSE_WHEN_STATEMENTS()
  ELSEIF T==#TKN_ENDCASE THEN
   LEX_NEXT OUT ,
   BREAK
  ELSE
   PARSER_SYNTAX_ERROR "EXPECTED 'WHEN', 'OTHERWISE', 'ENDCASE', ':' or '\n'"
  ENDIF
 ENDLOOP
 RETURN AST
END

DEF PARSE_WHEN_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_ENDCASE THEN RETURN ROOT
  IF T==#TKN_WHEN THEN RETURN ROOT
  IF T==#TKN_OTHERWISE THEN RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'WEND', 'ENDCASE' or 'OTHERWISE', but EOF"
   RETURN ROOT
  ENDIF
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_INC()
 VAR T,V,AST
 LEX_CUR OUT T,V
 IF T==#TKN_INC THEN
  AST=NEW_AST(#AST_INC)
 ELSE
  AST=NEW_AST(#AST_DEC)
 ENDIF
 LEX_NEXT OUT ,
 AST_LEFT[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T==#TKN_COMMA THEN
  LEX_NEXT OUT ,
  AST_RIGHT[AST]=PARSE_EXPR()
 ENDIF
 RETURN AST
END
DEF PARSE_READ()
 VAR T,V
 VAR AST=NEW_AST(#AST_READ)
 VAR P=NEW_AST(#AST_ITEM)
 AST_A1[AST]=P
 LOOP
  LEX_NEXT OUT ,
  VAR EXPR=PARSE_EXPR()
  VAR ITEM=NEW_AST(#AST_ITEM)
  AST_A1[ITEM]=EXPR
  AST_NEXT[P]=ITEM
  P=ITEM
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN
   BREAK
  ENDIF
 ENDLOOP
 RETURN AST
END
DEF PARSE_IDEN()
 VAR T,NAME$,V
 LEX_CUR OUT T,NAME$
 IF NAME$=="OPTION"THEN
  RETURN PARSE_OPTION()
 ELSEIF NAME$=="STOP"THEN
  RETURN PARSE_STOP()
 ENDIF
 VAR SI,ST,SV,SL,SP
 LEX_SAVE OUT SI,ST,SV,SL,SP
 VAR EXPR=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T==#TKN_ASSIGN THEN
  RETURN PARSE_ASSIGN(EXPR)
 ELSE
  LEX_LOAD SI,ST,SV,SL,SP
  RETURN PARSE_CALLFUNC(NAME$,#TRUE)
 ENDIF
 'IDEN=EXPR
 'IDEN [EXPR,EXPR...] [OUT REF-EXPR...]
END
DEF PARSE_STOP()
 VAR AST=NEW_AST(#AST_STOP),T,V
 LEX_NEXT OUT T,V
 IF IS_EXPR_TKN(T)THEN
  AST_A1[AST]=PARSE_EXPR()
 ENDIF
 RETURN AST
END
DEF PARSE_OPTION()
 VAR T,V
 LEX_NEXT OUT T,V
 IF T==#TKN_IDEN&&TO_UPPER$(V)=="STRICT"THEN
  LEX_NEXT OUT T,V
  RETURN NEW_AST(#AST_OPTIONSTRICT)
 ELSEIF T==#TKN_IDEN&&TO_UPPER$(V)=="DEFINT"THEN
  LEX_NEXT OUT T,V
  RETURN NEW_AST(#AST_OPTIONDEFINT)
 ENDIF
 PARSER_SYNTAX_ERROR "EXPECTED 'STRICT' or 'DEFINT' (OPTION)"
END
DEF PARSE_RESTORE()
 VAR T,V,AST
 LEX_NEXT OUT T,V
 IF T==#TKN_LABEL THEN
  AST=NEW_AST(#AST_RESTORE)
  AST$[AST]=V
  LEX_NEXT OUT T,V
 ELSEIF IS_EXPR_TKN(T) THEN
  AST=NEW_AST(#AST_RESTOREEXPR)
  AST_LEFT[AST]=PARSE_EXPR()
 ELSE
  AST=NEW_AST(#AST_RESTORE)
 ENDIF
 RETURN AST
END
DEF PARSE_CALL()
 VAR T,V
 LEX_NEXT OUT T,V
 IF T==#TKN_IDEN&&TO_UPPER$(V)=="SPRITE"THEN
  LEX_NEXT OUT T,V
  RETURN NEW_AST(#AST_CALLSPRITE)
 ELSEIF T==#TKN_IDEN&&TO_UPPER$(V)=="TEXT"THEN
  LEX_NEXT OUT T,V
  RETURN NEW_AST(#AST_CALLTEXT)
 ELSE
  RETURN PARSE_CALLFUNC("CALL",#FALSE)
 ENDIF
END
DEF PARSE_CALLFUNC(NAME$,NXT)
 VAR T,V
 VAR AST=NEW_AST(#AST_CALLFUNC)
 'A1:IN ARGS
 'A2:OUT ARGS
 VAR P=NEW_AST(#AST_ITEM)
 AST_A1[AST]=P
 AST$[AST]=NAME$
 VAR FIRST=P
 IF TRACE THEN ?"callfunc",NAME$
 VAR FRST=#TRUE,ITEM
 VAR EXPR
 LOOP
  IF NXT THEN
   LEX_NEXT OUT T,V
  ELSE
   LEX_CUR OUT T,V
   NXT=#TRUE
  ENDIF
  IF T==#TKN_COMMA THEN
   EXPR=NEW_AST(#AST_EMPTYEXPR)
  ELSEIF!IS_EXPR_TKN(T) THEN
   IF !FRST THEN
    EXPR=NEW_AST(#AST_EMPTYEXPR)
    ITEM=NEW_AST(#AST_ITEM)
    AST_PREV[ITEM]=P
    AST_A1[ITEM]=EXPR
    AST_NEXT[P]=ITEM
    P=ITEM
   ENDIF
   BREAK
  ELSE
   EXPR=PARSE_EXPR()
  ENDIF
  FRST=#FALSE
  ITEM=NEW_AST(#AST_ITEM)
  AST_A1[ITEM]=EXPR
  AST_PREV[ITEM]=P
  AST_NEXT[P]=ITEM
  LEX_CUR OUT T,V
  P=ITEM
  IF T!=#TKN_COMMA THEN
   BREAK
  ENDIF
 ENDLOOP
 AST_PREV[FIRST]=P
 IF T!=#TKN_OUT THEN
  RETURN AST
 ENDIF
 P=NEW_AST(#AST_ITEM)
 AST_A2[AST]=P
 FIRST=P
 FRST=#TRUE
 LOOP
  IF NXT THEN
   LEX_NEXT OUT T,V
  ELSE
   LEX_CUR OUT T,V
   NXT=#TRUE
  ENDIF
  IF T==#TKN_COMMA THEN
   EXPR=NEW_AST(#AST_EMPTYEXPR)
  ELSEIF!IS_EXPR_TKN(T) THEN
   IF !FRST THEN
    EXPR=NEW_AST(#AST_EMPTYEXPR)
    ITEM=NEW_AST(#AST_ITEM)
    AST_PREV[ITEM]=P
    AST_A1[ITEM]=EXPR
    AST_NEXT[P]=ITEM
    P=ITEM
   ENDIF
   BREAK
  ELSE
   EXPR=PARSE_EXPR()
  ENDIF
  FRST=#FALSE
  ITEM=NEW_AST(#AST_ITEM)
  AST_A1[ITEM]=EXPR
  AST_PREV[ITEM]=P
  AST_NEXT[P]=ITEM
  LEX_CUR OUT T,V
  P=ITEM
  IF T!=#TKN_COMMA THEN
   BREAK
  ENDIF
 ENDLOOP
 AST_PREV[FIRST]=P
 RETURN AST
END
DEF PARSE_ASSIGN(EXPR)
 LEX_NEXT OUT ,
 VAR AST=NEW_AST(#AST_ASSIGN)
 AST_LEFT[AST]=EXPR
 IF TRACE THEN ?"assign
 AST_RIGHT[AST]=PARSE_EXPR()
 RETURN AST
END
DEF PARSE_IF()
 LEX_NEXT OUT ,
 VAR EXPR=PARSE_EXPR()
 VAR T,V
 LEX_CUR OUT T,V
 CASE T
 WHEN #TKN_GOTO
  RETURN PARSE_MULTILINE_IF(EXPR,#FALSE)
 WHEN #TKN_THEN
  LEX_NEXT OUT T,V
  IF T==#TKN_NEWLINE THEN
   RETURN PARSE_MULTILINE_IF(EXPR,#TRUE)
  ENDIF
  RETURN PARSE_MULTILINE_IF(EXPR,#FALSE)
 OTHERWISE
  PARSER_SYNTAX_ERROR "EXPECTED 'THEN' or 'GOTO'"
 ENDCASE
END
DEF PARSE_MULTILINE_IF(EXPR,MULT)
 VAR AST=NEW_AST(#AST_IF)
 VAR THENSTMTS=PARSE_MULTILINE_IF_STATEMENTS(MULT)
 VAR T,V
 AST_A1[AST]=EXPR
 AST_A2[AST]=THENSTMTS
 LEX_CUR OUT T,V
 LEX_NEXT OUT ,
 IF !MULT&&T==#TKN_NEWLINE THEN
  RETURN AST
 ENDIF
 IF T==#TKN_ENDIF THEN
  RETURN AST
 ENDIF
 IF T==#TKN_ELSE THEN
  AST_A4[AST]=PARSE_MULTILINE_ELSE_STATEMENTS(MULT)
  LEX_NEXT OUT ,
  RETURN AST
 ENDIF
 IF T==#TKN_ELSEIF THEN
  IF !MULT THEN
   LEX_NEXT OUT ,
  ENDIF
  VAR P=NEW_AST(#AST_ITEM)
  AST_A3[AST]=P
  LOOP
   VAR ELIFEXPR=PARSE_EXPR()
   LEX_CUR OUT T,V
   IF T!=#TKN_THEN THEN
    PARSER_SYNTAX_ERROR "EXPECTED 'THEN'"
    RETURN AST
   ENDIF
   LEX_NEXT OUT ,
   VAR ELIFSTMTS=PARSE_MULTILINE_IF_STATEMENTS(MULT)
   VAR ITEM=NEW_AST(#AST_ITEM)
   AST_A1[ITEM]=ELIFEXPR
   AST_A2[ITEM]=ELIFSTMTS
   AST_NEXT[P]=ITEM
   P=ITEM
   LEX_CUR OUT T,V
   LEX_NEXT OUT ,
   IF !MULT&&T==#TKN_NEWLINE THEN
    RETURN AST
   ENDIF
   IF T==#TKN_ENDIF THEN
    RETURN AST
   ENDIF
   IF T==#TKN_ELSE THEN
    AST_A4[AST]=PARSE_MULTILINE_ELSE_STATEMENTS(MULT)
    LEX_NEXT OUT ,
    RETURN AST
   ENDIF
  ENDLOOP
  RETURN AST
 ENDIF
 PARSER_SYNTAX_ERROR "EXPECTED 'ENDIF', 'ELSE' or 'ELSEIF'"
 RETURN AST
END
DEF PARSE_MULTILINE_IF_STATEMENTS(MULT)
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LEX_CUR OUT T,V
 VAR S
 IF !MULT&&T==#TKN_LABEL THEN
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=NEW_AST_STR(#AST_GOTO,V)
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
  LEX_NEXT OUT ,
 ENDIF
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE&&!MULT THEN RETURN ROOT
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_ENDIF THEN RETURN ROOT
  IF T==#TKN_ELSE THEN RETURN ROOT
  IF T==#TKN_ELSEIF THEN RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'ENDIF', 'ELSE' or 'ELSEIF'"
   RETURN ROOT
  ENDIF
  S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_MULTILINE_ELSE_STATEMENTS(MULT)
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 VAR S
 IF !MULT&&T==#TKN_LABEL THEN
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=NEW_AST_STR(#AST_GOTO,V)
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
  LEX_NEXT OUT ,
 ENDIF
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE&&!MULT THEN RETURN ROOT
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_ENDIF THEN RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'ENDIF'"
   RETURN ROOT
  ENDIF
  S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_FOR_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_NEXT THEN RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'NEXT'"
   RETURN ROOT
  ENDIF
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_FOR()
 'A1:INDEXREFEXPR
 'A2:INITEXPR
 'A3:TOEXPR
 'A4:STEPEXPR
 'A5:STATEMENTS
 VAR T,V
 LEX_NEXT OUT ,
 VAR AST=NEW_AST(#AST_FOR)
 'REFEXPR
 AST_A1[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T!=#TKN_ASSIGN THEN
  PARSER_SYNTAX_ERROR "EXPECTED '='"
 ENDIF
 LEX_NEXT OUT ,
 'INITEXPR
 AST_A2[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T!=#TKN_IDEN||V!="TO" THEN
  PARSER_SYNTAX_ERROR "EXPECTED 'TO'"
 ENDIF
 LEX_NEXT OUT ,
 'TOEXPR
 AST_A3[AST]=PARSE_EXPR()
 LEX_CUR OUT T,V
 IF T==#TKN_IDEN&&V=="STEP" THEN
  LEX_NEXT OUT ,
  'STEPEXPR
  AST_A4[AST]=PARSE_EXPR()
 ENDIF
 AST_A5[AST]=PARSE_FOR_STATEMENTS()
 LEX_NEXT OUT T,V
 'NEXT [IDEN]
 'NEXT IDEN1,IDEN2 NOT ALLOWED
 IF T==#TKN_IDEN THEN LEX_NEXT OUT ,
 RETURN AST
END

DEF PARSE_WHILE()
 VAR AST=NEW_AST(#AST_WHILE)
 VAR T,V
 LEX_NEXT OUT ,
 AST_A1[AST]=PARSE_EXPR()
 AST_A2[AST]=PARSE_WHILE_STATEMENTS()
 RETURN AST
END
DEF PARSE_WHILE_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_WEND THEN LEX_NEXT OUT,:RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'WEND'"
   RETURN ROOT
  ENDIF
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END

DEF PARSE_REPEAT()
 VAR AST=NEW_AST(#AST_REPEAT)
 VAR T,V
 LEX_NEXT OUT ,
 AST_A2[AST]=PARSE_REPEAT_STATEMENTS()
 AST_A1[AST]=PARSE_EXPR()
 RETURN AST
END
DEF PARSE_REPEAT_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_UNTIL THEN LEX_NEXT OUT ,:RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'UNTIL'"
   RETURN ROOT
  ENDIF
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_LOOP()
 VAR AST=NEW_AST(#AST_LOOP)
 VAR T,V
 LEX_NEXT OUT ,
 AST_A2[AST]=PARSE_LOOP_STATEMENTS()
 RETURN AST
END
DEF PARSE_LOOP_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_ENDLOOP THEN LEX_NEXT OUT ,:RETURN ROOT
  IF T==#TKN_EOF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'ENDLOOP'"
   RETURN ROOT
  ENDIF
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_LABEL()
 VAR T,V
 LEX_CUR OUT T,V
 LEX_NEXT OUT ,
 VAR AST=NEW_AST(#AST_LABEL)
 AST$[AST]=V
 RETURN AST
END
DEF PARSE_GOTO()
 VAR T,V,AST
 LEX_NEXT OUT T,V
 IF T==#TKN_LABEL THEN
  AST=NEW_AST(#AST_GOTO)
  AST$[AST]=V
  LEX_NEXT OUT T,V
 ELSE
  AST=NEW_AST(#AST_GOTOEXPR)
  AST_LEFT[AST]=PARSE_EXPR()
 ENDIF
 RETURN AST
END
DEF PARSE_GOSUB()
 VAR T,V,AST
 LEX_NEXT OUT T,V
 IF T==#TKN_LABEL THEN
  AST=NEW_AST(#AST_GOSUB)
  AST$[AST]=V
  LEX_NEXT OUT T,V
 ELSE
  AST=NEW_AST(#AST_GOSUBEXPR)
  AST_LEFT[AST]=PARSE_EXPR()
 ENDIF
 RETURN AST
END
DEF PARSE_ON()
 VAR T,V,AST
 LEX_NEXT OUT T,V
 IF T==#TKN_BREAK THEN
  LEX_NEXT OUT T,V
  IF T==#TKN_LABEL THEN
   AST=NEW_AST(#AST_ONBREAKGOTO)
   AST$[AST]=V
  ELSE
   AST=NEW_AST(#AST_ONBREAKGOTOEXPR)
   AST_LEFT[AST]=PARSE_EXPR()
  ENDIF
 ELSE
  VAR EXPR=PARSE_EXPR()
  LEX_CUR OUT T,V
  IF T==#TKN_GOTO THEN
   AST=NEW_AST(#AST_ONGOTO)
  ELSEIF T==#TKN_GOSUB THEN
   AST=NEW_AST(#AST_ONGOSUB)
  ELSE
   PARSER_SYNTAX_ERROR "EXPECTED 'GOTO' or 'GOSUB'(ON GOTO)"
   RETURN AST
  ENDIF
  AST_A1[AST]=EXPR
  VAR P=NEW_AST(#AST_ITEM)
  AST_A2[AST]=P
  LOOP
   LEX_NEXT OUT T,V
   IF T!=#TKN_LABEL THEN
    PARSER_SYNTAX_ERROR "EXPECTED @LABEL(ON GOTO)"
    RETURN AST
   ENDIF
   VAR ITEM=NEW_AST(#AST_ITEM)
   AST$[ITEM]=V
   AST_NEXT[P]=ITEM
   P=ITEM
   LEX_NEXT OUT T,V
   IF T!=#TKN_COMMA THEN BREAK
  ENDLOOP
 ENDIF
 RETURN AST
END
DEF PARSE_RETURN()
 LEX_NEXT OUT ,
 VAR AST
 IF PARSER_IN_FUNC THEN
  AST=NEW_AST(#AST_RETURNFUNC)
 ELSE
  AST=NEW_AST(#AST_RETURN)
 ENDIF
 IF PARSER_RETURN_EXPR THEN
  AST_LEFT[AST]=PARSE_EXPR()
 ENDIF
 RETURN AST
END
DEF PARSE_DATA()
 VAR AST=NEW_AST(#AST_DATA)
 VAR T,V
 VAR P=NEW_AST(#AST_ITEM)
 AST_A1[AST]=P
 LOOP
  LEX_NEXT OUT ,
  VAR EXPR=PARSE_EXPR()
  VAR ITEM=NEW_AST(#AST_ITEM)
  AST_A1[ITEM]=EXPR
  AST_NEXT[P]=ITEM
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN BREAK
  P=ITEM
 ENDLOOP
 RETURN AST
END
DEF PARSE_ARRAY_INDEX()
 VAR T,V
 VAR P=NEW_AST(#AST_ITEM)
 VAR R=P
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_RB THEN
   LEX_NEXT OUT T,V
   BREAK
  ENDIF
  IF TRACE THEN ?"PARSE_ARRAY_INDEX==
  VAR EXPR=PARSE_EXPR()
  IF TRACE THEN ?"PARSE_ARRAY_INDEX==~~
  VAR ITEM=NEW_AST(#AST_ITEM)
  AST_A1[ITEM]=EXPR
  AST_NEXT[P]=ITEM
  AST_PREV[ITEM]=P
  P=ITEM
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN
   IF T==#TKN_RB THEN
    LEX_NEXT OUT T,V
   ELSE
    PARSER_SYNTAX_ERROR "EXPECTED ']'"
   ENDIF
   BREAK
  ENDIF
  LEX_NEXT OUT T,V
 ENDLOOP
 AST_PREV[R]=P
 RETURN R
END
DEF PARSE_VAR()
 VAR T,V
 LEX_CUR OUT T,V
 VAR AST
 VAR VAR_
 VAR CONST_
 CASE T
 WHEN #TKN_VAR
  AST=NEW_AST(#AST_DEFVAR)
  VAR_=#TRUE
 WHEN #TKN_CONST
  AST=NEW_AST(#AST_CONST)
  CONST_=#TRUE
 WHEN #TKN_ENUM
  AST=NEW_AST(#AST_ENUM)
 ENDCASE
 'VAR IDEN[\[EXPR[,EXPR[,EXPR[,EXPR]]]\]](=EXPR|=\[EXPR...\]|)...
 'DIM ARY[N]=[]'TYPEMISMATCH
 VAR P=NEW_AST(#AST_ITEM)
 AST_A1[AST]=P
 VAR HAS
 LOOP
  LEX_NEXT OUT T,V
  IF VAR_&&T!=#TKN_IDEN THEN
   'VAR HA KETSU COMMA OK
   IF HAS THEN
    BREAK
   ENDIF
   PARSER_SYNTAX_ERROR "EXPECTED IDENTIFIER(VAR)"
   RETURN AST
  ENDIF
  HAS=#TRUE
  IF !VAR_&&T!=#TKN_CONSTVAR THEN
   PARSER_SYNTAX_ERROR "EXPECTED IDENTIFIER(CONST/ENUM)"
   RETURN AST
  ENDIF
  VAR ITEM=NEW_AST(#AST_ITEM)
  AST_NEXT[P]=ITEM
  AST$[ITEM]=V
  P=ITEM
  '$:NAME
  'A1:INIT EXPR
  'A2:ARRAY DIM
  'A3:ARRAY INIT LIST
  LEX_NEXT OUT T,V
  IF VAR_&&T==#TKN_LB THEN
   'DEFINE ARRAY
   LEX_NEXT OUT T,V
   AST_A2[ITEM]=PARSE_ARRAY_INDEX()
   IF TRACE THEN ?"END ARRAY INDE INIT"
   LEX_CUR OUT T,V
  ENDIF
  IF T==#TKN_ASSIGN THEN
   LEX_NEXT OUT T,V
   'INIT ARRAY
   IF VAR_&&T==#TKN_LB THEN
    LEX_NEXT OUT T,V
    AST_A3[ITEM]=PARSE_ARRAY_INDEX()
    LEX_CUR OUT T,V
   ELSE
    AST_A1[ITEM]=PARSE_EXPR()
   ENDIF
  ELSEIF CONST_ THEN
   PARSER_SYNTAX_ERROR "EXPECTED '='(CONST)"
  ENDIF
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN
   BREAK
  ENDIF
 ENDLOOP
 RETURN AST
END
DEF PARSE_DEF_ARG$()
 VAR T,V
 VAR VN$
 LEX_CUR OUT T,V
 IF T!=#TKN_IDEN THEN
  PARSER_SYNTAX_ERROR
  RETURN ""
 ENDIF
 VN$=V
 LEX_NEXT OUT T,V
 IF T==#TKN_LB THEN
  LEX_NEXT OUT T,V
  IF T!=#TKN_RB THEN
   PARSER_SYNTAX_ERROR "EXPECTED ']'(DEF ARGUMENT)"
  ENDIF
  LEX_NEXT OUT T,V
 ENDIF
 RETURN VN$
END
DEF PARSE_DEF_LIST()
 VAR T,V
 VAR P=NEW_AST(#AST_ITEM)
 VAR R=P
 LOOP
  LEX_CUR OUT T,V
  IF T!=#TKN_IDEN THEN
   BREAK
  ENDIF
  VAR V$=PARSE_DEF_ARG$()
  VAR ITEM=NEW_AST(#AST_ITEM)
  AST$[ITEM]=V$
  AST_NEXT[P]=ITEM
  AST_PREV[ITEM]=P
  P=ITEM
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN
   BREAK
  ENDIF
  LEX_NEXT OUT T,V
 ENDLOOP
 AST_PREV[R]=P
 RETURN R
END
CONST #AST_DEF_A4_HAS_RET_VAL=&B0000001
CONST #AST_DEF_A4_IN_VAARGS  =&B0000010
CONST #AST_DEF_A4_OUT_VAARGS =&B0000100
CONST #AST_DEF_A4_COMMON_DEF =&B0001000
DEF PARSE_DEF()
 'DEF IDEN ([IDEN[\[\]]...]|*) OUT ([IDEN[\[\]]...]|*)
 VAR AST=NEW_AST(#AST_DEF)
 '$:NAME
 'A1:IN LIST
 'A2:OUT LIST
 'A3:STATEMENTS
 'A4:FLGS
 VAR T,V
 LEX_CUR OUT T,V
 IF T==#TKN_COMMON THEN
  AST_A4[AST]=AST_A4[AST]OR #AST_DEF_A4_COMMON_DEF
  LEX_NEXT OUT T,V
  IF T!=#TKN_DEF THEN
   PARSER_SYNTAX_ERROR "EXPECTED 'DEF'(COMMON DEF)"
   RETURN AST
  ENDIF
 ENDIF
 LEX_NEXT OUT T,V
 IF PARSER_IN_FUNC THEN
  NESTED_DEF
 ENDIF
 PARSER_IN_FUNC=#TRUE
 AST$[AST]=PARSE_DEF_ARG$()
 LEX_CUR OUT T,V
 IF T==#TKN_LP THEN
  PARSER_RETURN_EXPR=#TRUE
  LEX_NEXT OUT T,V
 ENDIF
 IF T==#TKN_MUL THEN
  AST_A4[AST]=AST_A4[AST]OR #AST_DEF_A4_IN_VAARGS
  LEX_NEXT OUT ,
 ELSE
  AST_A1[AST]=PARSE_DEF_LIST()
 ENDIF
 LEX_CUR OUT T,V
 IF PARSER_RETURN_EXPR THEN
  AST_A4[AST]=AST_A4[AST]OR #AST_DEF_A4_HAS_RET_VAL
  IF T!=#TKN_RP THEN
   PARSER_SYNTAX_ERROR "EXPECTED ')'(DEF)"
  ELSE
   LEX_NEXT OUT ,
  ENDIF
 ELSE
  LEX_CUR OUT T,V
  IF T==#TKN_OUT THEN
   LEX_NEXT OUT T,V
   IF T==#TKN_MUL THEN
    AST_A4[AST]=AST_A4[AST]OR #AST_DEF_A4_OUT_VAARGS
    LEX_NEXT OUT ,
   ELSE
    AST_A2[AST]=PARSE_DEF_LIST()
   ENDIF
  ENDIF
 ENDIF
 AST_A3[AST]=PARSE_DEF_STATEMENTS()
 PARSER_IN_FUNC=#FALSE
 PARSER_RETURN_EXPR=#FALSE
 RETURN AST
END

DEF PARSE_DEF_STATEMENTS()
 VAR ROOT=NEW_AST(#AST_STATEMENTS)
 VAR A=ROOT
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[A]=PRV
 VAR T,V
 LOOP
  LEX_CUR OUT T,V
  IF T==#TKN_NEWLINE||T==#TKN_COL THEN LEX_NEXT OUT ,:CONTINUE
  IF T==#TKN_END THEN LEX_NEXT OUT ,:RETURN ROOT
  IF T==#TKN_EOF THEN PARSER_SYNTAX_ERROR:RETURN ROOT
  VAR S=PARSE_STATEMENT()
  A=NEW_AST(#AST_ITEM)
  AST_LEFT[A]=S
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
 ENDLOOP
END
DEF PARSE_END()
 LEX_NEXT OUT ,
 RETURN NEW_AST(#AST_END)
END
DEF IS_EXPR_TKN(T)
 CASE T
 WHEN #TKN_NUM
 WHEN #TKN_STR
 WHEN #TKN_IDEN
 WHEN #TKN_LP
 WHEN #TKN_MINUS
 WHEN #TKN_NOT
 WHEN #TKN_LNOT
 WHEN #TKN_LABEL
 WHEN #TKN_CONSTVAR
  RETURN #TRUE
 ENDCASE
 RETURN #FALSE
END
DEF PARSE_PRINT(TPRNT)
 VAR T,V
 VAR AST
 IF TPRNT THEN
  AST=NEW_AST(#AST_TPRINT)
 ELSE
  AST=NEW_AST(#AST_PRINT)
 ENDIF
 VAR PRV=NEW_AST(#AST_ITEM)
 AST_LEFT[AST]=PRV
 LEX_NEXT OUT T,V
 IF !IS_EXPR_TKN(T)THEN
  IF TRACE THEN ?"PRINT_E"
  RETURN AST
 ENDIF
 WHILE 1
  VAR EXPR=PARSE_EXPR()
  LEX_CUR OUT T,V
  VAR A
  IF T==#TKN_COMMA THEN
   IF TRACE THEN ?"PRINT_COMMA"
   A=NEW_AST(#AST_PRINT_EXPR_COMMA)
   LEX_NEXT OUT ,
  ELSEIF T==#TKN_SEMI THEN
   IF TPRNT&&AST_LEFT[AST]==PRV THEN
    PARSER_SYNTAX_ERROR "EXPECTED ','(TPRINT)"
   ENDIF
   IF TRACE THEN ?"PRINT_SEMI"
   A=NEW_AST(#AST_PRINT_EXPR_SEMI)
   LEX_NEXT OUT ,
  ELSE
   IF TRACE THEN ?"PRINT"
   A=NEW_AST(#AST_PRINT_EXPR_NEWLINE)
  ENDIF
  AST_LEFT[A]=EXPR
  AST_NEXT[PRV]=A
  AST_PREV[A]=PRV
  PRV=A
  IF T!=#TKN_COMMA&&T!=#TKN_SEMI THEN
   RETURN AST
  ENDIF
  LEX_CUR OUT T,V
  IF !IS_EXPR_TKN(T)THEN
   RETURN AST
  ENDIF
 WEND
END
DEF PARSE_TERM()
 VAR T,V
 LEX_CUR OUT T,V
 VAR AST
 CASE T
 WHEN #TKN_LNOT
 WHEN #TKN_NOT
 WHEN #TKN_MINUS
  AST=NEW_AST(#AST_UNAOP)
  LEX_NEXT OUT ,
  AST%[AST]=T
  AST_LEFT[AST]=PARSE_TERM()
  IF TRACE THEN ?"UNARY"
 'FIXME:EXPND CONST EXPR
 WHEN #TKN_NUM
  IF TRACE THEN ?"IMM",V
  IF TYPEOF(V)==#T_INT THEN
   AST=NEW_AST_INT(#AST_IMM_INT,V)
   LEX_NEXT OUT ,
  ELSEIF TYPEOF(V)==#T_REAL THEN
   AST=NEW_AST_DBL(#AST_IMM_DBL,V)
   LEX_NEXT OUT ,
  ELSE
  STOP
  ENDIF
 WHEN #TKN_LABEL
 WHEN #TKN_STR
  IF TRACE THEN ?"IMM",V
  AST=NEW_AST_STR(#AST_IMM_STR,V)
  LEX_NEXT OUT ,
 WHEN #TKN_CONSTVAR
  IF TRACE THEN ?"CONSTVAR",V
  AST=NEW_AST_STR(#AST_CONSTVAR,V)
  LEX_NEXT OUT ,
 WHEN #TKN_IDEN
  LEX_NEXT OUT ,
  VAR T2,V2
  LEX_CUR OUT T2,V2
  IF T2==#TKN_LP THEN
   AST=PARSE_CALLFUNCEXPR(V)
  ELSE
   IF TRACE THEN ?"VAR",V
   AST=NEW_AST_STR(#AST_VAR,V)
  ENDIF
 WHEN #TKN_LP
  LEX_NEXT OUT ,
  AST=PARSE_EXPR()
  LEX_CUR OUT T,V
  IF T!=#TKN_RP THEN
   PARSER_SYNTAX_ERROR "EXPECTED ')'(EXPRESSION)"
  ELSE
   LEX_NEXT OUT ,
  ENDIF
 OTHERWISE
  PARSER_SYNTAX_ERROR "(EXPRESSION)"
  LEX_NEXT OUT ,
 ENDCASE
 RETURN AST
END
DEF PARSE_CALLFUNCEXPR(NAME$)
 VAR AST=NEW_AST_STR(#AST_CALLFUNCEXPR,NAME$)
 VAR T,V
 VAR P=NEW_AST(#AST_ITEM)
 AST_A1[AST]=P
 AST$[AST]=NAME$
 VAR FIRST=P
 LOOP
  LEX_NEXT OUT T,V
  IF T==#TKN_RP THEN
   LEX_NEXT OUT T,V
   BREAK
  ENDIF
  VAR EXPR=PARSE_EXPR()
  VAR ITEM=NEW_AST(#AST_ITEM)
  AST_A1[ITEM]=EXPR
  AST_PREV[ITEM]=P
  AST_NEXT[P]=ITEM
  P=ITEM
  LEX_CUR OUT T,V
  IF T!=#TKN_COMMA THEN
   IF T==#TKN_RP THEN
    LEX_NEXT OUT T,V
   ELSE
    PARSER_SYNTAX_ERROR "EXPECTED ')'"
   ENDIF
   BREAK
  ENDIF
 ENDLOOP
 AST_PREV[FIRST]=P
 RETURN AST
END
ENUM\
 #OPRANK_NOTANOP,\
 #OPRANK_MIN,\
 #OPRANK_PARENT,\
 #OPRANK_MUL,\
 #OPRANK_PLUS,\
 #OPRANK_SHIFT,\
 #OPRANK_EQ,\
 #OPRANK_BIT,\
 #OPRANK_LOG,\
 #OPRANK_MAX
DEF GET_OP_RANK(T)
 CASE T
 WHEN #TKN_LP
 WHEN #TKN_LB
  RETURN #OPRANK_PARENT
 WHEN #TKN_MUL
 WHEN #TKN_DIV
 WHEN #TKN_DIVINT
 WHEN #TKN_MOD
  RETURN #OPRANK_MUL
 WHEN #TKN_PLUS
 WHEN #TKN_MINUS
  RETURN #OPRANK_PLUS
 WHEN #TKN_LSHIFT
 WHEN #TKN_RSHIFT
  RETURN #OPRANK_SHIFT
 WHEN #TKN_EQ
 WHEN #TKN_NEQ
 WHEN #TKN_LESS
 WHEN #TKN_LEQ
 WHEN #TKN_GREAT
 WHEN #TKN_GEQ
  RETURN #OPRANK_EQ
 WHEN #TKN_AND
 WHEN #TKN_OR
 WHEN #TKN_XOR
  RETURN #OPRANK_BIT
 WHEN #TKN_LAND
 WHEN #TKN_LOR
  RETURN #OPRANK_LOG
 ENDCASE
 RETURN #OPRANK_NOTANOP
END
VAR PPP
DEF PARSE_EXPR()
 RETURN PARSE_EXPR0(#OPRANK_MAX)
END
DEF PARSE_EXPR0(RANK)
 IF RANK==#OPRANK_MIN THEN
  RETURN PARSE_TERM()
 ENDIF
 VAR T,V
 VAR LEFT=PARSE_EXPR0(RANK-1)
 LOOP
  LEX_CUR OUT T,V
  IF GET_OP_RANK(T)==RANK THEN
   LEX_NEXT OUT ,
   VAR RIGHT
   IF T==#TKN_LB THEN
    RIGHT=PARSE_ARRAY_INDEX()
    IF TRACE THEN ?"BINARY OP",TKN_STR$(T)
    LEFT=NEW_AST_LR(#AST_BINOP,LEFT,RIGHT)
    AST%[LEFT]=T
   ELSE
    RIGHT=PARSE_EXPR0(RANK-1)
    IF TRACE THEN ?"BINARY OP",TKN_STR$(T)
    LEFT=NEW_AST_LR(#AST_BINOP,LEFT,RIGHT)
    AST%[LEFT]=T
   ENDIF
   CONTINUE
  ENDIF
  BREAK
 ENDLOOP
 RETURN LEFT
END

DEF PARSER_SYNTAX_ERROR *
 VAR I,T,V
 LEX_CUR OUT T,V
 ?"Syntax error in "
 ?"UNEXPECTED ";TKN_STR$(T)
 FOR I=0TO DEFARGC()-1
  ?DEFARG(I);
 NEXT
 IF DEFARGC() THEN
  ?
 ENDIF
 PARSER_HAS_ERR=#TRUE
END

ENUM\
 #VMT_DEFAULT,\
 #VMT_INT,\
 #VMT_REAL,\
 #VMT_STR,\
 #VMT_INTARRAY,\
 #VMT_REALARRAY,\
 #VMT_STRARRAY,\
 #VMT_VARREF,\
 #VMT_LVARREF,\
 #VMT_EMPTYREF,\
 #VMT_ARYREF,\
 #VMT_SUBROUTINE,\
 #VMT_LAST

ENUM\
 #VMPRINT_EMPTY,\
 #VMPRINT_COMMA,\
 #VMPRINT_NEWLINE,\
 #VMPRINT_SEMI

VAR CMP_STRICT
VAR CMP_DEFINT
VAR CMP_GVARTBL
VAR CMP_GLBLTBL
VAR CMP_FUNCTBL
VAR CMP_CONSTTBL

VAR CMP_GVARNUM

DIM CMP_BREAK[]
DIM CMP_CONTINUE[]
VAR CMP_CURFUNC

DIM FUNC_ADDR[]
'-1:VAARGS
DIM FUNC_INCNT[]
DIM FUNC_OUTCNT[]
DIM FUNC_VARTBL[]
DIM FUNC_LBLTBL[]
DIM FUNC_VARNUM[]
DIM FUNC_SLOT[]

DIM VAR_IDX[]
DIM VAR_TYP[]

DIM LABEL_ADDR[]
DIM LABEL_DATA_ADDR[]

DIM CMP_DATA_TYP[]
DIM CMP_DATA%[]
DIM CMP_DATA#[]
DIM CMP_DATA$[]

DIM CMP_CONST_TYP[]
DIM CMP_CONST%[]
DIM CMP_CONST#[]
DIM CMP_CONST$[]

VAR CMP_SLOT
DEF INIT_COMPILER_VAR
 VAR S=1
 VAR_IDX=ARRAY%(S)
 VAR_TYP=ARRAY%(S)
END
DEF NEW_VAR(IDX,TYP)
 PUSH VAR_IDX,IDX
 PUSH VAR_TYP,TYP
 RETURN LAST(VAR_IDX)
END
DEF INIT_COMPILER_LABEL
 VAR S=1
 LABEL_ADDR=ARRAY%(S)
 LABEL_DATA_ADDR=ARRAY%(S)
END
DEF NEW_LABEL(ADDR,DADDR)
 PUSH LABEL_ADDR,ADDR
 PUSH LABEL_DATA_ADDR,DADDR
 RETURN LAST(LABEL_ADDR)
END
DEF INIT_COMPILER_FUNC
 VAR S=1
 FUNC_ADDR=ARRAY%(S)
 FUNC_INCNT=ARRAY%(S)
 FUNC_OUTCNT=ARRAY%(S)
 FUNC_VARTBL=ARRAY%(S)
 FUNC_LBLTBL=ARRAY%(S)
 FUNC_VARNUM=ARRAY%(S)
 FUNC_SLOT=ARRAY%(S)
END
DEF NEW_FUNC(ADDR,INCNT,OUTCNT,SLOT)
 PUSH FUNC_ADDR,ADDR
 PUSH FUNC_INCNT,INCNT
 PUSH FUNC_OUTCNT,OUTCNT
 PUSH FUNC_VARTBL,NEW_SPLAY_TREE()
 PUSH FUNC_LBLTBL,NEW_SPLAY_TREE()
 PUSH FUNC_VARNUM,0
 PUSH FUNC_SLOT,SLOT
 RETURN LAST(FUNC_LBLTBL)
END
DEF INIT_COMPILER_CONST
 VAR S=1
 CMP_CONST_TYP=ARRAY%(S)
 CMP_CONST%=ARRAY%(S)
 CMP_CONST#=ARRAY#(S)
 CMP_CONST$=ARRAY$(S)
 ADD_CONST "#ON",#ON:ADD_CONST "#OFF",#OFF:ADD_CONST "#YES",#YES:ADD_CONST "#NO",#NO:ADD_CONST "#TRUE",#TRUE:ADD_CONST "#FALSE",#FALSE:ADD_CONST "#PI",#PI:ADD_CONST "#EXP",#EXP:ADD_CONST "#C_CLEAR",#C_CLEAR:ADD_CONST "#C_AQUA",#C_AQUA:ADD_CONST "#C_BLACK",#C_BLACK:ADD_CONST "#C_BLUE",#C_BLUE:ADD_CONST "#C_CYAN",#C_CYAN:ADD_CONST "#C_FUCHSIA",#C_FUCHSIA:ADD_CONST "#C_GRAY",#C_GRAY:ADD_CONST "#C_GREEN",#C_GREEN:ADD_CONST "#C_LIME",#C_LIME:ADD_CONST "#C_MAGENTA",#C_MAGENTA:ADD_CONST "#C_MAROON",#C_MAROON:ADD_CONST "#C_NAVY",#C_NAVY:ADD_CONST "#C_OLIVE",#C_OLIVE:ADD_CONST "#C_PURPLE",#C_PURPLE:ADD_CONST "#C_RED",#C_RED:ADD_CONST "#C_SILVER",#C_SILVER:ADD_CONST "#C_TEAL",#C_TEAL:ADD_CONST "#C_WHITE",#C_WHITE:ADD_CONST "#C_YELLOW",#C_YELLOW:ADD_CONST "#B_RUP",#B_RUP:ADD_CONST "#B_RDOWN",#B_RDOWN:ADD_CONST "#B_RLEFT",#B_RLEFT:ADD_CONST "#B_RRIGHT",#B_RRIGHT:ADD_CONST "#B_LUP",#B_LUP:ADD_CONST "#B_LDOWN",#B_LDOWN:ADD_CONST "#B_LLEFT",#B_LLEFT:ADD_CONST "#B_LRIGHT",#B_LRIGHT:ADD_CONST "#B_L1",#B_L1:ADD_CONST "#B_R1",#B_R1:ADD_CONST "#B_L2",#B_L2:ADD_CONST "#B_R2",#B_R2:ADD_CONST "#B_SL",#B_SL:ADD_CONST "#B_SR",#B_SR:ADD_CONST "#B_S1",#B_S1:ADD_CONST "#B_S2",#B_S2:ADD_CONST "#B_LSTICK",#B_LSTICK:ADD_CONST "#B_RSTICK",#B_RSTICK:ADD_CONST "#B_RANY",#B_RANY:ADD_CONST "#B_LANY",#B_LANY:ADD_CONST "#B_ANY",#B_ANY:ADD_CONST "#A_ROT0",#A_ROT0:ADD_CONST "#A_ROT90",#A_ROT90:ADD_CONST "#A_ROT180",#A_ROT180:ADD_CONST "#A_ROT270",#A_ROT270:ADD_CONST "#A_REVH",#A_REVH:ADD_CONST "#A_REVV",#A_REVV:ADD_CONST "#A_ADD",#A_ADD:ADD_CONST "#CHKXY",#CHKXY:ADD_CONST "#CHKZ",#CHKZ:ADD_CONST "#CHKR",#CHKR:ADD_CONST "#CHKS",#CHKS:ADD_CONST "#CHKC",#CHKC:ADD_CONST "#CHKV",#CHKV:ADD_CONST "#CHKUV",#CHKUV:ADD_CONST "#CHKI",#CHKI:ADD_CONST "#T_DEFAULT",#T_DEFAULT:ADD_CONST "#T_INT",#T_INT:ADD_CONST "#T_REAL",#T_REAL:ADD_CONST "#T_STR",#T_STR:ADD_CONST "#T_INTARRAY",#T_INTARRAY:ADD_CONST "#T_REALARRAY",#T_REALARRAY:ADD_CONST "#T_STRARRAY",#T_STRARRAY:ADD_CONST "#G_NORMAL",#G_NORMAL:ADD_CONST "#G_NORMAL2",#G_NORMAL2:ADD_CONST "#G_ALPHA",#G_ALPHA:ADD_CONST "#G_ALPHA2",#G_ALPHA2:ADD_CONST "#G_ADD",#G_ADD:ADD_CONST "#BQAPF",#BQAPF:ADD_CONST "#BQLPF",#BQLPF:ADD_CONST "#BQHPF",#BQHPF:ADD_CONST "#BQBPF",#BQBPF:ADD_CONST "#BQBSF",#BQBSF:ADD_CONST "#BQLSF",#BQLSF:ADD_CONST "#BQHSF",#BQHSF:ADD_CONST "#BQPEQ",#BQPEQ:ADD_CONST "#WFRECT",#WFRECT:ADD_CONST "#WFHAMM",#WFHAMM:ADD_CONST "#WFHANN",#WFHANN:ADD_CONST "#WFBLKM",#WFBLKM:ADD_CONST "#AOPADD",#AOPADD:ADD_CONST "#AOPSUB",#AOPSUB:ADD_CONST "#AOPMUL",#AOPMUL:ADD_CONST "#AOPDIV",#AOPDIV:ADD_CONST "#AOPMAD",#AOPMAD:ADD_CONST "#AOPLIP",#AOPLIP:ADD_CONST "#AOPCLP",#AOPCLP:ADD_CONST "#EFCOFF",#EFCOFF:ADD_CONST "#EFCON",#EFCON:ADD_CONST "#EFCBATH",#EFCBATH:ADD_CONST "#EFCCAVE",#EFCCAVE:ADD_CONST "#EFCSPACE",#EFCSPACE:ADD_CONST "#EFCREFSROOM",#EFCREFSROOM:ADD_CONST "#EFCREFLROOM",#EFCREFLROOM:ADD_CONST "#EFCREFHALL",#EFCREFHALL:ADD_CONST "#EFCREFCAVE",#EFCREFCAVE:ADD_CONST "#EFCREFNONE",#EFCREFNONE:ADD_CONST "#EFCREVROOM",#EFCREVROOM:ADD_CONST "#EFCREVHALL",#EFCREVHALL:ADD_CONST "#EFCREVMETAL",#EFCREVMETAL:ADD_CONST "#EFCREVCAVE",#EFCREVCAVE:ADD_CONST "#EFCREVREV",#EFCREVREV:ADD_CONST "#PVLEFT",#PVLEFT:ADD_CONST "#PVRIGHT",#PVRIGHT:ADD_CONST "#GRPWIDTH",#GRPWIDTH:ADD_CONST "#GRPHEIGHT",#GRPHEIGHT:ADD_CONST "#GRPF",#GRPF:ADD_CONST "#GSPRITE",#GSPRITE:ADD_CONST "#TCONSOLE",#TCONSOLE:ADD_CONST "#MAXT",#MAXT:ADD_CONST "#MAXSP",#MAXSP:ADD_CONST "#MAXGRP",#MAXGRP:ADD_CONST "#HARDWARE",#HARDWARE
 ADD_CONST "#VERSION",#VERSION
 ADD_CONST "#_SLOT",0
 ADD_CONST "#_LINE",0
 ADD_CONST "#_FILENAME",""
END
DEF NEW_CONST(C)
 VAR N$
 PUSH CMP_CONST_TYP,0
 PUSH CMP_CONST%,0
 PUSH CMP_CONST#,0
 PUSH CMP_CONST$,N$
 VAR L=LAST(CMP_CONST%)
 CASE TYPEOF(C)
 WHEN #T_INT
  CMP_CONST%[L]=C
  CMP_CONST_TYP[L]=#VMT_INT
 WHEN #T_REAL
  CMP_CONST#[L]=C
  CMP_CONST_TYP[L]=#VMT_REAL
 WHEN #T_STR
  CMP_CONST$[L]=C
  CMP_CONST_TYP[L]=#VMT_STR
 ENDCASE
 RETURN L
END
DEF INIT_COMPILER SLOT
 CMP_STRICT=#FALSE
 CMP_DEFINT=#FALSE
 CMP_GVARTBL=NEW_SPLAY_TREE()
 CMP_GLBLTBL=NEW_SPLAY_TREE()
 CMP_FUNCTBL=NEW_SPLAY_TREE()
 CMP_CONSTTBL=NEW_SPLAY_TREE()
 INIT_COMPILER_CONST
 CMP_GVARNUM=1
 CMP_BREAK=EMPTY()
 CMP_CONTINUE=EMPTY()
 CMP_DATA%=ARRAY%(0)
 CMP_DATA#=ARRAY#(0)
 CMP_DATA$=ARRAY$(0)
 CMP_DATA_TYP=ARRAY%(0)
 INIT_VM_CODEGEN
 CMP_SLOT=SLOT
END
DEF ADD_DATA V
 VAR N$
 PUSH CMP_DATA%,0
 PUSH CMP_DATA#,0
 PUSH CMP_DATA$,N$
 PUSH CMP_DATA_TYP,0
 CASE TYPEOF(V)
 WHEN #T_INT
  CMP_DATA_TYP[LAST(CMP_DATA_TYP)]=#VMT_INT
  CMP_DATA%[LAST(CMP_DATA%)]=V
 WHEN #T_REAL
  CMP_DATA_TYP[LAST(CMP_DATA_TYP)]=#VMT_REAL
  CMP_DATA#[LAST(CMP_DATA#)]=V
 WHEN #T_STR
  CMP_DATA_TYP[LAST(CMP_DATA_TYP)]=#VMT_STR
  CMP_DATA$[LAST(CMP_DATA$)]=V
 OTHERWISE
  INTERNAL_COMPILER_ERROR
 ENDCASE
END
DEF DETER_VAR_TYPE NAME$,ARY OUT TYP
 CASE RIGHT$(NAME$,1)
 WHEN "$"
  IF ARY THEN
   TYP=#VMT_STRARRAY
  ELSE
   TYP=#VMT_STR
  ENDIF
 WHEN "%"
  IF ARY THEN
   TYP=#VMT_INTARRAY
  ELSE
   TYP=#VMT_INT
  ENDIF
 WHEN "#"
  IF ARY THEN
   TYP=#VMT_REALARRAY
  ELSE
   TYP=#VMT_REAL
  ENDIF
 OTHERWISE
  IF CMP_DEFINT THEN
   IF ARY THEN
    TYP=#VMT_INTARRAY
   ELSE
    TYP=#VMT_INT
   ENDIF
  ELSE
   IF ARY THEN
    TYP=#VMT_REALARRAY
   ELSE
    TYP=#VMT_REAL
   ENDIF
  ENDIF
 ENDCASE
END
DEF DEFINE_VAR NAME$,ARY OUT IDX,LOCAL
 VAR TYP
 DETER_VAR_TYPE NAME$,ARY OUT TYP
 IF CMP_CURFUNC THEN
  SPLAY_INSERT% FUNC_VARTBL[CMP_CURFUNC],NAME$,NEW_VAR(FUNC_VARNUM[CMP_CURFUNC],TYP)
  INC FUNC_VARNUM[CMP_CURFUNC]
  IDX=FUNC_VARNUM[CMP_CURFUNC]-1
  LOCAL=#TRUE
 ELSE
  SPLAY_INSERT% CMP_GVARTBL,NAME$,NEW_VAR(CMP_GVARNUM,TYP)
  INC CMP_GVARNUM
  LOCAL=#FALSE
  IDX=CMP_GVARNUM-1
 ENDIF
END
DEF GET_VAR_INDEX NAME$ OUT IDX,LOCAL
 VAR FOUND,V
 IF CMP_CURFUNC THEN
  LOCAL=#TRUE
  SPLAY_GET% FUNC_VARTBL[CMP_CURFUNC],NAME$ OUT FOUND,V
 ENDIF
 IF !FOUND THEN
  LOCAL=#FALSE
  SPLAY_GET% CMP_GVARTBL,NAME$ OUT FOUND,V
 ENDIF
 IF !FOUND THEN
  IF CMP_STRICT THEN
   UNDEFINED_VARIABLE_ERROR
  ENDIF
  DEFINE_VAR NAME$,#FALSE OUT IDX,LOCAL
 ELSE
  IDX=VAR_IDX[V]
 ENDIF
END
DEF DEFINE_LABEL NAME$
 'TODO:LOCAL
 VAR FOUND
 VAR TBL
 IF CMP_CURFUNC THEN
  TBL=FUNC_LBLTBL[CMP_CURFUNC]
 ELSE
  TBL=CMP_GLBLTBL
 ENDIF
 SPLAY_GET% TBL,NAME$ OUT FOUND,
 IF FOUND THEN
  DUPLICATE_LABEL NAME$
 ENDIF
 SPLAY_INSERT% TBL,NAME$,NEW_LABEL(COMPILER_CURRENT_ADDR(),LEN(CMP_DATA_TYP))
END
DEF COMPILE AST
 COMPILE_STATEMENTS AST
END
DEF COMPILE_STATEMENTS A
 VAR I
 CASE AST_TYP[A]
 WHEN #AST_STATEMENTS
  I=AST_NEXT[AST_LEFT[A]]
  WHILE I
   IF!I THEN BREAK
   COMPILE_STATEMENT AST_LEFT[I]
   I=AST_NEXT[I]
  WEND
 OTHERWISE
  COMPILE_ERROR
 ENDCASE
END
DEF COMPILE_STATEMENT A
 VMDBG_ADD_SRC_INFO AST_LINE[A],AST_POS[A]
 CASE AST_TYP[A]
 WHEN #AST_PRINT
  COMPILE_PRINT A
 WHEN #AST_ASSIGN
  COMPILE_EXPR AST_RIGHT[A]
  COMPILE_REFEXPR AST_LEFT[A]
  EMIT_ASSIGN
 'A1:EXPR
 'A2:THEN STATEMENTS
 'A3:ELSEIF STATEMENTS
 'A4:ELSE STATEMENTS
 WHEN #AST_IF
  COMPILE_IF A
 WHEN #AST_FOR
  COMPILE_FOR A
 WHEN #AST_BREAK
  COMPILE_BREAK
 WHEN #AST_CONTINUE
  COMPILE_CONTINUE
 WHEN #AST_WHILE
  COMPILE_WHILE A
 WHEN #AST_REPEAT
  COMPILE_REPEAT A
 WHEN #AST_LOOP
  COMPILE_LOOP A
 WHEN #AST_LABEL
  COMPILE_LABEL A
 WHEN #AST_GOTO
  COMPILE_GOTO A
 WHEN #AST_GOSUB
  COMPILE_GOSUB A
 WHEN #AST_GOTOEXPR
  COMPILE_GOTOEXPR A
 WHEN #AST_GOSUBEXPR
  COMPILE_GOSUBEXPR A
 WHEN #AST_ONGOTO
 WHEN #AST_ONGOSUB
  COMPILE_ONGOTO A
 WHEN #AST_ONBREAKGOTO
  COMPILE_ONBREAKGOTO A
 WHEN #AST_ONBREAKGOTOEXPR
  COMPILE_ONBREAKGOTOEXPR A
 WHEN #AST_RETURN
  COMPILE_RETURN A
 WHEN #AST_CALLFUNC
  COMPILE_CALLFUNC A
 WHEN #AST_DEF
  COMPILE_DEF A
 WHEN #AST_RETURNFUNC
  COMPILE_RETURNFUNC A
 WHEN #AST_DEFVAR
  COMPILE_DEFVAR A
 WHEN #AST_END
  COMPILE_END A
 WHEN #AST_OPTIONSTRICT
  CMP_STRICT=#TRUE
 WHEN #AST_OPTIONDEFINT
  CMP_DEFINT=#TRUE
 WHEN #AST_DATA
  COMPILE_DATA A
 WHEN #AST_CONST
  COMPILE_CONST A
 WHEN #AST_ENUM
  COMPILE_ENUM A
 WHEN #AST_READ
  COMPILE_READ A
 WHEN #AST_RESTORE
  COMPILE_RESTORE A
 WHEN #AST_RESTOREEXPR
  COMPILE_RESTOREEXPR A
 WHEN #AST_CALLSPRITE
  EMIT_CALLSPRITE
 WHEN #AST_CALLTEXT
  EMIT_CALLTEXT
 WHEN #AST_TPRINT
  COMPILE_TPRINT A
 WHEN #AST_INC
 WHEN #AST_DEC
  COMPILE_INC A
 WHEN #AST_CASE
  COMPILE_CASE A
 WHEN #AST_SWAP
  COMPILE_SWAP A
 WHEN #AST_INPUT
  COMPILE_INPUT A
 WHEN #AST_LINPUT
  COMPILE_LINPUT A
 WHEN #AST_DEFOUT
  COMPILE_DEFOUT A
 WHEN #AST_EXEC
  COMPILE_EXEC A
 WHEN #AST_STOP
  COMPILE_STOP A
 OTHERWISE
  ?AST_STR$(AST_TYP[A])
  COMPILE_ERROR
 ENDCASE
END

DEF COMPILE_STOP A
 IF AST_A1[A]THEN
  COMPILE_EXPR AST_A1[A]
  EMIT_STOP2
 ELSE
  EMIT_STOP1
 ENDIF
END
DEF COMPILE_EXEC A
 'RIGHT TO LEFT
 IF AST_A2[A]THEN
  COMPILE_EXPR AST_A2[A]
  COMPILE_EXPR AST_A1[A]
  EMIT_EXEC2
 ELSE
  COMPILE_EXPR AST_A1[A]
  EMIT_EXEC1
 ENDIF
END
DEF COMPILE_DEFOUT A
 'RIGHT TO LEFT
 COMPILE_EXPR AST_A2[A]
 COMPILE_EXPR AST_A1[A]
 EMIT_DEFOUT
END
DEF COMPILE_INPUT A
 'RIGHT TO LEFT
 VAR I=AST_PREV[AST_A2[A]]
 VAR CNT
 WHILE I!=AST_A2[A]
  COMPILE_REFEXPR AST_A1[I]
  INC CNT
  I=AST_PREV[I]
 WEND
 IF AST_A1[A]THEN
  COMPILE_EXPR AST_A1[A]
  EMIT_INPUT #TRUE,AST_A3[A],CNT
 ELSE
  EMIT_INPUT #FALSE,AST_A3[A],CNT
 ENDIF
END
DEF COMPILE_LINPUT A
 IF AST_A1[A]THEN
  COMPILE_EXPR AST_A1[A]
  EMIT_LINPUT #TRUE
 ELSE
  EMIT_LINPUT #FALSE
 ENDIF
 COMPILE_REFEXPR AST_A2[A]
 EMIT_ASSIGN
END
DEF COMPILE_SWAP A
 'RIGHT TO LEFT
 COMPILE_REFEXPR AST_RIGHT[A]
 COMPILE_REFEXPR AST_LEFT[A]
 EMIT_SWAP
END
DEF AST_IS_EMPTY_STMTS(A)
 RETURN AST_NEXT[AST_LEFT[A]]==0
END
DEF COMPILE_CASE A
 COMPILE_EXPR AST_A1[A]
 VAR I
 I=AST_NEXT[AST_A2[A]]
 VAR LBL
 DIM BRLIST=ARRAY%(0)
 DIM ENDCASELIST=ARRAY%(0)
 VAR EXPR,STMTS
 WHILE I
  EXPR=AST_A1[I]
  STMTS=AST_A2[I]
  IF EXPR THEN
   COMPILE_EXPR EXPR
   PUSH BRLIST,EMIT_WHEN()
  ELSE
   EMIT_POP 1
   PUSH BRLIST,EMIT_BR()
  ENDIF
  I=AST_NEXT[I]
 WEND
 I=AST_NEXT[AST_A2[A]]
 VAR J
 WHILE I
  EXPR=AST_A1[I]
  STMTS=AST_A2[I]
  EMIT_ADDR BRLIST[J]
  IF EXPR THEN
   IF !AST_IS_EMPTY_STMTS(STMTS)THEN
    COMPILE_STATEMENTS STMTS
    PUSH ENDCASELIST,EMIT_BR()
   ENDIF
  ELSE
   COMPILE_STATEMENTS STMTS
  ENDIF
  INC J
  I=AST_NEXT[I]
 WEND
 FOR I=0TO LAST(ENDCASELIST)
  EMIT_ADDR ENDCASELIST[I]
 NEXT
END
DEF COMPILE_ONGOTO A
 COMPILE_EXPR AST_A1[A]
 VAR I=AST_NEXT[AST_A2[A]]
 DIM LBL$[]
 WHILE I
  PUSH LBL$,AST$[I]
  I=AST_NEXT[I]
 WEND
 EMIT_ONGOTO LBL$,AST_TYP[A]==#AST_ONGOSUB
END
DEF COMPILE_INC A
 'RIGHT TO LEFT
 IF AST_RIGHT[A] THEN
  COMPILE_EXPR AST_RIGHT[A]
 ELSE
  EMIT_PUSHINT 1
 ENDIF
 COMPILE_REFEXPR AST_LEFT[A]
 IF AST_TYP[A]==#AST_INC THEN
  EMIT_INC
 ELSE
  EMIT_DEC
 ENDIF
END
DEF COMPILE_TPRINT A
 VAR I=AST_NEXT[AST_LEFT[A]]
 IF !I THEN
  TYPE_MISMATCH'FIXME:RUNTIME ERROR
 ENDIF
 COMPILE_EXPR AST_LEFT[I]
 I=AST_NEXT[I]
 IF !I THEN
  EMIT_TPRINT #VMPRINT_EMPTY
 ENDIF
 WHILE I
  IF!I THEN BREAK
  COMPILE_EXPR AST_LEFT[I]
  CASE AST_TYP[I]
  WHEN #AST_PRINT_EXPR_COMMA
   EMIT_TPRINT #VMPRINT_COMMA
  WHEN #AST_PRINT_EXPR_NEWLINE
   EMIT_TPRINT #VMPRINT_NEWLINE
  WHEN #AST_PRINT_EXPR_SEMI
   EMIT_TPRINT #VMPRINT_SEMI
  ENDCASE
  I=AST_NEXT[I]
 WEND
 EMIT_POP 1
END
DEF COMPILE_PRINT A
 VAR I=AST_NEXT[AST_LEFT[A]]
 IF !I THEN
  EMIT_PRINT #VMPRINT_EMPTY
 ENDIF
 WHILE I
  IF!I THEN BREAK
  COMPILE_EXPR AST_LEFT[I]
  CASE AST_TYP[I]
  WHEN #AST_PRINT_EXPR_COMMA
   EMIT_PRINT #VMPRINT_COMMA
  WHEN #AST_PRINT_EXPR_NEWLINE
   EMIT_PRINT #VMPRINT_NEWLINE
  WHEN #AST_PRINT_EXPR_SEMI
   EMIT_PRINT #VMPRINT_SEMI
  ENDCASE
  I=AST_NEXT[I]
 WEND
END
DEF FOLD_CONSTEXPR_ARGS(A)
 VAR I=AST_NEXT[A]
 DIM RESULT=ARRAY%(0)
 WHILE I
  PUSH RESULT,FOLD_CONSTEXPR(AST_A1[I])
  I=AST_NEXT[I]
 WEND
 RETURN RESULT
END
DEF AST_IS_NUM(A)
 RETURN AST_TYP[A]==#AST_IMM_INT||AST_TYP[A]==#AST_IMM_DBL
END
DEF AST_IMM(A)
 CASE AST_TYP[A]
 WHEN #AST_IMM_INT
  RETURN AST%[A]
 WHEN #AST_IMM_DBL
  RETURN AST#[A]
 WHEN #AST_IMM_STR
  RETURN AST$[A]
 OTHERWISE
  STOP
 ENDCASE
END
DEF FOLD_CONSTEXPR(A)
 IF !A THEN RETURN 0
 CASE AST_TYP[A]
 WHEN #AST_IMM_INT
 WHEN #AST_IMM_DBL
 WHEN #AST_IMM_STR
  RETURN A
 WHEN #AST_CONSTVAR
  VAR FOUND,C
  SPLAY_GET% CMP_CONSTTBL,AST$[A] OUT FOUND,C
  IF!FOUND THEN
   UNDEFINED_CONSTANT AST$[A]
  ELSE
   CASE CMP_CONST_TYP[C]
   WHEN #VMT_INT
    RETURN NEW_AST_INT(#AST_IMM_INT,CMP_CONST%[C])
   WHEN #VMT_REAL
    RETURN NEW_AST_DBL(#AST_IMM_DBL,CMP_CONST#[C])
   WHEN #VMT_STR
    RETURN NEW_AST_STR(#AST_IMM_STR,CMP_CONST$[C])
   OTHERWISE
    INTERNAL_COMPILER_ERROR
   ENDCASE
  ENDIF
 WHEN #AST_CALLFUNCEXPR
  VAR ARGS=FOLD_CONSTEXPR_ARGS(AST_A1[A])
  CASE AST$[A]
  WHEN "RGB"
   IF LEN(ARGS)!=3&&LEN(ARGS)!=4 THEN
    RETURN A
   ENDIF
   IF AST_IS_NUM(ARGS[0])&&AST_IS_NUM(ARGS[1])&&AST_IS_NUM(ARGS[2])THEN
    IF LEN(ARGS)==4 THEN
     IF!AST_IS_NUM(ARGS[3])THEN
      RETURN A
     ELSE
      RETURN NEW_AST_INT(#AST_IMM_INT,RGB(AST_IMM(ARGS[0]),AST_IMM(ARGS[1]),AST_IMM(ARGS[2]),AST_IMM(ARGS[3])))
     ENDIF
    ENDIF
    RETURN NEW_AST_INT(#AST_IMM_INT,RGB(AST_IMM(ARGS[0]),AST_IMM(ARGS[1]),AST_IMM(ARGS[2])))
   ELSE
    RETURN A
   ENDIF
  WHEN "DEG"
   IF ARGS!=1 THEN
    RETURN A
   ENDIF
   RETURN NEW_AST_DBL(#AST_IMM_DBL,DEG(AST_IMM(ARGS[0])))
  WHEN "RAD"
   IF ARGS!=1 THEN
    RETURN A
   ENDIF
   RETURN NEW_AST_DBL(#AST_IMM_DBL,RAD(AST_IMM(ARGS[0])))
  WHEN "CHR$"
   IF ARGS!=1 THEN
    RETURN A
   ENDIF
   RETURN NEW_AST_STR(#AST_IMM_STR,RAD(AST_IMM(ARGS[0])))
  ENDCASE
 WHEN #AST_UNAOP
  VAR L=FOLD_CONSTEXPR(AST_LEFT[A])
  IF AST_IS_NUM(L) THEN
   L=AST_IMM(L)
   CASE AST%[A]
   WHEN #TKN_LNOT
    RETURN NEW_AST_IMM(!L)
   WHEN #TKN_MINUS
    RETURN NEW_AST_IMM(-L)
   WHEN #TKN_NOT
    RETURN NEW_AST_IMM(NOT L)
   ENDCASE
  ELSE
   RETURN A
  ENDIF
 WHEN #AST_BINOP
  L=FOLD_CONSTEXPR(AST_LEFT[A])
  VAR R=FOLD_CONSTEXPR(AST_RIGHT[A])
  VAR LV=AST_IMM(L)
  VAR RV=AST_IMM(R)
  CASE AST%[A]
  WHEN #TKN_PLUS
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV+RV)
   ENDIF
  WHEN #TKN_MINUS
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV-RV)
   ENDIF
  WHEN #TKN_MUL
   IF AST_IS_NUM(L)&&(AST_IS_NUM(R)||AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV*RV)
   ENDIF
  WHEN #TKN_DIV
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV/RV)
   ENDIF
  WHEN #TKN_DIVINT
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV DIV RV)
   ENDIF
  WHEN #TKN_MOD
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV MOD RV)
   ENDIF
  WHEN #TKN_AND
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV AND RV)
   ENDIF
  WHEN #TKN_OR
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV OR RV)
   ENDIF
  WHEN #TKN_EQ
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV==RV)
   ENDIF
  WHEN #TKN_NEQ
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV!=RV)
   ENDIF
  WHEN #TKN_LSHIFT
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV<<RV)
   ENDIF
  WHEN #TKN_RSHIFT
   IF AST_IS_NUM(L)&&AST_IS_NUM(R)THEN
    RETURN NEW_AST_IMM(LV>>RV)
   ENDIF
  WHEN #TKN_GREAT
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV<RV)
   ENDIF
  WHEN #TKN_LESS
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV>RV)
   ENDIF
  WHEN #TKN_GEQ
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV<=RV)
   ENDIF
  WHEN #TKN_LEQ
   IF (AST_IS_NUM(L)&&AST_IS_NUM(R))||(AST_TYP[L]==#AST_IMM_STR&&AST_TYP[R]==#AST_IMM_STR)THEN
    RETURN NEW_AST_IMM(LV>=RV)
   ENDIF
  OTHERWISE
   RETURN A
  ENDCASE
 OTHERWISE
  RETURN A
 ENDCASE
 RETURN A
END
DEF COMPILE_RESTORE A
 IF LEN(AST$[A])THEN
  EMIT_RESTORE_PLACEHOLDER AST$[A]
 ELSE
  'CURRENT SLOT??FIXME
  EMIT_RESTORE CMP_SLOT,0'4.0.1,4.0.2:TYPEMISMATCH
 ENDIF
END
DEF COMPILE_RESTOREEXPR A
 COMPILE_EXPR AST_LEFT[A]
 EMIT_RESTOREEXPR
END
DEF COMPILE_GOTOEXPR A
 COMPILE_EXPR AST_LEFT[A]
 EMIT_GOTOEXPR
END
DEF COMPILE_GOSUBEXPR A
 COMPILE_EXPR AST_LEFT[A]
 EMIT_GOSUBEXPR
END
DEF COMPILE_READ A
 VAR I=AST_NEXT[AST_A1[A]]
 WHILE I
  COMPILE_REFEXPR AST_A1[I]
  ' BAD:READ->EVAL REFEXPR->ASSIGN
  'GOOD:EVAL REFEXPR->READ->ASSIGN
  EMIT_READ
  I=AST_NEXT[I]
 WEND
END
DEF COMPILE_DATA A
 VAR I=AST_NEXT[AST_A1[A]]
 WHILE I
  VAR EXPR=FOLD_CONSTEXPR(AST_A1[I])
  CASE AST_TYP[EXPR]
  WHEN #AST_IMM_INT
   ADD_DATA AST%[EXPR]
  WHEN #AST_IMM_DBL
   ADD_DATA AST#[EXPR]
  WHEN #AST_IMM_STR
   ADD_DATA AST$[EXPR]
  OTHERWISE
   SYNTAX_ERROR "DATA"
  ENDCASE
  I=AST_NEXT[I]
 WEND
END
DEF ADD_CONST N$,C
 VAR FOUND
 SPLAY_GET% CMP_CONSTTBL,N$ OUT FOUND,
 IF FOUND THEN
  DUPLICATE_CONSTANT N$
  RETURN
 ENDIF
 SPLAY_INSERT% CMP_CONSTTBL,N$,NEW_CONST(C)
END
DEF COMPILE_END A
 EMIT_END
END
DEF COMPILE_CONST A
 VAR I=AST_NEXT[AST_A1[A]]
 WHILE I
  VAR NAME$=AST$[I]
  VAR EXPR=FOLD_CONSTEXPR(AST_A1[I])
  CASE AST_TYP[EXPR]
  WHEN #AST_IMM_INT
   ADD_CONST NAME$,AST%[EXPR]
  WHEN #AST_IMM_DBL
   ADD_CONST NAME$,AST#[EXPR]
  WHEN #AST_IMM_STR
   ADD_CONST NAME$,AST$[EXPR]
  OTHERWISE
   SYNTAX_ERROR "CONST"
  ENDCASE
  I=AST_NEXT[I]
 WEND
END
DEF COMPILE_ENUM A
 VAR I=AST_NEXT[AST_A1[A]]
 VAR C%
 WHILE I
  VAR NAME$=AST$[I]
  VAR EXPR=FOLD_CONSTEXPR(AST_A1[I])
  IF!EXPR THEN
   ADD_CONST NAME$,C%
   INC C%
  ELSE
   CASE AST_TYP[EXPR]
   WHEN #AST_IMM_INT
    C%=AST%[EXPR]
    ADD_CONST NAME$,C%
    INC C%
   WHEN #AST_IMM_DBL
   WHEN #AST_IMM_STR
    SYNTAX_ERROR "TYPE MISMATCH"
   OTHERWISE
    SYNTAX_ERROR "ENUM"
   ENDCASE
  ENDIF
  I=AST_NEXT[I]
 WEND
END
DEF COMPILE_DEFVAR A
 'A1:LIST
  '$:NAME
  'A1:INIT EXPR
  'A2:ARRAY DIM
  'A3:ARRAY INIT LIST 
 'LEFT TO RIGHT
 VAR I=AST_NEXT[AST_A1[A]]
 WHILE I
  VAR NAME$=AST$[I]
  VAR IDX,LOCAL,ARY
  IF AST_A2[I] THEN
   ARY=#TRUE
  ENDIF
  DEFINE_VAR NAME$,ARY OUT IDX,LOCAL
  IF AST_A1[I] THEN
   COMPILE_EXPR AST_A1[I]
   'FIXME:EXTRACT FUNCTION
   IF LOCAL THEN
    EMIT_PUSHLVARREF IDX
   ELSE
    EMIT_PUSHVARREF IDX
   ENDIF
   EMIT_ASSIGN
  ELSEIF ARY THEN
   'RIGHT TO LEFT
   VAR DM=COMPILE_ARRAY_INDEX_EXPR(AST_A2[I])
   IF DM==0THEN
    DM=1
    EMIT_PUSHINT AST_GET_ITEM_COUNT(AST_A3[I])
   ENDIF
   EMIT_NEWARRAY DM,DETER_VAR_TYPE(NAME$,#TRUE)
   IF LOCAL THEN
    EMIT_PUSHLVARREF IDX
   ELSE
    EMIT_PUSHVARREF IDX
   ENDIF
   EMIT_ASSIGN
   IF AST_A3[I]THEN
    'RIGHT TO LEFT
    VAR INITCOUNT=COMPILE_ARRAY_INDEX_EXPR(AST_A3[I])
    IF LOCAL THEN
     EMIT_PUSHLVARREF IDX
    ELSE
     EMIT_PUSHVARREF IDX
    ENDIF
    EMIT_REF
    EMIT_INITARRAY INITCOUNT
   ENDIF
  ENDIF
  I=AST_NEXT[I]
 WEND
END
'RET:DIM
DEF AST_GET_ITEM_COUNT(A)
 IF!A THEN RETURN 0
 VAR I=AST_NEXT[A]
 VAR CNT
 WHILE I
  INC CNT
  I=AST_NEXT[I]
 WEND
 RETURN CNT
END
DEF COMPILE_ARRAY_INDEX_EXPR(A)
 VAR I=AST_PREV[A]
 VAR DM
 WHILE I!=A
  INC DM
  COMPILE_EXPR AST_A1[I]
  I=AST_PREV[I]
 WEND
 RETURN DM
END
CONST #VM_LVAROFF=-7
DEF COMPILE_RETURNFUNC A
 VAR EXPR=AST_LEFT[A]
 IF EXPR THEN
  COMPILE_EXPR EXPR
  EMIT_PUSHLVARREF #VM_LVAROFF-FUNC_INCNT[CMP_CURFUNC]
  EMIT_ASSIGN
 ENDIF
 EMIT_RETURNFUNC
END
DEF COMPILE_DEF A
 '$:NAME
 'A1:IN LIST
 'A2:OUT LIST
 'A3:STATEMENTS
 'A4:HAS RETURN VALUE
 VAR SKIP=EMIT_BR()
 VAR FN$=AST$[A]
 VAR INCNT
 VAR I
 VAR OUTCNT
 VAR CMN
 INCNT=AST_GET_ITEM_COUNT(AST_A1[A])
 OUTCNT=AST_GET_ITEM_COUNT(AST_A2[A])
 IF AST_A4[A]AND #AST_DEF_A4_HAS_RET_VAL THEN
  INC OUTCNT
 ENDIF
 IF AST_A4[A]AND #AST_DEF_A4_OUT_VAARGS THEN
  INCNT=-1
 ENDIF
 IF AST_A4[A]AND #AST_DEF_A4_IN_VAARGS THEN
  OUTCNT=-1
 ENDIF
 IF AST_A4[A]AND #AST_DEF_A4_COMMON_DEF THEN
  CMN=#TRUE
 ENDIF
 CMP_CURFUNC=DEFINE_FUNC(FN$,COMPILER_CURRENT_ADDR(),INCNT,OUTCNT,CMN)
 I=AST_NEXT[AST_A1[A]]
 VAR IDX=#VM_LVAROFF+1
 WHILE I
  DEC IDX
  DEFINE_LOCAL_VAR CMP_CURFUNC,AST$[I],IDX
  I=AST_NEXT[I]
 WEND
 I=AST_PREV[AST_A2[A]]
 WHILE I!=AST_A2[A]
  DEC IDX
  DEFINE_LOCAL_VAR CMP_CURFUNC,AST$[I],IDX
  I=AST_PREV[I]
 WEND
 COMPILE_STATEMENTS AST_A3[A]
 EMIT_RETURNFUNC
 EMIT_ADDR SKIP
 CMP_CURFUNC=0
END
DEF DEFINE_LOCAL_VAR FUNC,V$,IDX
 VAR FOUND
 SPLAY_GET% FUNC_VARTBL[FUNC],V$ OUT FOUND,
 IF FOUND THEN
  'NO ERROR!?
  'IF VER<4.0.2 THEN RETURN
  DUPLICATE_VARIABLE V$
  RETURN
 ENDIF
 SPLAY_INSERT% FUNC_VARTBL[FUNC],V$,NEW_VAR(IDX,#VMT_DEFAULT)
END
DEF DEFINE_FUNC(FN$,ADDR,INCNT,OUTCNT,CMN)
 VAR FOUND
 SPLAY_GET% CMP_FUNCTBL,FN$ OUT FOUND,
 IF FOUND THEN
  DUPLICATE_FUNC FN$
 ENDIF
 VAR F=NEW_FUNC(ADDR,INCNT,OUTCNT,CMP_SLOT)
 SPLAY_INSERT% CMP_FUNCTBL,FN$,F
 IF CMN THEN
  VM_DEFINE_COMMON_DEF FN$,F
 ENDIF
 RETURN F
END
DEF COMPILE_CALLFUNC A
 'A1:IN ARGS
 'A2:OUT ARGS
 VAR FN$=AST$[A]
 VAR INCNT=0
 VAR I
 VAR OUTCNT
 IF AST_TYP[A]==#AST_CALLFUNC THEN
  OUTCNT=AST_GET_ITEM_COUNT(AST_A2[A])
 ELSE
  OUTCNT=1
 ENDIF
 EMIT_PUSHEMPTY OUTCNT
 I=AST_PREV[AST_A1[A]]
 WHILE I!=AST_A1[A]
  COMPILE_EXPR AST_A1[I]
  I=AST_PREV[I]
  INC INCNT
 WEND
 EMIT_CALLFUNC FN$,INCNT,OUTCNT
 IF AST_TYP[A]==#AST_CALLFUNC THEN
  I=AST_PREV[AST_A2[A]]
  WHILE I!=AST_A2[A]
   COMPILE_REFEXPR AST_A1[I]
   EMIT_ASSIGN
   I=AST_PREV[I]
   INC OUTCNT
  WEND
 ENDIF
END
DEF COMPILE_IF A
 COMPILE_EXPR AST_A1[A]
 VAR ADDR_ELSE=EMIT_BRFALSE()
 COMPILE_STATEMENTS AST_A2[A]
 IF AST_A4[A]THEN
  VAR ADDR_ENDIF=EMIT_BR()
 ENDIF
 EMIT_ADDR ADDR_ELSE
 IF AST_A3[A]THEN'ELSEIF
  DIM BRLIST[0]
  VAR I=AST_NEXT[AST_A3[A]]
  WHILE I
   COMPILE_EXPR AST_A1[I]
   VAR ADDR_AFTER_ELSEIF=EMIT_BRFALSE()
   COMPILE_STATEMENTS AST_A2[I]
   I=AST_NEXT[I]
   PUSH BRLIST,EMIT_BR()
   EMIT_ADDR ADDR_AFTER_ELSEIF
  WEND
 ENDIF
 IF AST_A4[A]THEN'ELSE
  COMPILE_STATEMENTS AST_A4[A]
  EMIT_ADDR ADDR_ENDIF
 ENDIF
 IF AST_A3[A]THEN'ELSEIF
  FOR I=0TO LAST(BRLIST)
   EMIT_ADDR BRLIST[I]
  NEXT
 ENDIF
END
DEF COMPILE_CONTINUE
 IF TYPEOF(CMP_CONTINUE)!=#T_INTARRAY THEN
  SYNTAX_ERROR
  RETURN
 ENDIF
 PUSH CMP_CONTINUE,EMIT_BR()
END
DEF COMPILE_BREAK
 IF TYPEOF(CMP_CONTINUE)!=#T_INTARRAY THEN
  SYNTAX_ERROR
  RETURN
 ENDIF
 PUSH CMP_BREAK,EMIT_BR()
END
DEF COMPILE_FOR A
 'A1:INDEXREFEXPR
 'A2:INITEXPR
 'A3:TOEXPR
 'A4:STEPEXPR
 'A5:STATEMENTS
 VAR INDEXREF=AST_A1[A]
 VAR INITEXPR=AST_A2[A]
 VAR TOEXPR=AST_A3[A]
 VAR STEPEXPR=AST_A4[A]
 VAR STATEMENTS=AST_A5[A]
 COMPILE_EXPR INITEXPR
 COMPILE_REFEXPR INDEXREF
 EMIT_ASSIGN
 'FOR INDEXREF=INITEXPR TO TOEXPR STEP STEPEXPR
 'PUSH INITEXPR
 'PUSH INDEXREF
 'ASSIGN
 '@CONT
 'PUSH INDEXREF
 'PUSH STEPEXPR
 'PUSH TOEXPR
 '*FOR STEP INSTR* @BRK
 'STATEMENTS... (GOTO @CONT,@BRK
 'GOTO @CONT
 '@BRK


 'FOR INDEXREF=INITEXPR TO TOEXPR
 'PUSH INITEXPR
 'PUSH INDEXREF
 'ASSIGN
 '@CONT
 'PUSH INDEXREF
 'PUSH TOEXPR
 '*FOR INSTR* @BRK
 'STATEMENTS... (GOTO @CONT,@BRK
 'GOTO @CONT
 '@BRK
 COMPILE_REFEXPR INDEXREF
 IF STEPEXPR THEN
  COMPILE_EXPR STEPEXPR
 ELSE
  EMIT_PUSHINT 1
 ENDIF
 COMPILE_EXPR TOEXPR
 VAR BRKADDR
 BRKADDR=EMIT_FORINIT()
 VAR LOOPADDR=COMPILER_CURRENT_ADDR()
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  COMPILE_STATEMENTS STATEMENTS
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   EMIT_ADDR CMP_CONTINUE[I]
  NEXT
  COMPILE_REFEXPR INDEXREF
  IF STEPEXPR THEN
   COMPILE_EXPR STEPEXPR
  ELSE
   EMIT_PUSHINT 1
  ENDIF
  COMPILE_EXPR TOEXPR
  VAR BRKADDR2
  BRKADDR2=EMIT_FOR()
  EMIT_ADDR BRKADDR
  EMIT_ADDR2 BRKADDR2,LOOPADDR
  FOR I=0TO LAST(CMP_BREAK)
   EMIT_ADDR CMP_BREAK[I]
  NEXT
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF COMPILE_WHILE A
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  VAR CONTADDR=COMPILER_CURRENT_ADDR()
  COMPILE_EXPR AST_A1[A]
  VAR BRL=EMIT_BRFALSE()
  COMPILE_STATEMENTS AST_A2[A]
  EMIT_ADDR2 EMIT_BR(),CONTADDR
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   EMIT_ADDR2 CMP_CONTINUE[I],CONTADDR
  NEXT
  FOR I=0TO LAST(CMP_BREAK)
   EMIT_ADDR CMP_BREAK[I]
  NEXT
  EMIT_ADDR BRL
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF COMPILE_REPEAT A
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  VAR LOOPADDR=COMPILER_CURRENT_ADDR()
  COMPILE_STATEMENTS AST_A2[A]
  VAR CONTADDR=COMPILER_CURRENT_ADDR()
  COMPILE_EXPR AST_A1[A]
  EMIT_ADDR2 EMIT_BRFALSE(),LOOPADDR
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   EMIT_ADDR2 CMP_CONTINUE[I],CONTADDR
  NEXT
  FOR I=0TO LAST(CMP_BREAK)
   EMIT_ADDR CMP_BREAK[I]
  NEXT
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF COMPILE_LOOP A
 VAR OLDC=CMP_CONTINUE
 VAR OLDB=CMP_BREAK
  CMP_CONTINUE=ARRAY%(0)
  CMP_BREAK=ARRAY%(0)
  VAR CONTADDR=COMPILER_CURRENT_ADDR()
  COMPILE_STATEMENTS AST_A2[A]
  EMIT_ADDR2 EMIT_BR(),CONTADDR
  VAR I
  FOR I=0TO LAST(CMP_CONTINUE)
   EMIT_ADDR2 CMP_CONTINUE[I],CONTADDR
  NEXT
  FOR I=0TO LAST(CMP_BREAK)
   EMIT_ADDR CMP_BREAK[I]
  NEXT
 CMP_CONTINUE=OLDC
 CMP_BREAK=OLDB
END
DEF COMPILE_REFEXPR A
 CASE AST_TYP[A]
 WHEN #AST_VAR
  VAR IDX,LC
  GET_VAR_INDEX AST$[A] OUT IDX,LC
  IF LC THEN
   EMIT_PUSHLVARREF IDX
  ELSE
   EMIT_PUSHVARREF IDX
  ENDIF
 WHEN #AST_EMPTYEXPR
  EMIT_PUSHEMPTYREF
 WHEN #AST_BINOP
  VAR TYP=AST%[A]
  IF TYP!=#TKN_LB THEN
   SYNTAX_ERROR "EXPECTED '['"
   RETURN
  ENDIF
  VAR DM=COMPILE_ARRAY_INDEX_EXPR(AST_RIGHT[A])
  COMPILE_EXPR AST_LEFT[A]
  EMIT_PUSHARYREF DM
 OTHERWISE
  COMPILE_ERROR
 ENDCASE
END
DEF COMPILE_EXPR A
 CASE AST_TYP[A]
 WHEN #AST_BINOP
  VAR TYP=AST%[A]
  IF TYP==#TKN_LAND THEN
   COMPILE_EXPR AST_LEFT[A]
   VAR BR1=EMIT_BRAND()
   COMPILE_EXPR AST_RIGHT[A]
   VAR BR2=EMIT_BRAND()
   EMIT_PUSHINT #TRUE
   EMIT_ADDR BR1
   EMIT_ADDR BR2
  ELSEIF TYP==#TKN_LOR THEN
   COMPILE_EXPR AST_LEFT[A]
   BR1=EMIT_BROR()
   COMPILE_EXPR AST_RIGHT[A]
   BR2=EMIT_BROR()
   EMIT_PUSHINT #FALSE
   EMIT_ADDR BR1
   EMIT_ADDR BR2
  ELSEIF TYP==#TKN_LB THEN
   VAR DM=COMPILE_ARRAY_INDEX_EXPR(AST_RIGHT[A])
   COMPILE_EXPR AST_LEFT[A]
   EMIT_PUSHARYREF DM
   EMIT_REF
  ELSE
   COMPILE_EXPR AST_LEFT[A]
   COMPILE_EXPR AST_RIGHT[A]
   EMIT_BINOP AST%[A]
  ENDIF
 WHEN #AST_IMM_INT
  EMIT_PUSHINT AST%[A]
 WHEN #AST_IMM_DBL
  EMIT_PUSHDBL AST#[A]
 WHEN #AST_IMM_STR
  EMIT_PUSHSTR AST$[A]
 WHEN #AST_VAR
  COMPILE_REFEXPR A
  EMIT_REF
 WHEN #AST_CALLFUNCEXPR
  COMPILE_CALLFUNC A
 WHEN #AST_CONSTVAR
  COMPILE_EXPR FOLD_CONSTEXPR(A)
 WHEN #AST_UNAOP
  COMPILE_EXPR AST_LEFT[A]
  EMIT_UNAOP AST%[A]
 WHEN #AST_EMPTYEXPR
  EMIT_PUSHEMPTY 1
 OTHERWISE
  ?AST_STR$(AST_TYP[A])
  COMPILE_ERROR
 ENDCASE
END
DEF COMPILE_LABEL A
 DEFINE_LABEL AST$[A]
END
DEF COMPILE_GOTO A
 EMIT_GOTO_PLACEHOLDER AST$[A]
END
DEF COMPILE_GOSUB A
 EMIT_GOSUB_PLACEHOLDER AST$[A]
END
DEF COMPILE_RETURN A
 EMIT_RETURN
END
DIM VM_OPS[]
DIM VMDBG_LINE_PC[]
DIM VMDBG_LINE[]
DIM VMDBG_LINE_POS[]
DIM VM_IMM#[]
DIM VM_IMM$[]

DIM VM_EXEC[]
DIM VM_STK_TYP[]
DIM VM_STK%[]
DIM VM_STK#[]
DIM VM_STK$[]
VAR VM_STK_SIZE
VAR VM_SP
VAR VM_BP
DIM VM_GVAR_TYP[]
DIM VM_GVAR%[]
DIM VM_GVAR#[]
DIM VM_GVAR$[]
VAR VM_GLBLTBL
VAR VM_GVARTBL
VAR VM_CFUNCTBL
VAR VM_FUNCTBL
VAR VM_PC
VAR VM_PREV_PC

DIM VM_DATA_TYP[]
DIM VM_DATA%[]
DIM VM_DATA#[]
DIM VM_DATA$[]
DIM VM_DATA_IDX
VAR VM_CURFUNC
VAR VM_CURSLOT
VAR VM_CURDATASLOT

VAR VM_ALLOC_ARRAY
DEF VM_ALLOC_ARRAY(ARY)
 IF TYPEOF(ARY)==1 THEN
  STOP
 ENDIF
 VAR S=AllocSBArray()
'?"Akic!";S
 SetSBArray S,ARY
 RETURN S
 SPVAR #GSPRITE,VM_ALLOC_ARRAY,ARY
 INC VM_ALLOC_ARRAY
 RETURN VM_ALLOC_ARRAY-1
END
DEF VM_FREE_ARRAY ARY
 FreeSBArray ARY
' SPVAR #GSPRITE,ARY,EMPTY()
END
DEF VM_GET_ARRAY(ARY)
 RETURN GetSBArray(ARY)
 RETURN SPVAR(#GSPRITE,ARY)
END

DEF VM_GETFREE_ARRAY(ARY)
'?"free!";ARY
 VAR B=GetSBArray(ARY)
 FreeSBArray ARY
 RETURN B
 VAR A=SPVAR(#GSPRITE,ARY)
' SPVAR #GSPRITE,ARY,EMPTY()
 RETURN A
END

DIM VM_SLOT_OPS[]
DIM VMDBG_SLOT_LINE[]
DIM VMDBG_SLOT_LINE_PC[]
DIM VMDBG_SLOT_LINE_POS[]
DIM VM_SLOT_IMM#[]
DIM VM_SLOT_IMM$[]
DIM VM_SLOT_GVARTBL[]
DIM VM_SLOT_GLBLTBL[]
DIM VM_SLOT_FUNCTBL[]
DIM VM_SLOT_GVAR_TYP[]
DIM VM_SLOT_GVAR%[]
DIM VM_SLOT_GVAR#[]
DIM VM_SLOT_GVAR$[]
DIM VM_SLOT_DATA_TYP[]
DIM VM_SLOT_DATA%[]
DIM VM_SLOT_DATA#[]
DIM VM_SLOT_DATA$[]
DEF VM_SWITCH_SLOT SLOT
 VM_OPS=VM_GET_ARRAY(VM_SLOT_OPS[SLOT])
 VM_IMM#=VM_GET_ARRAY(VM_SLOT_IMM#[SLOT])
 VM_IMM$=VM_GET_ARRAY(VM_SLOT_IMM$[SLOT])
 VM_GVAR_TYP=VM_GET_ARRAY(VM_SLOT_GVAR_TYP[SLOT])
 VM_GVAR%=VM_GET_ARRAY(VM_SLOT_GVAR%[SLOT])
 VM_GVAR#=VM_GET_ARRAY(VM_SLOT_GVAR#[SLOT])
 VM_GVAR$=VM_GET_ARRAY(VM_SLOT_GVAR$[SLOT])
 VM_GVARTBL=VM_SLOT_GVARTBL[SLOT]
 VM_GLBLTBL=VM_SLOT_GLBLTBL[SLOT]
 VM_FUNCTBL=VM_SLOT_FUNCTBL[SLOT]
END
DEF VM_SWITCH_SLOT_DATA SLOT
 VM_DATA_TYP=VM_GET_ARRAY(VM_SLOT_DATA_TYP[SLOT])
 VM_DATA%=VM_GET_ARRAY(VM_SLOT_DATA%[SLOT])
 VM_DATA#=VM_GET_ARRAY(VM_SLOT_DATA#[SLOT])
 VM_DATA$=VM_GET_ARRAY(VM_SLOT_DATA$[SLOT])
END
DEF INIT_VM_CODEGEN
 VM_OPS=ARRAY%(0)
 VM_IMM#=ARRAY#(0)
 VM_IMM$=ARRAY$(0)
 VMDBG_LINE=ARRAY%(0)
 VMDBG_LINE_PC=ARRAY%(0)
 VMDBG_LINE_POS=ARRAY%(0)
END
DEF INIT_VM
 VM_STK_SIZE=65536
 VM_STK_TYP=ARRAY%(VM_STK_SIZE)
 VM_STK%=ARRAY%(VM_STK_SIZE)
 VM_STK#=ARRAY#(VM_STK_SIZE)
 VM_STK$=ARRAY$(VM_STK_SIZE)
 VM_PC=0
 VM_DATA_IDX=0
 VM_CURFUNC=0
 VM_BP=0
 VM_SP=0
 INIT_COMPILER_VAR
 INIT_COMPILER_LABEL
 INIT_COMPILER_FUNC
 OTX_INIT_SBARRAY
 VM_CFUNCTBL=NEW_SPLAY_TREE()

 VM_CURSLOT=0
 VM_CURDATASLOT=0
 VAR MAX_SLOT=4
 VM_SLOT_OPS=ARRAY%(MAX_SLOT)
 VMDBG_SLOT_LINE=ARRAY%(MAX_SLOT)
 VMDBG_SLOT_LINE_PC=ARRAY%(MAX_SLOT)
 VMDBG_SLOT_LINE_POS=ARRAY%(MAX_SLOT)
 VM_SLOT_IMM#=ARRAY%(MAX_SLOT)
 VM_SLOT_IMM$=ARRAY%(MAX_SLOT)
 VM_SLOT_GVARTBL=ARRAY%(MAX_SLOT)
 VM_SLOT_GLBLTBL=ARRAY%(MAX_SLOT)
 VM_SLOT_FUNCTBL=ARRAY%(MAX_SLOT)
 VM_SLOT_GVAR_TYP=ARRAY%(MAX_SLOT)
 VM_SLOT_GVAR%=ARRAY%(MAX_SLOT)
 VM_SLOT_GVAR#=ARRAY%(MAX_SLOT)
 VM_SLOT_GVAR$=ARRAY%(MAX_SLOT)
 VM_SLOT_DATA_TYP=ARRAY%(MAX_SLOT)
 VM_SLOT_DATA%=ARRAY%(MAX_SLOT)
 VM_SLOT_DATA#=ARRAY%(MAX_SLOT)
 VM_SLOT_DATA$=ARRAY%(MAX_SLOT)
 VM_EXEC=ARRAY%(0)
END
DEF VM_RESET
 INIT_VM
END
DEF INIT_VM_GLOBAL_VAR TYPA,N
 IF !N THEN RETURN
 INIT_VM_GLOBAL_VAR TYPA,GET_SPLAYN_LEFT(N)
 VAR K$=GET_SPLAYN_KEY$(N)
 VAR V=GET_SPLAYN_VAL%(N)
 TYPA[VAR_IDX[V]]=VAR_TYP[V]
 INIT_VM_GLOBAL_VAR TYPA,GET_SPLAYN_RIGHT(N)
END
DEF LOAD_VM_SLOT SLOT
 VAR TYP=ARRAY%(CMP_GVARNUM)
 VAR G%=ARRAY%(CMP_GVARNUM)
 VAR G#=ARRAY#(CMP_GVARNUM)
 VAR G$=ARRAY$(CMP_GVARNUM)
 VM_SLOT_OPS[SLOT]=VM_ALLOC_ARRAY(VM_OPS)
 VMDBG_SLOT_LINE[SLOT]=VM_ALLOC_ARRAY(VMDBG_LINE)
 VMDBG_SLOT_LINE_PC[SLOT]=VM_ALLOC_ARRAY(VMDBG_LINE_PC)
 VMDBG_SLOT_LINE_POS[SLOT]=VM_ALLOC_ARRAY(VMDBG_LINE_POS)
 VM_SLOT_IMM#[SLOT]=VM_ALLOC_ARRAY(VM_IMM#)
 VM_SLOT_IMM$[SLOT]=VM_ALLOC_ARRAY(VM_IMM$)
 VM_SLOT_GVAR_TYP[SLOT]=VM_ALLOC_ARRAY(TYP)
 VM_SLOT_GVAR%[SLOT]=VM_ALLOC_ARRAY(G%)
 VM_SLOT_GVAR#[SLOT]=VM_ALLOC_ARRAY(G#)
 VM_SLOT_GVAR$[SLOT]=VM_ALLOC_ARRAY(G$)
 INIT_VM_GLOBAL_VAR TYP,GET_SPLAY_ROOT(CMP_GVARTBL)
 VM_SLOT_GLBLTBL[SLOT]=CMP_GLBLTBL
 VM_SLOT_FUNCTBL[SLOT]=CMP_FUNCTBL
 VM_SLOT_GVARTBL[SLOT]=CMP_GVARTBL
 VM_SLOT_DATA_TYP[SLOT]=VM_ALLOC_ARRAY(CMP_DATA_TYP)
 VM_SLOT_DATA%[SLOT]=VM_ALLOC_ARRAY(CMP_DATA%)
 VM_SLOT_DATA#[SLOT]=VM_ALLOC_ARRAY(CMP_DATA#)
 VM_SLOT_DATA$[SLOT]=VM_ALLOC_ARRAY(CMP_DATA$)
END
VAR VM_REPL_NEW_VAR_IDX
DEF INIT_COMPILER_REPL
 IF TYPEOF(VM_GVAR_TYP)==#T_DEFAULT THEN
  INIT_COMPILER 0
  RETURN
 ENDIF
 VMDBG_LINE=ARRAY%(0)
 VMDBG_LINE_PC=ARRAY%(0)
 VMDBG_LINE_POS=ARRAY%(0)
 CMP_DATA_TYP=VM_DATA_TYP
 CMP_DATA%=VM_DATA%
 CMP_DATA#=VM_DATA#
 CMP_DATA$=VM_DATA$
 CMP_GLBLTBL=VM_GLBLTBL
 CMP_FUNCTBL=VM_FUNCTBL
 CMP_GVARTBL=VM_GVARTBL
 CMP_GVARNUM=LEN(VM_GVAR_TYP)
 VM_REPL_NEW_VAR_IDX=CMP_GVARNUM
 CMP_STRICT=#FALSE
 CMP_DEFINT=#FALSE
 CMP_BREAK=EMPTY()
 CMP_CONTINUE=EMPTY()
 CMP_SLOT=VM_CURSLOT
 VM_PC=LEN(VM_OPS)
END

DEF INIT_VM_GLOBAL_VAR_REPL NEW_VAR_IDX,TYPA,N
 IF !N THEN RETURN
 INIT_VM_GLOBAL_VAR_REPL NEW_VAR_IDX,TYPA,GET_SPLAYN_LEFT(N)
 VAR V=GET_SPLAYN_VAL%(N)
 IF VAR_IDX[V]>=NEW_VAR_IDX THEN
  VAR K$=GET_SPLAYN_KEY$(N)
  TYPA[VAR_IDX[V]]=VAR_TYP[V]
 ENDIF
 INIT_VM_GLOBAL_VAR_REPL NEW_VAR_IDX,TYPA,GET_SPLAYN_RIGHT(N)
END
DEF LOAD_VM_SLOT_REPL
 IF TYPEOF(VM_GVAR_TYP)==#T_DEFAULT THEN
  LOAD_VM_SLOT 0
  VM_RUN_SLOT 0
  RETURN
 ENDIF
 VAR NEW_VAR_IDX=LEN(VM_GVAR_TYP)
 RESIZE VM_GVAR_TYP,CMP_GVARNUM
 RESIZE VM_GVAR%,CMP_GVARNUM
 RESIZE VM_GVAR#,CMP_GVARNUM
 RESIZE VM_GVAR$,CMP_GVARNUM
 INIT_VM_GLOBAL_VAR_REPL NEW_VAR_IDX,VM_GVAR_TYP,GET_SPLAY_ROOT(CMP_GVARTBL)
END

DEF VM_DEFINE_COMMON_DEF N$,FUNC
 VAR FOUND
 SPLAY_GET% VM_CFUNCTBL,N$ OUT FOUND,
 IF FOUND THEN
  DUPLICATE_FUNCTION N$
  RETURN
 ENDIF
 SPLAY_INSERT% VM_CFUNCTBL,N$,FUNC
END

DEF VM_RUN_SLOT SLOT
 VM_SWITCH_SLOT SLOT
 VM_SWITCH_SLOT_DATA SLOT
 VM_PC=0
 VM_PREV_PC=0
 VM_DATA_IDX=0
 VM_CURFUNC=0
 VM_BP=0
 VM_SP=0
 VM_CURSLOT=SLOT
 VM_CURDATASLOT=SLOT
END

ENUM\
 #VM_NOP,\
 #VM_PUSHINT,\
 #VM_PUSHDBL,\
 #VM_PUSHSTR,\
 #VM_BINOP,\
 #VM_PRINT,\
 #VM_TPRINT,\
 #VM_ASSIGN,\
 #VM_PUSHVARREF,\
 #VM_PUSHLVARREF,\
 #VM_REF,\
 #VM_BR,\
 #VM_BRTRUE,\
 #VM_BRFALSE,\
 #VM_FOR,\
 #VM_FORINIT,\
 #VM_BRAND,\
 #VM_BROR,\
 #VM_GOTO_PLACEHOLDER,\
 #VM_GOSUB_PLACEHOLDER,\
 #VM_GOSUB,\
 #VM_GOTOEXPR,\
 #VM_GOSUBEXPR,\
 #VM_ONGOTO,\
 #VM_ONGOSUB,\
 #VM_RETURN,\
 #VM_CALLFUNC,\
 #VM_PUSHEMPTY,\
 #VM_RETURNFUNC,\
 #VM_PUSHEMPTYREF,\
 #VM_PUSHARYREF,\
 #VM_END,\
 #VM_NEWARRAY,\
 #VM_INITARRAY,\
 #VM_READ,\
 #VM_RESTORE,\
 #VM_RESTORE_PLACEHOLDER,\
 #VM_RESTOREEXPR,\
 #VM_UNAOP,\
 #VM_CALLSPRITE,\
 #VM_CALLTEXT,\
 #VM_INC,\
 #VM_DEC,\
 #VM_POP,\
 #VM_WHEN,\
 #VM_SWAP,\
 #VM_INPUT,\
 #VM_LINPUT,\
 #VM_DEFOUT,\
 #VM_EXEC1,\
 #VM_EXEC2,\
 #VM_STOP1,\
 #VM_STOP2,\
 #VM_,\
 #VM_LAST

DEF VM_STR$(T)
 CASE T
 WHEN #VM_NOP:RETURN "#VM_NOP"WHEN #VM_PUSHINT:RETURN "#VM_PUSHINT"WHEN #VM_PUSHDBL:RETURN "#VM_PUSHDBL"WHEN #VM_PUSHSTR:RETURN "#VM_PUSHSTR"WHEN #VM_BINOP:RETURN "#VM_BINOP"WHEN #VM_PRINT:RETURN "#VM_PRINT"WHEN #VM_TPRINT:RETURN "#VM_TPRINT"WHEN #VM_ASSIGN:RETURN "#VM_ASSIGN"WHEN #VM_PUSHVARREF:RETURN "#VM_PUSHVARREF"WHEN #VM_PUSHLVARREF:RETURN "#VM_PUSHLVARREF"WHEN #VM_REF:RETURN "#VM_REF"WHEN #VM_BR:RETURN "#VM_BR"WHEN #VM_BRTRUE:RETURN "#VM_BRTRUE"WHEN #VM_BRFALSE:RETURN "#VM_BRFALSE"WHEN #VM_FOR:RETURN "#VM_FOR"WHEN #VM_FORINIT:RETURN "#VM_FORINIT"WHEN #VM_BRAND:RETURN "#VM_BRAND"WHEN #VM_BROR:RETURN "#VM_BROR"WHEN #VM_GOTO_PLACEHOLDER:RETURN "#VM_GOTO_PLACEHOLDER"WHEN #VM_GOSUB_PLACEHOLDER:RETURN "#VM_GOSUB_PLACEHOLDER"WHEN #VM_GOSUB:RETURN "#VM_GOSUB"WHEN #VM_GOTOEXPR:RETURN "#VM_GOTOEXPR"WHEN #VM_GOSUBEXPR:RETURN "#VM_GOSUBEXPR"WHEN #VM_ONGOTO:RETURN "#VM_ONGOTO"WHEN #VM_ONGOSUB:RETURN "#VM_ONGOSUB"WHEN #VM_RETURN:RETURN "#VM_RETURN"WHEN #VM_CALLFUNC:RETURN "#VM_CALLFUNC"WHEN #VM_PUSHEMPTY:RETURN "#VM_PUSHEMPTY"WHEN #VM_RETURNFUNC:RETURN "#VM_RETURNFUNC"WHEN #VM_PUSHEMPTYREF:RETURN "#VM_PUSHEMPTYREF"WHEN #VM_PUSHARYREF:RETURN "#VM_PUSHARYREF"WHEN #VM_END:RETURN "#VM_END"WHEN #VM_NEWARRAY:RETURN "#VM_NEWARRAY"WHEN #VM_INITARRAY:RETURN "#VM_INITARRAY"WHEN #VM_READ:RETURN "#VM_READ"WHEN #VM_RESTORE:RETURN "#VM_RESTORE"WHEN #VM_RESTORE_PLACEHOLDER:RETURN "#VM_RESTORE_PLACEHOLDER"WHEN #VM_RESTOREEXPR:RETURN "#VM_RESTOREEXPR"WHEN #VM_UNAOP:RETURN "#VM_UNAOP"WHEN #VM_CALLSPRITE:RETURN "#VM_CALLSPRITE"WHEN #VM_CALLTEXT:RETURN "#VM_CALLTEXT"WHEN #VM_INC:RETURN "#VM_INC"WHEN #VM_DEC:RETURN "#VM_DEC"WHEN #VM_POP:RETURN "#VM_POP"WHEN #VM_:RETURN "#VM_"WHEN #VM_LAST:RETURN "#VM_LAST" OTHERWISE
  RETURN "#VM_"+STR$(T)
 ENDCASE
END

'CODE GEN INTERFACE
DEF EMIT_PUSHINT V
 PUSH VM_OPS,#VM_PUSHINT
 PUSH VM_OPS,V
END
DEF VM_ADDIMMDBL(V#)
 PUSH VM_IMM#,V#
 RETURN LAST(VM_IMM#)
END
DEF VM_ADDIMMSTR(V$)
 PUSH VM_IMM$,V$
 RETURN LAST(VM_IMM$)
END
DEF EMIT_PUSHDBL V#
 PUSH VM_OPS,#VM_PUSHDBL
 PUSH VM_OPS,VM_ADDIMMDBL(V#)
END
DEF EMIT_PUSHSTR V$
 PUSH VM_OPS,#VM_PUSHSTR
 PUSH VM_OPS,VM_ADDIMMSTR(V$)
END
DEF EMIT_BINOP TYP
 PUSH VM_OPS,#VM_BINOP
 PUSH VM_OPS,TYP
END
DEF EMIT_PRINT TYP
 PUSH VM_OPS,#VM_PRINT
 PUSH VM_OPS,TYP
END
DEF EMIT_TPRINT TYP
 PUSH VM_OPS,#VM_TPRINT
 PUSH VM_OPS,TYP
END
DEF EMIT_PUSHVARREF IDX
 PUSH VM_OPS,#VM_PUSHVARREF
 PUSH VM_OPS,IDX
END
DEF EMIT_PUSHLVARREF IDX
 PUSH VM_OPS,#VM_PUSHLVARREF
 PUSH VM_OPS,IDX
END
DEF EMIT_REF
 PUSH VM_OPS,#VM_REF
END
DEF EMIT_ASSIGN
 PUSH VM_OPS,#VM_ASSIGN
END
DEF EMIT_BRFALSE()
 PUSH VM_OPS,#VM_BRFALSE
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_BRTRUE()
 PUSH VM_OPS,#VM_BRTRUE
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_BR()
 PUSH VM_OPS,#VM_BR
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_FOR()
 PUSH VM_OPS,#VM_FOR
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_FORINIT()
 PUSH VM_OPS,#VM_FORINIT
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_BRAND()
 PUSH VM_OPS,#VM_BRAND
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_BROR()
 PUSH VM_OPS,#VM_BROR
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_WHEN()
 PUSH VM_OPS,#VM_WHEN
 PUSH VM_OPS,&H7FFFFFFF
 RETURN LAST(VM_OPS)
END
DEF EMIT_ADDR ADDR
 VM_OPS[ADDR]=LEN(VM_OPS)
END
DEF EMIT_ADDR2 ADDR,ADDR2
 VM_OPS[ADDR]=ADDR2
END
DEF EMIT_GOTO_PLACEHOLDER LABEL$
 PUSH VM_OPS,#VM_GOTO_PLACEHOLDER
 PUSH VM_OPS,VM_ADDIMMSTR(LABEL$)
END
DEF EMIT_GOSUB_PLACEHOLDER LABEL$
 PUSH VM_OPS,#VM_GOSUB_PLACEHOLDER
 PUSH VM_OPS,VM_ADDIMMSTR(LABEL$)
END
DEF EMIT_RETURN
 PUSH VM_OPS,#VM_RETURN
END
DEF EMIT_CALLFUNC FN$,INCNT,OUTCNT
 PUSH VM_OPS,#VM_CALLFUNC
 PUSH VM_OPS,VM_ADDIMMSTR(FN$)
 PUSH VM_OPS,INCNT
 PUSH VM_OPS,OUTCNT
END
DEF EMIT_RETURNFUNC
 PUSH VM_OPS,#VM_RETURNFUNC
END
DEF EMIT_PUSHEMPTY N
 PUSH VM_OPS,#VM_PUSHEMPTY
 PUSH VM_OPS,N
END
DEF EMIT_PUSHEMPTYREF
 PUSH VM_OPS,#VM_PUSHEMPTYREF
END
DEF EMIT_END
 PUSH VM_OPS,#VM_END
END
DEF EMIT_NEWARRAY DM,TYP
 PUSH VM_OPS,#VM_NEWARRAY
 PUSH VM_OPS,DM
 PUSH VM_OPS,TYP
END
DEF EMIT_INITARRAY CNT
 PUSH VM_OPS,#VM_INITARRAY
 PUSH VM_OPS,CNT
END
DEF EMIT_PUSHARYREF DM
 PUSH VM_OPS,#VM_PUSHARYREF
 PUSH VM_OPS,DM
END
DEF EMIT_READ
 PUSH VM_OPS,#VM_READ
END
DEF EMIT_RESTORE_PLACEHOLDER LABEL$
 PUSH VM_OPS,#VM_RESTORE_PLACEHOLDER
 PUSH VM_OPS,VM_ADDIMMSTR(LABEL$)
END
DEF EMIT_RESTORE SLOT,ADDR
 PUSH VM_OPS,#VM_RESTORE
 PUSH VM_OPS,SLOT
 PUSH VM_OPS,ADDR
END
DEF EMIT_UNAOP TYP
 PUSH VM_OPS,#VM_UNAOP
 PUSH VM_OPS,TYP
END
DEF EMIT_CALLSPRITE
 PUSH VM_OPS,#VM_CALLSPRITE
END
DEF EMIT_CALLTEXT
 PUSH VM_OPS,#VM_CALLTEXT
END
DEF EMIT_RESTOREEXPR
 PUSH VM_OPS,#VM_RESTOREEXPR
END
DEF EMIT_GOTOEXPR
 PUSH VM_OPS,#VM_GOTOEXPR
END
DEF EMIT_GOSUBEXPR
 PUSH VM_OPS,#VM_GOSUBEXPR
END
DEF EMIT_INC
 PUSH VM_OPS,#VM_INC
END
DEF EMIT_DEC
 PUSH VM_OPS,#VM_DEC
END
DEF EMIT_POP N
 PUSH VM_OPS,#VM_POP
 PUSH VM_OPS,N
END
DEF EMIT_SWAP
 PUSH VM_OPS,#VM_SWAP
END
DEF EMIT_INPUT GUIDE,SEMI,CNT
 PUSH VM_OPS,#VM_INPUT
 PUSH VM_OPS,GUIDE
 PUSH VM_OPS,SEMI
 PUSH VM_OPS,CNT
END
DEF EMIT_LINPUT GUIDE
 PUSH VM_OPS,#VM_LINPUT
 PUSH VM_OPS,GUIDE
END
DEF EMIT_ONGOTO LBL$[],GSB
 IF!GSB THEN
  PUSH VM_OPS,#VM_ONGOTO
 ELSE
  PUSH VM_OPS,#VM_ONGOSUB
 ENDIF
 PUSH VM_OPS,LEN(LBL$)
 VAR I
 FOR I=0TO LAST(LBL$)
  PUSH VM_OPS,VM_ADDIMMSTR(LBL$[I])
 NEXT
END
DEF EMIT_DEFOUT
 PUSH VM_OPS,#VM_DEFOUT
END
DEF EMIT_EXEC1
 PUSH VM_OPS,#VM_EXEC1
END
DEF EMIT_EXEC2
 PUSH VM_OPS,#VM_EXEC2
END
DEF EMIT_STOP1
 PUSH VM_OPS,#VM_STOP1
END
DEF EMIT_STOP2
 PUSH VM_OPS,#VM_STOP2
END
DEF COMPILER_CURRENT_ADDR()
 RETURN LEN(VM_OPS)
END
DEF VMDBG_ADD_SRC_INFO LINE,POS
 PUSH VMDBG_LINE,LINE
 PUSH VMDBG_LINE_PC,LEN(VM_OPS)
 PUSH VMDBG_LINE_POS,POS
END

'CODE GEN INTERFACE END




'VM
DEF VM_PUSHINT V%
 VM_STK_TYP[VM_SP]=#VMT_INT
 VM_STK%[VM_SP]=V%
 INC VM_SP
END
DEF VM_PUSHDBL V#
 VM_STK_TYP[VM_SP]=#VMT_REAL
 VM_STK#[VM_SP]=V#
 INC VM_SP
END
DEF VM_PUSHSTR V$
 VM_STK_TYP[VM_SP]=#VMT_STR
 VM_STK$[VM_SP]=V$
 INC VM_SP
END
DEF VM_V(TYP,V)
 IF TYP==#VMT_INTARRAY||TYP==#VMT_REALARRAY||TYP==#VMT_STRARRAY THEN
  V=VM_ALLOC_ARRAY(V)
 ENDIF
 RETURN V
END
DEF VM_GETV(TYP,V)
 IF TYP==#VMT_INTARRAY||TYP==#VMT_REALARRAY||TYP==#VMT_STRARRAY THEN
  V=VM_GETFREE_ARRAY(V)
 ENDIF
 RETURN V
END
DEF VM_PUSHTYP V,TYP
 VM_STK_TYP[VM_SP]=TYP
 VAR A=VM_GETSTKARY(TYP)
 IF TYP==#VMT_INTARRAY||TYP==#VMT_REALARRAY||TYP==#VMT_STRARRAY THEN
  V=VM_ALLOC_ARRAY(V)
 ENDIF
 A[VM_SP]=V
 INC VM_SP
END
DEF VM_PUSH V
 CASE TYPEOF(V)
 WHEN #T_INT
  VM_STK_TYP[VM_SP]=#VMT_INT
  VM_STK%[VM_SP]=V
 WHEN #T_REAL
  VM_STK_TYP[VM_SP]=#VMT_REAL
  VM_STK#[VM_SP]=V
 WHEN #T_STR
  VM_STK_TYP[VM_SP]=#VMT_STR
  VM_STK$[VM_SP]=V
 WHEN #T_INTARRAY
  VM_STK_TYP[VM_SP]=#VMT_INTARRAY
  VM_STK%[VM_SP]=VM_ALLOC_ARRAY(V)
 WHEN #T_REALARRAY
  VM_STK_TYP[VM_SP]=#VMT_REALARRAY
  VM_STK%[VM_SP]=VM_ALLOC_ARRAY(V)
 WHEN #T_STRARRAY
  VM_STK_TYP[VM_SP]=#VMT_STRARRAY
  VM_STK%[VM_SP]=VM_ALLOC_ARRAY(V)
 OTHERWISE
  STOP
 ENDCASE
 INC VM_SP
END
DEF VM_POP * OUT T,V
 DEC VM_SP
 T=VM_STK_TYP[VM_SP]
 V=VM_GETSTKARY(T)[VM_SP]
 CASE T
 WHEN #VMT_INTARRAY
 WHEN #VMT_REALARRAY
 WHEN #VMT_STRARRAY
  IF DEFARGC()==1&&DEFARG(0)THEN
   V=VM_GET_ARRAY(V)
   RETURN
  ENDIF
  V=VM_GETFREE_ARRAY(V)
 ENDCASE
END
DEF VMINSTR_BINOP T
 VAR LT,LV
 VAR RT,RV
 VM_POP OUT RT,RV
 VM_POP OUT LT,LV
 CASE T
 WHEN #TKN_PLUS
  VM_PUSH LV+RV
 WHEN #TKN_MINUS
  VM_PUSH LV-RV
 WHEN #TKN_MUL
  VM_PUSH LV*RV
 WHEN #TKN_DIV
  VM_PUSH LV/RV
 WHEN #TKN_DIVINT
  VM_PUSH LV DIV RV
 WHEN #TKN_MOD
  VM_PUSH LV MOD RV
 WHEN #TKN_AND
  VM_PUSH LV AND RV
 WHEN #TKN_OR
  VM_PUSH LV OR RV
 WHEN #TKN_EQ
  VM_PUSH LV==RV
 WHEN #TKN_NEQ
  VM_PUSH LV!=RV
 WHEN #TKN_LSHIFT
  VM_PUSH LV<<RV
 WHEN #TKN_RSHIFT
  VM_PUSH LV>>RV
 WHEN #TKN_GREAT
  VM_PUSH LV<RV
 WHEN #TKN_LESS
  VM_PUSH LV>RV
 WHEN #TKN_GEQ
  VM_PUSH LV<=RV
 WHEN #TKN_LEQ
  VM_PUSH LV>=RV
 OTHERWISE
  STOP
 ENDCASE
END
DEF VMINSTR_UNAOP T
 VAR LT,LV
 VM_POP OUT LT,LV
 CASE T
 WHEN #TKN_MINUS
  VM_PUSH -LV
 WHEN #TKN_LNOT
  VM_PUSH !LV
 WHEN #TKN_NOT
  VM_PUSH NOT LV
 OTHERWISE
  STOP
 ENDCASE
END

DEF VM_PRINT IS_TPRINT,TYP
 VAR TP=#TCONSOLE
 VAR OFF=-2
 IF TYP==#VMPRINT_EMPTY THEN
  OFF=-1
 ENDIF
 IF IS_TPRINT THEN
  TP=VM_GETSTK(OFF)
 ENDIF
 IF TYP==#VMPRINT_EMPTY THEN
  TPRINT TP
  RETURN
 ENDIF
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_STR&&T!=#VMT_INT&&T!=#VMT_REAL THEN
  TYPE_MISMATCH "PRINT"
  RETURN
 ENDIF
 CASE TYP
 WHEN #VMPRINT_COMMA
  TPRINT TP,V,
 WHEN #VMPRINT_NEWLINE
  TPRINT TP,V
 WHEN #VMPRINT_SEMI
  TPRINT TP,V;
 ENDCASE
END
DEF VMINSTR_PUSHVARREF IDX
 VM_PUSHTYP IDX,#VMT_VARREF
END
DEF VMINSTR_PUSHLVARREF IDX
 VM_PUSHTYP IDX,#VMT_LVARREF
END
DEF VM_GETVAR(IDX)
 VAR TYP=VM_GVAR_TYP[IDX]
 CASE TYP
 WHEN #VMT_REAL
  RETURN VM_GVAR#[IDX]
 WHEN #VMT_INT
  RETURN VM_GVAR%[IDX]
 WHEN #VMT_STR
  RETURN VM_GVAR$[IDX]
 WHEN #VMT_INTARRAY
 WHEN #VMT_REALARRAY
 WHEN #VMT_STRARRAY
  RETURN VM_GET_ARRAY(VM_GVAR%[IDX])
 ENDCASE
 VM_ERROR
END
DEF VM_GETVAR2 IDX OUT TYP,V
 TYP=VM_GVAR_TYP[IDX]
 CASE TYP
 WHEN #VMT_REAL
  V=VM_GVAR#[IDX]
  RETURN
 WHEN #VMT_INT
  V=VM_GVAR%[IDX]
  RETURN
 WHEN #VMT_STR
  V=VM_GVAR$[IDX]
  RETURN
 ENDCASE
 VM_ERROR
END
DEF VM_SETVAR IDX,TYP,V
 VM_GVAR_TYP[IDX]=TYP
 CASE TYP
 WHEN #VMT_REAL
  VM_GVAR#[IDX]=V
 WHEN #VMT_INT
  VM_GVAR%[IDX]=V
 WHEN #VMT_STR
  VM_GVAR$[IDX]=V
 WHEN #VMT_INTARRAY
 WHEN #VMT_STRARRAY
 WHEN #VMT_REALARRAY
  VM_GVAR%[IDX]=VM_ALLOC_ARRAY(V)
 WHEN #VMT_DEFAULT
  RETURN
 OTHERWISE
  VM_ERROR_NOTIMPL
 ENDCASE
END
DEF VM_GETSTKARY(TYP)
 CASE TYP
 WHEN #VMT_REAL
  RETURN VM_STK#
 WHEN #VMT_ARYREF
 WHEN #VMT_INTARRAY
 WHEN #VMT_REALARRAY
 WHEN #VMT_STRARRAY
 WHEN #VMT_EMPTYREF
 WHEN #VMT_VARREF
 WHEN #VMT_LVARREF
 WHEN #VMT_INT
 WHEN #VMT_SUBROUTINE
 WHEN #VMT_DEFAULT
  RETURN VM_STK%
 WHEN #VMT_STR
  RETURN VM_STK$
 OTHERWISE
  STOP
 ENDCASE
END
DEF VM_GETLVAR IDX OUT T,V
 T=VM_STK_TYP[VM_BP+IDX]
 V=VM_GETV(T,VM_GETSTKARY(T)[VM_BP+IDX])
END
DEF VM_SETSTK IDX,V
 VAR T=VM_TYPE(V)
 VM_STK_TYP[VM_SP+IDX]=T
 VAR A=VM_GETSTKARY(T)
 A[VM_SP+IDX]=VM_V(T,V)
END
DEF VM_GETSTK IDX OUT V
 VAR T=VM_STK_TYP[VM_SP+IDX]
 V=VM_GETV(T,VM_GETSTKARY(T)[VM_SP+IDX])
END
DEF VM_SETLVAR IDX,T,V
 VM_STK_TYP[VM_BP+IDX]=T
 VAR A=VM_GETSTKARY(T)
 A[VM_BP+IDX]=VM_V(T,V)
END
DEF VM_TYPE(V)
 CASE TYPEOF(V)
 WHEN #T_DEFAULT
  RETURN #VMT_DEFAULT
 WHEN #T_INT
  RETURN #VMT_INT
 WHEN #T_REAL
  RETURN #VMT_REAL
 WHEN #T_STR
  RETURN #VMT_STR
 WHEN #T_INTARRAY
  RETURN #VMT_INTARRAY
 WHEN #T_REALARRAY
  RETURN #VMT_REALARRAY
 WHEN #T_STRARRAY
  RETURN #VMT_STRARRAY
 OTHERWISE
  STOP
 ENDCASE
END
DEF VMINSTR_REF
 VAR T,V
 VM_POP OUT T,V
 CASE T
 WHEN #VMT_VARREF
  VM_PUSH VM_GETVAR(V)
 WHEN #VMT_LVARREF
  VM_GETLVAR V OUT T,V
  VM_PUSHTYP V,T
 WHEN #VMT_ARYREF
  VAR DM1,DM2,DM3,DM4
  VAR ARYT,ARYV
  VM_POP OUT ARYT,ARYV
  IF!VM_ISARYTYP(ARYT)THEN
   TYPE_MISMATCH "ARRAY EXPECTED BUT "+VMT_STR$(ARYT)
   RETURN
  ENDIF
  VAR ERR
  VM_POP_DIMS V OUT DM1,DM2,DM3,DM4,ERR
  IF ERR THEN RETURN
  IF ARYT==#VMT_STR THEN
   IF V!=1THEN
    SYNTAX_ERROR "DIM MISMATCH"
    RETURN
   ENDIF
  ELSEIF ARYT==#VMT_INTARRAY||ARYT==#VMT_STRARRAY||ARYT==#VMT_REALARRAY THEN
   IF V!=1&&DIM(ARYV)!=V THEN
    SYNTAX_ERROR "DIM MISMATCH"
    RETURN
   ENDIF
  ENDIF
  CASE V
  WHEN 1
   IF LEN(ARYV)<=DM1 THEN
    SUBSCRIPT_OUT_OF_RANGE "REF ARRAY"
    RETURN
   ENDIF
   VM_PUSH ARYV[DM1]
  WHEN 2
   IF DIM(ARYV,0)<=DM1||DIM(ARYV,1)<=DM2 THEN
    SUBSCRIPT_OUT_OF_RANGE "REF ARRAY(2D)"
    RETURN
   ENDIF
   VM_PUSH ARYV[DM1,DM2]
  WHEN 3
   IF DIM(ARYV,0)<=DM1||DIM(ARYV,1)<=DM2||DIM(ARYV,2)<=DM3 THEN
    SUBSCRIPT_OUT_OF_RANGE "REF ARRAY(3D)"
    RETURN
   ENDIF
   VM_PUSH ARYV[DM1,DM2,DM3]
  WHEN 4
   IF DIM(ARYV,0)<=DM1||DIM(ARYV,1)<=DM2||DIM(ARYV,2)<=DM3||DIM(ARYV,3)<=DM4 THEN
    SUBSCRIPT_OUT_OF_RANGE "REF ARRAY(4D)"
    RETURN
   ENDIF
   VM_PUSH ARYV[DM1,DM2,DM3,DM4]
  OTHERWISE
   INTERNAL_VM_ERROR
  ENDCASE
 OTHERWISE
  INTERNAL_VM_ERROR
 ENDCASE
END
DEF VMINSTR_ASSIGN
 VAR T,V
 VAR REFT,REFV
 VM_POP OUT REFT,REFV
 VM_ASSIGN REFT,REFV,#TRUE,T,V,
END
DEF VM_ASSIGN REFT,REFV,POP,T,V,ERR
 ERR=#FALSE
 CASE REFT
 WHEN #VMT_LVARREF
  IF POP THEN VM_POP OUT T,V
  VM_SETLVAR REFV,T,V
 WHEN #VMT_VARREF
  IF POP THEN VM_POP OUT T,V
  VM_SETVAR REFV,T,V
 WHEN #VMT_EMPTYREF
  RETURN
 WHEN #VMT_ARYREF
  VAR DM1,DM2,DM3,DM4
  VAR ARYT,ARYV
  VM_POP OUT ARYT,ARYV
  IF!VM_ISARYTYP(ARYT)THEN
   ERR=#TRUE
   TYPE_MISMATCH "ARRAY EXPECTED BUT "+VMT_STR$(ARYT)
   RETURN
  ENDIF
  VM_POP_DIMS REFV OUT DM1,DM2,DM3,DM4,ERR
  IF ERR THEN RETURN
  IF POP THEN VM_POP OUT T,V
  IF ARYT==#VMT_STR||ARYT==#VMT_STRARRAY THEN
   IF T!=#VMT_STR THEN
    ERR=#TRUE
    TYPE_MISMATCH "ASSIGN ARRAY"
    RETURN
   ENDIF
  ELSEIF !VM_ISNUMTYPE(T) THEN
   ERR=#TRUE
   TYPE_MISMATCH "ASSIGN ARRAY"
   RETURN
  ENDIF
  IF REFV!=1&&DIM(ARYV)!=REFV THEN
   ERR=#TRUE
   SYNTAX_ERROR "DIM MISMATCH"
   RETURN
  ENDIF
  CASE REFV
  WHEN 1
   IF LEN(ARYV)<=DM1 THEN
    ERR=#TRUE
    SUBSCRIPT_OUT_OF_RANGE "ASSIGN ARRAY"
    RETURN
   ENDIF
   ARYV[DM1]=V
  WHEN 2
   IF DIM(ARYV,0)<=DM1||DIM(ARYV,1)<=DM2 THEN
    ERR=#TRUE
    SUBSCRIPT_OUT_OF_RANGE "ASSIGN ARRAY(2D)"
    RETURN
   ENDIF
   ARYV[DM1,DM2]=V
  WHEN 3
   IF DIM(ARYV,0)<=DM1||DIM(ARYV,1)<=DM2||DIM(ARYV,2)<=DM3 THEN
    ERR=#TRUE
    SUBSCRIPT_OUT_OF_RANGE "ASSIGN ARRAY(3D)"
    RETURN
   ENDIF
   ARYV[DM1,DM2,DM3]=V
  WHEN 4
   IF DIM(ARYV,0)<=DM1||DIM(ARYV,1)<=DM2||DIM(ARYV,2)<=DM3||DIM(ARYV,3)<=DM4 THEN
    ERR=#TRUE
    SUBSCRIPT_OUT_OF_RANGE "ASSIGN ARRAY(4D)"
    RETURN
   ENDIF
   ARYV[DM1,DM2,DM3,DM4]=V
  OTHERWISE
   INTERNAL_VM_ERROR
  ENDCASE
 OTHERWISE
  INTERNAL_VM_ERROR
 ENDCASE
END
DEF VM_REF OUT REFT,REFV,T,V,ERR
 ERR=#FALSE
 VM_POP OUT REFT,REFV
 CASE REFT
 WHEN #VMT_LVARREF
  VM_GETLVAR REFV OUT T,V
 WHEN #VMT_VARREF
  VM_GETVAR2 REFV OUT T,V
 WHEN #VMT_EMPTYREF
  RETURN
 WHEN #VMT_ARYREF
  VAR DM1,DM2,DM3,DM4
  VAR ARYT,ARYV
  VM_POP #TRUE OUT ARYT,ARYV
  IF!VM_ISARYTYP(ARYT)THEN
   ERR=#TRUE
   TYPE_MISMATCH "ARRAY EXPECTED BUT "+VMT_STR$(ARYT)
   RETURN
  ENDIF
  VM_POP_DIMS REFV OUT DM1,DM2,DM3,DM4,ERR
  IF ERR THEN RETURN
  CASE REFV
  WHEN 1
   V=ARYV[DM1]
  WHEN 2
   V=ARYV[DM1,DM2]
  WHEN 3
   V=ARYV[DM1,DM2,DM3]
  WHEN 4
   V=ARYV[DM1,DM2,DM3,DM4]
  OTHERWISE
   INTERNAL_VM_ERROR
  ENDCASE
  T=VM_TYPE(V)
 OTHERWISE
  INTERNAL_VM_ERROR
 ENDCASE
END
DEF VM_ISNUMTYPE(TYP)
 RETURN TYP==#VMT_INT||TYP==#VMT_REAL
END
DEF VMINSTR_FOR INIT
 VAR BRKADDR=VM_OPS[VM_PC]
 INC VM_PC
 VAR T_TO,V_TO
 VAR T_STEP=#VMT_INT,V_STEP=1
 VAR RT_IDX,RV_IDX
 VAR T_IDX,V_IDX
 VM_POP OUT T_TO,V_TO
 VM_POP OUT T_STEP,V_STEP
 VAR OSP=VM_SP
 VAR ERR
 VM_REF OUT RT_IDX,RV_IDX,T_IDX,V_IDX,ERR
 IF ERR THEN RETURN
 VM_SP=OSP-1
 IF!VM_ISNUMTYPE(T_IDX)||!VM_ISNUMTYPE(T_STEP)||!VM_ISNUMTYPE(T_TO) THEN
  TYPEMISMATCH "FOR"
  RETURN
 ENDIF
 IF !INIT THEN
  V_IDX=V_IDX+V_STEP
  VM_ASSIGN RT_IDX,RV_IDX,#FALSE,T_IDX,V_IDX,ERR
  IF ERR THEN RETURN
 ENDIF
 IF V_STEP>0&&V_IDX>V_TO THEN
  IF INIT THEN
   VM_PC=BRKADDR
  ENDIF
 ELSEIF V_STEP<0&&V_IDX<V_TO THEN
  IF INIT THEN
   VM_PC=BRKADDR
  ENDIF
 ELSE
  IF !INIT THEN
   VM_PC=BRKADDR
  ENDIF
 ENDIF
END
DEF VMINSTR_BRAND ADDR
 VAR T,V
 VM_POP OUT T,V
 IF!VM_ISNUMTYPE(T) THEN
  TYPEMISMATCH "&&"
  RETURN
 ENDIF
 IF !V THEN
  VM_PUSHINT #FALSE
  VM_PC=ADDR
 ENDIF
END
DEF VMINSTR_BROR ADDR
 VAR T,V
 VM_POP OUT T,V
 IF!VM_ISNUMTYPE(T) THEN
  TYPEMISMATCH "||"
  RETURN
 ENDIF
 IF V THEN
  VM_PC=ADDR
  VM_PUSHINT #TRUE
 ENDIF
END

DEF VM_CHKLABEL(LABEL$,F)
 'FIXME:SLOT
 VAR HAS_SLOT
 IF INSTR(LABEL$,":")!=-1 THEN
  LABEL$=MID$(LABEL$,INSTR(LABEL$,":")+1,&H7FFFFFFF)
  HAS_SLOT=#TRUE
  F=#TRUE
 ENDIF
 VAR FOUND
 IF !HAS_SLOT&&VM_CURFUNC THEN
  SPLAY_GET% FUNC_LBLTBL[VM_CURFUNC],LABEL$ OUT FOUND,
 ENDIF
 IF VM_CURFUNC&&!F THEN
  RETURN FOUND
 ENDIF
 IF !FOUND THEN
  SPLAY_GET% VM_GLBLTBL,LABEL$ OUT FOUND,
 ENDIF
 RETURN FOUND
END
'"0:FUNC"  :1
'"00:FUNC" :1
'" 00:FUNC":0
'"&H0:FUNC":0
'"0 :FUNC" :0
DEF VM_PARSE_SLOT L$,LABEL OUT ILL_FMT,HAS_SLOT,SLOT,N$
 N$=L$
 VAR POS=INSTR(L$,":")
 IF POS==-1 THEN
  HAS_SLOT=#FALSE
  ILL_FMT=#FALSE
  IF LABEL&&MID$(L$,0,1)!="@"THEN
   ILL_FMT=#TRUE
   RETURN
  ENDIF
  RETURN
 ENDIF
 N$=MID$(L$,POS+1,&H7FFFFFFF)
 VAR S$=MID$(L$,0,POS)
 VAR I
 FOR I=0TO LAST(S$)
  IF S$[I]<"0"||S$[I]>"9"THEN
   ILL_FMT=#TRUE
   RETURN
  ENDIF
 NEXT
 SLOT=VAL(S$)
 IF LABEL&&MID$(S$,0,1)!="@"THEN
  ILL_FMT=#TRUE
  RETURN
 ENDIF
 IF SLOT<0||SLOT>=4 THEN
  ILL_FMT=#TRUE
  RETURN
 ENDIF
 ILL_FMT=#FALSE
 HAS_SLOT=#TRUE
END

DEF VM_CHKCALL(FUNC$)
 VAR ILL_FMT,HAS_SLOT,SLOT
 VM_PARSE_SLOT FUNC$ OUT ILL_FMT,HAS_SLOT,SLOT,FUNC$
 IF ILL_FMT THEN
  RETURN #FALSE
 ENDIF
 VAR FOUND
 SPLAY_GET% VM_FUNCTBL,FUNC$ OUT FOUND,
 IF !FOUND&&!HAS_SLOT THEN
  SPLAY_GET% VM_CFUNCTBL,FUNC$ OUT FOUND,
 ENDIF
 'HAS SLOT && BUILTIN FUNCTION->#TRUE
 RETURN FOUND||CHKCALL(FUNC$)
END
DEF VM_GET_LABEL LABEL$ OUT SLOT,LABEL,FOUND
 VAR TBL
 VAR ILL_FMT,HAS_SLOT
 FOUND=#FALSE
 VM_PARSE_SLOT LABEL$,#TRUE OUT ILL_FMT,HAS_SLOT,SLOT,LABEL$
 IF ILL_FMT THEN
  ILLEGAL_LABEL_STRING LABEL$
  SLOT=-1
  LABEL=-1
  RETURN
 ENDIF
 IF VM_CURFUNC&&HAS_SLOT THEN
  UNDEFINED_LABEL LABEL$
  SLOT=-1
  LABEL=-1
  RETURN
 ENDIF
 IF !HAS_SLOT THEN
  SLOT=VM_CURSLOT
 ENDIF
 IF VM_CURFUNC THEN
  TBL=FUNC_LBLTBL[VM_CURFUNC]
 ELSE
  TBL=VM_SLOT_GLBLTBL[SLOT]
 ENDIF
 SPLAY_GET% TBL,LABEL$ OUT FOUND,LABEL
 IF !FOUND THEN
  UNDEFINED_LABEL LABEL$
  SLOT=-1
  LABEL=-1
  RETURN
 ENDIF
END

DEF VM_GET_LABEL_DATA_ADDR LABEL$ OUT SLOT,ADDR,FOUND
 VAR LABEL
 VM_GET_LABEL LABEL$ OUT SLOT,LABEL,FOUND
 IF !FOUND THEN RETURN
 ADDR=LABEL_DATA_ADDR[LABEL]
END
DEF VM_GET_LABEL_ADDR LABEL$ OUT SLOT,ADDR,FOUND
 VAR LABEL
 VM_GET_LABEL LABEL$ OUT SLOT,LABEL,FOUND
 IF !FOUND THEN RETURN
 ADDR=LABEL_ADDR[LABEL]
END
DEF VMINSTR_GOTO_PLACEHOLDER
 VAR ADDR,SLOT,FOUND
 VM_GET_LABEL_ADDR VM_IMM$[VM_OPS[VM_PC]] OUT SLOT,ADDR,FOUND
 IF !FOUND THEN RETURN
 VM_ASSERT VM_CURSLOT==SLOT
 VM_OPS[VM_PC-1]=#VM_BR
 VM_OPS[VM_PC]=ADDR
 VM_PC=ADDR
END
DEF VMINSTR_GOSUB_PLACEHOLDER
 VAR ADDR,SLOT,FOUND
 VM_GET_LABEL_ADDR VM_IMM$[VM_OPS[VM_PC]] OUT SLOT,ADDR,FOUND
 IF !FOUND THEN RETURN
 VM_ASSERT VM_CURSLOT==SLOT
 VM_OPS[VM_PC-1]=#VM_GOSUB
 VM_OPS[VM_PC]=ADDR
 DEC VM_PC
END
DEF VMINSTR_GOSUB SLOT,ADDR
 VAR RETADDR=VM_PC
 VM_PUSHTYP VM_CURSLOT,#VMT_SUBROUTINE
 VM_PUSHTYP RETADDR,#VMT_SUBROUTINE
 VM_PC=ADDR
 IF VM_CURSLOT!=SLOT THEN
  VM_CURSLOT=SLOT
  VM_SWITCH_SLOT VM_CURSLOT
 ENDIF
END
DEF VMINSTR_RETURN
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_SUBROUTINE THEN
  RETURN_WITHOUT_GOSUB
  RETURN
 ENDIF
 VAR TS,VS
 VM_POP OUT TS,VS
 IF TS!=#VMT_SUBROUTINE THEN
  VM_INTERNAL_ERROR
  RETURN
 ENDIF
 IF VS!=VM_CURSLOT THEN
  VM_CURSLOT=VS
  VM_SWITCH_SLOT VM_CURSLOT
 ENDIF
 VM_PC=V
END
ENUM\
 #VMSTK_STARTARGS=#VM_LVAROFF,\
 #VMSTK_OUTCNT,\
 #VMSTK_INCNT,\
 #VMSTK_FUNC,\
 #VMSTK_BP,\
 #VMSTK_SLOT,\
 #VMSTK_PC
DEF VMINSTR_PUSHEMPTY N
 FILL VM_STK_TYP,#VMT_DEFAULT,VM_SP,N
 INC VM_SP,N
END
DEF VM_GETFUNC NAME$,INCNT1,OUTCNT1 OUT FOUND,FUNC
 SPLAY_GET% VM_FUNCTBL,NAME$ OUT FOUND,FUNC
 IF FOUND THEN RETURN
 SPLAY_GET% VM_CFUNCTBL,NAME$ OUT FOUND,FUNC
 RETURN
END
DEF GENERATE_NATIVE_RELAY
 VAR I,O
 VAR R$=""
 VAR IM=9,OM=9
 PUSH R$,"DEF RELAY_NATIVE_FUNC N$,I,O"
 PUSH R$,CHR$(10)
 PUSH R$," DEC VM_SP,I"
 PUSH R$,CHR$(10)
 PUSH R$," VAR "
 FOR O=1TO OM
  PUSH R$,"O"
  PUSH R$,STR$(O)
  PUSH R$,","
 NEXT
 PUSH R$,CHR$(10)
 PUSH R$," ON I*"+STR$(OM+1)+"+O GOTO "
 FOR I=0TO IM
  FOR O=0TO OM
   PUSH R$,"@I"
   PUSH R$,STR$(I)
   PUSH R$,"O"
   PUSH R$,STR$(O)
   'TAILING COMMA NOT ALLOWED
   IF I!=IM||O!=OM THEN
    PUSH R$,","
   ENDIF
  NEXT
 NEXT
 PUSH R$,CHR$(10)
 FOR I=0TO IM
  FOR O=0TO OM
   PUSH R$," @I"
   PUSH R$,STR$(I)
   PUSH R$,"O"
   PUSH R$,STR$(O)
   PUSH R$,":"
   PUSH R$,"CALL N$"
   VAR I2
   FOR I2=1TO I
    PUSH R$,",VM_GETSTK(
    PUSH R$,STR$(I-I2)
    PUSH R$,")"
   NEXT
   FOR I2=1TO O
    IF I2==1 THEN
     PUSH R$," OUT O1"
    ELSE
     PUSH R$,",O"
     PUSH R$,STR$(I2)
    ENDIF
   NEXT
   PUSH R$,":"
   FOR I2=1TO O
    PUSH R$,"VM_SETSTK -"
    PUSH R$,STR$(I2)
    PUSH R$,",O"
    PUSH R$,STR$(O+1-I2)
    PUSH R$,":"
   NEXT
   PUSH R$,"RETURN"
   PUSH R$,CHR$(10)
  NEXT
 NEXT
 PUSH R$,"END"
 PUSH R$,CHR$(10)
 CLIPBOARD R$
END












DEF RELAY_NATIVE_FUNC N$,I,O
 DEC VM_SP,I
 VAR O1,O2,O3,O4,O5,O6,O7,O8,O9,
 ON I*10+O GOTO @I0O0,@I0O1,@I0O2,@I0O3,@I0O4,@I0O5,@I0O6,@I0O7,@I0O8,@I0O9,@I1O0,@I1O1,@I1O2,@I1O3,@I1O4,@I1O5,@I1O6,@I1O7,@I1O8,@I1O9,@I2O0,@I2O1,@I2O2,@I2O3,@I2O4,@I2O5,@I2O6,@I2O7,@I2O8,@I2O9,@I3O0,@I3O1,@I3O2,@I3O3,@I3O4,@I3O5,@I3O6,@I3O7,@I3O8,@I3O9,@I4O0,@I4O1,@I4O2,@I4O3,@I4O4,@I4O5,@I4O6,@I4O7,@I4O8,@I4O9,@I5O0,@I5O1,@I5O2,@I5O3,@I5O4,@I5O5,@I5O6,@I5O7,@I5O8,@I5O9,@I6O0,@I6O1,@I6O2,@I6O3,@I6O4,@I6O5,@I6O6,@I6O7,@I6O8,@I6O9,@I7O0,@I7O1,@I7O2,@I7O3,@I7O4,@I7O5,@I7O6,@I7O7,@I7O8,@I7O9,@I8O0,@I8O1,@I8O2,@I8O3,@I8O4,@I8O5,@I8O6,@I8O7,@I8O8,@I8O9,@I9O0,@I9O1,@I9O2,@I9O3,@I9O4,@I9O5,@I9O6,@I9O7,@I9O8,@I9O9
 @I0O0:CALL N$:RETURN
 @I0O1:CALL N$ OUT O1:VM_SETSTK -1,O1:RETURN
 @I0O2:CALL N$ OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I0O3:CALL N$ OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I0O4:CALL N$ OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I0O5:CALL N$ OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I0O6:CALL N$ OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I0O7:CALL N$ OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I0O8:CALL N$ OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I0O9:CALL N$ OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I1O0:CALL N$,VM_GETSTK(0):RETURN
 @I1O1:CALL N$,VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I1O2:CALL N$,VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I1O3:CALL N$,VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I1O4:CALL N$,VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I1O5:CALL N$,VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I1O6:CALL N$,VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I1O7:CALL N$,VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I1O8:CALL N$,VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I1O9:CALL N$,VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I2O0:CALL N$,VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I2O1:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I2O2:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I2O3:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I2O4:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I2O5:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I2O6:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I2O7:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I2O8:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I2O9:CALL N$,VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I3O0:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I3O1:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I3O2:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I3O3:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I3O4:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I3O5:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I3O6:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I3O7:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I3O8:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I3O9:CALL N$,VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I4O0:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I4O1:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I4O2:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I4O3:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I4O4:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I4O5:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I4O6:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I4O7:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I4O8:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I4O9:CALL N$,VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I5O0:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I5O1:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I5O2:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I5O3:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I5O4:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I5O5:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I5O6:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I5O7:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I5O8:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I5O9:CALL N$,VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I6O0:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I6O1:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I6O2:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I6O3:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I6O4:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I6O5:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I6O6:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I6O7:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I6O8:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I6O9:CALL N$,VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I7O0:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I7O1:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I7O2:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I7O3:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I7O4:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I7O5:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I7O6:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I7O7:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I7O8:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I7O9:CALL N$,VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I8O0:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I8O1:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I8O2:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I8O3:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I8O4:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I8O5:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I8O6:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I8O7:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I8O8:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I8O9:CALL N$,VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
 @I9O0:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0):RETURN
 @I9O1:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1:VM_SETSTK -1,O1:RETURN
 @I9O2:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2:VM_SETSTK -1,O2:VM_SETSTK -2,O1:RETURN
 @I9O3:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3:VM_SETSTK -1,O3:VM_SETSTK -2,O2:VM_SETSTK -3,O1:RETURN
 @I9O4:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4:VM_SETSTK -1,O4:VM_SETSTK -2,O3:VM_SETSTK -3,O2:VM_SETSTK -4,O1:RETURN
 @I9O5:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5:VM_SETSTK -1,O5:VM_SETSTK -2,O4:VM_SETSTK -3,O3:VM_SETSTK -4,O2:VM_SETSTK -5,O1:RETURN
 @I9O6:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6:VM_SETSTK -1,O6:VM_SETSTK -2,O5:VM_SETSTK -3,O4:VM_SETSTK -4,O3:VM_SETSTK -5,O2:VM_SETSTK -6,O1:RETURN
 @I9O7:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7:VM_SETSTK -1,O7:VM_SETSTK -2,O6:VM_SETSTK -3,O5:VM_SETSTK -4,O4:VM_SETSTK -5,O3:VM_SETSTK -6,O2:VM_SETSTK -7,O1:RETURN
 @I9O8:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8:VM_SETSTK -1,O8:VM_SETSTK -2,O7:VM_SETSTK -3,O6:VM_SETSTK -4,O5:VM_SETSTK -5,O4:VM_SETSTK -6,O3:VM_SETSTK -7,O2:VM_SETSTK -8,O1:RETURN
 @I9O9:CALL N$,VM_GETSTK(8),VM_GETSTK(7),VM_GETSTK(6),VM_GETSTK(5),VM_GETSTK(4),VM_GETSTK(3),VM_GETSTK(2),VM_GETSTK(1),VM_GETSTK(0) OUT O1,O2,O3,O4,O5,O6,O7,O8,O9:VM_SETSTK -1,O9:VM_SETSTK -2,O8:VM_SETSTK -3,O7:VM_SETSTK -4,O6:VM_SETSTK -5,O5:VM_SETSTK -6,O4:VM_SETSTK -7,O3:VM_SETSTK -8,O2:VM_SETSTK -9,O1:RETURN
END









DEF CALL_NATIVE_FUNC NAME$,INCNT,OUTCNT
 CASE NAME$
 WHEN "CHKLABEL"
  IF OUTCNT!=1||(INCNT!=1&&INCNT!=2) THEN
   MISSING_PARAMETER "CHKLABEL"
   RETURN
  ENDIF
  DEC VM_SP,INCNT
  VAR I1,I2,O1
  IF INCNT==2 THEN
   I1=VM_GETSTK(1)
   I2=VM_GETSTK(0)
   O1=VM_CHKLABEL(I1,I2)
  ELSE
   I1=VM_GETSTK(0)
   O1=VM_CHKLABEL(I1,#FALSE)
  ENDIF
  VM_SETSTK -1,O1
  RETURN
 WHEN "CHKCALL"
  IF OUTCNT!=1||INCNT!=1 THEN
   MISSING_PARAMETER "CHKCALL"
   RETURN
  ENDIF
  DEC VM_SP,INCNT
  I1=VM_GETSTK(0)
  O1=VM_CHKCALL(I1)
  VM_SETSTK -1,O1
  RETURN
 WHEN "DEFARGC"
  IF OUTCNT!=1||INCNT!=0 THEN
   MISSING_PARAMETER "DEFARGC"
   RETURN
  ENDIF
  DEC VM_SP,INCNT
  IF!VM_CURFUNC THEN
   VM_SETSTK -1,0
  ENDIF
  VAR T,V
  VM_GETLVAR #VMSTK_INCNT OUT T,V
  IF T!=#VMT_INT THEN
   VM_INTERNAL_ERROR "TYPE OF #VMSTK_INCNT SHOULD BE #VMT_INT"
  ENDIF
  VM_SETSTK -1,V
 WHEN "DEFARG"
  IF OUTCNT!=1||INCNT!=1 THEN
   MISSING_PARAMETER "DEFARG"
   RETURN
  ENDIF
  DEC VM_SP,INCNT
  IF!VM_CURFUNC THEN
   CANT_USE_OUTSIDE_DEF "DEFARG"
   RETURN
  ENDIF
  I1=VM_GETSTK(0)
  IF TYPEOF(I1)!=#T_INT&&TYPEOF(I1)!=#T_REAL THEN
   TYPE_MISMATCH "DEFARG"
   RETURN
  ENDIF
  VM_GETLVAR #VMSTK_STARTARGS-I1 OUT T,V
  IF !VM_ISPRITYP(T)THEN
   VM_INTERNAL_ERROR "DEFARG"
  ENDIF
  VM_SETSTK -1,V
 WHEN "DEFOUTC"
  IF OUTCNT!=1||INCNT!=0 THEN
   MISSING_PARAMETER "DEFOUTC"
   RETURN
  ENDIF
  DEC VM_SP,INCNT
  IF!VM_CURFUNC THEN
   VM_SETSTK -1,0
  ENDIF
  VM_GETLVAR #VMSTK_OUTCNT OUT T,V
  IF T!=#VMT_INT THEN
   VM_INTERNAL_ERROR "TYPE OF #VMSTK_OUTCNT SHOULD BE #VMT_INT"
  ENDIF
  VM_SETSTK -1,V
 OTHERWISE
  RELAY_NATIVE_FUNC NAME$,INCNT,OUTCNT
 ENDCASE
END
DEF VMINSTR_CALLFUNC
 VAR NAME$=VM_IMM$[VM_OPS[VM_PC]]
 INC VM_PC
 VAR INCNT=VM_OPS[VM_PC]
 INC VM_PC
 VAR OUTCNT=VM_OPS[VM_PC]
 INC VM_PC
 VAR ADDR
 VAR FUNC,INCNTF,OUTCNTF,FOUND
 IF NAME$=="CALL" THEN
  DEC INCNT
  VAR NAMET,NAMEV
  VM_POP OUT NAMET,NAMEV
  IF NAMET!=#VMT_STR THEN
   TYPE_MISMATCH "CALL"
   RETURN
  ENDIF
  NAME$=TO_UPPER$(NAMEV)
 ENDIF
 VM_GETFUNC NAME$,INCNT,OUTCNT OUT FOUND,FUNC
 IF !FOUND THEN
  IF CHKCALL(NAME$)THEN
   CALL_NATIVE_FUNC NAME$,INCNT,OUTCNT
   RETURN
  ENDIF
  SYNTAX_ERROR "UNDEFINED FUNCTION "+NAME$
  RETURN
 ENDIF
 IF (FUNC_INCNT[FUNC]!=-1&&FUNC_INCNT[FUNC]!=INCNT)||\
    (FUNC_OUTCNT[FUNC]!=-1&&FUNC_OUTCNT[FUNC]!=OUTCNT)THEN
  MISSING_PARAMETER NAME$
  RETURN
 ENDIF
 VM_PUSHINT OUTCNT
 VM_PUSHINT INCNT
 VM_PUSHINT VM_CURFUNC
 VM_PUSHINT VM_BP
 VM_PUSHINT VM_CURSLOT
 VM_PUSHINT VM_PC
 IF VM_CURSLOT!=FUNC_SLOT[FUNC]THEN
  VM_CURSLOT=FUNC_SLOT[FUNC]
  VM_SWITCH_SLOT VM_CURSLOT
 ENDIF
 VM_BP=VM_SP
 VM_PC=FUNC_ADDR[FUNC]
 INC VM_SP,FUNC_VARNUM[FUNC]+1
 VM_INITLVARSTK GET_SPLAY_ROOT(FUNC_VARTBL[FUNC])
 VM_CURFUNC=FUNC
END
DEF VM_INITLVARSTK NODE
 IF !NODE THEN RETURN
 VM_INITLVARSTK GET_SPLAYN_LEFT(NODE)
 VAR V=GET_SPLAYN_VAL%(NODE)
 VAR IDX=VAR_IDX[V]
 VAR TYP=VAR_TYP[V]
 IF IDX>=0 THEN
  VM_STK_TYP[VM_BP+IDX]=TYP
  VM_STK%[VM_BP+IDX]=0
  VM_STK#[VM_BP+IDX]=0
  VAR N$
  VM_STK$[VM_BP+IDX]=N$
 ENDIF
 VM_INITLVARSTK GET_SPLAYN_RIGHT(NODE)
END
DEF VM_ASSERT *
 IF DEFARG(0)THEN
  RETURN
 ELSE
  IF DEFARGC()==1 THEN
   ?"Assertion failed(VM)"
  ELSEIF DEFARGC()==2 THEN
   ?"Assertion failed(VM) ";DEFARG(1)
  ELSE
   ?"Assertion failed(VM) MISSING PARAMETER(ASSERT)"
  ENDIF
 ENDIF
END
DEF VMINSTR_RETURNFUNC
 VM_SP=VM_BP
 VAR RETADDR_T,RETADDR_V
 VM_POP OUT RETADDR_T,RETADDR_V
 VM_ASSERT RETADDR_T==#VMT_INT
 VAR RETSLOT_T,RETSLOT_V
 VM_POP OUT RETSLOT_T,RETSLOT_V
 VM_ASSERT RETADDR_T==#VMT_INT
 VAR OLDBP_T,OLDBP_V
 VM_POP OUT OLDBP_T,OLDBP_V
 VM_ASSERT OLDBP_T==#VMT_INT
 VAR OLDFUNC_T,OLDFUNC_V
 VM_POP OUT OLDFUNC_T,OLDFUNC_V
 VM_ASSERT OLDFUNC_T==#VMT_INT
 VM_CURFUNC=OLDFUNC_V
 VAR INCNT_T,OUTCNT_T
 VAR INCNT_V,OUTCNT_V
 VM_POP OUT INCNT_T,INCNT_V
 VM_ASSERT INCNT_T==#VMT_INT
 VM_POP OUT OUTCNT_T,OUTCNT_V
 VM_ASSERT OUTCNT_T==#VMT_INT
 VM_BP=OLDBP_V
 IF RETSLOT_V!=VM_CURSLOT THEN
  VM_CURSLOT=RETSLOT_V
  VM_SWITCH_SLOT VM_CURSLOT
 ENDIF
 VM_PC=RETADDR_V
 DEC VM_SP,INCNT_V
END
DEF VMINSTR_PUSHEMPTYREF
 VM_PUSHTYP 0,#VMT_EMPTYREF
END
DEF VM_POP_DIMS DM OUT DM1,DM2,DM3,DM4,ERR
 VAR T
 ERR=#FALSE
 IF DM>=1 THEN
  VM_POP OUT T,DM1
  IF!VM_ISNUMTYPE(T) THEN
   ERR=#TRUE
   TYPE_MISMATCH "ARRAY DIM"
   RETURN
  ENDIF
 ENDIF
 IF DM>=2 THEN
  VM_POP OUT T,DM2
  IF!VM_ISNUMTYPE(T) THEN
   ERR=#TRUE
   TYPE_MISMATCH "ARRAY DIM"
   RETURN
  ENDIF
 ENDIF
 IF DM>=3 THEN
  VM_POP OUT T,DM3
  IF!VM_ISNUMTYPE(T) THEN
   ERR=#TRUE
   TYPE_MISMATCH "ARRAY DIM"
   RETURN
  ENDIF
 ENDIF
 IF DM>=4 THEN
  VM_POP OUT T,DM4
  IF!VM_ISNUMTYPE(T) THEN
   ERR=#TRUE
   TYPE_MISMATCH "ARRAY DIM"
   RETURN
  ENDIF
 ENDIF
END
DEF VMINSTR_NEWARRAY
 VAR DM=VM_OPS[VM_PC]
 INC VM_PC
 VAR TYP=VM_OPS[VM_PC]
 INC VM_PC
 VAR V
 VAR DM1,DM2,DM3,DM4,ERR
 VAR T
 VM_POP_DIMS DM OUT DM1,DM2,DM3,DM4,ERR
 IF ERR THEN RETURN
 CASE TYP
 WHEN #VMT_INTARRAY
  CASE DM
  WHEN 1
   V=ARRAY%(DM1)
  WHEN 2
   V=ARRAY%(DM1,DM2)
  WHEN 3
   V=ARRAY%(DM1,DM2,DM3)
  WHEN 4
   V=ARRAY%(DM1,DM2,DM3,DM4)
  ENDCASE
 WHEN #VMT_REALARRAY
  CASE DM
  WHEN 1
   V=ARRAY#(DM1)
  WHEN 2
   V=ARRAY#(DM1,DM2)
  WHEN 3
   V=ARRAY#(DM1,DM2,DM3)
  WHEN 4
   V=ARRAY#(DM1,DM2,DM3,DM4)
  ENDCASE
 WHEN #VMT_STRARRAY
  CASE DM
  WHEN 1
   V=ARRAY$(DM1)
  WHEN 2
   V=ARRAY$(DM1,DM2)
  WHEN 3
   V=ARRAY$(DM1,DM2,DM3)
  WHEN 4
   V=ARRAY$(DM1,DM2,DM3,DM4)
  ENDCASE
 OTHERWISE
  VM_ERROR
 ENDCASE
 VM_PUSHTYP V,TYP
END
DEF VM_ISARYTYP(T)
 RETURN T==#VMT_INTARRAY||T==#VMT_REALARRAY||T==#VMT_STRARRAY||T==#VMT_STR
END
DEF VM_ISSCALARTYP(T)
 RETURN T==#VMT_INT||T==#VMT_REAL||T==#VMT_STR
END
DEF VM_ISPRITYP(T)
 RETURN T==#VMT_INT||T==#VMT_REAL||T==#VMT_STR||T==#VMT_INTARRAY||T==#VMT_REALARRAY||T==#VMT_STRARRAY||T==#VMT_DEFAULT
END
DEF VMINSTR_PUSHARYREF
 VAR DM=VM_OPS[VM_PC]
 INC VM_PC
 VM_PUSHTYP DM,#VMT_ARYREF
 RETURN
END
DEF VMINSTR_INITARRAY
 VAR CNT=VM_OPS[VM_PC]
 INC VM_PC
 VAR REFT,REFV
 VM_POP OUT REFT,REFV
 VAR I
 FOR I=0TO CNT-1
  VAR T,V
  VM_POP OUT T,V
  IF !VM_ISSCALARTYP(T) THEN
   TYPE_MISMATCH "INITARRAY"
   RETURN
  ENDIF
  REFV[I]=V
 NEXT
END
DEF VMINSTR_READ
 IF VM_DATA_IDX>=LEN(VM_DATA_TYP)THEN
  OUT_OF_DATA "READ"
  RETURN
 ENDIF
 VAR TYP=VM_DATA_TYP[VM_DATA_IDX]
 VAR V
 VAR REFT,REFV
 VM_POP OUT REFT,REFV
 CASE TYP
 WHEN #VMT_INT
  V=VM_DATA%[VM_DATA_IDX]
 WHEN #VMT_REAL
  V=VM_DATA#[VM_DATA_IDX]
 WHEN #VMT_STR
  V=VM_DATA$[VM_DATA_IDX]
 OTHERWISE
  INTERNAL_VM_ERROR
 ENDCASE
 VAR ERR
 VM_ASSIGN REFT,REFV,#FALSE,TYP,V,ERR
 IF ERR THEN RETURN
 INC VM_DATA_IDX
END
DEF VMINSTR_RESTORE
 VM_CURDATASLOT=VM_OPS[VM_PC]
 INC VM_PC
 VM_DATA_IDX=VM_OPS[VM_PC]
 INC VM_PC
 VM_SWITCH_SLOT_DATA VM_CURDATASLOT
END
DEF VMINSTR_RESTORE_PLACEHOLDER
 VAR ADDR,SLOT,FOUND
 VM_GET_LABEL_DATA_ADDR VM_IMM$[VM_OPS[VM_PC]] OUT SLOT,ADDR,FOUND
 IF!FOUND THEN
  RETURN
 ENDIF
 VM_OPS[VM_PC-2]=#VM_RESTORE
 VM_OPS[VM_PC-1]=SLOT
 VM_OPS[VM_PC]=ADDR
 DEC VM_PC,2
END
DEF VMINSTR_RESTOREEXPR
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_STR THEN
  TYPE_MISMATCH "RESTORE"
 ENDIF
 VAR SLOT,ADDR,FOUND
 VM_GET_LABEL_DATA_ADDR V OUT SLOT,ADDR,FOUND
 IF!FOUND THEN
  RETURN
 ENDIF
 IF SLOT!=VM_CURDATASLOT THEN
  VM_CURDATASLOT=SLOT
  VM_SWITCH_SLOT_DATA VM_CURDATASLOT
 ENDIF
 VM_DATA_IDX=ADDR
END
DEF VMINSTR_GOTOEXPR
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_STR THEN
  TYPE_MISMATCH "RESTORE"
  RETURN
 ENDIF
 VAR SLOT,ADDR,FOUND
 VM_GET_LABEL_ADDR V OUT SLOT,ADDR,FOUND
 IF !FOUND THEN
  RETURN
 ENDIF
 ADDR=VM_PC
 IF SLOT!=VM_CURSLOT THEN
  VM_CURSLOT=SLOT
  VM_SWITCH_SLOT VM_CURSLOT
 ENDIF
END
DEF VMINSTR_GOSUBEXPR
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_STR THEN
  TYPE_MISMATCH "RESTORE"
  RETURN
 ENDIF
 VAR SLOT,ADDR,FOUND
 VM_GET_LABEL_ADDR V OUT SLOT,ADDR,FOUND
 IF !FOUND THEN
  RETURN
 ENDIF
 VMINSTR_GOSUB SLOT,ADDR
END
DEF VMINSTR_INC MINUS
 VAR T,V
 VAR OSP=VM_SP
 VAR RT,RV
 VAR ERR
 VM_REF OUT RT,RV,T,V,ERR
 IF ERR THEN RETURN
 VAR DT,DV
 VM_POP OUT DT,DV
 VM_SP=OSP-1
 IF (T==#VMT_STR&&DT==#VMT_STR)||(VM_ISNUMTYPE(T)&&VM_ISNUMTYPE(DT))THEN
 ELSE
  TYPE_MISMATCH "INC"
  RETURN
 ENDIF
 IF MINUS THEN
  DEC V,DV
 ELSE
  INC V,DV
 ENDIF
 VM_ASSIGN RT,RV,#FALSE,T,V,ERR
 IF ERR THEN RETURN
END
DEF VMINSTR_ONGOTO GSB
 VAR T,V
 VM_POP OUT T,V
 IF!VM_ISNUMTYPE(T)THEN
  TYPE_MISMATCH "ON GOTO"
  RETURN
 ENDIF
 VAR CNT=VM_OPS[VM_PC]
 INC VM_PC
 IF V<0||V>=CNT THEN
  INC VM_PC,CNT
  RETURN
 ENDIF
 VAR ADDR=VM_OPS[VM_PC+V]
 IF ADDR>0 THEN
  VAR SLOT,FOUND
  VM_GET_LABEL_ADDR VM_IMM$[ADDR] OUT SLOT,ADDR,FOUND
  IF !FOUND THEN
   RETURN
  ENDIF
  VM_ASSERT SLOT==VM_CURSLOT
  VM_OPS[VM_PC+V]=-ADDR
 ELSE
  ADDR=-ADDR
 ENDIF
 INC VM_PC,CNT
 IF GSB THEN
  VMINSTR_GOSUB VM_CURSLOT,ADDR
 ELSE
  VM_PC=ADDR
 ENDIF
END
DEF VMINSTR_WHEN
 VAR ADDR=VM_OPS[VM_PC]
 INC VM_PC
 VAR T,V
 VAR T2,V2
 VM_POP OUT T,V
 VAR OSP=VM_SP
 VM_POP OUT T2,V2
 VM_SP=OSP
 IF (VM_ISNUMTYPE(T)&&VM_ISNUMTYPE(T2))||(T==#VMT_STR&&T2==#VMT_STR)THEN
 ELSE
  TYPE_MISMATCH "WHEN"
  RETURN
 ENDIF
 IF V==V2 THEN
  VM_PC=ADDR
  DEC VM_SP
 ENDIF
END
DEF VMINSTR_SWAP
 VAR T1,V1,RT1,RV1
 VAR T2,V2,RT2,RV2
 VAR OSP1=VM_SP
 VAR ERR
 VM_REF OUT RT1,RV1,T1,V1,ERR
 IF ERR THEN RETURN
 VAR OSP2=VM_SP
 VM_REF OUT RT2,RV2,T2,V2,ERR
 IF ERR THEN RETURN
 VAR OSP3=VM_SP
 VM_SP=OSP1-1
 VM_ASSIGN RT1,RV1,#FALSE,T2,V2,ERR
 IF ERR THEN RETURN
 VM_SP=OSP2-1
 VM_ASSIGN RT2,RV2,#FALSE,T1,V1,ERR
 IF ERR THEN RETURN
 VM_SP=OSP3
END
DEF VMINSTR_INPUT
 VAR GUIDE=VM_OPS[VM_PC]
 INC VM_PC
 VAR SEMI=VM_OPS[VM_PC]
 INC VM_PC
 VAR CNT=VM_OPS[VM_PC]
 INC VM_PC
 VAR GUIDET,GUIDEV=""
 VAR RT1,RV1,T1,V1,SP1
 VAR RT2,RV2,T2,V2,SP2
 VAR RT3,RV3,T3,V3,SP3
 VAR RT4,RV4,T4,V4,SP4
 IF GUIDE THEN
  VM_POP OUT GUIDET,GUIDEV
  IF GUIDET!=#VMT_STR THEN
   TYPE_MISMATCH "INPUT(GUIDE)"
   RETURN
  ENDIF
  ?GUIDEV;
 ENDIF
 VAR ERR
 IF CNT>=1 THEN
  SP1=VM_SP-1
  VM_REF OUT RT1,RV1,T1,V1,ERR
  IF ERR THEN RETURN
  IF CNT==1 THEN
   IF SEMI THEN
    INPUT "";V1
   ELSE
    INPUT "",V1
   ENDIF
  ENDIF
 ENDIF
 IF CNT>=2 THEN
  SP2=VM_SP-1
  VM_REF OUT RT2,RV2,T2,V2,ERR
  IF ERR THEN RETURN
  IF CNT==2 THEN
   IF SEMI THEN
    INPUT "";V1,V2
   ELSE
    INPUT "",V1,V2
   ENDIF
  ENDIF
 ENDIF
 IF CNT>=3 THEN
  SP3=VM_SP-1
  VM_REF OUT RT3,RV3,T3,V3,ERR
  IF ERR THEN RETURN
  IF CNT==3 THEN
   IF SEMI THEN
    INPUT "";V1,V2,V3
   ELSE
    INPUT "",V1,V2,V3
   ENDIF
  ENDIF
 ENDIF
 IF CNT>=4 THEN
  SP4=VM_SP-1
  VM_REF OUT RT4,RV4,T4,V4,ERR
  IF ERR THEN RETURN
  IF CNT==4 THEN
   IF SEMI THEN
    INPUT "";V1,V2,V3,V4
   ELSE
    INPUT "",V1,V2,V3,V4
   ENDIF
  ELSE
   VM_ERROR
  ENDIF
 ENDIF
 IF CNT>=1 THEN
  VM_SP=SP1
  VM_ASSIGN RT1,RV1,#FALSE,T1,V1,ERR
  IF ERR THEN RETURN
 ENDIF
 IF CNT>=2 THEN
  VM_SP=SP2
  VM_ASSIGN RT2,RV2,#FALSE,T2,V2,ERR
  IF ERR THEN RETURN
 ENDIF
 IF CNT>=3 THEN
  VM_SP=SP3
  VM_ASSIGN RT3,RV3,#FALSE,T3,V3,ERR
  IF ERR THEN RETURN
 ENDIF
 IF CNT>=4 THEN
  VM_SP=SP4
  VM_ASSIGN RT4,RV4,#FALSE,T4,V4,ERR
  IF ERR THEN RETURN
 ENDIF
END
DEF VMINSTR_LINPUT
 VAR GUIDE=VM_OPS[VM_PC]
 INC VM_PC
 VAR V
 VAR GUIDET,GUIDEV
 IF GUIDE THEN
  VM_POP OUT GUIDET,GUIDEV
  IF GUIDET!=#VMT_STR THEN
   TYPE_MISMATCH "INPUT(GUIDE)"
   RETURN
  ENDIF
  ?GUIDEV;
 ENDIF
 LINPUT V
 VM_PUSHSTR V
END
DEF VMINSTR_DEFOUT
 VAR T1,V1
 VAR T2,V2
 VM_POP OUT T1,V1
 VM_POP OUT T2,V2
 IF!VM_ISNUMTYPE(T1)THEN
  TYPE_MISMATCH "DEFOUT"
  RETURN
 ENDIF
 VAR IT,IV
 VM_GETLVAR #VMSTK_INCNT OUT IT,IV
 IF IT!=#VMT_INT THEN
  VM_INTERNAL_ERROR "TYPE OF #VMSTK_INCNT SHOULD BE #VMT_INT(DEFOUT)"
 ENDIF
 VAR OT,OV
 VM_GETLVAR #VMSTK_OUTCNT OUT OT,OV
 IF IT!=#VMT_INT THEN
  VM_INTERNAL_ERROR "TYPE OF #VMSTK_INCNT SHOULD BE #VMT_INT(DEFOUT)"
 ENDIF
 IF V1>=OV THEN
  OUT_OF_RANGE "DEFOUT"
  RETURN
 ENDIF
 VM_SETLVAR #VMSTK_STARTARGS-IV-OV+V1+1,T2,V2
END
DEF VMINSTR_EXEC1
 VAR T,V
 VM_POP OUT T,V
 VAR SLOT=VM_CURSLOT
 IF VM_ISNUMTYPE(T)THEN
  V=INT(V)
  VAR IN$=GET_SLOT$(V)
  SLOT=V
 ELSEIF T==#VMT_STR THEN
  SLOT=VM_CURSLOT
  STOP
 ELSE
  TYPE_MISMATCH "EXEC"
  RETURN
 ENDIF
 INIT_LEXER IN$
 INIT_AST
 INIT_PARSER
 VAR AST=PARSE()
 INIT_COMPILER SLOT
 COMPILE AST
 LOAD_VM_SLOT SLOT
 PUSH VM_EXEC,VM_PC
 PUSH VM_EXEC,VM_CURSLOT
 VM_CURSLOT=SLOT
 VM_SWITCH_SLOT VM_CURSLOT
 VM_PC=0
 VM_PREV_PC=0
END
DEF VMINSTR_EXEC2
 STOP
END
ENUM #VM_LASTERR_NONE,#VM_LASTERR_EN,#VM_LASTERR_ENJA
VAR VM_LASTERR
VAR VM_CONTINUABLE
VAR VM_LASTERR_EN$
VAR VM_LASTERR_JA$
VAR VM_STOP
VAR VM_STOP_MSG$
DEF VMINSTR_STOP1
 VM_STOP=#TRUE
 VM_RAISE_ERR1 "Break on "+VM_GET_CURLOC$()
 VM_CONTINUABLE=#TRUE
END
DEF VMINSTR_STOP2
 VAR T,V
 VM_POP OUT T,V
 IF T!=#VMT_STR THEN
  TYPE_MISMATCH "STOP"
  RETURN
 ENDIF
 VM_STOP=#TRUE
 VM_STOP_MSG$=V
 VM_RAISE_ERR1 "Break on "+VM_GET_CURLOC$()+CHR$(10)+V
 VM_CONTINUABLE=#TRUE
END
DEF VM_IS_STOPPED()
 RETURN VM_STOP
END
DEF VM_CONT
 IF !VM_STOP||!VM_CONTINUABLE THEN
  VM_RAISE_ERR2 "Can't continue","CONTできません"
  RETURN
 ENDIF
 VM_RUN
END
DEF VMDBG_BINSEARCH(ARY,KEY)
 VAR MIN=0
 VAR L=LEN(ARY)
 VAR MAX=L
 LOOP
  IF MAX<MIN THEN
   RETURN MAX
  ENDIF
  VAR MID=MIN+(MAX-MIN) DIV 2
  IF L<=MID THEN
   RETURN L-1
  ENDIF
  IF MID<0 THEN
   RETURN 0
  ENDIF
  IF ARY[MID]>KEY THEN
   MAX=MID-1
  ELSEIF ARY[MID]<KEY THEN
   MIN=MID+1
  ELSE
   RETURN MID
  ENDIF
 ENDLOOP
END
DEF VMDBG_GET OUT LINE,LINE_POS
 VAR L=VM_GET_ARRAY(VMDBG_SLOT_LINE[VM_CURSLOT])
 VAR LPC=VM_GET_ARRAY(VMDBG_SLOT_LINE_PC[VM_CURSLOT])
 VAR LPOS=VM_GET_ARRAY(VMDBG_SLOT_LINE_POS[VM_CURSLOT])
 VAR IND=VMDBG_BINSEARCH(LPC,VM_PREV_PC)
 IF IND<0||IND>=LEN(LPC)THEN
  LINE=0
  LINE_POS=0
  RETURN
 ENDIF
 LINE=L[IND]
 LINE_POS=LPOS[IND]
END
DEF VM_GET_CURLOC$()
 VAR LINE,LINE_POS
 VMDBG_GET OUT LINE,LINE_POS
 RETURN STR$(VM_CURSLOT)+":"+STR$(LINE)+":"+STR$(LINE_POS)
END
DEF SYNTAX_ERROR MSG$
 VM_RAISE_ERR2 "Syntax error","文法まちがい"
END
'A$[0]=1<=UNDEFINED VAR
DEF TYPE_MISMATCH MSG$
 VM_RAISE_ERR2 "Type mismatch","指定できない型の値です"
END
DEF SUBSCRIPT_OUT_OF_RANGE MSG$
 VM_RAISE_ERR2 "Subscript out of range","配列サイズを越えたアクセスです"
END
DEF OUT_OF_DATA MSG$
 VM_RAISE_ERR2 "Out of DATA","読み込めるDATA文がありません"
END
DEF UNDEFINED_LABEL MSG$
 VM_RAISE_ERR2 "Undefined label","未定義ラベル"
END
DEF ILLEGAL_LABEL_STRING MSG$
 VM_RAISE_ERR2 "Illegal label string","ラベル名として使えない文字列です"
END
DEF VM_RAISE_ERR1 E1$
 VM_LASTERR=#VM_LASTERR_EN
 VM_LASTERR=#TRUE
 VM_LASTERR_EN$=E1$
 VM_LASTERR_JA$=""
 VM_STOP=#TRUE
 VM_CONTINUABLE=#FALSE
END
DEF VM_RAISE_ERR2 E1$,E2$
 VM_LASTERR=#VM_LASTERR_ENJA
 'NOT DIRMODE
 VM_LASTERR_EN$=E1$+" in "+VM_GET_CURLOC$()
 VM_LASTERR_JA$=E2$
 VM_STOP=#TRUE
 VM_CONTINUABLE=#FALSE
END
DEF VM_LASTERR$()
 CASE VM_LASTERR
 WHEN #VM_LASTERR_EN
  RETURN VM_LASTERR_EN$
 WHEN #VM_LASTERR_ENJA
  RETURN VM_LASTERR_EN$+CHR$(10)+VM_LASTERR_JA$
 ENDCASE
END
DEF VM_RUN
 VM_STOP=#FALSE
 VAR T,V
 LOOP
  IF VM_STOP||LEN(VM_OPS)<=VM_PC THEN BREAK
  VM_PREV_PC=VM_PC
  VAR C=VM_OPS[VM_PC]
  INC VM_PC
  ON C GOTO @VM_NOP,@VM_PUSHINT,@VM_PUSHDBL,@VM_PUSHSTR,@VM_BINOP,@VM_PRINT,@VM_TPRINT,@VM_ASSIGN,@VM_PUSHVARREF,@VM_PUSHLVARREF,@VM_REF,@VM_BR,@VM_BRTRUE,@VM_BRFALSE,@VM_FOR,@VM_FORINIT,@VM_BRAND,@VM_BROR,@VM_GOTO_PLACEHOLDER,@VM_GOSUB_PLACEHOLDER,@VM_GOSUB,@VM_GOTOEXPR,@VM_GOSUBEXPR,@VM_ONGOTO,@VM_ONGOSUB,@VM_RETURN,@VM_CALLFUNC,@VM_PUSHEMPTY,@VM_RETURNFUNC,@VM_PUSHEMPTYREF,@VM_PUSHARYREF,@VM_END,@VM_NEWARRAY,@VM_INITARRAY,@VM_READ,@VM_RESTORE,@VM_RESTORE_PLACEHOLDER,@VM_RESTOREEXPR,@VM_UNAOP,@VM_CALLSPRITE,@VM_CALLTEXT,@VM_INC,@VM_DEC,@VM_POP,@VM_WHEN,@VM_SWAP,@VM_INPUT,@VM_LINPUT,@VM_DEFOUT,@VM_EXEC1,@VM_EXEC2,@VM_STOP1,@VM_STOP2
  @VM_NOP
  GOTO @VM_INVAL
  CASE C
  WHEN #VM_PUSHINT:@VM_PUSHINT
   VM_PUSHINT VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_PUSHDBL:@VM_PUSHDBL
   VM_PUSHDBL VM_IMM#[VM_OPS[VM_PC]]
   INC VM_PC
  WHEN #VM_PUSHSTR:@VM_PUSHSTR
   VM_PUSHSTR (VM_IMM$[VM_OPS[VM_PC]])+""
   INC VM_PC
  WHEN #VM_BINOP:@VM_BINOP
   T=VM_OPS[VM_PC]
   INC VM_PC
   VMINSTR_BINOP T
  WHEN #VM_PRINT:@VM_PRINT
   INC VM_PC
   VM_PRINT #FALSE,VM_OPS[VM_PC-1]
  WHEN #VM_TPRINT:@VM_TPRINT
   INC VM_PC
   VM_PRINT #TRUE,VM_OPS[VM_PC-1]
  WHEN #VM_PUSHVARREF:@VM_PUSHVARREF
   VMINSTR_PUSHVARREF VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_PUSHLVARREF:@VM_PUSHLVARREF
   VMINSTR_PUSHLVARREF VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_REF:@VM_REF
   VMINSTR_REF
  WHEN #VM_ASSIGN:@VM_ASSIGN
   VMINSTR_ASSIGN
  WHEN #VM_BR:@VM_BR
   VM_PC=VM_OPS[VM_PC]-1
   INC VM_PC
  WHEN #VM_BRFALSE:@VM_BRFALSE
   VM_POP OUT T,V
   CASE T
   WHEN #VMT_INT
   WHEN #VMT_REAL
    IF !V THEN VM_PC=VM_OPS[VM_PC]-1
   OTHERWISE
    TYPEMISMATCH
   ENDCASE
   INC VM_PC
  WHEN #VM_BRTRUE:@VM_BRTRUE
   VM_POP OUT T,V
   CASE T
   WHEN #VMT_INT
   WHEN #VMT_REAL
    IF V THEN VM_PC=VM_OPS[VM_PC]-1
   OTHERWISE
    TYPEMISMATCH
   ENDCASE
   INC VM_PC
  WHEN #VM_FOR:@VM_FOR
   VMINSTR_FOR #FALSE
  WHEN #VM_FORINIT:@VM_FORINIT
   VMINSTR_FOR #TRUE
  WHEN #VM_BROR:@VM_BROR
   INC VM_PC
   VMINSTR_BROR VM_OPS[VM_PC-1]
  WHEN #VM_BRAND:@VM_BRAND
   INC VM_PC
   VMINSTR_BRAND VM_OPS[VM_PC-1]
  WHEN #VM_GOTO_PLACEHOLDER:@VM_GOTO_PLACEHOLDER
   VMINSTR_GOTO_PLACEHOLDER
  WHEN #VM_GOSUB_PLACEHOLDER:@VM_GOSUB_PLACEHOLDER
   VMINSTR_GOSUB_PLACEHOLDER
  WHEN #VM_GOSUB:@VM_GOSUB
   INC VM_PC
   VMINSTR_GOSUB VM_CURSLOT,VM_OPS[VM_PC-1]
  WHEN #VM_RETURN:@VM_RETURN
   VMINSTR_RETURN
  WHEN #VM_CALLFUNC:@VM_CALLFUNC
   VMINSTR_CALLFUNC
  WHEN #VM_PUSHEMPTY:@VM_PUSHEMPTY
   INC VM_PC
   VMINSTR_PUSHEMPTY VM_OPS[VM_PC-1]
  WHEN #VM_RETURNFUNC:@VM_RETURNFUNC
   VMINSTR_RETURNFUNC
  WHEN #VM_PUSHEMPTYREF:@VM_PUSHEMPTYREF
   VMINSTR_PUSHEMPTYREF
  WHEN #VM_END:@VM_END
   IF LEN(VM_EXEC)THEN
    VM_CURSLOT=POP(VM_EXEC)
    VM_PC=POP(VM_EXEC)
    VM_SWITCH_SLOT VM_CURSLOT
   ELSE
    BREAK
   ENDIF
  WHEN #VM_NEWARRAY:@VM_NEWARRAY
   VMINSTR_NEWARRAY
  WHEN #VM_PUSHARYREF:@VM_PUSHARYREF
   VMINSTR_PUSHARYREF
  WHEN #VM_INITARRAY:@VM_INITARRAY
   VMINSTR_INITARRAY
  WHEN #VM_READ:@VM_READ
   VMINSTR_READ
  WHEN #VM_RESTORE:@VM_RESTORE
   VMINSTR_RESTORE
  WHEN #VM_RESTORE_PLACEHOLDER:@VM_RESTORE_PLACEHOLDER
   VMINSTR_RESTORE_PLACEHOLDER
  WHEN #VM_UNAOP:@VM_UNAOP
   INC VM_PC
   VMINSTR_UNAOP VM_OPS[VM_PC-1]
  WHEN #VM_CALLSPRITE:@VM_CALLSPRITE
   CALL SPRITE
  WHEN #VM_CALLTEXT:@VM_CALLTEXT
   CALL TEXT
  WHEN #VM_RESTOREEXPR:@VM_RESTOREEXPR
   VMINSTR_RESTOREEXPR
  WHEN #VM_GOTOEXPR:@VM_GOTOEXPR
   VMINSTR_GOTOEXPR
  WHEN #VM_GOSUBEXPR:@VM_GOSUBEXPR
   VMINSTR_GOSUBEXPR
  WHEN #VM_INC:@VM_INC
   VMINSTR_INC #FALSE
  WHEN #VM_DEC:@VM_DEC
   VMINSTR_DEC #TRUE
  WHEN #VM_POP:@VM_POP
   DEC VM_SP,VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_ONGOTO:@VM_ONGOTO
   VMINSTR_ONGOTO #FALSE
  WHEN #VM_ONGOSUB:@VM_ONGOSUB
   VMINSTR_ONGOTO #TRUE
  WHEN #VM_WHEN:@VM_WHEN
   VMINSTR_WHEN
  WHEN #VM_SWAP:@VM_SWAP
   VMINSTR_SWAP
  WHEN #VM_INPUT:@VM_INPUT
   VMINSTR_INPUT
  WHEN #VM_LINPUT:@VM_LINPUT
   VMINSTR_LINPUT
  WHEN #VM_DEFOUT:@VM_DEFOUT
   VMINSTR_DEFOUT
  WHEN #VM_EXEC1:@VM_EXEC1
   VMINSTR_EXEC1
  WHEN #VM_EXEC2:@VM_EXEC2
   VMINSTR_EXEC2
  WHEN #VM_STOP1:@VM_STOP1
   VMINSTR_STOP1
   BREAK
  WHEN #VM_STOP2:@VM_STOP2
   VMINSTR_STOP2
   BREAK
  WHEN #VM_
   VMINSTR_
  OTHERWISE:@VM_INVAL
   VM_ERROR
  ENDCASE
 ENDLOOP
END

DEF VM_DUMP_STR$(A$)
 RETURN CHR$(34)+A$+CHR$(34)
END
DEF VM_DUMP
 VAR VM_PC=0
 LOOP
  IF LEN(VM_OPS)<=VM_PC THEN BREAK
  VAR C=VM_OPS[VM_PC]
  INC VM_PC
  ON C GOTO @VM_NOP,@VM_PUSHINT,@VM_PUSHDBL,@VM_PUSHSTR,@VM_BINOP,@VM_PRINT,@VM_TPRINT,@VM_ASSIGN,@VM_PUSHVARREF,@VM_PUSHLVARREF,@VM_REF,@VM_BR,@VM_BRTRUE,@VM_BRFALSE,@VM_FOR,@VM_FORINIT,@VM_BRAND,@VM_BROR,@VM_GOTO_PLACEHOLDER,@VM_GOSUB_PLACEHOLDER,@VM_GOSUB,@VM_GOTOEXPR,@VM_GOSUBEXPR,@VM_ONGOTO,@VM_ONGOSUB,@VM_RETURN,@VM_CALLFUNC,@VM_PUSHEMPTY,@VM_RETURNFUNC,@VM_PUSHEMPTYREF,@VM_PUSHARYREF,@VM_END,@VM_NEWARRAY,@VM_INITARRAY,@VM_READ,@VM_RESTORE,@VM_RESTORE_PLACEHOLDER,@VM_RESTOREEXPR,@VM_UNAOP,@VM_CALLSPRITE,@VM_CALLTEXT,@VM_INC,@VM_DEC,@VM_POP,@VM_WHEN,@VM_SWAP,@VM_INPUT,@VM_LINPUT,@VM_DEFOUT,@VM_EXEC1,@VM_EXEC2,@VM_STOP1,@VM_STOP2
  @VM_NOP
  GOTO @VM_INVAL
  CASE C
  WHEN #VM_PUSHINT:@VM_PUSHINT
   ?"PUSHINT",VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_PUSHDBL:@VM_PUSHDBL
   ?"PUSHDBL",VM_IMM#[VM_OPS[VM_PC]]
   INC VM_PC
  WHEN #VM_PUSHSTR:@VM_PUSHSTR
   ?"PUSHSTR",VM_DUMP_STR$(VM_IMM$[VM_OPS[VM_PC]])
   INC VM_PC
  WHEN #VM_BINOP:@VM_BINOP
   VAR T=VM_OPS[VM_PC]
   INC VM_PC
   ?"BINOP",TKN_STR$(T)
  WHEN #VM_PRINT:@VM_PRINT
   INC VM_PC
   ?"PRINT",VM_OPS[VM_PC-1]
  WHEN #VM_TPRINT:@VM_TPRINT
   INC VM_PC
   ?"TPRINT",VM_OPS[VM_PC-1]
  WHEN #VM_PUSHVARREF:@VM_PUSHVARREF
   ?"PUSHVARREF",VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_PUSHLVARREF:@VM_PUSHLVARREF
   ?"PUSHLVARREF",VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_REF:@VM_REF
   ?"REF"
  WHEN #VM_ASSIGN:@VM_ASSIGN
   ?"ASSIGN"
  WHEN #VM_BR:@VM_BR
   ?"BR",VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_BRFALSE:@VM_BRFALSE
   ?"BRFALSE",VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_BRTRUE:@VM_BRTRUE
   ?"BRTRUE",VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_FOR:@VM_FOR
   ?"FOR"
  WHEN #VM_FORINIT:@VM_FORINIT
   ?"FORINIT"
  WHEN #VM_BROR:@VM_BROR
   ?"BROR",VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_BRAND:@VM_BRAND
   ?"BRAND",VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_GOTO_PLACEHOLDER:@VM_GOTO_PLACEHOLDER
   ?"GOTO",VM_IMM$[VM_OPS[VM_PC]]
   INC VM_PC
  WHEN #VM_GOSUB_PLACEHOLDER:@VM_GOSUB_PLACEHOLDER
   ?"GOSUB",VM_IMM$[VM_OPS[VM_PC]]
   INC VM_PC
  WHEN #VM_GOSUB:@VM_GOSUB
   ?"GOSUB",VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_RETURN:@VM_RETURN
   ?"RETURN"
  WHEN #VM_CALLFUNC:@VM_CALLFUNC
   ?"CALLFUNC",VM_IMM$[VM_OPS[VM_PC]],VM_OPS[VM_PC+1],VM_OPS[VM_PC+2]
   INC VM_PC,3
  WHEN #VM_PUSHEMPTY:@VM_PUSHEMPTY
   INC VM_PC
   ?"PUSHEMPTY",VM_OPS[VM_PC-1]
  WHEN #VM_RETURNFUNC:@VM_RETURNFUNC
   ?"RETURNFUNC"
  WHEN #VM_PUSHEMPTYREF:@VM_PUSHEMPTYREF
   ?"PUSHEMPTYREF"
  WHEN #VM_END:@VM_END
   ?"END"
  WHEN #VM_NEWARRAY:@VM_NEWARRAY
   ?"NEWARRAY",VM_OPS[VM_PC],VM_OPS[VM_PC+1]
   INC VM_PC,2
  WHEN #VM_PUSHARYREF:@VM_PUSHARYREF
   ?"PUSHARYREF",VM_OPS[VM_PC]
   INC VM_PC,1
  WHEN #VM_INITARRAY:@VM_INITARRAY
   ?"INITARRAY",VM_OPS[VM_PC]
   INC VM_PC,1
  WHEN #VM_READ:@VM_READ
   ?"READ"
  WHEN #VM_RESTORE:@VM_RESTORE
   ?"RESTORE",VM_OPS[VM_PC]
   INC VM_PC,1
  WHEN #VM_RESTORE_PLACEHOLDER:@VM_RESTORE_PLACEHOLDER
   ?"RESTORE",VM_IMM$[VM_OPS[VM_PC]]
   INC VM_PC,1
  WHEN #VM_UNAOP:@VM_UNAOP
   ?"UNAOP",VM_OPS[VM_PC]
   INC VM_PC,1
  WHEN #VM_CALLSPRITE:@VM_CALLSPRITE
   ?"CALLSPRITE"
  WHEN #VM_CALLTEXT:@VM_CALLTEXT
   ?"CALLTEXT"
  WHEN #VM_RESTOREEXPR:@VM_RESTOREEXPR
   ?"RESTOREEXPR"
  WHEN #VM_GOTOEXPR:@VM_GOTOEXPR
   ?"GOTOEXPR"
  WHEN #VM_GOSUBEXPR:@VM_GOSUBEXPR
   ?"GOSUBEXPR"
  WHEN #VM_INC:@VM_INC
   ?"INC"
  WHEN #VM_DEC:@VM_DEC
   ?"DEC"
  WHEN #VM_POP:@VM_POP
   ?"POP",VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_ONGOTO:@VM_ONGOTO
   VAR LEN=VM_OPS[VM_PC]
   INC VM_PC
   ?"ONGOTO",LEN
   INC VM_PC,LEN
  WHEN #VM_ONGOSUB:@VM_ONGOSUB
   LEN=VM_OPS[VM_PC]
   INC VM_PC
   ?"ONGOSUB",LEN
   INC VM_PC,LEN
  WHEN #VM_WHEN:@VM_WHEN
   ?"WHEN",VM_OPS[VM_PC]
   INC VM_PC
  WHEN #VM_SWAP:@VM_SWAP
   ?"SWAP"
  WHEN #VM_INPUT:@VM_INPUT
   ?"INPUT",VM_OPS[VM_PC],VM_OPS[VM_PC+1],VM_OPS[VM_PC+2]
   INC VM_PC,3
  WHEN #VM_LINPUT:@VM_LINPUT
   ?"LINPUT"
  WHEN #VM_DEFOUT:@VM_DEFOUT
   ?"DEFOUT"
  WHEN #VM_EXEC1:@VM_EXEC1
   ?"EXEC1"
  WHEN #VM_EXEC2:@VM_EXEC2
   ?"EXEC2"
  WHEN #VM_STOP1:@VM_STOP1
   ?"STOP1"
  WHEN #VM_STOP2:@VM_STOP2
   ?"STOP2"
  OTHERWISE:@VM_INVAL
   VM_ERROR
  ENDCASE
 ENDLOOP

END

'VM END




'VIRTUAL SLOT
DIM VSLOTL_LINE$[]
DIM VSLOTL_NEXT[]
DIM VSLOTL_PREV[]
VAR VSLOTL_FREE'FREELIST
DIM VSLOT[]
DIM VSLOT_CURLINE[]
DIM VSLOT_CURLINE_NO[]
DIM VSLOT_LINECNT[]
DIM VSLOT_CHRCNT[]
DIM VSLOT_EOF[]
VAR VSLOT_MAX
CONST #VSLOT_INVALSLOT=-1
VAR VSLOT_CURSLOT
DEF VSLOT_INIT
 VSLOT_CURSLOT=#VSLOT_INVALSLOT
 VSLOT_MAX=4
 VSLOT=ARRAY%(VSLOT_MAX)
 VSLOT_CURLINE=ARRAY%(VSLOT_MAX)
 VSLOT_CURLINE_NO=ARRAY%(VSLOT_MAX)
 VSLOT_LINECNT=ARRAY%(VSLOT_MAX)
 VSLOT_CHRCNT=ARRAY%(VSLOT_MAX)
 VSLOT_EOF=ARRAY%(VSLOT_MAX)
 VAR VSLOT_INIT_CAP=1024
 VSLOTL_LINE$=ARRAY$(VSLOT_INIT_CAP)
 VSLOTL_NEXT=ARRAY%(VSLOT_INIT_CAP)
 VSLOTL_PREV=ARRAY%(VSLOT_INIT_CAP)
 VAR I
 FOR I=1TO VSLOT_INIT_CAP-2
  VSLOTL_NEXT[I]=I+1
 NEXT
 VSLOTL_FREE=1
 FOR I=0TO VSLOT_MAX-1
  VSLOT_LOAD I,CHR$(10)
 NEXT
END

DEF NEW_VSLOTL()
 IF!VSLOTL_FREE THEN
  VAR LAST=LEN(VSLOTL_LINE$)
  RESIZE VSLOTL_LINE$,LEN(VSLOTL_LINE$)*2
  RESIZE VSLOTL_NEXT,LEN(VSLOTL_NEXT)*2
  RESIZE VSLOTL_PREV,LEN(VSLOTL_PREV)*2
  VAR I
  FOR I=LAST TO LEN(VSLOTL_NEXT)-2
   VSLOTL_NEXT[I]=I+1
  NEXT
  VSLOTL_FREE=LAST
 ENDIF
 VAR L=VSLOTL_FREE
 VSLOTL_FREE=VSLOTL_NEXT[VSLOTL_FREE]
 VSLOTL_NEXT[L]=0
 RETURN L
END

DEF DELETE_VSLOTL L
 VSLOTL_NEXT[L]=VSLOTL_FREE
 VSLOTL_FREE=L
 VSLOTL_PREV[L]=0
 VAR E$
 VSLOTL_LINE$[L]=E$
END

DEF VSLOT_DESTROY SLOT
 VAR S=VSLOT[SLOT]
 WHILE S
  VAR NXT=VSLOTL_NEXT[S]
  DELETE_VSLOTL S
  S=NXT
 WEND
 VSLOT[SLOT]=0
END

DEF VSLOT_DUMP SLOT
 VAR S=VSLOT[SLOT]
 VAR L
 WHILE S
  INC L
  IF S==VSLOT_CURLINE[SLOT]THEN
   ?VSLOT_CURLINE_NO[SLOT];"=>";
  ENDIF
  ?L;".";VSLOTL_LINE$[S];
  S=VSLOTL_NEXT[S]
 WEND
END

DEF VSLOT_DUMPR SLOT
 VAR S=VSLOT[SLOT]
 VAR L
 WHILE S
  INC L
  IF!VSLOTL_NEXT[S]THEN BREAK
  S=VSLOTL_NEXT[S]
 WEND
 WHILE S
  IF S==VSLOT_CURLINE[SLOT]THEN
   ?VSLOT_CURLINE_NO[SLOT];"=>";
  ENDIF
  ?L;".";VSLOTL_LINE$[S];
  S=VSLOTL_PREV[S]
  DEC L
 WEND
END


DEF VSLOT_LOAD SLOT,V$
 VAR I
 VAR LF$=CHR$(10)
 VSLOT_DESTROY SLOT
 VAR PREV=0
 VAR FRST
 VAR LINE
 VSLOT_CHRCNT[SLOT]=0
 LOOP
  IF I>=LEN(V$)THEN BREAK
  VAR NXTLF=INSTR(I,V$,LF$)
  IF NXTLF==-1 THEN
   NXTLF=LEN(V$)
  ENDIF
  VAR S$=MID$(V$,I,NXTLF-I+1)
  VAR L=NEW_VSLOTL()
  INC LINE
  INC VSLOT_CHRCNT[SLOT],LEN(S$)
  VSLOTL_LINE$[L]=S$
  IF!PREV THEN
   PREV=L
   FRST=L
  ELSE
   VSLOTL_NEXT[PREV]=L
   VSLOTL_PREV[L]=PREV
  ENDIF
  PREV=L
  I=NXTLF+1
 ENDLOOP
 VSLOT_LINECNT[SLOT]=LINE
 VSLOT[SLOT]=FRST
 VSLOT_CURLINE[SLOT]=PREV
 VSLOT_CURLINE_NO[SLOT]=LINE
 VSLOT_EOF[SLOT]=#TRUE
END

DEF VSLOT_SEEK(SLOT,DIFF)
 VSLOT_EOF[SLOT]=#FALSE
 IF DIFF==1 THEN
  IF VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]==0 THEN
   VSLOT_EOF[SLOT]=#TRUE
   RETURN 0
  ENDIF
  VSLOT_CURLINE[SLOT]=VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]
  INC VSLOT_CURLINE_NO[SLOT]
  RETURN 1
 ENDIF
 IF DIFF==-1 THEN
  IF VSLOTL_PREV[VSLOT_CURLINE[SLOT]]==0 THEN
   RETURN 0
  ENDIF
  VSLOT_CURLINE[SLOT]=VSLOTL_PREV[VSLOT_CURLINE[SLOT]]
  DEC VSLOT_CURLINE_NO[SLOT]
  RETURN 1
 ENDIF
 STOP
END
DEF VSLOT_SEEKEOF SLOT
 LOOP
  IF VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]==0 THEN
   VSLOT_EOF[SLOT]=#TRUE
   BREAK
  ENDIF
  VSLOT_CURLINE[SLOT]=VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]
  INC VSLOT_CURLINE_NO[SLOT]
 ENDLOOP
END
DEF VSLOT_SEEKLINE SLOT,LINE
 VAR DIFF=LINE-VSLOT_CURLINE_NO[SLOT]
 VSLOT_EOF[SLOT]=#FALSE
 IF DIFF==0 THEN
  RETURN
 ENDIF
 IF DIFF>0 THEN
  FOR DIFF=DIFF TO 1 STEP -1
   IF VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]==0 THEN
    BREAK
   ENDIF
   VSLOT_CURLINE[SLOT]=VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]
   INC VSLOT_CURLINE_NO[SLOT]
  NEXT
 ELSE
  FOR DIFF=DIFF TO -1
   IF VSLOTL_PREV[VSLOT_CURLINE[SLOT]]==0 THEN
    BREAK
   ENDIF
   VSLOT_CURLINE[SLOT]=VSLOTL_PREV[VSLOT_CURLINE[SLOT]]
   DEC VSLOT_CURLINE_NO[SLOT]
  NEXT
 ENDIF
END

DEF VSLOT_SET SLOT,V$
 V$=V$+CHR$(10)
 VAR I
 VAR LF$=CHR$(10)
 VAR NL
 VAR MULTIPLE
 IF!VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]&&!VSLOT_EOF[SLOT]THEN
  NL=NEW_VSLOTL()
  VSLOTL_LINE$[NL]=LF$
  INC VSLOT_CHRCNT[SLOT]
  VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]=NL
  VSLOTL_PREV[NL]=VSLOT_CURLINE[SLOT]
  INC VSLOT_LINECNT[SLOT]
 ENDIF
 LOOP
  VAR NXTLF=INSTR(I,V$,LF$)
  IF NXTLF==-1 THEN
   NXTLF=LEN(V$)
  ENDIF
  VAR LINE$=MID$(V$,I,NXTLF-I+1)
  VAR L=VSLOT_CURLINE[SLOT]
  INC VSLOT_CHRCNT[SLOT],LEN(LINE$)-LEN(VSLOTL_LINE$[L])
  VSLOTL_LINE$[L]=LINE$
  I=NXTLF+1
  IF I>=LEN(V$)THEN BREAK
  INC VSLOT_CURLINE_NO[SLOT]
  INC VSLOT_LINECNT[SLOT]
  NL=NEW_VSLOTL()
  VSLOTL_PREV[NL]=L
  VSLOTL_NEXT[NL]=VSLOTL_NEXT[L]
  VSLOTL_PREV[VSLOTL_NEXT[L]]=NL
  VSLOTL_NEXT[L]=NL
  VSLOT_CURLINE[SLOT]=NL
  MULTIPLE=#TRUE
 ENDLOOP
 IF VSLOT_EOF[SLOT]THEN
  NL=NEW_VSLOTL()
  VSLOTL_PREV[NL]=L
  VSLOTL_NEXT[L]=NL
  VSLOTL_LINE$[NL]=LF$
  VSLOT_CURLINE[SLOT]=NL
  INC VSLOT_LINECNT[SLOT]
  INC VSLOT_CURLINE_NO[SLOT]
  INC VSLOT_CHRCNT[SLOT],LEN(LF$)
 ELSE
  INC VSLOT_CURLINE_NO[SLOT]
  IF VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]THEN
   VSLOT_CURLINE[SLOT]=VSLOTL_NEXT[VSLOT_CURLINE[SLOT]]
  ENDIF
 ENDIF
END

DEF VSLOT_INS SLOT,V$,PS
 V$=V$+CHR$(10)
 VAR I
 VAR LF$=CHR$(10)
 VAR NL
 VAR INSTO=VSLOT_CURLINE[SLOT]
 IF PS THEN
  INSTO=INSTO
 ELSE
  INSTO=VSLOTL_PREV[INSTO]
 ENDIF
 IF !INSTO&&PS THEN
  INSTO=VSLOT_CURLINE[SLOT]
 ENDIF
 LOOP
  VAR NXTLF=INSTR(I,V$,LF$)
  IF NXTLF==-1 THEN
   NXTLF=LEN(V$)
  ENDIF
  VAR LINE$=MID$(V$,I,NXTLF-I+1)
  NL=NEW_VSLOTL()
  IF !INSTO THEN
   VSLOTL_PREV[NL]=INSTO
   VSLOTL_NEXT[NL]=VSLOTL_NEXT[INSTO]
   IF INSTO THEN
    VSLOTL_NEXT[INSTO]=NL
   ELSE
    VSLOTL_NEXT[NL]=VSLOT[SLOT]
    VSLOTL_PREV[VSLOT[SLOT]]=NL
    VSLOT[SLOT]=NL
   ENDIF
  ELSE
   VAR PRV=VSLOTL_PREV[INSTO]
   VAR NXT=VSLOTL_NEXT[INSTO]
   VSLOTL_NEXT[INSTO]=NL
   VSLOTL_NEXT[NL]=NXT
   VSLOTL_PREV[NL]=INSTO
   VSLOTL_PREV[NXT]=NL
  ENDIF
  INC VSLOT_CURLINE_NO[SLOT]
  IF PS THEN
   VSLOT_CURLINE[SLOT]=NL
  ELSE
   VSLOT_CURLINE[SLOT]=VSLOTL_NEXT[NL]
  ENDIF
  INSTO=NL
  INC VSLOT_LINECNT[SLOT]
  INC VSLOT_CHRCNT[SLOT],LEN(LINE$)
  VAR L=NL
  VSLOTL_LINE$[L]=LINE$
  I=NXTLF+1
  IF I>=LEN(V$)THEN BREAK
 ENDLOOP
END

DEF VSLOT_DEL SLOT,D
 IF D<0THEN
  VAR PRSV=VSLOT_EOF[SLOT]
  VSLOT_DESTROY SLOT
  VSLOT_LOAD SLOT,CHR$(10)
  VSLOT_EOF[SLOT]=PRSV
  RETURN
 ENDIF
 VAR CL=VSLOT_CURLINE[SLOT]
 VAR DELFRST
 WHILE D>0&&CL
  DEC D
  VAR NXT=VSLOTL_NEXT[CL]
  VAR PRV=VSLOTL_PREV[CL]
  DEC VSLOT_LINECNT[SLOT]
  DEC VSLOT_CHRCNT[SLOT],LEN(VSLOTL_LINE$[CL])
  VSLOTL_NEXT[PRV]=NXT
  IF NXT THEN
   VSLOTL_PREV[NXT]=PRV
  ELSE
   DEC VSLOT_CURLINE_NO[SLOT]
   NXT=PRV
  ENDIF
  VSLOT_CURLINE[SLOT]=NXT
  DELETE_VSLOTL CL
  IF CL==VSLOT[SLOT]THEN
   IF NXT THEN
    VSLOT[SLOT]=NXT
    VSLOT_CURLINE_NO[SLOT]=1
   ELSE
    DELFRST=#TRUE
   ENDIF
  ENDIF
  CL=NXT
 WEND
 IF DELFRST THEN
  PRSV=VSLOT_EOF[SLOT]
  VSLOT[SLOT]=0
  VSLOT_LOAD SLOT,CHR$(10)
  VSLOT_EOF[SLOT]=PRSV
 ENDIF
END

DEF VSLOT_PRGEDIT SLOT,LINE
 VSLOT_CURSLOT=SLOT
 IF LINE!=-1 THEN
  VSLOT_SEEKLINE SLOT,LINE
 ELSE
  VSLOT_SEEKEOF SLOT
 ENDIF
END

DEF VSLOT_PRGGET$(SEEKFLG)
 IF VSLOT_EOF[VSLOT_CURSLOT]THEN
  RETURN ""
 ENDIF
 VAR V$=VSLOTL_LINE$[VSLOT_CURLINE[VSLOT_CURSLOT]]
 IF SEEKFLG THEN
  VAR _=VSLOT_SEEK(VSLOT_CURSLOT,1)
 ENDIF
 RETURN V$
END

DEF VSLOT_PRGSEEK(D)
 RETURN VSLOT_SEEK(VSLOT_CURSLOT,D)
END

DEF VSLOT_PRGEDIT_OUT OUT SLOT,LINE
 SLOT=VSLOT_CURSLOT
 LINE=VSLOT_CURLINE_NO[SLOT]
END

DEF VSLOT_PRGSET L$
 VSLOT_SET VSLOT_CURSLOT,L$
END

DEF VSLOT_PRGINS L$,D
 VSLOT_INS VSLOT_CURSLOT,L$,D
END

DEF VSLOT_PRGDEL D
 VSLOT_DEL VSLOT_CURSLOT,D
END

DEF VSLOT_PRGSIZE(SLOT,TYP)
 IF TYP==0 THEN
  IF VSLOT_LINECNT[SLOT]==1&&VSLOTL_LINE$[VSLOT[SLOT]]==CHR$(10)THEN
   RETURN 0
  ENDIF
  RETURN VSLOT_LINECNT[SLOT]
 ELSEIF TYP==1THEN
  RETURN VSLOT_CHRCNT[SLOT]
 ENDIF
 RETURN 1048576-VSLOT_CHRCNT[SLOT]
END


VAR VSLOT_TEST_SLOT
DEF VSLOT_TEST_SET LINE,STR$
 VAR I
 FOR I=0TO LAST(STR$)
  IF STR$[I]=="/"THEN STR$[I]=CHR$(10)
 NEXT
 VSLOT_PRGEDIT VSLOT_TEST_SLOT,1
 VSLOT_PRGDEL -1
 VSLOT_PRGSET STR$
 VSLOT_PRGEDIT VSLOT_TEST_SLOT,LINE
 PRGEDIT VSLOT_TEST_SLOT
 PRGDEL -1
 PRGSET STR$
 PRGEDIT VSLOT_TEST_SLOT,LINE
END
VAR VSLOT_ASSERT_FAILED
DEF VSLOT_ASSERT *
 IF!DEFARG(0)THEN
  VSLOT_ASSERT_FAILED=#TRUE
  ?"Assertion failed",DEFARG(1),"SLOT ";DEFARG(2);" LINE ";DEFARG(3);" FILE ";CHR$(34);DEFARG(4);CHR$(34)
 ENDIF
END
DEF VSLOT_ASSERT_EQ L,L$,R,R$,SLOT,LINE,FILE
 IF L!=R THEN
  VSLOT_ASSERT_FAILED=#TRUE
  VAR LL$=VSLOT_TEST_ESCAPE$(L)
  VAR RR$=VSLOT_TEST_ESCAPE$(R)
  ?"Assertion failed",LL$;"!=";RR$,L$;"!=";R$,"SLOT ";SLOT;" LINE ";LINE;" FILE ";CHR$(34);FILE;CHR$(34)
 ENDIF
END
DEF VSLOT_TEST_ESCAPE$(S$)
 IF TYPEOF(S$)==#T_STR THEN
  VAR I
  VAR R$=""
  PUSH R$,CHR$(34)
  FOR I=0TO LAST(S$)
   IF ASC(S$[I])==10THEN
    PUSH R$,"\n"
   ELSEIF S$[I]=="\"THEN
    PUSH R$,"\\"
   ELSE
    PUSH R$,S$[I]
   ENDIF
  NEXT
  PUSH R$,CHR$(34)
  RETURN R$
 ELSE
  RETURN STR$(S$)
 ENDIF
END
VAR VSLOT_TEST_CNT
VAR VSLOT_TEST_SUCC_CNT
VAR VSLOT_TEST_FAILED_CNT
DEF VSLOT_CHECK
 INC VSLOT_TEST_CNT
 VSLOT_ASSERT_FAILED=#FALSE
 VAR SLOT=VSLOT_TEST_SLOT
 VAR S=VSLOT[SLOT]
 VAR L
 VAR LINES$[]
 VAR LINESR$[]
 VAR P_IS_EOF=PRGGET$(#FALSE)==""
 VAR V_IS_EOF=VSLOT_EOF[SLOT]
 VSLOT_ASSERT_EQ P_IS_EOF,"P_IS_EOF",V_IS_EOF,"V_IS_EOF",#_SLOT,#_LINE,#_FILENAME
 VAR P_LINE=PRGEDIT()
 VAR V_LINE=VSLOT_CURLINE_NO[SLOT]
 VSLOT_ASSERT_EQ P_LINE,"P_LINE",V_LINE,"V_LINE",#_SLOT,#_LINE,#_FILENAME
 VSLOT_ASSERT_EQ PRGGET$(#FALSE),"PRGGET$(#FALSE)",VSLOT_PRGGET$(#FALSE),"VSLOT_PRGGET$(#FALSE)",#_SLOT,#_LINE,#_FILENAME
 VAR HAS_CURLINE
 WHILE S
  INC L
  IF S==VSLOT_CURLINE[SLOT]THEN
   VSLOT_ASSERT_EQ VSLOT_CURLINE_NO[SLOT],"VSLOT_CURLINE_NO[SLOT]",L,"L",#_SLOT,#_LINE,#_FILENAME
   HAS_CURLINE=#TRUE
  ENDIF
  PUSH LINES$,VSLOTL_LINE$[S]
  IF!VSLOTL_NEXT[S] THEN
   BREAK
  ENDIF
  S=VSLOTL_NEXT[S]
 WEND
 VSLOT_ASSERT HAS_CURLINE,"HAS_CURLINE",#_SLOT,#_LINE,#_FILENAME
 HAS_CURLINE=#FALSE
 VAR V_LINE_CNT=L
 WHILE S
  IF S==VSLOT_CURLINE[SLOT]THEN
   VSLOT_ASSERT_EQ VSLOT_CURLINE_NO[SLOT],"VSLOT_CURLINE_NO[SLOT]",L,"L",#_SLOT,#_LINE,#_FILENAME
   HAS_CURLINE=#TRUE
  ENDIF
  UNSHIFT LINESR$,VSLOTL_LINE$[S]
  S=VSLOTL_PREV[S]
  DEC L
 WEND
 VSLOT_ASSERT HAS_CURLINE,"HAS_CURLINE",#_SLOT,#_LINE,#_FILENAME
 PRGEDIT SLOT,1
 DIM LINESP$[]
 LOOP
  VAR L$=PRGGET$()
  IF L$==""THEN BREAK
  PUSH LINESP$,L$
 ENDLOOP
 PRGEDIT SLOT,-1
 VAR P_LINE_CNT=PRGEDIT()
 VSLOT_ASSERT_EQ P_LINE_CNT,"P_LINE_CNT",V_LINE_CNT,"V_LINE_CNT",#_SLOT,#_LINE,#_FILENAME
 VSLOT_ASSERT_EQ LEN(LINES$),"LEN(LINES$)",LEN(LINESP$),"LEN(LINESP$)",#_SLOT,#_LINE,#_FILENAME
 VSLOT_ASSERT LEN(LINES$),"LEN(LINES$)",LEN(LINESR$),"LEN(LINESR$)",#_SLOT,#_LINE,#_FILENAME
 VAR I
 FOR I=0TO MIN(LAST(LINES$[I]),LAST(LINESP$),LAST(LINESR$))'P_LINE-1
  VSLOT_ASSERT_EQ LINES$[I],"LINES$[I]",LINESP$[I],"LINESP$[I]",#_SLOT,#_LINE,#_FILENAME
  VSLOT_ASSERT_EQ LINES$[I],"LINES$[I]",LINESR$[I],"LINESR$[I]",#_SLOT,#_LINE,#_FILENAME
 NEXT
 VSLOT_ASSERT_EQ PRGSIZE(VSLOT_TEST_SLOT,0),"PRGSIZE(VSLOT_TEST_SLOT,0)",VSLOT_PRGSIZE(VSLOT_TEST_SLOT,0),"VSLOT_PRGSIZE(VSLOT_TEST_SLOT,0)",#_SLOT,#_LINE,#_FILENAME
 VSLOT_ASSERT_EQ PRGSIZE(VSLOT_TEST_SLOT,1),"PRGSIZE(VSLOT_TEST_SLOT,1)",VSLOT_PRGSIZE(VSLOT_TEST_SLOT,1),"VSLOT_PRGSIZE(VSLOT_TEST_SLOT,1)",#_SLOT,#_LINE,#_FILENAME
 IF VSLOT_ASSERT_FAILED THEN
  ?FORMAT$("%15S%15S%15S","LINESP","LINES","LINESR")
  FOR I=0TO MAX(LAST(LINES$),LAST(LINESP$),LAST(LINESR$))
   IF LEN(LINESP$)>I THEN
    ?FORMAT$("%20S",VSLOT_TEST_ESCAPE$(LINESP$[I]));
   ELSE
    ?FORMAT$("%20S","XXX");
   ENDIF
   IF LEN(LINES$)>I THEN
    ?FORMAT$("%20S",VSLOT_TEST_ESCAPE$(LINES$[I]));
   ELSE
    ?FORMAT$("%20S","XXX");
   ENDIF
   IF LEN(LINESR$)>I THEN
    ?FORMAT$("%20S",VSLOT_TEST_ESCAPE$(LINESR$[I]))
   ELSE
    ?FORMAT$("%20S","XXX");
   ENDIF
  NEXT
 ENDIF
 IF VSLOT_ASSERT_FAILED THEN
  INC VSLOT_TEST_FAILED_CNT
  STOP
 ELSE
  INC VSLOT_TEST_SUCC_CNT
 ENDIF
END

DEF VSLOT_TEST_PRGINS A$,B
 PRGINS A$,B
 VSLOT_PRGINS A$,B
END
DEF VSLOT_TEST_PRGSET A$
 PRGSET A$
 VSLOT_PRGSET A$
END
DEF VSLOT_TEST_PRGDEL L
 PRGDEL L
 VSLOT_PRGDEL L
END
DEF VSLOT_TEST_PRGSEEK L
 VSLOT_ASSERT_EQ PRGSEEK(L),"PRGSEEK("+STR$(L)+")",VSLOT_PRGSEEK(L),"VSLOT_PRGSEEK("+STR$(L)+")",#_SLOT,#_LINE,#_FILENAME
END
DEF VSLOT_TEST_PRGGET L
 VSLOT_ASSERT_EQ PRGGET$(L),"PRGGET$("+STR$(L)+")",VSLOT_PRGGET$(L),"VSLOT_PRGGET$("+STR$(L)+")",#_SLOT,#_LINE,#_FILENAME
END

DEF VSLOT_TEST
 VSLOT_TEST_SLOT=3
 VAR I,J,K
 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 "+STR$(I)
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGINS "PRGINS0,"+STR$(I),0
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGINS "PRGINS1,"+STR$(I),1
  VSLOT_CHECK
 NEXT


 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGINS "PRGINS0,"+STR$(I)+CHR$(10)+"\n",0
  VSLOT_CHECK
 NEXT


 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGINS "PRGINS1,"+STR$(I)+CHR$(10)+"\n",1
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGSET "PRGSET"+STR$(I)
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGSET "PRGSET"+STR$(I)+CHR$(10)+"\n"
  VSLOT_CHECK
 NEXT


 FOR I=-1TO 2
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,""
  VSLOT_TEST_PRGSET "PRGSET"+STR$(I)+CHR$(10)+"\n"
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3"
  VSLOT_TEST_PRGSET "PRGSET"+STR$(I)+CHR$(10)+"\n1"
  VSLOT_TEST_PRGINS "PRGINS0,"+STR$(I)+CHR$(10)+"\n2",0
  VSLOT_TEST_PRGINS "PRGINS1,"+STR$(I)+CHR$(10)+"\n3",1
  VSLOT_TEST_PRGSET "PRGSET"+STR$(I)+CHR$(10)+"\n4"
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 DEL"+STR$(I)
  VSLOT_TEST_PRGDEL -1
  VSLOT_CHECK
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  FOR J=-1TO 5
   IF J==0THEN CONTINUE
   VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 DEL"+STR$(I)+","+STR$(J)
   VSLOT_TEST_PRGDEL J
   VSLOT_CHECK
  NEXT
 NEXT

 FOR I=-1TO 5
  IF I==0THEN CONTINUE
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 SEEK"+STR$(I)
  VSLOT_TEST_PRGSEEK 1
  VSLOT_CHECK
  VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 SEEK"+STR$(I)
  VSLOT_TEST_PRGSEEK -1
  VSLOT_CHECK
  FOR J=0TO 5
   VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 GET0,"+STR$(I)
   FOR K=0TO J
    VSLOT_TEST_PRGGET 0
   NEXT
   VSLOT_CHECK
   VSLOT_TEST_SET I,"LINE1/LINE2/LINE3 GET1,"+STR$(I)
   FOR K=0TO J
    VSLOT_TEST_PRGGET 1
   NEXT
   VSLOT_CHECK
  NEXT
 NEXT
 ?"(";VSLOT_TEST_SUCC_CNT;"/";VSLOT_TEST_CNT;") passed"
 STOP
END


'INTERFACES
DEF SBSB_LOAD * OUT *
 IF DEFARGC()!=0 THEN
  MISSING_PARAMETER "LOAD"
  RETURN
 ENDIF
 IF DEFARGC()!=1&&DEFARGC()!=2 THEN
  MISSING_PARAMETER "LOAD"
  RETURN
 ENDIF
 VAR FN$=DEFARG(0)
 VAR SLOT=0
 IF TYPEOF(FN$)!=#T_STR THEN
  TYPE_MISMATCH "LOAD"
  RETURN
 ENDIF
 IF DEFARGC()==2THEN
  SLOT=DEFARG(1)
  IF TYPEOF(SLOT)!=#T_INT THEN
   TYPE_MISMATCH "LOAD"
   RETURN
  ENDIF
 ENDIF
 IF SLOT<0||SLOT>=VSLOT_MAX THEN
  OUT_OF_RANGE "LOAD"
  RETURN
 ENDIF
 IF INSTR(FN$,"TXT:")!=0 THEN
  FN$="TXT:"+FN$
 ENDIF
 'FIXME:VALIDATE FILENAME
 VAR V$=LOADV(FN$)
 VSLOT_LOAD SLOT,V$
END


DEF SBSB_PRGEDIT * OUT *
 IF DEFARGC()==0&&DEFOUTC()==1THEN
 ELSEIF DEFARGC()==0&&DEFOUTC()==2THEN
 ELSEIF DEFARGC()==1&&DEFOUTC()==0THEN
 ELSEIF DEFARGC()==2&&DEFOUTC()==0THEN
 ELSE
  MISSING_PARAMETER "PRGEDIT"
 ENDIF
END


'UTIL

DIM SPLAYN_LEFT[]
DIM SPLAYN_RIGHT[]
DIM SPLAYN_PARENT[]
DIM SPLAYN_KEY$[]
DIM SPLAYN_VAL$[]
DIM SPLAYN_VAL%[]
DIM SPLAYN_VAL#[]
DIM SPLAY_ROOT[]
VAR SPLAY_INIT

DEF INIT_SPLAY
 VAR S=1
 SPLAYN_LEFT=ARRAY%(S)
 SPLAYN_RIGHT=ARRAY%(S)
 SPLAYN_PARENT=ARRAY%(S)
 SPLAYN_KEY$=ARRAY$(S)
 SPLAYN_VAL$=ARRAY$(S)
 SPLAYN_VAL#=ARRAY%(S)
 SPLAYN_VAL%=ARRAY%(S)
 SPLAY_ROOT=ARRAY%(S)
 SPLAY_INIT=#TRUE
END

DEF NEW_SPLAY_TREE()
 IF!SPLAY_INIT THEN
  INIT_SPLAY
 ENDIF
 PUSH SPLAY_ROOT,0
 RETURN LAST(SPLAY_ROOT)
END
DEF NEW_SPLAYN(K$)
 PUSH SPLAYN_LEFT,0
 PUSH SPLAYN_RIGHT,0
 PUSH SPLAYN_PARENT,0
 PUSH SPLAYN_KEY$,K$
 VAR E$
 PUSH SPLAYN_VAL$,E$
 PUSH SPLAYN_VAL%,0
 PUSH SPLAYN_VAL#,0
 RETURN LAST(SPLAYN_LEFT)
END
DEF NEW_SPLAYN%(K$,V%)
 VAR S=NEW_SPLAYN(K$)
 SPLAYN_VAL%[S]=V%
 RETURN S
END
DEF NEW_SPLAYN#(K$,V#)
 VAR S=NEW_SPLAYN(K$)
 SPLAYN_VAL#[S]=V#
 RETURN S
END
DEF NEW_SPLAYN$(K$,V$)
 VAR S=NEW_SPLAYN(K$)
 SPLAYN_VAL$[S]=V$
 RETURN S
END

DEF SPLAY_LEFT_ROTATE S,X
 VAR Y=SPLAYN_RIGHT[X]
 IF Y THEN
  SPLAYN_RIGHT[X]=SPLAYN_LEFT[Y]
  IF SPLAYN_LEFT[Y] THEN
   SPLAYN_PARENT[SPLAYN_LEFT[Y]]=X
  ENDIF
  SPLAYN_PARENT[Y]=SPLAYN_PARENT[X]
 ENDIF
 IF !SPLAYN_PARENT[X] THEN
  SPLAY_ROOT[S]=Y
 ELSEIF X==SPLAYN_LEFT[SPLAYN_PARENT[X]] THEN
  SPLAYN_LEFT[SPLAYN_PARENT[X]]=Y
 ELSE
  SPLAYN_RIGHT[SPLAYN_PARENT[X]]=Y
 ENDIF
 IF Y THEN
  SPLAYN_LEFT[Y]=X
 ENDIF
 SPLAYN_PARENT[X]=Y
END

DEF SPLAY_RIGHT_ROTATE S,X
 VAR Y=SPLAYN_LEFT[X]
 IF Y THEN
  SPLAYN_LEFT[X]=SPLAYN_RIGHT[Y]
  IF SPLAYN_RIGHT[Y]THEN
   SPLAYN_PARENT[SPLAYN_RIGHT[Y]]=X
  ENDIF
  SPLAYN_PARENT[Y]=SPLAYN_PARENT[X]
 ENDIF
 IF !SPLAYN_PARENT[X]THEN
  SPLAY_ROOT[S]=Y
 ELSEIF X==SPLAYN_LEFT[SPLAYN_PARENT[X]]THEN
  SPLAYN_LEFT[SPLAYN_PARENT[X]]=Y
 ELSE
  SPLAYN_RIGHT[SPLAYN_PARENT[X]]=Y
 ENDIF
 IF Y THEN
  SPLAYN_RIGHT[Y]=X
 ENDIF
 SPLAYN_PARENT[X]=Y
END

DEF SPLAY S,X
 WHILE SPLAYN_PARENT[X]
  VAR P=SPLAYN_PARENT[X]
  IF !SPLAYN_PARENT[P]THEN
   IF SPLAYN_LEFT[P]==X THEN
    SPLAY_RIGHT_ROTATE S,P
   ELSE
    SPLAY_LEFT_ROTATE S,P
   ENDIF
  ELSEIF SPLAYN_LEFT[P]==X&&SPLAYN_LEFT[SPLAYN_PARENT[P]]==P THEN
   SPLAY_RIGHT_ROTATE S,SPLAYN_PARENT[P]
   SPLAY_RIGHT_ROTATE S,SPLAYN_PARENT[X]
  ELSEIF SPLAYN_RIGHT[P]==X&&SPLAYN_RIGHT[SPLAYN_PARENT[P]]==P THEN
   SPLAY_LEFT_ROTATE S,SPLAYN_PARENT[P]
   SPLAY_LEFT_ROTATE S,SPLAYN_PARENT[X]
  ELSEIF SPLAYN_LEFT[P]==X&&SPLAYN_RIGHT[SPLAYN_PARENT[P]]==P THEN
   SPLAY_RIGHT_ROTATE S,P
   SPLAY_LEFT_ROTATE S,SPLAYN_PARENT[X]
  ELSE
   SPLAY_LEFT_ROTATE S,P
   SPLAY_RIGHT_ROTATE S,SPLAYN_PARENT[X]
  ENDIF
 WEND
END
DEF SPLAY_REPLACE S,U,V
 IF !SPLAYN_PARENT[U]THEN
  SPLAY_ROOT[S]=V
 ELSEIF U==SPLAYN_LEFT[SPLAYN_PARENT[U]]THEN
  SPLAYN_LEFT[SPLAYN_PARENT[U]]=V
 ELSE
  SPLAYN_RIGHT[SPLAYN_PARENT[U]]=V
 ENDIF
 IF V THEN
  SPLAYN_PARENT[V]=SPLAYN_PARENT[U]
 ENDIF
END

DEF SPLAY_SUBTREE_MIN(S,U)
 WHILE SPLAYN_LEFT[U]
  U=SPLAYN_LEFT[U]
 WEND
 RETURN U
END
DEF SPLAY_SUBTREE_MAX(S,U)
 WHILE SPLAYN_RIGHT[U]
  U=SPLAYN_RIGHT[U]
 WEND
 RETURN U
END

DEF SPLAY_INSERT% S,KEY$,VALUE%
 SPLAY_INSERT S,KEY$,VALUE%,#T_INT
END
DEF SPLAY_INSERT$ S,KEY$,VALUE$
 SPLAY_INSERT S,KEY$,VALUE$,#T_STR
END
DEF SPLAY_INSERT# S,KEY$,VALUE#
 SPLAY_INSERT S,KEY$,VALUE#,#T_REAL
END

DEF SPLAY_INSERT S,KEY$,VALUE,T
 VAR Z=SPLAY_ROOT[S]
 VAR P
 WHILE Z
  P=Z
  IF SPLAYN_KEY$[Z]<KEY$THEN
   Z=SPLAYN_RIGHT[Z]
  ELSE
   Z=SPLAYN_LEFT[Z]
  ENDIF
 WEND
 CASE T
 WHEN #T_INT
  Z=NEW_SPLAYN%(KEY$,VALUE)
 WHEN #T_STR
  Z=NEW_SPLAYN$(KEY$,VALUE)
 WHEN #T_REAL
  Z=NEW_SPLAYN#(KEY$,VALUE)
 ENDCASE
 SPLAYN_PARENT[Z]=P
 IF !P THEN
  SPLAY_ROOT[S]=Z
 ELSEIF SPLAYN_KEY$[P]<SPLAYN_KEY$[Z]THEN
  SPLAYN_RIGHT[P]=Z
 ELSE
  SPLAYN_LEFT[P]=Z
 ENDIF
 SPLAY S,Z
END

DEF SPLAY_FIND(S,KEY$)
 VAR Z=SPLAY_ROOT[S]
 WHILE Z
  IF SPLAYN_KEY$[Z]<KEY$THEN
   Z=SPLAYN_RIGHT[Z]
  ELSEIF SPLAYN_KEY$[Z]==KEY$THEN
   RETURN Z
  ELSE
   Z=SPLAYN_LEFT[Z]
  ENDIF
 WEND
 RETURN 0
END

DEF SPLAY_GET% S,KEY$ OUT FOUND,VALUE%
 VAR N=SPLAY_FIND(S,KEY$)
 IF !N THEN
  FOUND=#FALSE
  VALUE%=0
  RETURN
 ENDIF
 FOUND=#TRUE
 VALUE%=SPLAYN_VAL%[N]
END
DEF SPLAY_GET# S,KEY$ OUT FOUND,VALUE#
 VAR N=SPLAY_FIND(S,KEY$)
 IF !N THEN
  FOUND=#FALSE
  VALUE#=0E0
  RETURN
 ENDIF
 FOUND=#TRUE
 VALUE#=SPLAYN_VAL#[N]
END
DEF SPLAY_GET$ S,KEY$ OUT FOUND,VALUE$
 VAR N=SPLAY_FIND(S,KEY$)
 IF !N THEN
  FOUND=#FALSE
  VALUE$=""
  RETURN
 ENDIF
 FOUND=#TRUE
 VALUE$=SPLAYN_VAL$[N]
END

DEF SPLAY_ERASE S,KEY$
 VAR Z=SPLAY_FIND(S,KEY$)
 IF !Z THEN
  RETURN
 ENDIF
 SPLAY S,Z
 IF !SPLAYN_LEFT[Z]THEN
  SPLAY_REPLACE S,Z,SPLAYN_RIGHT[Z]
 ELSEIF !SPLAYN_RIGHT[Z]THEN
  SPLAY_REPLACE S,Z,SPLAYN_LEFT[Z]
 ELSE
  VAR Y=SPLAY_SUBTREE_MIN(S,SPLAYN_RIGHT[Z])
  IF SPLAYN_PARENT[Y]!=Z THEN
   SPLAY_REPLACE S,Y,SPLAYN_RIGHT[Y]
   SPLAYN_RIGHT[Y]=SPLAYN_RIGHT[Z]
   SPLAYN_PARENT[SPLAYN_RIGHT[Y]]=Y
  ENDIF
  SPLAY_REPLACE S,Z,Y
  SPLAYN_LEFT[Y]=SPLAYN_LEFT[Z]
  SPLAYN_PARENT[SPLAYN_LEFT[Y]]=Y
 ENDIF
 'DELETE Z
END

DEF SPLAY_TEST
 VAR T=NEW_SPLAY_TREE()
 SPLAY_INSERT T,"K","V1"
 SPLAY_INSERT T,"K2","V2"
 SPLAY_INSERT T,"K3","V3"
 VAR F
 SPLAY_GET T,"K" OUT ,F
 ?F
 SPLAY_GET T,"K2" OUT ,F
 ?F
 SPLAY_GET T,"K3" OUT ,F
 ?F
 SPLAY_ERASE T,"K2"
 SPLAY_GET T,"K" OUT ,F
 ?F
 SPLAY_GET T,"K2" OUT ,F
 ?F
 SPLAY_GET T,"K3" OUT ,F
 ?F
 SPLAY_ERASE T,"K3"
 SPLAY_ERASE T,"K"
 SPLAY_GET T,"K" OUT ,F
 ?F
 SPLAY_GET T,"K2" OUT ,F
 ?F
 SPLAY_GET T,"K3" OUT ,F
 ?F

 VAR I
 VAR O=50000
 DIM LST1=ARRAY$(0)
 DIM LST2=ARRAY$(0)
 FOR I=0TO O-1
  PUSH LST1,STR$(I)
  PUSH LST2,STR$(I)
 NEXT
 FOR I=0TO O*10
  SWAP LST1[RND(O)],LST1[RND(O)]
  SWAP LST2[RND(O)],LST2[RND(O)]
 NEXT
 PERFBEGIN 0
 FOR I=0TO O-1
  SPLAY_INSERT T,LST1[I],"a"
 NEXT
 ?PERFEND(0)/O
 PERFBEGIN 0
 FOR I=0TO O-1
  SPLAY_GET T,LST2[I] OUT ,
 NEXT
 ?PERFEND(0)/O
 PERFBEGIN 0
 FOR I=0TO O-1
  SPVAR #GSPRITE,LST1[I],"a"
 NEXT
 ?PERFEND(0)/O
 PERFBEGIN 0
 VAR A$
 FOR I=0TO O-1
  SPVAR #GSPRITE,LST2[I] OUT A$
 NEXT
 ?PERFEND(0)/O
END

DEF GET_SPLAY_ROOT(S)
 RETURN SPLAY_ROOT[S]
END
DEF GET_SPLAYN_LEFT(S)
 RETURN SPLAYN_LEFT[S]
END
DEF GET_SPLAYN_RIGHT(S)
 RETURN SPLAYN_RIGHT[S]
END
DEF GET_SPLAYN_VAL%(S)
 RETURN SPLAYN_VAL%[S]
END
DEF GET_SPLAYN_VAL#(S)
 RETURN SPLAYN_VAL#[S]
END
DEF GET_SPLAYN_VAL$(S)
 RETURN SPLAYN_VAL$[S]
END
DEF GET_SPLAYN_KEY$(S)
 RETURN SPLAYN_KEY$[S]
END

DIM NULLARRAY[0]
DIM SBARY[0]
VAR SBARYMAX
VAR SBARYFREE
DEF OTX_INIT_SBARRAY
 SBARYMAX=1024'256
 SBARY=ARRAY%(SBARYMAX)
 VAR I
 FOR I=0TO SBARYMAX-2
  SBARY[I]=I+1
 NEXT
 SBARY[SBARYMAX-1]=-1
 SBARYFREE=1
 NULLARRAY=ARRAY%(0)
END
COMMON DEF AllocSBArray()
 VAR A=SBARYFREE
 IF A==-1THEN RETURN -1
 SBARYFREE=SBARY[A]
 RETURN A
END
COMMON DEF FreeSBArray A
 SBARY[A]=SBARYFREE
 SBARYFREE=A
 VAR("_"+HEX$(A))=NULLARRAY
END
COMMON DEF GetSBArray(A)
 RETURN VAR("_"+HEX$(A))
END
COMMON DEF SetSBArray A,ARY
 VAR("_"+HEX$(A))=ARY
END
DIM _0[0],_1[0],_2[0],_3[0],_4[0],_5[0],_6[0],_7[0],_8[0],_9[0],_A[0],_B[0],_C[0],_D[0],_E[0],_F[0],_10[0],_11[0],_12[0],_13[0],_14[0],_15[0],_16[0],_17[0],_18[0],_19[0],_1A[0],_1B[0],_1C[0],_1D[0],_1E[0],_1F[0],_20[0],_21[0],_22[0],_23[0],_24[0],_25[0],_26[0],_27[0],_28[0],_29[0],_2A[0],_2B[0],_2C[0],_2D[0],_2E[0],_2F[0],_30[0],_31[0],_32[0],_33[0],_34[0],_35[0],_36[0],_37[0],_38[0],_39[0],_3A[0],_3B[0],_3C[0],_3D[0],_3E[0],_3F[0],_40[0],_41[0],_42[0],_43[0],_44[0],_45[0],_46[0],_47[0],_48[0],_49[0],_4A[0],_4B[0],_4C[0],_4D[0],_4E[0],_4F[0],_50[0],_51[0],_52[0],_53[0],_54[0],_55[0],_56[0],_57[0],_58[0],_59[0],_5A[0],_5B[0],_5C[0],_5D[0],_5E[0],_5F[0],_60[0],_61[0],_62[0],_63[0],_64[0],_65[0],_66[0],_67[0],_68[0],_69[0],_6A[0],_6B[0],_6C[0],_6D[0],_6E[0],_6F[0],_70[0],_71[0],_72[0],_73[0],_74[0],_75[0],_76[0],_77[0],_78[0],_79[0],_7A[0],_7B[0],_7C[0],_7D[0],_7E[0],_7F[0],_80[0],_81[0],_82[0],_83[0],_84[0],_85[0],_86[0],_87[0],_88[0],_89[0],_8A[0],_8B[0],_8C[0],_8D[0],_8E[0],_8F[0],_90[0],_91[0],_92[0],_93[0],_94[0],_95[0],_96[0],_97[0],_98[0],_99[0],_9A[0],_9B[0],_9C[0],_9D[0],_9E[0],_9F[0],_A0[0],_A1[0],_A2[0],_A3[0],_A4[0],_A5[0],_A6[0],_A7[0],_A8[0],_A9[0],_AA[0],_AB[0],_AC[0],_AD[0],_AE[0],_AF[0],_B0[0],_B1[0],_B2[0],_B3[0],_B4[0],_B5[0],_B6[0],_B7[0],_B8[0],_B9[0],_BA[0],_BB[0],_BC[0],_BD[0],_BE[0],_BF[0],_C0[0],_C1[0],_C2[0],_C3[0],_C4[0],_C5[0],_C6[0],_C7[0],_C8[0],_C9[0],_CA[0],_CB[0],_CC[0],_CD[0],_CE[0],_CF[0],_D0[0],_D1[0],_D2[0],_D3[0],_D4[0],_D5[0],_D6[0],_D7[0],_D8[0],_D9[0],_DA[0],_DB[0],_DC[0],_DD[0],_DE[0],_DF[0],_E0[0],_E1[0],_E2[0],_E3[0],_E4[0],_E5[0],_E6[0],_E7[0],_E8[0],_E9[0],_EA[0],_EB[0],_EC[0],_ED[0],_EE[0],_EF[0],_F0[0],_F1[0],_F2[0],_F3[0],_F4[0],_F5[0],_F6[0],_F7[0],_F8[0],_F9[0],_FA[0],_FB[0],_FC[0],_FD[0],_FE[0],_FF[0],_100[0],_101[0],_102[0],_103[0],_104[0],_105[0],_106[0],_107[0],_108[0],_109[0],_10A[0],_10B[0],_10C[0],_10D[0],_10E[0],_10F[0],_110[0],_111[0],_112[0],_113[0],_114[0],_115[0],_116[0],_117[0],_118[0],_119[0],_11A[0],_11B[0],_11C[0],_11D[0],_11E[0],_11F[0],_120[0],_121[0],_122[0],_123[0],_124[0],_125[0],_126[0],_127[0],_128[0],_129[0],_12A[0],_12B[0],_12C[0],_12D[0],_12E[0],_12F[0],_130[0],_131[0],_132[0],_133[0],_134[0],_135[0],_136[0],_137[0],_138[0],_139[0],_13A[0],_13B[0],_13C[0],_13D[0],_13E[0],_13F[0],_140[0],_141[0],_142[0],_143[0],_144[0],_145[0],_146[0],_147[0],_148[0],_149[0],_14A[0],_14B[0],_14C[0],_14D[0],_14E[0],_14F[0],_150[0],_151[0],_152[0],_153[0],_154[0],_155[0],_156[0],_157[0],_158[0],_159[0],_15A[0],_15B[0],_15C[0],_15D[0],_15E[0],_15F[0],_160[0],_161[0],_162[0],_163[0],_164[0],_165[0],_166[0],_167[0],_168[0],_169[0],_16A[0],_16B[0],_16C[0],_16D[0],_16E[0],_16F[0],_170[0],_171[0],_172[0],_173[0],_174[0],_175[0],_176[0],_177[0],_178[0],_179[0],_17A[0],_17B[0],_17C[0],_17D[0],_17E[0],_17F[0],_180[0],_181[0],_182[0],_183[0],_184[0],_185[0],_186[0],_187[0],_188[0],_189[0],_18A[0],_18B[0],_18C[0],_18D[0],_18E[0],_18F[0],_190[0],_191[0],_192[0],_193[0],_194[0],_195[0],_196[0],_197[0],_198[0],_199[0],_19A[0],_19B[0],_19C[0],_19D[0],_19E[0],_19F[0],_1A0[0],_1A1[0],_1A2[0],_1A3[0],_1A4[0],_1A5[0],_1A6[0],_1A7[0],_1A8[0],_1A9[0],_1AA[0],_1AB[0],_1AC[0],_1AD[0],_1AE[0],_1AF[0],_1B0[0],_1B1[0],_1B2[0],_1B3[0],_1B4[0],_1B5[0],_1B6[0],_1B7[0],_1B8[0],_1B9[0],_1BA[0],_1BB[0],_1BC[0],_1BD[0],_1BE[0],_1BF[0],_1C0[0],_1C1[0],_1C2[0],_1C3[0],_1C4[0],_1C5[0],_1C6[0],_1C7[0],_1C8[0],_1C9[0],_1CA[0],_1CB[0],_1CC[0],_1CD[0],_1CE[0],_1CF[0],_1D0[0],_1D1[0],_1D2[0],_1D3[0],_1D4[0],_1D5[0],_1D6[0],_1D7[0],_1D8[0],_1D9[0],_1DA[0],_1DB[0],_1DC[0],_1DD[0],_1DE[0],_1DF[0],_1E0[0],_1E1[0],_1E2[0],_1E3[0],_1E4[0],_1E5[0],_1E6[0],_1E7[0],_1E8[0],_1E9[0],_1EA[0],_1EB[0],_1EC[0],_1ED[0],_1EE[0],_1EF[0],_1F0[0],_1F1[0],_1F2[0],_1F3[0],_1F4[0],_1F5[0],_1F6[0],_1F7[0],_1F8[0],_1F9[0],_1FA[0],_1FB[0],_1FC[0],_1FD[0],_1FE[0],_1FF[0],_200[0],_201[0],_202[0],_203[0],_204[0],_205[0],_206[0],_207[0],_208[0],_209[0],_20A[0],_20B[0],_20C[0],_20D[0],_20E[0],_20F[0],_210[0],_211[0],_212[0],_213[0],_214[0],_215[0],_216[0],_217[0],_218[0],_219[0],_21A[0],_21B[0],_21C[0],_21D[0],_21E[0],_21F[0],_220[0],_221[0],_222[0],_223[0],_224[0],_225[0],_226[0],_227[0],_228[0],_229[0],_22A[0],_22B[0],_22C[0],_22D[0],_22E[0],_22F[0],_230[0],_231[0],_232[0],_233[0],_234[0],_235[0],_236[0],_237[0],_238[0],_239[0],_23A[0],_23B[0],_23C[0],_23D[0],_23E[0],_23F[0],_240[0],_241[0],_242[0],_243[0],_244[0],_245[0],_246[0],_247[0],_248[0],_249[0],_24A[0],_24B[0],_24C[0],_24D[0],_24E[0],_24F[0],_250[0],_251[0],_252[0],_253[0],_254[0],_255[0],_256[0],_257[0],_258[0],_259[0],_25A[0],_25B[0],_25C[0],_25D[0],_25E[0],_25F[0],_260[0],_261[0],_262[0],_263[0],_264[0],_265[0],_266[0],_267[0],_268[0],_269[0],_26A[0],_26B[0],_26C[0],_26D[0],_26E[0],_26F[0],_270[0],_271[0],_272[0],_273[0],_274[0],_275[0],_276[0],_277[0],_278[0],_279[0],_27A[0],_27B[0],_27C[0],_27D[0],_27E[0],_27F[0],_280[0],_281[0],_282[0],_283[0],_284[0],_285[0],_286[0],_287[0],_288[0],_289[0],_28A[0],_28B[0],_28C[0],_28D[0],_28E[0],_28F[0],_290[0],_291[0],_292[0],_293[0],_294[0],_295[0],_296[0],_297[0],_298[0],_299[0],_29A[0],_29B[0],_29C[0],_29D[0],_29E[0],_29F[0],_2A0[0],_2A1[0],_2A2[0],_2A3[0],_2A4[0],_2A5[0],_2A6[0],_2A7[0],_2A8[0],_2A9[0],_2AA[0],_2AB[0],_2AC[0],_2AD[0],_2AE[0],_2AF[0],_2B0[0],_2B1[0],_2B2[0],_2B3[0],_2B4[0],_2B5[0],_2B6[0],_2B7[0],_2B8[0],_2B9[0],_2BA[0],_2BB[0],_2BC[0],_2BD[0],_2BE[0],_2BF[0],_2C0[0],_2C1[0],_2C2[0],_2C3[0],_2C4[0],_2C5[0],_2C6[0],_2C7[0],_2C8[0],_2C9[0],_2CA[0],_2CB[0],_2CC[0],_2CD[0],_2CE[0],_2CF[0],_2D0[0],_2D1[0],_2D2[0],_2D3[0],_2D4[0],_2D5[0],_2D6[0],_2D7[0],_2D8[0],_2D9[0],_2DA[0],_2DB[0],_2DC[0],_2DD[0],_2DE[0],_2DF[0],_2E0[0],_2E1[0],_2E2[0],_2E3[0],_2E4[0],_2E5[0],_2E6[0],_2E7[0],_2E8[0],_2E9[0],_2EA[0],_2EB[0],_2EC[0],_2ED[0],_2EE[0],_2EF[0],_2F0[0],_2F1[0],_2F2[0],_2F3[0],_2F4[0],_2F5[0],_2F6[0],_2F7[0],_2F8[0],_2F9[0],_2FA[0],_2FB[0],_2FC[0],_2FD[0],_2FE[0],_2FF[0],_300[0],_301[0],_302[0],_303[0],_304[0],_305[0],_306[0],_307[0],_308[0],_309[0],_30A[0],_30B[0],_30C[0],_30D[0],_30E[0],_30F[0],_310[0],_311[0],_312[0],_313[0],_314[0],_315[0],_316[0],_317[0],_318[0],_319[0],_31A[0],_31B[0],_31C[0],_31D[0],_31E[0],_31F[0],_320[0],_321[0],_322[0],_323[0],_324[0],_325[0],_326[0],_327[0],_328[0],_329[0],_32A[0],_32B[0],_32C[0],_32D[0],_32E[0],_32F[0],_330[0],_331[0],_332[0],_333[0],_334[0],_335[0],_336[0],_337[0],_338[0],_339[0],_33A[0],_33B[0],_33C[0],_33D[0],_33E[0],_33F[0],_340[0],_341[0],_342[0],_343[0],_344[0],_345[0],_346[0],_347[0],_348[0],_349[0],_34A[0],_34B[0],_34C[0],_34D[0],_34E[0],_34F[0],_350[0],_351[0],_352[0],_353[0],_354[0],_355[0],_356[0],_357[0],_358[0],_359[0],_35A[0],_35B[0],_35C[0],_35D[0],_35E[0],_35F[0],_360[0],_361[0],_362[0],_363[0],_364[0],_365[0],_366[0],_367[0],_368[0],_369[0],_36A[0],_36B[0],_36C[0],_36D[0],_36E[0],_36F[0],_370[0],_371[0],_372[0],_373[0],_374[0],_375[0],_376[0],_377[0],_378[0],_379[0],_37A[0],_37B[0],_37C[0],_37D[0],_37E[0],_37F[0],_380[0],_381[0],_382[0],_383[0],_384[0],_385[0],_386[0],_387[0],_388[0],_389[0],_38A[0],_38B[0],_38C[0],_38D[0],_38E[0],_38F[0],_390[0],_391[0],_392[0],_393[0],_394[0],_395[0],_396[0],_397[0],_398[0],_399[0],_39A[0],_39B[0],_39C[0],_39D[0],_39E[0],_39F[0],_3A0[0],_3A1[0],_3A2[0],_3A3[0],_3A4[0],_3A5[0],_3A6[0],_3A7[0],_3A8[0],_3A9[0],_3AA[0],_3AB[0],_3AC[0],_3AD[0],_3AE[0],_3AF[0],_3B0[0],_3B1[0],_3B2[0],_3B3[0],_3B4[0],_3B5[0],_3B6[0],_3B7[0],_3B8[0],_3B9[0],_3BA[0],_3BB[0],_3BC[0],_3BD[0],_3BE[0],_3BF[0],_3C0[0],_3C1[0],_3C2[0],_3C3[0],_3C4[0],_3C5[0],_3C6[0],_3C7[0],_3C8[0],_3C9[0],_3CA[0],_3CB[0],_3CC[0],_3CD[0],_3CE[0],_3CF[0],_3D0[0],_3D1[0],_3D2[0],_3D3[0],_3D4[0],_3D5[0],_3D6[0],_3D7[0],_3D8[0],_3D9[0],_3DA[0],_3DB[0],_3DC[0],_3DD[0],_3DE[0],_3DF[0],_3E0[0],_3E1[0],_3E2[0],_3E3[0],_3E4[0],_3E5[0],_3E6[0],_3E7[0],_3E8[0],_3E9[0],_3EA[0],_3EB[0],_3EC[0],_3ED[0],_3EE[0],_3EF[0],_3F0[0],_3F1[0],_3F2[0],_3F3[0],_3F4[0],_3F5[0],_3F6[0],_3F7[0],_3F8[0],_3F9[0],_3FA[0],_3FB[0],_3FC[0],_3FD[0],_3FE[0],_3FF[0],_400[0]

'UTIL END

